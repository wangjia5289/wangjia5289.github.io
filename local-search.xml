<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>笔记：Hexo + Obsidian + GitHub Pages</title>
    <link href="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/"/>
    <url>/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><hr><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><ol><li><code>Git</code></li><li><code>Node.js</code></li><li><code>PowerShell</code></li></ol><hr><h2 id="4-创建-Hexo-项目"><a href="#4-创建-Hexo-项目" class="headerlink" title="4. 创建 Hexo 项目"></a>4. 创建 Hexo 项目</h2><h3 id="4-1-初始化-Hexo-项目"><a href="#4-1-初始化-Hexo-项目" class="headerlink" title="4.1. 初始化 Hexo 项目"></a>4.1. 初始化 Hexo 项目</h3><p><font color="#92d050">1. 创建文件夹</font><br>这里我命名为 <code>myNote</code>（名称可自定义）<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages.png"></p><p><font color="#92d050">2. 使用 PowerShell 打开文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-1.png"></p><p><font color="#92d050">3. 全局安装 hexo</font></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 初始化 Hexo 项目</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 安装相关依赖</font></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-2-配置-Hexo-元数据"><a href="#4-2-配置-Hexo-元数据" class="headerlink" title="4.2. 配置 Hexo 元数据"></a>4.2. 配置 Hexo 元数据</h3><p><font color="#92d050">1. 使用 VS Code 打开 myNote 文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-2.png"></p><p><font color="#92d050">2. 配置 Hexo 元数据</font><br>在系统 <code>myNote/_config.yml</code> 文件中配置元数据：<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-3.png"></p><hr><h3 id="4-3-启动-Hexo，查看效果"><a href="#4-3-启动-Hexo，查看效果" class="headerlink" title="4.3. 启动 Hexo，查看效果"></a>4.3. 启动 Hexo，查看效果</h3><p><font color="#92d050">1. 使用 PowerShell 打开文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-4.png"></p><p><font color="#92d050">2. 依次执行命令</font></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. 清除现存的 Hexo 的静态文件</span><br><span class="hljs-attribute">hexo</span> clean<br><br><br><span class="hljs-comment"># 2. 生成新的 Hexo 静态文件</span><br>hexo g<br><br><br><span class="hljs-comment"># 3. 启动本地服务器，预览生成的网页效果，便于本地调试</span><br>hexo s<br></code></pre></td></tr></table></figure><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-5.png"></p><p><font color="#92d050">3. 查看 Hexo 效果</font><br>查看： <a href="http://localhost:4000/">http://localhost:4000/</a></p><hr><h3 id="4-4-配置-Hexo-主题"><a href="#4-4-配置-Hexo-主题" class="headerlink" title="4.4. 配置 Hexo 主题"></a>4.4. 配置 Hexo 主题</h3><p>上面展示的 Hexo 默认样式较为简陋，视觉效果不佳。你可以在 <a href="https://hexo.io/themes/">Hexo主题库</a> 中挑选一个自己喜欢的主题，这里我选择 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> 作为我的主题。</p><p><font color="#92d050">1. 下载 fluid 安装包</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-6.png"></p><p><font color="#92d050">2. 解压缩到 myNote&#x2F;theme 目录下，并将其重命名为 fluid</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-7.png"></p><p><font color="#92d050">3. 配置使用 fluid 主题</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-8.png"></p><p><font color="#92d050">4. 使用 PowerShell 打开文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-9.png"></p><p><font color="#92d050">5. 添加 about 页面</font></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> page about<br></code></pre></td></tr></table></figure><p><font color="#92d050">6. 设置 about&#x2F;index.md 的头部属性</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-10.png"></p><p><font color="#92d050">7. 进行 Hexo 主题配置</font><br>根据需要在主题的 <code>myNote/themes/fluid/config.yml</code> 文件中进行相应的配置，具体怎么配，看你自己喜欢就行。</p><p><font color="#92d050">8. 启动 Hexo，查看效果</font></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. 清除现存的 Hexo 的静态文件</span><br><span class="hljs-attribute">hexo</span> clean<br><br><br><span class="hljs-comment"># 2. 生成新的 Hexo 静态文件</span><br>hexo g<br><br><br><span class="hljs-comment"># 3. 启动本地服务器，预览生成的网页效果，便于本地调试</span><br>hexo s<br></code></pre></td></tr></table></figure><hr><h2 id="5-集成-GitHub-Pages"><a href="#5-集成-GitHub-Pages" class="headerlink" title="5. 集成 GitHub Pages"></a>5. 集成 GitHub Pages</h2><h3 id="5-1-进行-Git-代理配置"><a href="#5-1-进行-Git-代理配置" class="headerlink" title="5.1. 进行 Git 代理配置"></a>5.1. 进行 Git 代理配置</h3><p>由于需要将静态页面部署到 <code>GitHub Pages</code>，并将整个 <code>Obsidian</code> 仓库推送到 <code>MyNote</code> 仓库，我们先设置 <code>Git</code> 代理，以提升网络传输速度</p><p><font color="#92d050">1. 检查是否配置过 Git 代理</font></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global http.proxy</span><br><br><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global https.proxy</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 如果存在代理，进行代理取消</font></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> http<span class="hljs-selector-class">.proxy</span><br><br><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> https.proxy<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 重新配置 Git 代理</font></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global https.proxy 127.0.0.1:7890</span><br><br><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global http.proxy 127.0.0.1:7890</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>此处的端口号需根据你本地 <code>Clash</code> 的配置进行调整，填写你实际使用的代理端口。</li></ol></blockquote><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-11.png"></p><hr><h3 id="5-2-创建-GitHub-Pages"><a href="#5-2-创建-GitHub-Pages" class="headerlink" title="5.2. 创建 GitHub Pages"></a>5.2. 创建 GitHub Pages</h3><p>首先，登录 <code>GitHub</code> 并创建一个名为 <code>&lt;your_id&gt;.github.io</code> 的仓库，并确保将其设置为 <code>Public</code>（公开）<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-12.png"></p><hr><h3 id="5-3-Hexo-项目关联到-GitHub-Pages"><a href="#5-3-Hexo-项目关联到-GitHub-Pages" class="headerlink" title="5.3. Hexo 项目关联到 GitHub Pages"></a>5.3. Hexo 项目关联到 GitHub Pages</h3><p><font color="#92d050">1. 安装 deploy 插件</font></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 进行 myNote&#x2F;config.yml 配置</font></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/wangjia5289/wangjia5289.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><hr><h3 id="5-4-Hexo-项目推送到-GitHub-Pages"><a href="#5-4-Hexo-项目推送到-GitHub-Pages" class="headerlink" title="5.4. Hexo 项目推送到 GitHub Pages"></a>5.4. Hexo 项目推送到 GitHub Pages</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. 清除现存的Hexo的静态文件</span><br><span class="hljs-attribute">hexo</span> clean<br><br><br><span class="hljs-comment"># 2. 生成新的 Hexo 静态文件</span><br>hexo g<br><br><br><span class="hljs-comment"># 3. 启动本地服务器，预览生成的网页效果，便于本地调试</span><br>hexo s<br><br><br><span class="hljs-comment"># 4. 将 Hexo 项目推送到 GitHub Pages</span><br>hexo d<br></code></pre></td></tr></table></figure><hr><h3 id="5-5-查看-GitHub-Pages-效果"><a href="#5-5-查看-GitHub-Pages-效果" class="headerlink" title="5.5. 查看 GitHub Pages 效果"></a>5.5. 查看 GitHub Pages 效果</h3><p>查看： <a href="https://github.com/wangjia5289/wangjia5289.github.io.git">https://github.com/wangjia5289/wangjia5289.github.io.git</a></p><hr><h2 id="6-集成-GitHub-Repository"><a href="#6-集成-GitHub-Repository" class="headerlink" title="6. 集成 GitHub Repository"></a>6. 集成 GitHub Repository</h2><p><font color="#92d050">1. 创建 GitHub Repository</font><br>我们额外创建一个名为 <code>myNote</code>（名称可自定义）的仓库，并确保将其设置为 <code>Private</code>（私有）用于备份所有文件，以防数据丢失<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-13.png"></p><p><font color="#92d050">2. 依次运行命令</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 1. 初始化本地 Git 仓库</span><br>git <span class="hljs-keyword">init</span><br><br><br><span class="hljs-meta"># 2. 创建 README 文档</span><br>echo <span class="hljs-string">&quot;随便写点东西好了&quot;</span> &gt; README.md<br><br><br><span class="hljs-meta"># 3. 将 README 稳定添加到缓冲取</span><br>git <span class="hljs-keyword">add</span> README.md<br><br><br><span class="hljs-meta"># 4. 进行第一次推送（务必进行，相当于点火器）</span><br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><br><br><span class="hljs-meta"># 5. 将当前分支强制重命名为 main</span><br>git branch -M main<br><br><br><span class="hljs-meta"># 6. 本地仓库与远程仓库进行关联。</span><br>git remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/wangjia5289/xxxxxx.git</span><br><br><br><span class="hljs-meta"># 7. 进行分支关联（使用 -u 选项，将本地 main 分支与远程 main 分支关联，之后可以直接使用 git push 和 git pull，而无需每次指定远程仓库和分支。）</span><br>git push -u origin main<br><br><br><span class="hljs-meta"># 8. 后续推送</span><br>我们可以通过命令行或使用 GitHub Desktop 等工具来推送代码。<br></code></pre></td></tr></table></figure><hr><h2 id="7-集成-Obsidian"><a href="#7-集成-Obsidian" class="headerlink" title="7. 集成 Obsidian"></a>7. 集成 Obsidian</h2><h3 id="7-1-创建模版"><a href="#7-1-创建模版" class="headerlink" title="7.1. 创建模版"></a>7.1. 创建模版</h3><p>在Hexo中，为确保每篇文章都能以预设格式和样式展示，通常需要在文章头部设置特定的属性。然而，手动设置这些属性对于每一次撰写新文章来说可能显得繁琐。为简化这一过程，可以创建一个模板。这样，每次撰写新文章时，只需导入该模板，即可自动包含所需的默认属性设置。</p><p><font color="#92d050">1. 创建模版</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-14.png"></p><p><font color="#92d050">2. 设置模版</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-15.png"></p><blockquote><p>[!NOTE] 注意事项：Hexo 页面加锁</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 1. 安装 hexo-blog-encrypt</span><br>npm <span class="hljs-keyword">install </span>--save hexo-<span class="hljs-keyword">blog-encrypt</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment">## 2. 在文章头部添加 password</span><br><span class="hljs-symbol">password:</span> xxxxxx<br></code></pre></td></tr></table></figure><hr><h3 id="7-2-Custom-Attachment-Location-插件"><a href="#7-2-Custom-Attachment-Location-插件" class="headerlink" title="7.2. Custom Attachment Location 插件"></a>7.2. Custom Attachment Location 插件</h3><p><font color="#92d050">1. 修改 Obsidian 配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-16.png"></p><p><font color="#92d050">2. 安装 Custom Attachment Location 插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-17.png"></p><p><font color="#92d050">3. 进行插件配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-18.png"></p><p><font color="#92d050">4. 进行 myNote&#x2F;config.yml 配置</font></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 1. 将 post_asset_foler 设置为 true</span><br><span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br><br><br><span class="hljs-comment"># 2. 添加下述内容</span><br><span class="hljs-params">marked:</span> <br>  <span class="hljs-params">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h3 id="7-3-File-Explorer-插件"><a href="#7-3-File-Explorer-插件" class="headerlink" title="7.3. File Explorer++ 插件"></a>7.3. File Explorer++ 插件</h3><p><font color="#92d050">1. 安装 File Explorer++ 插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-19.png"></p><p><font color="#92d050">2. 进行插件配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-20.png"></p><hr><h3 id="7-4-Git-插件"><a href="#7-4-Git-插件" class="headerlink" title="7.4. Git 插件"></a>7.4. Git 插件</h3><p><font color="#92d050">1. 安装 Git 插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-21.png"></p><p><font color="#92d050">2. 配置插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-22.png"></p><p><font color="#92d050">3. 手动实现推送到 Repository</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-23.png"></p><hr><h2 id="8-Page-与域名绑定（可选）"><a href="#8-Page-与域名绑定（可选）" class="headerlink" title="8. Page 与域名绑定（可选）"></a>8. Page 与域名绑定（可选）</h2><p><font color="#92d050">1. 登录 GitHub，在您的 id.github.io 项目中，通过 Settings选项进行域名配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-24.png"></p><p><font color="#92d050">2. 在 public 文件夹下创建一个名为 CNAME 的文件，并在其中保存您希望绑定的域名</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-25.png"></p><p><font color="#92d050">3. 为域名添加 CNAME 记录并指向 id.github.io</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-26.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：JUC</title>
    <link href="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/"/>
    <url>/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.eddx"></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/JUC-2b2974fbda5e8012975ef0197d6e8237">https://www.notion.so/JUC-2b2974fbda5e8012975ef0197d6e8237</a></p></li></ol><hr><h1 id="三、JUC-前置基础"><a href="#三、JUC-前置基础" class="headerlink" title="三、JUC 前置基础"></a>三、JUC 前置基础</h1><h2 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h2><h3 id="1-1-操作系统层"><a href="#1-1-操作系统层" class="headerlink" title="1.1. 操作系统层"></a>1.1. 操作系统层</h3><p>操作系统层的线程状态，是操作系统内核对线程的实际调度反映<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.png"></p><hr><h3 id="1-2-Java-应用层"><a href="#1-2-Java-应用层" class="headerlink" title="1.2. Java 应用层"></a>1.2. Java 应用层</h3><p><code>Java</code> 应用层的线程状态，是 <code>JVM</code> 对线程生命周期的抽象和管理，主要反映线程在 <code>Java</code> 内存模型中的行为<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-1.png"></p><ol><li><code>NEW</code><ol><li>在 <code>Java</code> 应用层，<code>Thread</code> 实例已创建，但尚未调用 <code>Thread#start</code>，处于未启动状态</li><li>需要注意的是，我们只是创建了线程实例，但是该实例尚未与操作系统层面的线程建立关联</li></ol></li><li><code>RUNNABLE</code><ol><li>可运行状态<ol><li>当我们调用 <code>Thread#start</code> 后，<code>JVM</code> 会在操作系统层面请求创建一个本地线程</li><li>一旦操作系统创建了这个本地线程，并将其与 <code>Thread</code> 实例 “绑定”，<code>Thread</code> 实例就会进入可运行状态</li><li>可运行状态表示 <code>Thread</code> 实例已经准备好运行了，然而，能否真正运行还要取决于操作系统的调度</li></ol></li><li>运行状态<ol><li>本地线程被分配到 <code>CPU</code> 时间片后，开始执行 <code>Java</code> 代码</li></ol></li><li>阻塞状态<ol><li>阻塞状态其实就是本地线程进入 <code>IO</code> 阻塞</li><li>需要注意的是：<ol><li>在 <code>Java</code> 应用层的 <code>IO</code> 阻塞、<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>，在操作系统层都属于阻塞状态，<code>CPU</code> 不再调用这个线程</li><li><code>IO</code> 阻塞严格来说是操作系统层的阻塞，但是我们没必要划分的那么清晰，知道它是什么东西即可</li></ol></li></ol></li></ol></li><li><code>TERMINATED</code><ol><li>当线程执行完任务后，线程实例就会进入<code>TERMINATED</code> 状态</li><li>在 <code>Java</code> 层面上，线程是一个线程对象，当这个线程对象不再被引用时，会在下一次 GC 时被垃圾回收。</li></ol></li></ol><hr><h2 id="2-线程相关分类"><a href="#2-线程相关分类" class="headerlink" title="2. 线程相关分类"></a>2. 线程相关分类</h2><p>在 <code>Java</code> 应用层，线程分为：</p><ol><li>用户线程</li><li>守护线程</li></ol><p>我们平时创建的 <code>Thread</code> 实例默认都是用户线程，<code>main</code> 方法的主线程也是一个用户线程。很多人误以为：只要主线程结束后，<code>JVM</code> 进程就会结束。事实上，这种理解是错误的，只要仍有用户线程在运行，<code>JVM</code> 进程就会继续存活。</p><p>但是守护线程的行为则非如此，当所有用户线程都执行完毕后，<code>JVM</code> 进程将自动退出，而不管是否还有守护线程在运行。此时守护线程会被强制终止，其 <code>finally</code> 块中的代码也不保证一定执行。因此守护线程常用于后台服务，例如垃圾回收、心跳监控、日志清理等任务</p><hr><h2 id="3-线程阻塞相关分类"><a href="#3-线程阻塞相关分类" class="headerlink" title="3. 线程阻塞相关分类"></a>3. 线程阻塞相关分类</h2><ol><li><code>IO</code> 阻塞<ol><li><code>Java</code> 程序在与操作系统交互时，由操作系统层代我们执行的阻塞，让我们的本地线程进入阻塞状态</li><li>虽然 <code>IO</code> 阻塞在操作系统层面也属于阻塞状态，但对 <code>Java</code> 应用层来说，它并不能直接感知本地线程是否正处于 <code>IO</code> 阻塞，因此 <code>Thread</code> 实例的状态仍为 <code>RUNNABLE</code>。简单来说就是：因为感知不到，所以认为还在运行</li></ol></li><li><code>BLOCKED</code> 阻塞、<code>WAITING</code> 阻塞、<code>TIMED_WAITING</code> 阻塞<ol><li><code>Java</code> 应用层还提供了多种 <code>API</code> 让本地线程主动进入阻塞状态，<code>Thread</code> 实例进入 <code>BWTW</code> 状态</li><li>因为调用了 <code>Java</code> 应用层提供的 <code>API</code>，所以 <code>Java</code> 应用层能知道线程进入了阻塞状态，并且还知道线程进入阻塞状态的 “原因”，所以 <code>Thread</code> 实例能进入对应的 <code>BLOCKED</code>、<code>WAITING</code> 或 <code>TIMED_WAITING</code> 状态</li><li><code>Java</code> 应用层提供的相关 <code>API</code> 主要包括：<ol><li><code>Thread.sleep</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，等待被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li><li>基于 <code>Monitor</code> 的阻塞<ol><li>竞争 <code>Monitor</code> 锁失败<ol><li><code>synchronized</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>BLOCKED</code> 状态，并被投递到 <code>Monitor</code> 的 <code>EntryList</code> 队列（竞争队列），等待被唤醒（<code>Monitor</code> 锁被释放时，由 <code>JVM</code> 唤醒）</li></ol></li></ol></li><li><code>Object#wait</code><ol><li><code>Object#wait()</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，并被投递到 <code>Monitor</code> 的 <code>WaitSet</code> 队列（等待队列），等待被唤醒（<code>Object#notify</code>）、被中断</li></ol></li><li><code>Object#wait(long timeoutMillis)</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，并被投递到 <code>Monitor</code> 的 <code>WaitSet</code> 队列（等待队列），等待被唤醒（<code>Object#notify</code>）、被中断、阻塞超时</li></ol></li></ol></li><li><code>Thread#join</code><ol><li><code>Thread#join()</code><ol><li>没什么好说的，因为其本质是基于 <code>Object#wait</code> 实现的阻塞</li></ol></li><li><code>Thread#join(final long millis)</code></li><li><code>Thread#join(long millis, int nanos)</code></li></ol></li><li>需要注意的是：<ol><li><code>Object#wait</code> 和 <code>Thread#join</code> 都会使 <code>Thread</code> 实例进入 <code>Monitor</code> 的等待队列。那么为什么要进入等待队列，而不是进入竞争队列呢？</li><li>进入等待队列是因为 <code>Thread</code> 实例在竞争到 <code>Monitor</code> 锁后，发现某个条件尚未满足，为了不影响其他线程继续获取 <code>Monitor</code> 锁，所以会主动释放锁，并进入等待队列中等待条件被满足</li><li>所以 <code>Object#wait</code> 和 <code>Thread#join</code> 的前置条件是：竞争到 <code>Monitor</code> 锁。只有先竞争到 <code>Monitor</code> 锁，才知道某个条件尚未满足</li><li>我的意思是：<code>Object#wait</code>、<code>Thread#join</code> 和 <code>synchronized</code> 是绑定的，它们必须出现在 <code>synchronized</code> 代码块中，否则会抛出异常。而 <code>Thread.sleep</code>、基于 <code>Park</code> 的阻塞没有这种限制，可以在任何地方使用</li><li>需要注意的是：如果竞争到 <code>Monitor</code> 锁，但是使用了 <code>Thread.sleep</code>、基于 <code>Park</code> 的阻塞的情况下，<code>Monitor</code> 锁是不会被释放的</li></ol></li></ol></li><li>基于 <code>Park</code> 的阻塞<ol><li><code>LockSupport.park</code><ol><li><code>LockSupport.park()</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）</li></ol></li><li><code>LockSupport.parkNanos(long nanos)</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li><li><code>LockSupport.parkUntil(long deadline)</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li><li>需要注意的是，具体的过程比上述描述稍微复杂一点，详见源码：<code>LockSupport</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.LockSupport源码解析</a>，<code>Hexo</code> 链接：）</li></ol></li></ol></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>IO</code> 阻塞、<code>Threa.sleep</code> 都依赖于操作系统层的队列</li><li>基于 <code>Monitor</code> 的阻塞依赖于 <code>Java</code> 应用层的 <code>Monitor</code> 中的 <code>EntryList</code>、<code>WaitSet</code> 队列</li><li>而基于 <code>Park</code> 的阻塞，原则上是不依赖于任何数据结构，不过在实际中，几乎所有基于 <code>Park</code> 阻塞的产品，都会维护一个数据结构（可能是队列，也可能是其他数据结构）。因为如果没有这个数据结构，就无法记录哪些线程被阻塞、以及应当唤醒哪些线程</li></ol></blockquote><hr><h2 id="4-线程之间的执行关系"><a href="#4-线程之间的执行关系" class="headerlink" title="4. 线程之间的执行关系"></a>4. 线程之间的执行关系</h2><p><font color="#92d050">1. 串行</font><br>串行是指任务按顺序一个接一个地执行，只有当前一个任务执行完成，后一个任务才会开始执行，严格遵循任务提交的先后顺序。即便系统拥有多个 <code>CPU</code> 核心，在串行模式下，任意时刻也只会有一个线程在运行。</p><p><font color="#92d050">2. 并发</font><br>并发是指多个线程看起来像是在同时运行，其是通过时间片轮转机制实现，通过快速切换线程，让每个线程都获得运行机会，因此并发特性在单核环境中体现得尤为明显。</p><p>而在多核 <code>CPU</code> 上，线程有可能被分配到不同的核心上并行执行，但当线程数量多于核心数量时，<code>CPU</code> 仍需通过时间片轮转进行调度，以确保所有线程都能获得执行机会。</p><p><font color="#92d050">3. 并行</font><br>并行是指多个线程在真正意义上同时运行，分别占用不同的 <code>CPU</code> 核心，在同一时刻执行各自的任务，体现出真正的同时处理能力。</p><hr><h2 id="5-线程的活跃性"><a href="#5-线程的活跃性" class="headerlink" title="5. 线程的活跃性"></a>5. 线程的活跃性</h2><h3 id="5-1-死锁"><a href="#5-1-死锁" class="headerlink" title="5.1. 死锁"></a>5.1. 死锁</h3><h4 id="5-1-1-死锁概述"><a href="#5-1-1-死锁概述" class="headerlink" title="5.1.1. 死锁概述"></a>5.1.1. 死锁概述</h4><p>死锁是指：两个或两个以上的线程在执行过程中，因互相持有对方所需的资源而造成的一种互相等待的现象。如果没有外力干涉，这些线程都将无法推进下去，永远处于阻塞状态</p><p>例如线程 $T_1$ 已经持有了锁 <code>A</code>，现在想去竞争锁 <code>B</code>。线程 $T_2$ 已经持有了锁 <code>B</code>，现在想去竞争锁 <code>A</code>，这便形成了死锁</p><p>需要注意的是：在 <code>JUC</code> 中，所谓的 “资源” 是指：锁</p><hr><h4 id="5-1-2-死锁的必要条件"><a href="#5-1-2-死锁的必要条件" class="headerlink" title="5.1.2. 死锁的必要条件"></a>5.1.2. 死锁的必要条件</h4><ol><li>互斥条件<ol><li>资源是独占的，同一时刻只能被一个线程持有</li></ol></li><li>不剥夺条件<ol><li>线程已持有的资源，在末使用完之前，不能被其他线程强行剥夺，只能由线程自己主动释放</li></ol></li><li>循环等待条件<ol><li>若干线程之间形成一种头尾相接的循环等待资源的关系（例如 <code>A</code> 等 <code>B</code>，<code>B</code> 等 <code>A</code>）</li></ol></li><li>请求与保持条件<ol><li>线程在等待新资源时，对已经持有的资源保持不放（吃着碗里的，看着锅里的）</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>解决死锁的核心思路，就是破坏上述四个条件的任意一个。由于 “互斥条件” 是锁的基本特性，通常我们无法破坏，因此主要针对后三个条件进行破坏</li></ol></blockquote><hr><h4 id="5-1-3-死锁的解决方案"><a href="#5-1-3-死锁的解决方案" class="headerlink" title="5.1.3. 死锁的解决方案"></a>5.1.3. 死锁的解决方案</h4><h5 id="5-1-3-1-破坏不剥夺条件"><a href="#5-1-3-1-破坏不剥夺条件" class="headerlink" title="5.1.3.1. 破坏不剥夺条件"></a>5.1.3.1. 破坏不剥夺条件</h5><p>破坏不剥夺条件是指：线程等待资源超过一段时间，就放弃等待，并释放已持有的资源</p><hr><h5 id="5-1-3-2-破坏循环等待条件（最常用）"><a href="#5-1-3-2-破坏循环等待条件（最常用）" class="headerlink" title="5.1.3.2. 破坏循环等待条件（最常用）"></a>5.1.3.2. 破坏循环等待条件（最常用）</h5><p>破坏循环等待条件是指：规定所有线程必须按照相同的顺序获取资源。例如规定所有线程必须先获取锁 <code>A</code>，再获取锁 <code>B</code>，再获取锁 <code>C</code></p><hr><h5 id="5-1-3-3-破坏请求与保持条件"><a href="#5-1-3-3-破坏请求与保持条件" class="headerlink" title="5.1.3.3. 破坏请求与保持条件"></a>5.1.3.3. 破坏请求与保持条件</h5><p>破坏请求与保持条件是指：采用 “预先申请” 的方式，让所有线程必须一次性申请它所需要的所有资源。如果能申请到所有资源，线程继续向下执行。如果不能申请到所有资源，则释放已持有的资源</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>破坏请求与保持条件，通常和破坏不剥夺条件结合使用</li></ol></blockquote><hr><h3 id="5-2-活锁"><a href="#5-2-活锁" class="headerlink" title="5.2. 活锁"></a>5.2. 活锁</h3><h4 id="5-2-1-活锁概述"><a href="#5-2-1-活锁概述" class="headerlink" title="5.2.1. 活锁概述"></a>5.2.1. 活锁概述</h4><p>活锁是指：两个或两个以上的线程在执行过程种，因为不断互相改变对方的终止条件，导致所有线程都无法继续向下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">double</span> seconds)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep((<span class="hljs-type">long</span>) (seconds * <span class="hljs-number">1000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count--;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望加到 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count++;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>活锁本质上是 ”重试“ 导致的冲突</li></ol></blockquote><hr><h4 id="5-2-2-活锁的解决方案"><a href="#5-2-2-活锁的解决方案" class="headerlink" title="5.2.2. 活锁的解决方案"></a>5.2.2. 活锁的解决方案</h4><h5 id="5-2-2-1-加锁"><a href="#5-2-2-1-加锁" class="headerlink" title="5.2.2.1. 加锁"></a>5.2.2.1. 加锁</h5><p>活锁本质上并不是 “锁” 本身，但解决活锁时，却是可以使用 ”加锁“ 来解决</p><hr><h5 id="5-2-2-2-随机避让（最常用）"><a href="#5-2-2-2-随机避让（最常用）" class="headerlink" title="5.2.2.2. 随机避让（最常用）"></a>5.2.2.2. 随机避让（最常用）</h5><p>随即避让是指：当多个 ”请求“ 同时争抢资源失败时，不要立即重试，也不要使用固定的休眠时间。更合理的做法是采用 ”指数退避 + 随机抖动“ 的策略，降低竞争冲突</p><p>这里同样能使用随即避让能避免这个问题，不过场景不再是 “争抢资源”，而是 “重试” 导致的冲突。我们可以在重试时加入随机避让，减少重试之间的同步碰撞</p><hr><h5 id="5-2-2-3-限制重试次数"><a href="#5-2-2-3-限制重试次数" class="headerlink" title="5.2.2.3. 限制重试次数"></a>5.2.2.3. 限制重试次数</h5><hr><h3 id="5-3-饥饿"><a href="#5-3-饥饿" class="headerlink" title="5.3. 饥饿"></a>5.3. 饥饿</h3><h4 id="5-3-1-饥饿概述"><a href="#5-3-1-饥饿概述" class="headerlink" title="5.3.1. 饥饿概述"></a>5.3.1. 饥饿概述</h4><p>饥饿是指：某个线程虽然长期处于可运行状态，但是却一直无法获取所需要的资源（例如 <code>CPU</code> 时间片、锁、资源池资源等），导致线程无法继续执行</p><hr><h4 id="5-3-2-饥饿的解决方案"><a href="#5-3-2-饥饿的解决方案" class="headerlink" title="5.3.2. 饥饿的解决方案"></a>5.3.2. 饥饿的解决方案</h4><p>无论是线程饥饿、流量控制，还是 <code>IO</code> 阻塞，这些问题的本质都是相同的：因无法获取所需要的资源，导致无法继续执行。</p><p>针对这种 ”资源匮乏“ 的问题，通常有五种解决方案：</p><ol><li>强制排队</li><li>资源预留</li><li>及时止损<ol><li>异步处理</li><li>降级处理</li><li>启动告警</li><li>异步编程回调</li></ol></li><li>随机避让</li><li>调整优先级</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>流量控制主要包括并发控制和速率限制</li></ol></blockquote><h5 id="5-3-2-1-强制排队"><a href="#5-3-2-1-强制排队" class="headerlink" title="5.3.2.1. 强制排队"></a>5.3.2.1. 强制排队</h5><p>强制排队是指：放弃 “自由竞争”，严格遵循 “先来后到” 原则，保证每个 ”请求“ 最终都能得到处理</p><p>以锁资源为例，我们可以使用公平锁，而不是非公平锁</p><hr><h5 id="5-3-2-2-资源预留"><a href="#5-3-2-2-资源预留" class="headerlink" title="5.3.2.2. 资源预留"></a>5.3.2.2. 资源预留</h5><p>资源预留是指：提前划分好资源配额，实行资源隔离，做到 ”专款专用“，防止某单一 ”请求“ 耗尽所有资源</p><p>以线程资源为例，我们可以为每个业务分配一个独立的线程池，而不是共用一个大的线程池</p><hr><h5 id="5-3-2-3-及时止损"><a href="#5-3-2-3-及时止损" class="headerlink" title="5.3.2.3. 及时止损"></a>5.3.2.3. 及时止损</h5><p>及时止损是指：当通过限时阻塞（超时未获取）或非阻塞（尝试一次未获取）确定拿不到资源的时候，不再继续等待，而是采取以下策略：</p><ol><li>异步处理<ol><li>利用 ”削峰填谷“ 的思想，将请求写入 <code>MQ</code></li></ol></li><li>降级处理</li><li>启动告警</li><li>异步编程回调</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>可能是限时阻塞，也可能是非阻塞，还可能是直接使用异步编程回调（连非阻塞也不用，直接使用异步编程回调）</li></ol></blockquote><hr><h5 id="5-3-2-4-随机避让"><a href="#5-3-2-4-随机避让" class="headerlink" title="5.3.2.4. 随机避让"></a>5.3.2.4. 随机避让</h5><p>随即避让是指：当多个 ”请求“ 同时争抢资源失败时，不要立即重试，也不要使用固定的休眠时间。更合理的做法是采用 ”指数退避 + 随机抖动“ 的策略，降低竞争冲突</p><hr><h5 id="5-3-2-5-调整优先级"><a href="#5-3-2-5-调整优先级" class="headerlink" title="5.3.2.5. 调整优先级"></a>5.3.2.5. 调整优先级</h5><p>调整优先级是指：调整竞争权重，让核心的 ”请求“ 拥有更高的优先级</p><p>以 <code>CPU</code> 时间片资源为例，我们动态调整线程的优先级</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然 <code>Java</code> 提供了 <code>Thread#setPriority</code>，但这通常不是一个靠谱的解决方案，更多时候我们要反其道而行之：尽量不要修改线程的优先级，让所有线程的优先级保持同等水平</li></ol></blockquote><hr><h2 id="8-线程相关常用方法"><a href="#8-线程相关常用方法" class="headerlink" title="8. 线程相关常用方法"></a>8. 线程相关常用方法</h2><p>线程相关的常用方法主要包括：</p><ol><li><code>Thread</code> 中的一些的方法</li><li><code>TimeUnit</code> 中的一些方法<ol><li><code>TimeUnit#sleep</code></li><li><code>TimeUnit#timedJoin</code></li><li><code>TimeUnit#timedWait</code></li></ol></li><li><code>Object</code> 中的一些方法<ol><li><code>Object#wait</code></li><li><code>Object#notify</code></li></ol></li><li><code>LockSupport</code> 中的一些方法</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Thread</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Thread源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Object</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Object源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>LockSupport</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.LockSupport源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h1 id="四、ThreadLocal"><a href="#四、ThreadLocal" class="headerlink" title="四、ThreadLocal"></a>四、ThreadLocal</h1><p><code>ThreadLocal</code> 是指：<code>Thread-&gt;threadLocals</code>，用于记录该 <code>Thread</code> 实例独属的一些信息。而 <code>Thread-&gt;threadLocals</code> 又是 <code>ThreadLocal.ThreadLocalMap</code> 类型，详见源码：<code>ThreadLocal&lt;T&gt;.ThreadLocalMap</code>（<code>obsidian</code> 内部连接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.ThreadLocal＜T＞.ThreadLocalMap源码解析</a>，<code>Hexo</code> 链接：）</p><hr><h1 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h1><h2 id="1-锁基础体系"><a href="#1-锁基础体系" class="headerlink" title="1. 锁基础体系"></a>1. 锁基础体系</h2><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-2.png"></p><ol><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Lock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Lock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ReadWriteLock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReadWriteLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Condition</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Condition源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>AbstractOwnableSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedLongSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedLongSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol><hr><h2 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2. synchronized"></a>2. synchronized</h2><h3 id="2-1-synchronized-前置基础"><a href="#2-1-synchronized-前置基础" class="headerlink" title="2.1. synchronized 前置基础"></a>2.1. synchronized 前置基础</h3><h4 id="2-1-1-Java-对象头"><a href="#2-1-1-Java-对象头" class="headerlink" title="2.1.1. Java 对象头"></a>2.1.1. Java 对象头</h4><p>通常我们的一个 <code>Java</code> 实例，他在堆内存中由三部分组成：</p><ol><li><code>Java</code> 对象头（<code>Object Header</code>）</li><li>实例数据（<code>Instance Data</code>）</li><li>对齐填充（<code>Padding</code>）</li></ol><p>以 <code>32</code> 位虚拟机为例：<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-3.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里的 <code>Klass Word</code> 应该叫做 <code>Klass Pointer</code></li></ol></blockquote><hr><h3 id="2-2-synchronized-概述"><a href="#2-2-synchronized-概述" class="headerlink" title="2.2. synchronized 概述"></a>2.2. synchronized 概述</h3><p><code>synchronized</code> 是一种可重入、悲观、非公平、互斥的锁</p><hr><h3 id="2-3-synchronized-使用方式"><a href="#2-3-synchronized-使用方式" class="headerlink" title="2.3. synchronized 使用方式"></a>2.3. synchronized 使用方式</h3><p>以如下代码为例，如果 <code>Room#increment</code> 竞争到了锁，那么 <code>Room#decrement</code>、<code>Room#getCounter</code> 都无法再竞争到锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        counter++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        counter--;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCounter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>当我们为静态具体方法加上 <code>synchronized</code> 修饰符，锁的是类对象（即 <code>Class</code> 对象）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>counter++;<br>&#125;<br><br><br><span class="hljs-comment">// 等价写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (Room.Class) &#123;<br>counter++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. 当我们为实例普通方法加上 <code>synchronized</code> 修饰符，锁的是仅是当前对象（即 <code>this</code>）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>counter++;<br>&#125;<br><br><br><span class="hljs-comment">// 等价写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>counter++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>3. 普通实例方法并不必然只能锁当前对象 (<code>this</code>)，静态方法也并非只能锁类对象（<code>Class</code> 对象）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>counter++;<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (Room.class) &#123;<br>counter++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>4. 以如下代码为例，虽然 <code>Room#sleep</code> 和 <code>Room#study</code> 本身没有逻辑上的交集，我们可以通过引入多把锁来进行优化：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-comment">// 引入多把锁进行优化</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>5. 即便一个方法中，只涉及到了共享变量的读操作，我们仍然要为其加锁。这主要是为了其可见性、原子性。可见性可以通过多种方式来保证，因此并不一定需要加锁。但原子性必须依赖锁来确保，避免 <code>B</code> 线程在进行读操作时，<code>A</code> 线程进行写操作，从根本上杜绝脏读、不可重复读、幻读等问题<br>6. 对于 <code>synchronized</code> 的本质，我们可以简单的理解为：通过为某对象或某类对象的加锁，从而控制多线程对共享资源的读写操作</p></blockquote><hr><h3 id="2-4-synchrnoized-锁升级"><a href="#2-4-synchrnoized-锁升级" class="headerlink" title="2.4. synchrnoized 锁升级"></a>2.4. synchrnoized 锁升级</h3><p>锁升级的流程为：<code>偏向锁 ➔ 轻量级锁 ➔ 重量级锁</code></p><h4 id="2-4-1-偏向锁"><a href="#2-4-1-偏向锁" class="headerlink" title="2.4.1. 偏向锁"></a>2.4.1. 偏向锁</h4><p>偏向锁的设计初衷，是在无竞争场景下进一步降低竞争锁的开销，从而提升锁操作的性能</p><p>当某线程（例如 $T_1$） 要去执行临界区代码，<code>JVM</code> 会通过 <code>CAS</code> 尝试将 $T_1$ 的 <code>Thread ID</code> 写入被加锁对象或被加锁类对象的对象头中的 <code>Mark Word</code> 中。</p><p>如果写入成功， $T_1$ 顺利执行临界区代码。如果 $T_1$ 后续再次执行临界区代码，只需检查 <code>Mark Word</code> 中的 <code>Thread ID</code> 是否与自身一致（由于偏向锁在释放时并不会主动重置对象头，因此在无竞争场景下，<code>Mark Word</code> 中依旧保留着 $T_1$ 的 <code>Thread ID</code>，所以能直接执行）</p><p>如果写入失败，则是其他线程（例如 $T_2$）正在持有偏向锁（无论 $T_2$ 是否在执行临界区代码），而这就发生了竞争，偏向锁模式就会宣告失败。此时 <code>JVM</code> 会将偏向锁升级为轻量级锁</p><p>我们可以简单的理解为：一旦某个线程持有了偏向锁，它就 “偏向” 这个线程，从头到尾都只认它，无论该线程是否在执行临界区代码。但是一旦出现第二个线程尝试竞争锁，偏向锁就会被撤销并升级为轻量级锁</p><p>然而，随着硬件性能提升和虚拟机其他优化手段的发展，偏向锁带来的性能收益已逐渐减弱，同时其实现的复杂性也成为阻碍 <code>JVM</code> 进一步优化的负担。除此之外，在高并发场景中，偏向锁撤销的开销往往大于其带来的收益。因此，<code>Oracle</code> 在 <code>Java15</code> 之后将偏向锁标记为废弃，并在 <code>Java17</code> 中将其彻底移除。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果使用的是 <code>Java8</code>，偏向锁默认是开启的，我们可以通过 <code>JVM</code> 启动参数来关闭偏向锁</li></ol></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:-UseBiasedLocking</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. 由于 <code>Mark Word</code> 的空间是有限的，存储了 <code>HashCode</code> 就没地方存 <code>Thread ID</code> 了。因此，如果在无锁状态计算了 <code>HashCode</code>，就无法再使用偏向锁，而是直接使用轻量级锁。如果在持有偏向锁时计算了 <code>HashCode</code>，偏向锁会被立即撤销，并直接升级为重量级锁（因为重量级锁的 <code>Monitor</code> 中可以存储 <code>HashCode</code>）</p></blockquote><hr><h4 id="2-4-2-轻量级锁"><a href="#2-4-2-轻量级锁" class="headerlink" title="2.4.2. 轻量级锁"></a>2.4.2. 轻量级锁</h4><p>轻量级锁的设计初衷，是在轻量竞争场景下进一步降低竞争锁的开销，从而提升锁操作的性能</p><p>当某线程（例如 $T_1$）要去执行临界区代码，<code>JVM</code> 会在 $T_1$ 的虚拟机栈的栈帧中创建一个锁记录（<code>Lock Record</code>）<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-4.png"></p><p>然后 <code>JVM</code> 将 <code>Lock Record</code> 的 <code>Object reference</code> 指向被加锁对象或被加锁类对象，并且通过 <code>CAS</code> 尝试将 <code>Lock Record</code> 的 <code>lock record</code> 地址 <code>00</code> 与被加锁对象或被加锁类对象的 <code>MarkWord</code>（即 <code>Hashcode Age Bias 01</code>）进行交换</p><p>如果交换成功， $T_1$ 顺利执行临界区代码。如果在 $T_1$ 执行临界区代码时发生了重入，同样会添加新的 <code>Lock Record</code>。$T_1$ 的虚拟机栈的栈帧中有多少个 <code>Lock Record</code>，说明发生了多少次重入<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-5.png"></p><p>当 $T_1$ 执行完临界区的代码，<code>JVM</code> 会将两者再交换回来<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-6.png"></p><p>如果交换失败，则是其他线程（例如 $T_2$）持有轻量级锁，那么 $T_1$ 会进行多次自旋。如果多次自旋仍热未成功，<code>JVM</code> 会将轻量级锁升级为重量级锁<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-7.png"></p><hr><h4 id="2-4-3-重量级锁"><a href="#2-4-3-重量级锁" class="headerlink" title="2.4.3. 重量级锁"></a>2.4.3. 重量级锁</h4><p>监视器（<code>Monitor</code>、管程）是 <code>JVM</code> 内部专门用于实现重量级锁的结构。当升级为重量级锁时，<code>JVM</code> 会为被加锁对象或被加锁类对象创建一个 <code>Monitor</code> 对象<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-8.png"></p><p>当 $T_1$ 执行完临界区代码后，会根据线程中保存的指向被加锁对象或被加锁类对象的地址，找到该对象或类对象，然后再根据该对象的对象头的 <code>Mark Word</code> 找到 <code>Monitor</code>，将其 <code>Owner</code> 设置为 <code>null</code>，并唤醒 <code>Monitor</code> 中 <code>EntryList</code> 中所有等待的线程，这些线程随后开始竞争重量级锁（ <code>Monitor</code> 的 <code>Owner</code>）</p><hr><h2 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h2><p>详见源码：<code>ReentrantLock</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h2 id="4-ReentrantReadWriteLock"><a href="#4-ReentrantReadWriteLock" class="headerlink" title="4. ReentrantReadWriteLock"></a>4. ReentrantReadWriteLock</h2><p>详见源码：<code>ReentrantReadWriteLock</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantReadWriteLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h2 id="5-CAS"><a href="#5-CAS" class="headerlink" title="5. CAS"></a>5. CAS</h2><h3 id="5-1-CAS-概述"><a href="#5-1-CAS-概述" class="headerlink" title="5.1. CAS 概述"></a>5.1. CAS 概述</h3><p><code>CAS</code> 是一种思想，其核心思想是：当前线程在进行写操作时，当 <code>V = E</code> 时，修改为 <code>N</code>。当 <code>V ≠ E</code> 时，不进行任何操作。其中 <code>V</code>、<code>E</code>、<code>N</code> 是指：</p><ol><li><code>V</code>（<code>Current Value</code>）<ol><li>当前线程在进行写操作时，共享变量在主内存中的实际值</li></ol></li><li><code>E</code>（<code>Expected Value</code>）<ol><li>当前线程在进行写操作时，期望共享变量在主内存中的实际值</li><li>简单来说就是：$t_1$ 时从主内存拿到的共享变量，我们期望 $t_2$ 时主内存中的共享变量仍然是这个值</li></ol></li><li><code>N</code>（<code>New Value</code>）<ol><li>当前线程在进行写操作时，要把共享变量修改为该值</li></ol></li></ol><p>为了实现 <code>CAS</code> 思想，不同的 <code>CPU</code> 厂商提供了不同的原子性的机器码指令（例如 <code>x86</code> 是 <code>CMPXCHG</code>，<code>ARM</code> 是 <code>LDXR/STXR</code> 组合），我们一般把这些机器码指令称之为 “<code>CAS</code> 指令”</p><p>在日常交流中，我们常把把 <code>CAS</code> 和 <code>CAS</code> 指令混为一谈。在 <code>Java</code> 中，说到 “使用 <code>CAS</code>”，其实就是通过 <code>Unsafe</code> 调用了 <code>CAS</code> 指令</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>CAS</code> 本质上并不是一种锁，而是一种更新机制</li><li>虽然 <code>V</code> 说是 ”当前线程在进行写操作时，共享变量在主内存中的实际值“，但是由于 <code>JMM</code> 的存在，我们可能仍从工作内存读 <code>V</code>，所以有可见性问题。除此之外，还有有序性问题。因此即便使用 <code>CAS</code>，通常结合 <code>volatile</code> 修饰符使用，<code>CAS</code> 保证原子性，<code>volatile</code> 保证可见性、顺序性</li><li>当我们使用 <code>CAS</code> 时，目标肯定是希望写操作成功。所以我们通常会循环执行 <code>CAS</code>，直到写操作成功</li></ol></blockquote><hr><h3 id="5-2-CAS-问题爆破"><a href="#5-2-CAS-问题爆破" class="headerlink" title="5.2. CAS 问题爆破"></a>5.2. CAS 问题爆破</h3><h4 id="5-2-1-ABA-问题"><a href="#5-2-1-ABA-问题" class="headerlink" title="5.2.1. ABA 问题"></a>5.2.1. ABA 问题</h4><h5 id="5-2-1-1-ABA-问题概述"><a href="#5-2-1-1-ABA-问题概述" class="headerlink" title="5.2.1.1. ABA 问题概述"></a>5.2.1.1. ABA 问题概述</h5><p><code>ABA</code> 问题是指：当 <code>V = E</code> 时，尽管 <code>CAS</code> 操作成功了，但实际上该位置的数据可能曾经发生过变化。例如我们桌子上有一杯水（<code>A</code>），你离开了一会儿。期间别人把你杯子里的水喝了（变成 <code>B</code>），然后又重新倒满水（变回 <code>A</code>）。等你回来时，看到水还是满的，你以为没人动过，但实际上里面的水已经变了</p><p>很多时候 <code>ABA</code> 问题可能无伤大雅。但是在一些业务逻辑时，这个问题可能是致命的</p><hr><h5 id="5-2-1-2-ABA-问题解决方案"><a href="#5-2-1-2-ABA-问题解决方案" class="headerlink" title="5.2.1.2. ABA 问题解决方案"></a>5.2.1.2. ABA 问题解决方案</h5><h6 id="5-2-1-2-1-版本号"><a href="#5-2-1-2-1-版本号" class="headerlink" title="5.2.1.2.1. 版本号"></a>5.2.1.2.1. 版本号</h6><p>版本号是指：不仅比较值（即 <code>V = E</code>），还要比较版本号。即 $CAS(E, N)➔CAS(E + Version_E, B + Version_B)$，当线程在进行写操作时，不仅要 <code>V = E</code>，还要 $Version_V&#x3D;Version_E$</p><p>而 <code>AtomicStampedReference</code> 就采用了这种方式解决了 <code>ABA</code> 问题。</p><p>除此之外，<code>AtomicMarkableReference</code> 可以看作是 <code>AtomicStampedReference</code> 的简化版，但是它并没有严格使用版本号。<code>AtomicMarkableReference</code> 是为了解决 “很多时候我们并不需要知道它被修改了多少次，而是只需要知道它是否被修改过” 的问题</p><hr><h3 id="5-3-Atomic-原子类"><a href="#5-3-Atomic-原子类" class="headerlink" title="5.3. Atomic* 原子类"></a>5.3. Atomic* 原子类</h3><h4 id="5-3-1-Atomic-原子类概述"><a href="#5-3-1-Atomic-原子类概述" class="headerlink" title="5.3.1. Atomic* 原子类概述"></a>5.3.1. Atomic* 原子类概述</h4><p><code>Atomic*</code> 原子类是使用 <code>CAS</code> 实现多线程并发安全的一些类</p><hr><h4 id="5-3-2-Atomic-原子类相关分类"><a href="#5-3-2-Atomic-原子类相关分类" class="headerlink" title="5.3.2. Atomic* 原子类相关分类"></a>5.3.2. Atomic* 原子类相关分类</h4><ol><li><code>AtomicBoolean</code></li><li><code>AtomicInteger</code></li><li><code>AtomicIntegerArray</code></li><li><code>AtomicIntegerFieldUpdater</code></li><li><code>AtomicIntegerFieldUpdaterImpl</code></li><li><code>AtomicLong</code></li><li><code>AtomicLongArray</code></li><li><code>AtomicLongFieldUpdater</code></li><li><code>AtomicReference</code></li><li><code>AtomicReferenceArray</code></li><li><code>AtomicReferenceFieldUpdater</code></li><li><code>AtomicReferenceFieldUpdaterImpl</code></li><li><code>AtomicMarkableReference</code></li><li><code>AtomicStampedReference</code></li><li><code>LongAdder</code></li><li><code>DoubleAdder</code></li></ol><hr><h1 id="六、并发工具"><a href="#六、并发工具" class="headerlink" title="六、并发工具"></a>六、并发工具</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h2><p>详见源码：<code>CountDownLatch</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CountDownLatch源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p>详见源码：<code>CyclicBarrier</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CyclicBarrier源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h2><p>详见源码：<code>Semaphore</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Semaphore源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1-线程池基础体系"><a href="#1-线程池基础体系" class="headerlink" title="1. 线程池基础体系"></a>1. 线程池基础体系</h2><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-9.png"></p><ol><li>详见源码：<code>Executor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Executor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>AbstractExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.AbstractExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ScheduledExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ThreadPoolExecutor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ThreadPoolExecutor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ScheduledThreadPoolExecutor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledThreadPoolExecutor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ForkJoinPool</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol><p>    </p><blockquote><p>[!NOTE] 注意事项</p><ol><li>线程池的三架马车：<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>ForkJoinPool</code></li></ol></blockquote><hr><h1 id="八、异步编程"><a href="#八、异步编程" class="headerlink" title="八、异步编程"></a>八、异步编程</h1><h2 id="1-异步编程基础体系"><a href="#1-异步编程基础体系" class="headerlink" title="1. 异步编程基础体系"></a>1. 异步编程基础体系</h2><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-10.png"></p><ol><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Comparable&lt;T&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Comparable＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Callable&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Callable＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Delayed</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Delayed源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Future＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>RunnableFuture&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ForkJoinTask&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>FutureTask&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.FutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>RunnableScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ScheduledFutureTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>RecursiveAction</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RecursiveAction源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>RecursiveTask&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RecursiveTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>CountedCompleter&lt;T&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CountedCompleter＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol><hr><h2 id="2-异步编程实现方式"><a href="#2-异步编程实现方式" class="headerlink" title="2. 异步编程实现方式"></a>2. 异步编程实现方式</h2><h3 id="2-1-伪异步"><a href="#2-1-伪异步" class="headerlink" title="2.1. 伪异步"></a>2.1. 伪异步</h3><p>伪异步是指：当前线程将我们执行的 <code>Java</code> 代码中，一些耗时的操作交给其他线程（通常使用专门的线程池）去执行，当前线程可以直接继续向下执行</p><hr><h3 id="2-2-伪异步-异步编程等待"><a href="#2-2-伪异步-异步编程等待" class="headerlink" title="2.2. 伪异步 + 异步编程等待"></a>2.2. 伪异步 + 异步编程等待</h3><p> 伪异步 + 异步编程等待是指：虽然当前线程将我们执行的 <code>Java</code> 代码中，一些耗时的操作交给其他线程（通常使用专门的线程池）去执行，但当前线程仍然需要该任务的返回结果，所以当前线程必须在后续某个时刻获取该任务的返回结果</p><p>通常的做法是：提交任务后返回一个凭证（即 <code>Future</code>，常见具体实现类主要包括 <code>FutureTask</code>、<code>ScheduledFutureTask</code>、<code>ForkJoinTask</code>），然后根据这个凭证在需要结果时获取结果，然后再继续向下执行</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>异步编程等待既可能是阻塞的也可能是限时阻塞的</li></ol></blockquote><hr><h3 id="2-3-伪异步-异步编程回调"><a href="#2-3-伪异步-异步编程回调" class="headerlink" title="2.3. 伪异步 + 异步编程回调"></a>2.3. 伪异步 + 异步编程回调</h3><p>这部分内容涉及到了 <code>CompletableFuture</code>，详见笔记：<code>Java</code> 函数式编程（<code>obsidian</code> 内部链接：<a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">笔记：Java函数式编程</a>，<code>Hexo</code> 链接：）</p><hr><h3 id="伪异步-异步流式回调（响应式）"><a href="#伪异步-异步流式回调（响应式）" class="headerlink" title="伪异步 + 异步流式回调（响应式）"></a>伪异步 + 异步流式回调（响应式）</h3><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Semaphore 源码解析</title>
    <link href="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Semaphore-概述"><a href="#3-1-Semaphore-概述" class="headerlink" title="3.1. Semaphore 概述"></a>3.1. Semaphore 概述</h3><p><code>Semaphore</code> 是一个具体类</p><p>信号量（<code>Semaphore</code>）是使用 <code>AQS</code> 实现的共享模式的同步器。<code>State</code> 和共享资源分别表示以下含义：</p><ol><li><code>State</code> 表示剩余的 “许可证” 的数量</li><li>共享资源表示持有 “许可证” 期间被允许执行的操作</li></ol><p>我们可以将 <code>Semaphore</code> 简单的理解为：可重复的、既能做减法也能做加法的计数器，计的数就是 “许可证”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>简单理解 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>：<ol><li><code>CountDownLatch</code> 是门闩开启才能继续执行</li><li><code>CyclicBarrier</code> 是 “互相等待” 都准备好才能继续执行</li><li><code>Semaphore</code> 是拿到 “许可证” 才能继续执行</li></ol></li></ol></blockquote><hr><h3 id="3-2-Semaphore-应用场景"><a href="#3-2-Semaphore-应用场景" class="headerlink" title="3.2. Semaphore 应用场景"></a>3.2. Semaphore 应用场景</h3><h4 id="3-2-1-并发控制"><a href="#3-2-1-并发控制" class="headerlink" title="3.2.1. 并发控制"></a>3.2.1. 并发控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFlowControl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">mySemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mySemaphore.acquire(); <br>            ...<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mySemaphore.release();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>无论是线程饥饿、流量控制，还是 <code>IO</code> 阻塞，这些问题的本质都是相同的：因无法获取所需要的资源，导致无法继续执行。针对这种 “资源匮乏” 的问题，通常有五种解决方案：<ol><li>强制排队</li><li>资源预留</li><li>及时止损<ol><li>异步处理</li><li>降级处理</li><li>启动告警</li><li>异步编程回调</li></ol></li><li>随即避让</li><li>调整优先级</li></ol></li><li>流量控制主要包括并发控制和速率限制</li></ol></blockquote><hr><h4 id="3-2-2-资源池管理"><a href="#3-2-2-资源池管理" class="headerlink" title="3.2.2. 资源池管理"></a>3.2.2. 资源池管理</h4><p>常见的资源池包括连接池、线程池、对象池</p><p>以连接池为例，可以将连接池中的连接的数量与 <code>Semaphore</code> 的 ”许可证“ 的数量关联起来。在获取连接之前先获取 ”许可证“，在归还连接之后再归还 ”许可证“</p><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Sync"><a href="#4-1-Sync" class="headerlink" title="4.1. Sync"></a>4.1. Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br>Sync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br>setState(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPermits</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br><span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>compareAndSetState(available, remaining))<br><span class="hljs-keyword">return</span> remaining;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br><span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br><span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reducePermits</span><span class="hljs-params">(<span class="hljs-type">int</span> reductions)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current - reductions;<br><span class="hljs-keyword">if</span> (next &gt; current) <span class="hljs-comment">// underflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Permit count underflow&quot;</span>);<br><span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">drainPermits</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (current == <span class="hljs-number">0</span> || compareAndSetState(current, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> current;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-FairSync"><a href="#4-2-FairSync" class="headerlink" title="4.2. FairSync"></a>4.2. FairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>FairSync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br><span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>compareAndSetState(available, remaining))<br><span class="hljs-keyword">return</span> remaining;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-NonfairSync"><a href="#4-3-NonfairSync" class="headerlink" title="4.3. NonfairSync"></a>4.3. NonfairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>NonfairSync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-Semaphore-int-permits"><a href="#5-1-Semaphore-int-permits" class="headerlink" title="5.1. Semaphore(int permits)"></a>5.1. Semaphore(int permits)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br><br>sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-Semaphore-int-permits-boolean-fair"><a href="#5-2-Semaphore-int-permits-boolean-fair" class="headerlink" title="5.2. Semaphore(int permits, boolean fair)"></a>5.2. Semaphore(int permits, boolean fair)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br><br>sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CyclicBarrier 源码解析</title>
    <link href="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CyclicBarrier-概述"><a href="#3-1-CyclicBarrier-概述" class="headerlink" title="3.1. CyclicBarrier 概述"></a>3.1. CyclicBarrier 概述</h3><p><code>CyclicBarrier</code> 是一个具体类</p><p>循环栅栏（<code>CyclicBarrier</code>）可以简单的理解为 <code>CountDownLatch</code> 的一个变种。我们使用 <code>CountDownLatch</code> 实现汇总模式（主线程等待、子线程减数）、发令枪模式（子线程等待，主线程减数）时，会发现它们总是需要另一方来触发减数，像是缺少一个 “点火” 键</p><p>而 <code>CyclicBarrier</code> 是参与线程既减数，也等待。假设需要 <code>10</code> 个线程到达同步点，前 <code>9</code> 个线程在到达同步点后，都会减数然后等待，此时计数从 <code>10 ➔ 1</code>。当最后一个线程到达同步点时，也会减数然后等待，此时计数从 <code>1 ➔ 0</code>，所有线程同时继续向下执行。整个过程不需要额外的 “点火” 键，实现了 “线程互相等待”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>CountDownLatch</code> 是使用 <code>AQS</code> 实现的，而 <code>CyclicBarrier</code> 是使用 <code>ReentrantLock</code> 实现的</li><li><code>CountDownLatch</code> 是一次性的，而 <code>CyclicBarrier</code> 是可重复使用的</li><li>简单理解 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>：<ol><li><code>CountDownLatch</code> 是门闩开启才能继续执行</li><li><code>CyclicBarrier</code> 是 “互相等待” 都准备好才能继续执行</li><li><code>Semaphore</code> 是拿到 “许可证” 才能继续执行</li></ol></li></ol></blockquote><hr><h3 id="3-2-CyclicBarrier-应用场景"><a href="#3-2-CyclicBarrier-应用场景" class="headerlink" title="3.2. CyclicBarrier 应用场景"></a>3.2. CyclicBarrier 应用场景</h3><h4 id="3-2-1-并发压力测试"><a href="#3-2-1-并发压力测试" class="headerlink" title="3.2.1. 并发压力测试"></a>3.2.1. 并发压力测试</h4><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedLongSynchronizer 源码解析</title>
    <link href="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedLongSynchronizer-概述"><a href="#3-1-AbstractQueuedLongSynchronizer-概述" class="headerlink" title="3.1. AbstractQueuedLongSynchronizer 概述"></a>3.1. AbstractQueuedLongSynchronizer 概述</h3><p><code>AbstractQueuedLongSynchronizer</code> 是一个抽象类，继承了 <code>java.util.concurrent.locks.AbstractOwnableSynchronizer</code>，实现了 <code>java.io.Serializable</code><br><img src="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>AbstractQueuedLongSynchronizer</code> 和 <code>AbstractQueuedSynchronizer</code> 是一样的，只不过 <code>State</code> 从 <code>32 bit ➔ 64 bit</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractOwnableSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.ThreadLocal＜T＞.ThreadLocalMap 源码解析</title>
    <link href="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ThreadLocal-ThreadLocalMap-概述"><a href="#3-1-ThreadLocal-ThreadLocalMap-概述" class="headerlink" title="3.1. ThreadLocal.ThreadLocalMap 概述"></a>3.1. ThreadLocal.ThreadLocalMap 概述</h3><p><code>ThreadLocal.ThreadLocalMap</code> 是一个具体类，是 <code>ThreadLocal</code> 的静态内部类</p><p><code>ThreadLocal.ThreadLocalMap</code> 是通过 <code>ThreadLocal.ThreadLocalMap-&gt;table</code> 存储数据的，该数组是由 <code>Entry</code> 构建的数组。每个 <code>Entry</code> 的 <code>key</code> 必须是 <code>ThreadLocal</code> 类型，而 <code>value</code> 是 <code>Object</code> 类型。因此，我们可以把它简单理解为：<br><img src="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>为什么 <code>ThreadLocal.ThreadLocalMap</code> 要使用 <code>ThreadLocal</code> 实例作为 <code>Key</code>？能不能使用其他类的实例？<ol><li>在一个复杂的 <code>Java</code> 应用中，会引入大量第三方依赖，它们内部可能都会使用 <code>ThreadLocal</code> 存储上下文数据</li><li>如果 <code>Key</code> 使用字符串（例如 “<code>myName</code>”），不同依赖可能恰好用到同名的 <code>Key</code>，最终导致数据被覆盖</li><li>而使用 <code>ThreadLocal</code> 实例作为 <code>Key</code> 依赖于它的对象地址，因为你即便创建了同名的 <code>ThreadLocal</code> 实例，它们的对象地址仍然是不同的</li><li>那么到底能不能使用其他类的实例呢？从实现的角度来看，只要是实例，就都能当 <code>Key</code>，当然不限制必须是 <code>ThreadLocal</code> 实例。但是 Entry 的构造方法被设计的就是使用 <code>ThreadLocal</code> 实例，所以我们就使用这个好了</li></ol></li><li>为什么 <code>Thread</code> 不直接使用其他的 <code>Map</code>，而是使用 <code>ThreadLocal.ThreadLocalMap</code>？<ol><li>这主要是为了尽量避免内存泄漏，虽然没有彻底杜绝，但是比其他的 <code>Map</code> 要好得多</li><li>因为其他的 <code>Map</code> 的 <code>Key</code> 是强引用，只要线程存活，那么 <code>ThreadLocal</code> 实例就永远无法被回收</li><li>而 <code>ThreadLocal.ThreadLocalMap</code> 的 <code>Key</code> 是弱引用，可以在 <code>ThreadLocal</code> 实例不再被使用时被回收</li><li>虽然 <code>ThreadLocal#set</code>、<code>ThreadLocal#get</code> 能在 <code>Key</code> 为 <code>null</code> 时清理 <code>Value</code>，但是这是 “被动清理”，并不可靠</li></ol></li><li><code>ThreadLocal.ThreadLocalMap</code> 有没有位置冲突？它是如何解决位置冲突的？<ol><li>有，它是采取 “线性探测” 的方式解决位置冲突的。即 如果 <code>i</code> 已经被占用，就尝试 <code>i + 1</code>，以此类推…</li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-ThreadLocal-ThreadLocalMap-使用方式"><a href="#3-2-ThreadLocal-ThreadLocalMap-使用方式" class="headerlink" title="3.2. ThreadLocal.ThreadLocalMap 使用方式"></a>3.2. ThreadLocal.ThreadLocalMap 使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个 ThreadLocal 实例，通常由 static final 修饰</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; userContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 存数据</span><br>            userContext.set(<span class="hljs-string">&quot;用户A的数据&quot;</span>);<br>            <span class="hljs-comment">// 取数据</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取: &quot;</span> + userContext.get());<br>            <span class="hljs-comment">// 删数据</span><br>            userContext.remove();<br>        &#125;, <span class="hljs-string">&quot;Thread-A&quot;</span>).start();<br><br>        <span class="hljs-comment">// 模拟线程 B</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            userContext.set(<span class="hljs-string">&quot;用户B的数据&quot;</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取: &quot;</span> + userContext.get());<br>            userContext.remove();<br>        &#125;, <span class="hljs-string">&quot;Thread-B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在上述代码中，看起来像是在对 <code>ThreadLocal</code> 实例本身进行读写，但真正的逻辑是：通过当前线程找到它所持有的 <code>ThreadLocal.ThreadLocalMap</code>，然后在这个 <code>Map</code> 的 <code>Entry[]</code> 中，以当前 <code>ThreadLocal</code> 实例为 <code>Key</code> 进行读写。</li><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code><ol><li>为什么 <code>ThreadLocal</code> 实例通常由 <code>static final</code> 修饰？<ol><li>这主要是为了减少内存占用，因为即便多个 <code>ThreadLocal.ThreadLocalMap</code> 使用同一个 <code>ThreadLocal</code> 实例当 <code>Key</code>，但是它们互不影响。所以没必要专门为每一个 <code>ThreadLocal.ThreadLocalMap</code> 创建一个 <code>ThreadLocal</code> 实例</li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-3-ThreadLocal-ThreadLocalMap-问题爆破"><a href="#3-3-ThreadLocal-ThreadLocalMap-问题爆破" class="headerlink" title="3.3. ThreadLocal.ThreadLocalMap 问题爆破"></a>3.3. ThreadLocal.ThreadLocalMap 问题爆破</h3><h4 id="3-3-1-数据-“脏读”"><a href="#3-3-1-数据-“脏读”" class="headerlink" title="3.3.1. 数据 “脏读”"></a>3.3.1. 数据 “脏读”</h4><p>某线程在处理上一个任务时，向 <code>ThreadLocal</code> 写入了数据，但是任务结束后没有清理。当该线程去处理下一个任务的时候，调用 <code>ThreadLocal#get</code> 会读到上一个任务遗留下来的数据</p><p>为了解决这一问题，我们需要任务结束后调用 <code>Thread#remove</code> 删除数据</p><hr><h4 id="3-3-2-内存泄漏"><a href="#3-3-2-内存泄漏" class="headerlink" title="3.3.2. 内存泄漏"></a>3.3.2. 内存泄漏</h4><p>由于 <code>ThreadLocal.ThreadLocalMap</code> 的 <code>Key</code> 是弱引用，而 <code>Value</code> 是强引用。所以当 <code>ThreadLocal</code> 实例被回收后，<code>Key</code> 会变成 <code>null</code>，但是对应的 <code>Value</code> 仍然存在，无法被回收</p><p>为了解决这一问题，我们需要任务结束后调用 <code>Thread#remove</code> 删除数据</p><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Entry"><a href="#4-1-Entry" class="headerlink" title="4.1. Entry"></a>4.1. Entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br><br>Object value;<br><br>Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br><span class="hljs-built_in">super</span>(k);<br>value = v;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br><span class="hljs-keyword">private</span> Entry[] table;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CountDownLatch 源码解析</title>
    <link href="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CountDownLatch-概述"><a href="#3-1-CountDownLatch-概述" class="headerlink" title="3.1. CountDownLatch 概述"></a>3.1. CountDownLatch 概述</h3><p><code>CountDownLatch</code> 是一个具体类</p><p>倒计时门闩（<code>CountDownLatch</code>）是使用 <code>AQS</code> 实现的共享模式的同步器。<code>State</code> 和共享资源分别表示以下含义：</p><ol><li><code>State</code> 表示门闩是否开启<ol><li><code>0</code><ol><li>门闩开启</li></ol></li><li><code>n</code>（<code>n &gt; 0</code>）<ol><li>门闩关闭</li></ol></li></ol></li><li>共享资源表示门闩开启后，被允许执行的操作</li></ol><p>我们可以将 <code>CountDownLatch</code> 简单的理解为：一次性的、只做减法的计数器。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>简单理解 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>：<ol><li><code>CountDownLatch</code> 是门闩开启才能继续执行</li><li><code>CyclicBarrier</code> 是 “互相等待” 都准备好才能继续执行</li><li><code>Semaphore</code> 是拿到 “许可证” 才能继续执行</li></ol></li></ol></blockquote><hr><h3 id="3-2-CountDownLatch-应用场景"><a href="#3-2-CountDownLatch-应用场景" class="headerlink" title="3.2. CountDownLatch 应用场景"></a>3.2. CountDownLatch 应用场景</h3><h4 id="3-2-1-汇总模式"><a href="#3-2-1-汇总模式" class="headerlink" title="3.2.1. 汇总模式"></a>3.2.1. 汇总模式</h4><p>汇总模式是指：主线程等待多个子线程准备好后，才能继续执行</p><p>我们可以简单的理解为：主线程等待，子线程减数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">myCountDownlatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(finalI);<br>                <br>                <span class="hljs-comment">// 调用 CountDownLatch#countDown</span><br>                myCountDownlatch.countDown();<br>            &#125;).start();<br>        &#125;<br><br><span class="hljs-comment">// 调用 CountDownLatch#await</span><br>        myCountDownlatch.await();<br>        <br>        System.out.println(<span class="hljs-string">&quot;天下贤才尽数会于麾下！&quot;</span>);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-发令枪模式"><a href="#3-2-2-发令枪模式" class="headerlink" title="3.2.2. 发令枪模式"></a>3.2.2. 发令枪模式</h4><p>发令枪模式是指：多个子线程准备好后，等待主线程 “发枪”，才能继续执行</p><p>我们可以简单的理解为：子线程等待，主线程减数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">myCountDownlatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                <br>                <span class="hljs-comment">// 调用 CountDownLatch#await</span><br>                    myCountDownlatch.await();<br>                    System.out.println(finalI);<br>                    myCountDownlatch.countDown();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;天下贤才尽数听令而动！&quot;</span>);<br><br><span class="hljs-comment">// 调用 CountDownLatch#countDown</span><br>        myCountDownlatch.countDown();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <br>        Sync(<span class="hljs-type">int</span> count) &#123;<br>            setState(count);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>        <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.getCount();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + <span class="hljs-string">&quot;[Count = &quot;</span> + sync.getCount() + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RecursiveTask＜V＞ 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="RecursiveTask-概述"><a href="#RecursiveTask-概述" class="headerlink" title="RecursiveTask 概述"></a>RecursiveTask 概述</h3><p><code>RecursiveTask</code> 是一个抽象类，继承了 <code>java.util.concurrent.ForkJoinTask＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ForkJoinTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究。详见源码：<code>ForkJoinPool</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a>，<code>Hexo</code> 链接：）</li></ol></blockquote><hr><h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">5232453952276485270L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecursiveTask</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span><br>    V result;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span> &#123;<br>        result = value;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        result = compute();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CountedCompleter＜T＞ 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CountedCompleter-概述"><a href="#3-1-CountedCompleter-概述" class="headerlink" title="3.1. CountedCompleter 概述"></a>3.1. CountedCompleter 概述</h3><p><code>CountedCompleter</code> 是一个抽象类，继承了 <code>java.util.concurrent.ForkJoinTask＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>CountedCompleter</code> 是一个 ”天书“ 级别的类，它设计的初衷是：解决 ”当一组任务完成后触发一个回调“ 的问题，但是它用起来非常的反直觉，并且极易出错</p><p>而 <code>CompletableFuture</code> 就是 <code>CountedCompleter</code> 的 ”现代易用版“，我们可以直接使用 <code>CompletableFuture</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ForkJoinTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ForkJoinTask＜V＞ 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ForkJoinTask-概述"><a href="#3-1-ForkJoinTask-概述" class="headerlink" title="3.1. ForkJoinTask 概述"></a>3.1. ForkJoinTask 概述</h3><p><code>ForkJoinTask</code> 是一个抽象类，实现了 <code>java.util.concurren.Future＜V＞</code>、<code>java.io.Serializable</code><br><img src="/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Future＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Serializable源码解析</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究。详见源码：<code>ForkJoinPool</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a>，<code>Hexo</code> 链接：）</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RecursiveAction 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-RecursiveAction-概述"><a href="#3-1-RecursiveAction-概述" class="headerlink" title="3.1. RecursiveAction 概述"></a>3.1. RecursiveAction 概述</h3><p><code>RecursiveAction</code> 是一个抽象类，继承了 <code>java.util.concurrent.ForkJoinTask＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ForkJoinTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究。详见源码：<code>ForkJoinPool</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a>，<code>Hexo</code> 链接：）</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">5232453952276485070L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecursiveAction</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void mustBeNull)</span> &#123; &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        compute();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledThreadPoolExecutor-ScheduledFutureTask-概述"><a href="#3-1-ScheduledThreadPoolExecutor-ScheduledFutureTask-概述" class="headerlink" title="3.1. ScheduledThreadPoolExecutor.ScheduledFutureTask 概述"></a>3.1. ScheduledThreadPoolExecutor.ScheduledFutureTask 概述</h3><p><code>ScheduledThreadPoolExecutor.ScheduledFutureTask</code> 是一个具体类，是 <code>java.util.concurrent.ScheduledThreadPoolExecutor</code> 的普通内部类，继承了 <code>java.util.concurrent.FutureTask＜V＞</code>、<code>java.util.concurrent.RunnableScheduledFuture＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>FutureTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.FutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>RunnableScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示任务执行点</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 哪些需要排序的 Java 数据类型就是以任务执行点进行排序的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> time;<br><br><span class="hljs-comment">// 表示任务序号</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果多个 FutureTask 的任务执行点相同，任务序号小的任务会排在前面</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequenceNumber;<br><br><span class="hljs-comment">// 表示任务是否是周期性任务，以及如何进行周期性</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 可选参数包括：</span><br><span class="hljs-comment">//     1. 0</span><br><span class="hljs-comment">//         1. “一次性” 任务</span><br><span class="hljs-comment">//     2. n（n &gt; 0）</span><br><span class="hljs-comment">//         1. 以 period 的固定速率，周期性执行任务</span><br><span class="hljs-comment">//     2. n（n &lt; 0）</span><br><span class="hljs-comment">//         1. 以 period 的固定延迟，周期性执行任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<br><br><span class="hljs-comment">// 表示任务对应的二叉堆索引</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 堆索引是为了实现快速 Future#cancel 操作的重大优化</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 因为 DelayQueue 使用了 PriorityQueue,而 PriorityQueue 底层基于二叉堆，而二叉堆底层又基于数组</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果没有 heapIndex 并调用 Future#cancel，就需要遍历数组去找到这个任务，然后再进行删除</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果拥有 heapIndex，当任务在 DelayQueue 变化位置时，会自动更新这个 heapIndex，那么 heapIndex 是直指这个任务的。所以调用 Future#cancel 的时候，就可以直接根据 heapIndex 找到这个任务，然后再进行删除</span><br><span class="hljs-type">int</span> heapIndex;<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-ScheduledFutureTask-Callable＜V＞-callable-long-triggerTime-long-sequenceNumber"><a href="#5-1-ScheduledFutureTask-Callable＜V＞-callable-long-triggerTime-long-sequenceNumber" class="headerlink" title="5.1. ScheduledFutureTask(Callable＜V＞ callable, long triggerTime, long sequenceNumber)"></a>5.1. ScheduledFutureTask(Callable＜V＞ callable, long triggerTime, long sequenceNumber)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> triggerTime,<br><span class="hljs-type">long</span> sequenceNumber) &#123;<br><span class="hljs-built_in">super</span>(callable);<br><span class="hljs-built_in">this</span>.time = triggerTime;<br><span class="hljs-built_in">this</span>.period = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">this</span>.sequenceNumber = sequenceNumber;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-sequenceNumber"><a href="#5-2-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-sequenceNumber" class="headerlink" title="5.2. ScheduledFutureTask(Runnable r, V result, long triggerTime, long sequenceNumber)"></a>5.2. ScheduledFutureTask(Runnable r, V result, long triggerTime, long sequenceNumber)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> triggerTime,<br><span class="hljs-type">long</span> sequenceNumber) &#123;<br><span class="hljs-built_in">super</span>(r, result);<br><span class="hljs-built_in">this</span>.time = triggerTime;<br><span class="hljs-built_in">this</span>.period = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">this</span>.sequenceNumber = sequenceNumber;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-3-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-period-long-sequenceNumber"><a href="#5-3-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-period-long-sequenceNumber" class="headerlink" title="5.3. ScheduledFutureTask(Runnable r, V result, long triggerTime, long period, long sequenceNumber)"></a>5.3. ScheduledFutureTask(Runnable r, V result, long triggerTime, long period, long sequenceNumber)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> triggerTime,<br><span class="hljs-type">long</span> period, <span class="hljs-type">long</span> sequenceNumber) &#123;<br><span class="hljs-built_in">super</span>(r, result);<br><span class="hljs-built_in">this</span>.time = triggerTime;<br><span class="hljs-built_in">this</span>.period = period;<br><span class="hljs-built_in">this</span>.sequenceNumber = sequenceNumber;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h2><h3 id="6-1-实例具体方法"><a href="#6-1-实例具体方法" class="headerlink" title="6.1. 实例具体方法"></a>6.1. 实例具体方法</h3><h4 id="6-1-1-具体方法（普通）"><a href="#6-1-1-具体方法（普通）" class="headerlink" title="6.1.1. 具体方法（普通）"></a>6.1.1. 具体方法（普通）</h4><h5 id="6-1-1-1-void-setNextRunTime"><a href="#6-1-1-1-void-setNextRunTime" class="headerlink" title="6.1.1.1. void setNextRunTime()"></a>6.1.1.1. void setNextRunTime()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br><span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>time += p;<br><span class="hljs-keyword">else</span><br>time = triggerTime(-p);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="6-1-2-具体方法（实现）"><a href="#6-1-2-具体方法（实现）" class="headerlink" title="6.1.2. 具体方法（实现）"></a>6.1.2. 具体方法（实现）</h4><h5 id="6-1-2-1-Comparable＜T＞-中接口方法的实现"><a href="#6-1-2-1-Comparable＜T＞-中接口方法的实现" class="headerlink" title="6.1.2.1. Comparable＜T＞ 中接口方法的实现"></a>6.1.2.1. Comparable＜T＞ 中接口方法的实现</h5><h6 id="6-1-2-1-1-int-compareTo-Delayed-other"><a href="#6-1-2-1-1-int-compareTo-Delayed-other" class="headerlink" title="6.1.2.1.1. int compareTo(Delayed other)"></a>6.1.2.1.1. int compareTo(Delayed other)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br><span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-comment">// compare zero if same object</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br><span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;<br><span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);<br><span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-2-Runnable-中接口方法的实现"><a href="#6-1-2-2-Runnable-中接口方法的实现" class="headerlink" title="6.1.2.2. Runnable 中接口方法的实现"></a>6.1.2.2. Runnable 中接口方法的实现</h5><h6 id="6-1-2-2-1-void-run"><a href="#6-1-2-2-1-void-run" class="headerlink" title="6.1.2.2.1. void run()"></a>6.1.2.2.1. void run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!canRunInCurrentRunState(<span class="hljs-built_in">this</span>))<br>cancel(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isPeriodic())<br><span class="hljs-built_in">super</span>.run();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>setNextRunTime();<br>reExecutePeriodic(outerTask);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-3-Delayed-中接口方法的实现"><a href="#6-1-2-3-Delayed-中接口方法的实现" class="headerlink" title="6.1.2.3. Delayed 中接口方法的实现"></a>6.1.2.3. Delayed 中接口方法的实现</h5><h6 id="6-1-2-3-1-long-getDelay-TimeUnit-unit"><a href="#6-1-2-3-1-long-getDelay-TimeUnit-unit" class="headerlink" title="6.1.2.3.1. long getDelay(TimeUnit unit)"></a>6.1.2.3.1. long getDelay(TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br><span class="hljs-keyword">return</span> unit.convert(time - System.nanoTime(), NANOSECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-4-Future＜V＞-中接口方法的实现"><a href="#6-1-2-4-Future＜V＞-中接口方法的实现" class="headerlink" title="6.1.2.4. Future＜V＞ 中接口方法的实现"></a>6.1.2.4. Future＜V＞ 中接口方法的实现</h5><h6 id="6-1-2-4-1-boolean-cancel-boolean-mayInterruptIfRunning"><a href="#6-1-2-4-1-boolean-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="6.1.2.4.1. boolean cancel(boolean mayInterruptIfRunning)"></a>6.1.2.4.1. boolean cancel(boolean mayInterruptIfRunning)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br><span class="hljs-comment">// The racy read of heapIndex below is benign:</span><br><span class="hljs-comment">// if heapIndex &lt; 0, then OOTA guarantees that we have surely</span><br><span class="hljs-comment">// been removed; else we recheck under lock in remove()</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.cancel(mayInterruptIfRunning);<br><span class="hljs-keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="hljs-number">0</span>)<br>remove(<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">return</span> cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-5-RunnableScheduledFuture＜V＞-中接口方法的实现"><a href="#6-1-2-5-RunnableScheduledFuture＜V＞-中接口方法的实现" class="headerlink" title="6.1.2.5. RunnableScheduledFuture＜V＞ 中接口方法的实现"></a>6.1.2.5. RunnableScheduledFuture＜V＞ 中接口方法的实现</h5><h6 id="6-1-2-5-1-boolean-isPeriodic"><a href="#6-1-2-5-1-boolean-isPeriodic" class="headerlink" title="6.1.2.5.1. boolean isPeriodic()"></a>6.1.2.5.1. boolean isPeriodic()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPeriodic</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> period != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ForkJoinPool 源码解析</title>
    <link href="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ForkJoinPool-概述"><a href="#3-1-ForkJoinPool-概述" class="headerlink" title="3.1. ForkJoinPool 概述"></a>3.1. ForkJoinPool 概述</h3><p><code>ForkJoinPool</code> 是一个具体类，继承了 <code>java.util.concurrent.AbstractExecutorService</code></p><p><code>ForkJoinPool</code> 被设计用于高效执行那些可以被 ”递归拆分“ 的任务，其核心特性是：</p><ol><li>分而治之</li><li>递归拆分</li><li>工作窃取</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.AbstractExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask&lt;V&gt;</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究</li></ol></blockquote><hr><h3 id="3-2-ForkJoinPool-相关流程"><a href="#3-2-ForkJoinPool-相关流程" class="headerlink" title="3.2. ForkJoinPool 相关流程"></a>3.2. ForkJoinPool 相关流程</h3><p>我们知道：<code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 的线程执行流程大致为：<code>本地线程 ➔ Thread#run ➔ Worker#run</code></p><p>而 <code>ForkJoinPool</code> 并没有使用 <code>Worker</code>，甚至没有使用原生的 <code>Thread</code>，而是直接使用了 <code>ForkJoinWorkerThread</code>（<code>ForkJoinWorkerThread</code> 继承了 <code>Thread</code>）</p><p>你可能会疑惑：为什么要让 <code>ForkJoinWorkerThread</code> 继承 <code>Thread</code>，而不是继续使用 <code>Worker</code> 或者在 <code>Worker</code> 的基础上 “魔改” 呢？原因很简单，因为我们要为每个线程单独维护一个任务队列</p><p>每个线程都会维护一个 <code>ForkJoinPool.WorkQueue</code>，这是一个双端队列。并且这些队列都会被注册到 <code>ForkJoinPool-&gt;queues</code> 中<br><img src="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p>当线程去执行一个大任务 <code>A</code> 时，可以把 <code>A</code> 拆分成多个子任务（例如 <code>B</code>、<code>C</code>、<code>D</code>），这些子任务会被投递到该本地线程维护的任务队列中。然后你是不是认为 “线程需要阻塞等待 <code>B</code>、<code>C</code>、<code>D</code> 的完成呢？”</p><p>接下来的一部分，是 <code>ForkJoinPool</code> 设计最精妙的地方：</p><ol><li>当一个任务 <code>A</code> 被拆分成子任务 <code>B</code>、<code>C</code>、<code>D</code>，并被投递到任务队列后，按理说当前线程应该阻塞并等待 <code>B</code>、<code>C</code>、<code>D</code> 的完成。然而并非如此：当前线程确实在等待，但并没有阻塞。相反，它会继续执行当前线程维护的任务队列中的其他任务</li><li>假如执行到了 <code>B</code>，在执行 <code>B</code> 的过程中，<code>B</code> 又可以进一步拆分成更小的子任务 <code>E</code>、<code>F</code>、<code>G</code>，并被投递到任务队列后，同样在等待子任务的结果的同时，当前线程并不会立即阻塞，而是会继续执行当前线程维护的任务队列中的其他任务。以此类推…直到任务被拆分到足够小</li><li>当子任务完成后，它的结果会返回给父任务。父任务在收到所有子任务结果后，再将汇总结果返回给自己的父任务。以此类推…直到最初的大任务最终得到完整的计算结果</li><li>需要注意的是：<ol><li>如果当前线程维护的任务队列中没有其他任务了，它会根据 <code>ForkJoinPool-&gt;queues</code> 随机选择一个其他线程维护的任务队列，从队尾 “窃取” 一个任务来执行</li><li>如果当前线程维护的任务队列中没有其他任务了，也 “窃取” 不到任务了，就会有以下两种情况：<ol><li>如果当前线程还在等待任务<ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，并被投递到（XXXXX，肯定是 ForkJOinPoolTask 的队列啊） <code>Task</code> 的某队列，等待被唤醒（<code>LockSupport.unpark</code>）、被中断</li><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态后，能响应中断。线程被唤醒，重新获得 <code>CPU</code> 时间片后，会抛出 <code>InterruptedException</code> 异常，并清除 <code>Thread</code> 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）。不过我们无需对此过多关注，因为相关逻辑已由 <code>ForkJoinPool</code> 处理好了。一旦发生中断，为了不污染我们的代码，<code>ForkJoinPool</code> 会抛出 <code>CancellationException</code> 非受检异常</li></ol></li><li>如果当前线程未在等待任务（“空闲”）<ol><li>如果线程池中的线程的数量 ≤ <code>corePoolSize</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，并被投递到 ForkJoinPool 的某队列，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）</li><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态后，能响应中断。线程被唤醒，重新获得 <code>CPU</code> 时间片后，会抛出 <code>InterruptedException</code> 异常，并清除 <code>Thread</code> 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）。不过我们无需对此过多关注，因为相关逻辑已由 <code>ForkJoinPool</code> 处理好了。一旦发生中断，我们不会感知到任何异常</li></ol></li><li>如果线程池中的线程的数量 ＞<code>corePoolSize</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，并被投递到 <code>ForkJoinPool</code> 的某队列，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时<ol><li>如果超时，<code>ForkJoinPool</code> 会销毁该线程</li></ol></li><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态后，能响应中断。线程被唤醒，重新获得 <code>CPU</code> 时间片后，会抛出 <code>InterruptedException</code> 异常，并清除 <code>Thread</code> 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）。不过我们无需对此过多关注，因为相关逻辑已由 <code>ForkJoinPool</code> 处理好了。一旦发生中断，我们不会感知到任何异常</li></ol></li></ol></li></ol></li></ol></li></ol><p>我们以 <code>1</code> 累加到 <code>10000</code> 为例，来看一看究竟是怎么执行的：<br><img src="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>为什么我们不能采取 <code>ForkJoinPool</code> 的 “一个任务尚未完成，但是可以去执行其他任务” 思想，用于同步阻塞 <code>IO</code> 工作模式下的服务端，从而避免 “伪异步 + 异步编程回调”？</li><li>为什么不 “魔改” <code>Worker</code>，在 <code>Worker</code> 中添加任务队列呢？</li><li>为什么当前线程维护的任务队列中没有其他任务了，也 “窃取” 不到任务了，就要阻塞？<ol><li>防止 CPU 空转</li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h2><h3 id="4-1-public-ForkJoinPool-int-parallelism-ForkJoinWorkerThreadFactory-factory-UncaughtExceptionHandler-handler-boolean-asyncMode-int-corePoolSize-int-maximumPoolSize-int-minimumRunnable-Predicate＜-super-ForkJoinPool＞-saturate-long-keepAliveTime-TimeUnit-unit"><a href="#4-1-public-ForkJoinPool-int-parallelism-ForkJoinWorkerThreadFactory-factory-UncaughtExceptionHandler-handler-boolean-asyncMode-int-corePoolSize-int-maximumPoolSize-int-minimumRunnable-Predicate＜-super-ForkJoinPool＞-saturate-long-keepAliveTime-TimeUnit-unit" class="headerlink" title="4.1. public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode, int corePoolSize, int maximumPoolSize, int minimumRunnable, Predicate＜? super ForkJoinPool＞ saturate, long keepAliveTime,TimeUnit unit)"></a>4.1. public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode, int corePoolSize, int maximumPoolSize, int minimumRunnable, Predicate＜? super ForkJoinPool＞ saturate, long keepAliveTime,TimeUnit unit)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：</span><br><span class="hljs-comment"> * public ForkJoinPool(int parallelism,</span><br><span class="hljs-comment"> *         ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-comment"> *         UncaughtExceptionHandler handler,</span><br><span class="hljs-comment"> *         boolean asyncMode,</span><br><span class="hljs-comment"> *         int corePoolSize,</span><br><span class="hljs-comment"> *         int maximumPoolSize,</span><br><span class="hljs-comment"> *         int minimumRunnable,</span><br><span class="hljs-comment"> *         Predicate&lt;? super ForkJoinPool&gt; saturate,</span><br><span class="hljs-comment"> *         long keepAliveTime,</span><br><span class="hljs-comment"> *         TimeUnit unit)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. int parallelism</span><br><span class="hljs-comment"> *          1. 指定我们期望线程池中 ”活跃“ 线程的线程数量</span><br><span class="hljs-comment"> *          2. 所谓的 “活跃” 是指：正在执行任务或正在 ”窃取“ 任务的线程的线程数量</span><br><span class="hljs-comment"> *          3. ForkJoinPool 会尽力维持这个数量，但不能保证</span><br><span class="hljs-comment"> *      2. ForkJoinWorkerThreadFactory factory</span><br><span class="hljs-comment"> *          1. 指定创建 ForkJoinWorkerThread 实例的线程工厂</span><br><span class="hljs-comment"> *      3. UncaughtExceptionHandler handler</span><br><span class="hljs-comment"> *          1. 指定未捕获异常的处理器</span><br><span class="hljs-comment"> *          2. 当一个本地线程在执行任务时因未捕获的异常而终止（异常退出）时，会调用未捕获异常的处理器</span><br><span class="hljs-comment"> *      4. boolean asyncMode</span><br><span class="hljs-comment"> *          1. 指定本地线程从其维护的任务队列获取任务的顺序</span><br><span class="hljs-comment"> *          2. 可选参数包括：</span><br><span class="hljs-comment"> *              1. true</span><br><span class="hljs-comment"> *                  1. FIFO</span><br><span class="hljs-comment"> *              2. false</span><br><span class="hljs-comment"> *                  1. LIFO</span><br><span class="hljs-comment"> *      5. int corePoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中 “存活” 的线程被允许的最小数量</span><br><span class="hljs-comment"> *          2. 当某本地线程 “空闲” 的时间超过 keepAliveTime unit，会在销毁前检查该参数，然后再决定是否销毁</span><br><span class="hljs-comment"> *          3. 需要注意的是：该参数可以为 0</span><br><span class="hljs-comment"> *      6. int maximumPoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中的线程被允许的最大数量</span><br><span class="hljs-comment"> *      7. int minimumRunnable</span><br><span class="hljs-comment"> *          1. 指定线程池中没有调用 ForkJoinTask#join 的线程被允许的最小数量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          1. 指定可运行的工作线程被允许的最小数量</span><br><span class="hljs-comment"> *          2. 如果低于，将创建新的工作线程，直到达到 maximumPoolSize</span><br><span class="hljs-comment"> *      8. Predicate&lt;? super ForkJoinPool&gt; saturate</span><br><span class="hljs-comment"> *          1. 指定饱和策略</span><br><span class="hljs-comment"> *          2. 当没有调用 ForkJoinTask#join 的线程低于 minimumRunnable，但是也达到了 maximumPoolSize 时，会调用饱和策略</span><br><span class="hljs-comment"> *      9. long keepAliveTime</span><br><span class="hljs-comment"> *          1. 指定线程 “空闲”被允许的最长时间为：keepAliveTime unit</span><br><span class="hljs-comment"> *          2. 所谓的 “空闲” 是指：某本地线程维护的任务队列没有任务了，并且也 “窃取” 不到任务了</span><br><span class="hljs-comment"> *          3. 当某本地线程 “空闲” 的时间超过 keepAliveTime unit，</span><br><span class="hljs-comment"> *      10. TimeUnit unit</span><br><span class="hljs-comment"> *          1. 指定线程 “空闲”被允许的最长时间为：keepAliveTime unit</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 构造示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">UncaughtExceptionHandler handler,</span><br><span class="hljs-params"><span class="hljs-type">boolean</span> asyncMode,</span><br><span class="hljs-params"><span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params"><span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params"><span class="hljs-type">int</span> minimumRunnable,</span><br><span class="hljs-params">Predicate&lt;? <span class="hljs-built_in">super</span> ForkJoinPool&gt; saturate,</span><br><span class="hljs-params"><span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">TimeUnit unit)</span> &#123;<br><br>checkPermission();<br><span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> parallelism;<br><span class="hljs-keyword">if</span> (p &lt;= <span class="hljs-number">0</span> || p &gt; MAX_CAP || p &gt; maximumPoolSize || keepAliveTime &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-built_in">this</span>.factory = factory;<br><span class="hljs-built_in">this</span>.ueh = handler;<br><span class="hljs-built_in">this</span>.saturate = saturate;<br><span class="hljs-built_in">this</span>.keepAlive = Math.max(unit.toMillis(keepAliveTime), TIMEOUT_SLOP);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">33</span> - Integer.numberOfLeadingZeros(p - <span class="hljs-number">1</span>));<br><span class="hljs-type">int</span> <span class="hljs-variable">corep</span> <span class="hljs-operator">=</span> Math.min(Math.max(corePoolSize, p), MAX_CAP);<br><span class="hljs-type">int</span> <span class="hljs-variable">maxSpares</span> <span class="hljs-operator">=</span> Math.min(maximumPoolSize, MAX_CAP) - p;<br><span class="hljs-type">int</span> <span class="hljs-variable">minAvail</span> <span class="hljs-operator">=</span> Math.min(Math.max(minimumRunnable, <span class="hljs-number">0</span>), MAX_CAP);<br><span class="hljs-built_in">this</span>.bounds = ((minAvail - p) &amp; SMASK) | (maxSpares &lt;&lt; SWIDTH);<br><span class="hljs-built_in">this</span>.mode = p | (asyncMode ? FIFO : <span class="hljs-number">0</span>);<br><span class="hljs-built_in">this</span>.ctl = ((((<span class="hljs-type">long</span>)(-corep) &lt;&lt; TC_SHIFT) &amp; TC_MASK) |<br>(((<span class="hljs-type">long</span>)(-p)     &lt;&lt; RC_SHIFT) &amp; RC_MASK));<br><span class="hljs-built_in">this</span>.registrationLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-built_in">this</span>.queues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkQueue</span>[size];<br><span class="hljs-type">String</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> Integer.toString(getAndAddPoolIds(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">this</span>.workerNamePrefix = <span class="hljs-string">&quot;ForkJoinPool-&quot;</span> + pid + <span class="hljs-string">&quot;-worker-&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.LockSupport 源码解析</title>
    <link href="/2025/11/13/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/13/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-LockSupport-概述"><a href="#3-1-LockSupport-概述" class="headerlink" title="3.1. LockSupport 概述"></a>3.1. LockSupport 概述</h3><p>想象这样几个问题：</p><ol><li><code>Object#wait</code>、<code>Object#notify</code> 和 <code>synchronized</code> 是绑定的，它们必须出现在 <code>synchronized</code> 代码块中。也就是说：为了实现一次 “等待” 或 “通知”，线程必须先去竞争到 <code>Monitor</code> 锁。而在高并发场景下，这种对 <code>Monitor</code> 锁的竞争是重量级的</li><li><code>Object#notify()</code> 是唤醒 <code>Monitor</code> 的 <code>WaitSet</code> 中的 “任意” 一个 <code>Thread</code> 实例。而 <code>Object#notifyAll()</code> 是唤醒 <code>Monitor</code> 的 <code>WaitSet</code> 中的所有 <code>Thread</code> 实例，导致 “惊群效应”。它们都没有办法精确唤醒我们指定要唤醒的线程</li><li>除此之外，还有一个经典的竞态条件：如果本地线程 <code>B</code> 调用 <code>Object#notify</code> 先于本地线程 <code>A</code> 调用 <code>Object#wait</code>，那么这个 <code>Object#notify</code> 就永久消失了，本地线程 <code>A</code> 将 ”无限期“ 地等待一个永远不会再来的 <code>Object#notify</code>。而我们往常解决的方法是：在使用 <code>Object#wait</code>、<code>Object#notify</code> 前，要先用 <code>while(condition)</code> 循环来检查状态，非常的繁琐</li></ol><p>为了解决这一问题，<code>Doug Lea</code> 就封装了 <code>LockSupport</code>，我们在 <code>AQS</code> 中实现的阻塞、唤醒都是基于 <code>LockSupport</code></p><p>在 <code>LockSupport</code> 体系下，我们可以把每个本地线程想象成一个需要持有 “许可证” 才能继续运行的人。这个许可证不是计数器，不会累加，只有两种状态：<code>1</code> 和 <code>0</code></p><p>当我们调用 <code>LockSupport.unpark</code> 唤醒某本地线程时，无论该本地线程是阻塞还是运行，都会为它发放一个 “许可证”</p><p>而当我们调用 <code>LockSupport.park</code> 时，本地线程会先检查自己是否持有许可证：</p><ol><li>如果持有许可证<ol><li>消耗许可证（许可证从 <code>1 ➔ 0</code>），继续向下执行</li></ol></li><li>如果未持有许可证<ol><li>让本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>BWTW</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>LockSupport.unpark</code> 可以先于 <code>LockSupport.park</code> 执行，而不会 ”条件消失“，这是 <code>Doug Lea</code> 封装它的核心原因</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LockSupport</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-comment">// 用于非阻塞设置某本地线程进入阻塞状态，Thread 实例进入 BWTW 状态的原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该原因会被设置到 Thread-&gt;parkBlocker</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlocker</span><span class="hljs-params">(Thread t, Object arg)</span> &#123;<br>        U.putReferenceOpaque(t, PARKBLOCKER, arg);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞设置本地线程进入阻塞状态，Thread 实例进入 BWTW 状态的原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该原因会被设置到 Thread-&gt;parkBlocker</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentBlocker</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        U.putReferenceOpaque(Thread.currentThread(), PARKBLOCKER, blocker);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞唤醒某本地线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            U.unpark(thread);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时，并设置原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时，并设置原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            setBlocker(t, blocker);<br>            U.park(<span class="hljs-literal">false</span>, nanos);<br>            setBlocker(t, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时，并设置原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-literal">true</span>, deadline);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <br><span class="hljs-comment">// 用于非阻塞获取某本地线程进入阻塞状态，Thread 实例进入 BWTW 状态的原因</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBlocker</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> U.getReferenceOpaque(t, PARKBLOCKER);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>        U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>)<br>            U.park(<span class="hljs-literal">false</span>, nanos);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span> &#123;<br>        U.park(<span class="hljs-literal">true</span>, deadline);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getThreadId</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">return</span> U.getLong(thread, TID);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">U</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">PARKBLOCKER</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(Thread.class, <span class="hljs-string">&quot;parkBlocker&quot;</span>);<br>        <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">TID</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(Thread.class, <span class="hljs-string">&quot;tid&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Thread 源码解析</title>
    <link href="/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Thread-概述"><a href="#3-1-Thread-概述" class="headerlink" title="3.1. Thread 概述"></a>3.1. Thread 概述</h3><p><code>Thread</code> 是一个具体类，实现了 <code>java.util.concurrent.Runnable</code><br><img src="/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>Thread</code> 实例是一个 <code>Runnable</code> 任务，当我们调用 <code>Thread#start</code> 后，<code>JVM</code> 会在操作系统层面请求创建一个本地线程。一旦操作系统创建了这个本地线程，并将其与 <code>Thread</code> 实例 “绑定”，<code>Thread</code> 实例就会进入可运行状态。当本地线程被分配到 <code>CPU</code> 时间片后，开始执行 <code>Java</code> 代码，执行的就是 <code>Thread#run</code> </p><p>然而，由于 <code>Thread#run</code> 的源码又是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>target.run();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以线程执行的流程大致为：<code>本地线程 ➔ Thread#run ➔ target#run</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>虽然线程执行的流程大致为：<code>本地线程 ➔ Thread#run ➔ target#run</code>。但是在某些场景下，我们不希望在创建 <code>Thread</code> 实例时传入一个 <code>Runnable</code> 实例，因为我们已经明确知道该线程要执行的具体逻辑。此时，常见的做法是直接继承 <code>Thread</code> 具体类，并重写 <code>Thread#run</code>，我们直接使用这个 <code>Thread</code> 具体类的子类。这样线程执行的流程大致为：<code>本地线程 ➔ Thread#run</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        ...<br>    &#125;  <br>    <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        myThread.start();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-创建-Thread-实例常见方式"><a href="#3-2-创建-Thread-实例常见方式" class="headerlink" title="3.2. 创建 Thread 实例常见方式"></a>3.2. 创建 Thread 实例常见方式</h3><h4 id="3-2-1-继承-Thread-具体类，重写-Thread-run，创建-Thread-具体类的子类实例"><a href="#3-2-1-继承-Thread-具体类，重写-Thread-run，创建-Thread-具体类的子类实例" class="headerlink" title="3.2.1. 继承 Thread 具体类，重写 Thread#run，创建 Thread 具体类的子类实例"></a>3.2.1. 继承 Thread 具体类，重写 Thread#run，创建 Thread 具体类的子类实例</h4><p>正如我们上面讨论的，直接继承 <code>Thread</code> 类，重写 <code>Thread#run</code>，创建 <code>Thread</code> 具体类的子类实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        ...<br>    &#125;  <br>    <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        myThread.start();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们可以使用匿名内部类继承 <code>Thread</code> 具体类：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;myThread&quot;</span>) &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                ...<br>            &#125;  <br>        &#125;;  <br>        myThread.start();  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-2-2-创建-Runnable-实例，创建-Thread-实例，并将-Runnable-实例作为-Thread-实例的构造方法参数传递进去"><a href="#3-2-2-创建-Runnable-实例，创建-Thread-实例，并将-Runnable-实例作为-Thread-实例的构造方法参数传递进去" class="headerlink" title="3.2.2. 创建 Runnable 实例，创建 Thread 实例，并将 Runnable 实例作为 Thread 实例的构造方法参数传递进去"></a>3.2.2. 创建 Runnable 实例，创建 Thread 实例，并将 Runnable 实例作为 Thread 实例的构造方法参数传递进去</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>....<br>&#125;<br>&#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;myThread&quot;</span>);<br>        myThread.start();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-2-3-使用线程池"><a href="#3-2-3-使用线程池" class="headerlink" title="3.2.3. 使用线程池"></a>3.2.3. 使用线程池</h4><p>详见笔记：<code>JUC</code></p><ol><li><code>obsidian</code> 内部链接<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.md">笔记：JUC</a></li></ol></li><li><code>Hexo</code> 链接<ol><li></li></ol></li></ol><hr><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h2><h3 id="4-1-Thread-String-name"><a href="#4-1-Thread-String-name" class="headerlink" title="4.1. Thread(String name)"></a>4.1. Thread(String name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(String name)</span> &#123;<br><br><span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, name, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-Thread-Runnable-target"><a href="#4-2-Thread-Runnable-target" class="headerlink" title="4.2. Thread(Runnable target)"></a>4.2. Thread(Runnable target)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br><br><span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h3 id="4-3-Thread-Runnable-target-String-name"><a href="#4-3-Thread-Runnable-target-String-name" class="headerlink" title="4.3. Thread(Runnable target, String name)"></a>4.3. Thread(Runnable target, String name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target, String name)</span> &#123;<br><br><span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, target, name, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-Thread-ThreadGroup-group-Runnable-target-String-name-long-stackSize"><a href="#4-4-Thread-ThreadGroup-group-Runnable-target-String-name-long-stackSize" class="headerlink" title="4.4. Thread(ThreadGroup group, Runnable target, String name, long stackSize)"></a>4.4. Thread(ThreadGroup group, Runnable target, String name, long stackSize)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(ThreadGroup group, Runnable target, String name,</span><br><span class="hljs-params">  <span class="hljs-type">long</span> stackSize)</span> &#123;<br><br><span class="hljs-built_in">this</span>(group, target, name, stackSize, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>ThreadGroup</code> 是一个非常古老且很少被正确使用的功能，在现代开发中几乎永远不会碰它</li></ol></blockquote><hr><h2 id="5-实例方法"><a href="#5-实例方法" class="headerlink" title="5. 实例方法"></a>5. 实例方法</h2><h3 id="5-1-实例具体方法"><a href="#5-1-实例具体方法" class="headerlink" title="5.1. 实例具体方法"></a>5.1. 实例具体方法</h3><h4 id="5-1-1-具体方法（普通）"><a href="#5-1-1-具体方法（普通）" class="headerlink" title="5.1.1. 具体方法（普通）"></a>5.1.1. 具体方法（普通）</h4><h5 id="5-1-1-1-void-start"><a href="#5-1-1-1-void-start" class="headerlink" title="5.1.1.1. void start()"></a>5.1.1.1. void start()</h5><p>该方法用于非阻塞启动一个 <code>Thread</code> 实例</p><p>当我们调用 <code>Thread#start</code> 后，<code>JVM</code> 会在操作系统层面请求创建一个本地线程。一旦操作系统创建了这个本地线程，并将其与 <code>Thread</code> 实例 “绑定”，<code>Thread</code> 实例就会进入可运行状态</p><p>当本地线程被分配到 <code>CPU</code> 时间片后，开始执行 <code>Java</code> 代码，执行的就是 <code>Thread#run</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 实例具体方法（普通）：</span><br><span class="hljs-comment"> * public synchronized void start()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. synchronized</span><br><span class="hljs-comment"> *          1. 方法加 synchronized 锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. IllegalThreadStateException</span><br><span class="hljs-comment"> *          1. 如果 Thread 实例已启动，但是又被启动，就会抛出 IllegalThreadStateException 异常</span><br><span class="hljs-comment"> *          2. 简单来说就是：一个 Thread 实例只能调用一次 Thread#start</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> * Thread myThread = new Thread(&quot;myThread&quot;) &#123;</span><br><span class="hljs-comment"> *     <span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment"> *     public void run() &#123;</span><br><span class="hljs-comment"> *         ...</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * myThread.start();</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>group.add(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br>start0();<br>started = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!started) &#123;<br>group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-2-void-interrupt"><a href="#5-1-1-2-void-interrupt" class="headerlink" title="5.1.1.2. void interrupt()"></a>5.1.1.2. void interrupt()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞中断线程</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 该方法会为被中断的 Thread 实例设置中断状态</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 如果被中断的 Thread 实例处于 RUNNABLE 状态，就只会设置 Thread 实例的中断状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果被中断的 Thread 实例处于 BLOCKED、WAITING、TIMED_WAITING 状态，可能有以下几种情况：</span><br><span class="hljs-comment">//     1. 本地线程进入阻塞状态，Thread 实例进入 BWTW 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//     2. 本地线程进入阻塞状态，Thread 实例进入 BWTW 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br><span class="hljs-comment">//     3. 本地线程进入阻塞状态，Thread 实例进入 BWTW 状态后，不能能响应中断。线程会继续阻塞，并会保留 Thread 示例的中断状态。当线程被唤醒后，会继续向下执行（正常退出（未发生异常））</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread()) &#123;<br>checkAccess();<br><br><span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br><span class="hljs-type">Interruptible</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> blocker;<br><span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>interrupt0();<br>b.interrupt(<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br>interrupted = <span class="hljs-literal">true</span>;<br>interrupt0();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-3-void-setPriority-int-newPriority"><a href="#5-1-1-3-void-setPriority-int-newPriority" class="headerlink" title="5.1.1.3. void setPriority(int newPriority)"></a>5.1.1.3. void setPriority(int newPriority)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞设置本地线程的优先级</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// JVM 规定本地线程的优先级为 1 - 10 之间的整数，优先级越高，本地线程被 CPU 调度的可能性越大</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 这里的优先级仅是建议性提示，是否生效取决于具体的调度策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPriority</span><span class="hljs-params">(<span class="hljs-type">int</span> newPriority)</span> &#123;<br><br>ThreadGroup g;<br>checkAccess();<br><span class="hljs-keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>&#125;<br><span class="hljs-keyword">if</span>((g = getThreadGroup()) != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;<br>newPriority = g.getMaxPriority();<br>&#125;<br>setPriority0(priority = newPriority);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-4-int-getPriority"><a href="#5-1-1-4-int-getPriority" class="headerlink" title="5.1.1.4. int getPriority()"></a>5.1.1.4. int getPriority()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞获取本地线程的优先级</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPriority</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> priority;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-5-void-join"><a href="#5-1-1-5-void-join" class="headerlink" title="5.1.1.5. void join()"></a>5.1.1.5. void join()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 Monitor 中的 WaitSet 队列，等待被唤醒（Obect#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>join(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-6-void-join-final-long-millis"><a href="#5-1-1-6-void-join-final-long-millis" class="headerlink" title="5.1.1.6. void join(final long millis)"></a>5.1.1.6. void join(final long millis)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 中的 WaitSet 队列，等待被唤醒（Obect#notify）、被中断、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> millis)</span><br><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (millis &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (isAlive()) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis;<br><span class="hljs-keyword">do</span> &#123;<br>wait(delay);<br>&#125; <span class="hljs-keyword">while</span> (isAlive() &amp;&amp; (delay = millis -<br>TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="hljs-number">0</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">while</span> (isAlive()) &#123;<br>wait(<span class="hljs-number">0</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>推荐使用 <code>TimeUnit#timedJoin</code> 替代该方法，因为其可读性更好</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeUnit.MINUTES.timedJoin(worker, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="void-join-long-millis-int-nanos"><a href="#void-join-long-millis-int-nanos" class="headerlink" title="void join(long millis, int nanos)"></a>void join(long millis, int nanos)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 中的 WaitSet 队列，等待被唤醒（Obect#notify）、被中断、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br><span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span> || nanos &gt; <span class="hljs-number">999999</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br><span class="hljs-string">&quot;nanosecond timeout value out of range&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span> &amp;&amp; millis &lt; Long.MAX_VALUE) &#123;<br>millis++;<br>&#125;<br><br>join(millis);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-7-void-setDaemon-boolean-on"><a href="#5-1-1-7-void-setDaemon-boolean-on" class="headerlink" title="5.1.1.7. void setDaemon(boolean on)"></a>5.1.1.7. void setDaemon(boolean on)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞设置 Thread 实例为守护线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDaemon</span><span class="hljs-params">(<span class="hljs-type">boolean</span> on)</span> &#123;<br><br>checkAccess();<br><span class="hljs-keyword">if</span> (isAlive()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>&#125;<br>daemon = on;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-8-boolean-isInterrupted"><a href="#5-1-1-8-boolean-isInterrupted" class="headerlink" title="5.1.1.8. boolean isInterrupted()"></a>5.1.1.8. boolean isInterrupted()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞查看 Thread 实例的中断状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 true，说明 Thread 实例被中断过</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 false，说明 Thread 实例没有被中断过</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> interrupted;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Thread.interrupted</code> 与 <code>Thread#isInterrupted</code> 的区别在于：<code>Thread.interrupted</code> 会清除 <code>Thread</code> 实例的中断状态，而 <code>Thread#isInterrupted</code> 不会</li></ol></blockquote><hr><h5 id="5-1-1-9-boolean-isAlive"><a href="#5-1-1-9-boolean-isAlive" class="headerlink" title="5.1.1.9. boolean isAlive()"></a>5.1.1.9. boolean isAlive()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞查看本地线程是否存活</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlive</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> eetop != <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="5-1-2-具体方法（实现）"><a href="#5-1-2-具体方法（实现）" class="headerlink" title="5.1.2. 具体方法（实现）"></a>5.1.2. 具体方法（实现）</h4><h5 id="5-1-2-1-Runnable-中接口方法的实现"><a href="#5-1-2-1-Runnable-中接口方法的实现" class="headerlink" title="5.1.2.1. Runnable 中接口方法的实现"></a>5.1.2.1. Runnable 中接口方法的实现</h5><h6 id="5-1-2-1-1-void-run"><a href="#5-1-2-1-1-void-run" class="headerlink" title="5.1.2.1.1. void run()"></a>5.1.2.1.1. void run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>target.run();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-静态方法"><a href="#6-静态方法" class="headerlink" title="6. 静态方法"></a>6. 静态方法</h2><h3 id="6-1-静态具体方法"><a href="#6-1-静态具体方法" class="headerlink" title="6.1. 静态具体方法"></a>6.1. 静态具体方法</h3><h4 id="6-1-1-具体方法（普通）"><a href="#6-1-1-具体方法（普通）" class="headerlink" title="6.1.1. 具体方法（普通）"></a>6.1.1. 具体方法（普通）</h4><h5 id="6-1-1-1-void-sleep-long-millis"><a href="#6-1-1-1-void-sleep-long-millis" class="headerlink" title="6.1.1.1. void sleep(long millis)"></a>6.1.1.1. void sleep(long millis)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入阻塞（TIMED_WAITING）状态，等待被中断、阻塞超时</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入阻塞（TIMED_WAITING）状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>推荐使用 <code>TimeUnit#sleep</code> 替代该方法，因为其可读性更好</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeUnit.HOURS.sleep(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-2-void-yield"><a href="#6-1-1-2-void-yield" class="headerlink" title="6.1.1.2. void yield()"></a>6.1.1.2. void yield()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞提示线程调度器让出当前本地线程的 CPU 时间片</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 让出 CPU 时间片后，Thread 实例的状态会从 运行状态 ➔ 可运行状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 所谓的 “提示” 是指：仅是建议性提示，是否生效取决于具体的调度策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>本地线程让出 <code>CPU</code> 时间片后，由于是可运行状态，可能会立即被其他 <code>CPU</code> 核重新调度。因此，在多核处理器或系统负载较低的情况下，该方法的效果可能并不明显。但是在单核环境或系统负载较高时，其调度行为会比较明显</li></ol></blockquote><hr><h5 id="6-1-1-3-Thread-currentThread"><a href="#6-1-1-3-Thread-currentThread" class="headerlink" title="6.1.1.3. Thread currentThread()"></a>6.1.1.3. Thread currentThread()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞获取执行当前 Java 代码的本地线程对应的 Thread 实例</span><br><span class="hljs-meta">@IntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Thread <span class="hljs-title function_">currentThread</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-4-boolean-interrupted"><a href="#6-1-1-4-boolean-interrupted" class="headerlink" title="6.1.1.4. boolean interrupted()"></a>6.1.1.4. boolean interrupted()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞查看 Thread 实例的中断状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 true，说明 Thread 实例被中断过</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 false，说明 Thread 实例没有被中断过</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> currentThread();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> t.interrupted;<br><span class="hljs-keyword">if</span> (interrupted) &#123;<br><span class="hljs-comment">// 清除 Thread 实例中的中断状态</span><br>t.interrupted = <span class="hljs-literal">false</span>;<br>clearInterruptEvent();<br>&#125;<br><span class="hljs-keyword">return</span> interrupted;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Thread.interrupted</code> 与 <code>Thread#isInterrupted</code> 的区别在于：<code>Thread.interrupted</code> 会清除 <code>Thread</code> 实例的中断状态，而 <code>Thread#isInterrupted</code> 不会</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RunnableScheduledFuture＜V＞ 源码解析</title>
    <link href="/2025/11/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-RunnableScheduledFuture＜V＞-概述"><a href="#3-1-RunnableScheduledFuture＜V＞-概述" class="headerlink" title="3.1. RunnableScheduledFuture＜V＞ 概述"></a>3.1. RunnableScheduledFuture＜V＞ 概述</h3><p><code>RunnableScheduledFuture＜V＞</code> 是一个接口，继承了<code> java.util.concurrent.RunnableFuture＜V＞</code>、<code>java.util.concurrent.ScheduledFuture＜V＞</code></p><p><code>RunnableScheduledFuture＜V＞</code> 在 <code>RunnableFuture＜V＞</code> 的基础上，提供了以下方法：</p><ol><li>查看任务是否是周期性任务</li></ol><p>如果某实现类实现了 <code>RunnableScheduledFuture＜V＞</code> 接口，就实现了以下接口：<br><img src="/2025/11/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>RunnableFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;, ScheduledFuture&lt;V&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞查看任务是否是周期性任务</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPeriodic</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReentrantReadWriteLock 源码解析</title>
    <link href="/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReentrantReadWriteLock-概述"><a href="#3-1-ReentrantReadWriteLock-概述" class="headerlink" title="3.1. ReentrantReadWriteLock 概述"></a>3.1. ReentrantReadWriteLock 概述</h3><p><code>ReentrantReadWriteLock</code> 是一个具体类，实现了 <code>java.util.concurrent.locks.ReadWriteLock</code>、<code>java.io.Serializable</code><br><img src="/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ReentrantReadWriteLock</code> 是一种可重入、悲观、公平或非公平、互斥或共享的锁，并且是使用 <code>AQS</code> 实现的混合模式的同步器。State 和共享资源分别表示以下含义：</p><ol><li><code>State</code> 表示写锁或读锁的重入次数<ol><li><code>State</code> 被 <code>ReentrantReadWriteLock</code> 拆分为两部分，分别表示写锁和读锁的重入次数<ol><li>低 <code>16</code> 位表示写锁的重入次数</li><li>高 <code>16</code> 位表示读锁的重入次数</li></ol></li><li>需要注意的是：如果为 <code>0</code>，表示锁空闲，既没有写锁，也没有读锁</li></ol></li><li>共享资源表示加锁期间的操作</li></ol><p>我们可以简单的理解为：<code>ReentrantReadWriteLock</code> 为我们准备了两把锁，一把是读锁，一把是写锁，我们就是依赖这两把锁进行协调，这两把锁遵循这样的规律：</p><ol><li>写写互斥<ol><li>当一个线程持有写锁后，其他线程如果要竞争写锁，必须等待该线程释放写锁</li></ol></li><li>读写互斥<ol><li>当一个线程持有写锁后，其他线程如果要竞争读锁，必须等待该线程释放写锁</li><li>当一个线程持有读锁后，其他线程如果要竞争写锁，必须等待该线程释放读锁</li></ol></li><li>读读共享<ol><li>当一个线程持有读锁后，其他线程如果要竞争读锁，可以直接持有读锁</li><li>也就是说：一个读锁可以被多个线程共享</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ReadWriteLock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReadWriteLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-ReentrantReadWriteLock-锁降级"><a href="#3-2-ReentrantReadWriteLock-锁降级" class="headerlink" title="3.2. ReentrantReadWriteLock 锁降级"></a>3.2. ReentrantReadWriteLock 锁降级</h3><p><code>ReentrantLock</code> 允许一个线程在持有写锁的情况下竞争读锁，竞争到读锁后再释放写锁。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code><ol><li>为什么不先释放写锁，再竞争读锁？<ol><li>如果线程 <code>A</code> 写数据后，需要立刻读数据</li><li>如果先释放写锁，再竞争读锁，那么线程 <code>A</code> 释放写锁后，线程 <code>B</code> 可能立即竞争到了写锁</li><li>如果线程 <code>B</code> 也写了数据，则当线程 <code>A</code> 再竞争到读锁的时候，读到的数据就不是刚刚写的数据了</li></ol></li><li>为什么不干脆 “不释放写锁”，直到读完数据？<ol><li>可以这样做，但是性能差，而我们的目标是：在保证数据一致性的前提下，尽可能地提升并发度</li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-3-ReentrantReadWriteLock-适用场景"><a href="#3-3-ReentrantReadWriteLock-适用场景" class="headerlink" title="3.3. ReentrantReadWriteLock 适用场景"></a>3.3. ReentrantReadWriteLock 适用场景</h3><h4 id="3-3-1-读多写少"><a href="#3-3-1-读多写少" class="headerlink" title="3.3.1. 读多写少"></a>3.3.1. 读多写少</h4><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Sync"><a href="#4-1-Sync" class="headerlink" title="4.1. Sync"></a>4.1. Sync</h3><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">...</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-2-FairSync"><a href="#4-2-FairSync" class="headerlink" title="4.2. FairSync"></a>4.2. FairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2274990926593161451L</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-NonfairSync"><a href="#4-3-NonfairSync" class="headerlink" title="4.3. NonfairSync"></a>4.3. NonfairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-ReadLock"><a href="#4-4-ReadLock" class="headerlink" title="4.4. ReadLock"></a>4.4. ReadLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">ReadLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>sync = lock.sync;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.tryReadLock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sync.getReadLockCount();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() +<br><span class="hljs-string">&quot;[Read locks = &quot;</span> + r + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-5-WriteLock"><a href="#4-5-WriteLock" class="headerlink" title="4.5. WriteLock"></a>4.5. WriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">WriteLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>sync = lock.sync;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.tryWriteLock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.newCondition();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> sync.getOwner();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + ((o == <span class="hljs-literal">null</span>) ?<br>   <span class="hljs-string">&quot;[Unlocked]&quot;</span> :<br>   <span class="hljs-string">&quot;[Locked by thread &quot;</span> + o.getName() + <span class="hljs-string">&quot;]&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldByCurrentThread</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.isHeldExclusively();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHoldCount</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.getWriteHoldCount();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-实例方法"><a href="#5-实例方法" class="headerlink" title="5. 实例方法"></a>5. 实例方法</h2><h3 id="5-1-实例具体方法"><a href="#5-1-实例具体方法" class="headerlink" title="5.1. 实例具体方法"></a>5.1. 实例具体方法</h3><h4 id="5-1-1-具体方法（实现）"><a href="#5-1-1-具体方法（实现）" class="headerlink" title="5.1.1. 具体方法（实现）"></a>5.1.1. 具体方法（实现）</h4><h5 id="5-1-1-1-ReadWriteLock-中接口方法的实现"><a href="#5-1-1-1-ReadWriteLock-中接口方法的实现" class="headerlink" title="5.1.1.1. ReadWriteLock 中接口方法的实现"></a>5.1.1.1. ReadWriteLock 中接口方法的实现</h5><h6 id="5-1-1-1-1-WriteLock-writeLock"><a href="#5-1-1-1-1-WriteLock-writeLock" class="headerlink" title="5.1.1.1.1. WriteLock writeLock()"></a>5.1.1.1.1. WriteLock writeLock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span> &#123; <br><br><span class="hljs-keyword">return</span> writerLock; <br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="5-1-1-1-2-ReadLock-readLock"><a href="#5-1-1-1-2-ReadLock-readLock" class="headerlink" title="5.1.1.1.2. ReadLock  readLock()"></a>5.1.1.1.2. ReadLock  readLock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReentrantReadWriteLock.ReadLock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span> &#123; <br><br><span class="hljs-keyword">return</span> readerLock; <br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReadWriteLock 源码解析</title>
    <link href="/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReadWriteLock-概述"><a href="#3-1-ReadWriteLock-概述" class="headerlink" title="3.1. ReadWriteLock 概述"></a>3.1. ReadWriteLock 概述</h3><p><code>ReadWriteLock</code> 是一个接口</p><p><code>ReadWriteLock</code> 为我们提供了以下方法：</p><ol><li>获取 <code>ReadLock</code>（非阻塞）</li><li>获取 <code>WriteLock</code>（非阻塞）</li></ol><hr><h1 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br><br>    <span class="hljs-comment">// 用于非阻塞获取 ReadLock</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：该方法并不是直接竞争读锁，而是我们获取 ReadLock 后，还需要调用 ReadLock 的方法竞争读锁</span><br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 用于非阻塞获取 WriteLock</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：该方法并不是直接竞争读锁，而是我们获取 WriteLock 后，还需要调用 WriteLock 的方法竞争写锁</span><br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.Lock 源码解析</title>
    <link href="/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Lock-概述"><a href="#3-1-Lock-概述" class="headerlink" title="3.1. Lock 概述"></a>3.1. Lock 概述</h3><p><code>Lock</code> 是一个接口</p><p><code>Lock</code> 为我们提供了以下方法</p><ol><li>竞争锁（阻塞、非阻塞、限时阻塞）</li><li>释放锁（非阻塞）</li><li>创建条件队列（非阻塞）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Monitor</code> 中有竞争队列、等待队列，<code>AQS</code> 中有同步队列、条件队列</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <br>    <span class="hljs-comment">// 用于阻塞竞争锁</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果锁被其他线程持有，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 AQS 的同步队列，等待被唤醒（LockSupport.unpark）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，不能能响应中断。线程会继续阻塞，并会保留 Thread 示例的中断状态。当线程被唤醒后，会继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">// 用于阻塞竞争锁</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果锁被其他线程持有，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 AQS 的同步队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">// 用于非阻塞竞争锁</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果成功，返回 true</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果失败，返回 false</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 所谓的 “非阻塞” 是指：尝试一下，行就行，不行就不行，不要让当前线程进入阻塞（BWTW）状态</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于限时阻塞竞争锁</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：time unit</span><br><span class="hljs-comment">//    1. 如果超时，将返回 false</span><br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果锁被其他线程持有，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 AQS 的同步队列，等待被唤醒（LockSupport.unpark）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果成功，返回 true</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果失败，返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于非阻塞释放当前线程持有的锁</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果不持有锁的线程释放锁，抛出 IllegalMonitorStateException 非受检异常</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞创建条件队列</span><br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Comparable＜T＞ 源码解析</title>
    <link href="/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Comparable-概述"><a href="#3-1-Comparable-概述" class="headerlink" title="3.1. Comparable 概述"></a>3.1. Comparable 概述</h3><p><code>Comparable</code> 是一个接口</p><p><code>Comparable</code> 为我们提供了以下方法：</p><ol><li>配置自然排序的规则</li></ol><p>一些需要排序的 <code>Java</code> 数据类型（例如 <code>TreeSet</code>、<code>TreeMap</code>、<code>ConcurrentSkipListMap</code>、<code>PriorityQueue</code>、<code>PriorityBlockingQueue</code>、<code>DelayQueue</code>、<code>ScheduledThreadPoolExecutor.DelayedWorkQueue</code>），默认会使用 <code>Comparable#compareTo</code> 进行比较，从而进行自然排序</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 用于配置自然排序的规则</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Delayed 源码解析</title>
    <link href="/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Delayed-概述"><a href="#3-1-Delayed-概述" class="headerlink" title="3.1. Delayed 概述"></a>3.1. Delayed 概述</h3><p><code>Delayed</code> 是一个接口，继承了<code> java.lang.Comparable＜T＞</code><br><img src="/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>Delayed</code> 在 <code>Comparable＜T＞</code> 的基础上，提供了以下方法：</p><ol><li>获取剩余延迟的时间</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Comparable＜T＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Comparable＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞获取剩余延迟的时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ThreadPoolExecutor.Worker 源码解析</title>
    <link href="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ThreadPoolExecutor-Worker-概述"><a href="#3-1-ThreadPoolExecutor-Worker-概述" class="headerlink" title="3.1. ThreadPoolExecutor.Worker 概述"></a>3.1. ThreadPoolExecutor.Worker 概述</h3><p>想象这样一个问题：我们的 <code>Thread</code> 是用来执行一个 <code>Runnable</code> 类型的任务，任务执行完毕后，<code>Thread</code> 就会进入 “死亡” 状态。可是在线程池中，我们希望的是能够复用线程，让它们持续地从任务队列中获取并执行任务</p><p>为了解决这一问题，<code>Doug Lea</code> 引入了 <code>Worker</code> 的概念。<code>Worker</code> 本身实现了 <code>Runnable</code> 接口，因此它也是一个 <code>Runnable</code> 类型的任务。我们让 <code>Thread</code> 执行这个 <code>Worker</code>，而在 <code>Worker</code> 的 <code>run</code> 中，使用一个循环不断地从任务队列中获取任务并执行。这样，就 “另辟蹊径” 的实现了 “复用线程”<br><img src="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>Worker</code> 是一个具体类，是 <code>java.util.concurrent.ThreadPoolExecutor</code> 的成员内部类，继承了 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>，实现了<code> java.lang.Runnable</code></p><p><code>Worker</code> 是使用 <code>AQS</code> 实现的状态机，<code>State</code> 表示以下含义：</p><ol><li><code>-1</code><ol><li><code>Worker</code> 正在被实例化</li></ol></li><li><code>0</code><ol><li><code>Worker</code> 并没有 “执行” 任务（正在从任务队列中获取任务）</li></ol></li><li><code>1</code><ol><li><code>Worker</code> 正在 “执行” 任务</li></ol></li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br><span class="hljs-comment">// 表示 Worker 封装的 Thread 实例</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该 Thread 实例负责执行 Worker#run，并且是在 Worker 被实例化的时候被实例化的</span><br><span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="hljs-keyword">final</span> Thread thread;<br><br><span class="hljs-comment">// 表示 Worker 的 “启动任务”</span><br><span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span> <br>Runnable firstTask;<br><br><span class="hljs-comment">// 表示 Worker 已完成任务的任务数量</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>Worker(Runnable firstTask) &#123;<br>setState(-<span class="hljs-number">1</span>); <br><span class="hljs-built_in">this</span>.firstTask = firstTask;<br><span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 调用 ThreadPoolExecutor#runWorker，并把 this 作为方法参数传递进去</span><br>runWorker(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>setState(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <br>acquire(<span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; <br>release(<span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">return</span> isHeldExclusively(); <br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>Thread t;<br><span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.interrupt();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledFuture＜V＞ 源码解析</title>
    <link href="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledFuture＜V＞-概述"><a href="#3-1-ScheduledFuture＜V＞-概述" class="headerlink" title="3.1. ScheduledFuture＜V＞ 概述"></a>3.1. ScheduledFuture＜V＞ 概述</h3><p><code>ScheduledFuture</code> 是一个接口，继承了<code> java.util.concurrent.Delayed</code>、<code>java.util.concurren.Future＜V＞</code><br><img src="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Delayed</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Delayed源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Future＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>, Future&lt;V&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledThreadPoolExecutor 源码解析</title>
    <link href="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledThreadPoolExecutor-概述"><a href="#3-1-ScheduledThreadPoolExecutor-概述" class="headerlink" title="3.1. ScheduledThreadPoolExecutor 概述"></a>3.1. ScheduledThreadPoolExecutor 概述</h3><p><code>ScheduledThreadPoolExecutor</code> 是一个具体类，继承了 <code>java.util.concurrent.ThreadPoolExecutor</code>，实现了 <code>java.util.concurrent.ScheduledExecutorService</code></p><p><code>ScheduledThreadPoolExecutor</code> 在 <code>ThreadPoolExecutor</code> 的基础上，只做了三件事：</p><ol><li>使用 <code>ScheduledThreadPoolExecutor.DelayedWorkQueue</code> 作为任务队列</li><li>使用 <code>ScheduledThreadPoolExecutor.ScheduledFutureTask</code> 而不是 <code>FutureTask</code></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ThreadPoolExecutor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ThreadPoolExecutor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>ScheduledExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-DelayedWorkQueue"><a href="#4-1-DelayedWorkQueue" class="headerlink" title="4.1. DelayedWorkQueue"></a>4.1. DelayedWorkQueue</h3><p>详见笔记：<code>Java 数据类型</code></p><ol><li><code>obsidian</code> 内部链接<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">笔记：Java数据类型</a></li></ol></li><li><code>Hexo</code> 链接<ol><li></li></ol></li></ol><hr><h3 id="4-2-ScheduledFutureTask"><a href="#4-2-ScheduledFutureTask" class="headerlink" title="4.2. ScheduledFutureTask"></a>4.2. ScheduledFutureTask</h3><p>详见源码：<code>ScheduledFutureTask＜V＞</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-ScheduledThreadPoolExecutor-int-corePoolSize-ThreadFactory-threadFactory-RejectedExecutionHandler-handler"><a href="#5-1-ScheduledThreadPoolExecutor-int-corePoolSize-ThreadFactory-threadFactory-RejectedExecutionHandler-handler" class="headerlink" title="5.1. ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)"></a>5.1. ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">   ThreadFactory threadFactory,</span><br><span class="hljs-params">   RejectedExecutionHandler handler)</span> &#123;<br><span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE,<br>  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>DEFAULT_KEEPALIVE_MILLIS</code> 是 <code>ScheduledThreadPoolExecutor::DEFAULT_KEEPALIVE_MILLIS</code> ，值为：<code>10L</code></li></ol></blockquote><hr><h2 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h2><h3 id="6-1-实例具体方法"><a href="#6-1-实例具体方法" class="headerlink" title="6.1. 实例具体方法"></a>6.1. 实例具体方法</h3><h4 id="6-1-1-具体方法（实现）"><a href="#6-1-1-具体方法（实现）" class="headerlink" title="6.1.1. 具体方法（实现）"></a>6.1.1. 具体方法（实现）</h4><h5 id="6-1-1-1-Executor-中接口方法的实现"><a href="#6-1-1-1-Executor-中接口方法的实现" class="headerlink" title="6.1.1.1. Executor 中接口方法的实现"></a>6.1.1.1. Executor 中接口方法的实现</h5><h6 id="6-1-1-1-1-void-execute-Runnable-command"><a href="#6-1-1-1-1-void-execute-Runnable-command" class="headerlink" title="6.1.1.1.1. void execute(Runnable command)"></a>6.1.1.1.1. void execute(Runnable command)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><br>schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-2-ExecutorService-中接口方法的实现"><a href="#6-1-1-2-ExecutorService-中接口方法的实现" class="headerlink" title="6.1.1.2. ExecutorService 中接口方法的实现"></a>6.1.1.2. ExecutorService 中接口方法的实现</h5><h6 id="6-1-1-2-1-Future＜-＞-submit-Runnable-task"><a href="#6-1-1-2-1-Future＜-＞-submit-Runnable-task" class="headerlink" title="6.1.1.2.1. Future＜?＞ submit(Runnable task)"></a>6.1.1.2.1. Future＜?＞ submit(Runnable task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br><br><span class="hljs-keyword">return</span> schedule(task, <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-2-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result"><a href="#6-1-1-2-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result" class="headerlink" title="6.1.1.2.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)"></a>6.1.1.2.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br><br><span class="hljs-keyword">return</span> schedule(Executors.callable(task, result), <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-2-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task"><a href="#6-1-1-2-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task" class="headerlink" title="6.1.1.2.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)"></a>6.1.1.2.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br><br><span class="hljs-keyword">return</span> schedule(task, <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-3-ScheduledExecutorService-中接口方法的实现"><a href="#6-1-1-3-ScheduledExecutorService-中接口方法的实现" class="headerlink" title="6.1.1.3. ScheduledExecutorService 中接口方法的实现"></a>6.1.1.3. ScheduledExecutorService 中接口方法的实现</h5><h6 id="6-1-1-3-1-ScheduledFuture＜-＞-schedule-Runnable-comm-long-delay-TimeUnit-unit"><a href="#6-1-1-3-1-ScheduledFuture＜-＞-schedule-Runnable-comm-long-delay-TimeUnit-unit" class="headerlink" title="6.1.1.3.1. ScheduledFuture＜?＞ schedule(Runnable comm, long delay, TimeUnit unit)"></a>6.1.1.3.1. ScheduledFuture＜?＞ schedule(Runnable comm, long delay, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>   <span class="hljs-type">long</span> delay,<br>   TimeUnit unit) &#123;<br><br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,<br>  triggerTime(delay, unit),<br>  sequencer.getAndIncrement()));<br>  <br>delayedExecute(t);<br><br><span class="hljs-keyword">return</span> t;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-3-2-＜V＞-ScheduledFuture＜V＞-schedule-Callable＜V＞-callable-long-delay-TimeUnit-unit"><a href="#6-1-1-3-2-＜V＞-ScheduledFuture＜V＞-schedule-Callable＜V＞-callable-long-delay-TimeUnit-unit" class="headerlink" title="6.1.1.3.2. ＜V＞ ScheduledFuture＜V＞ schedule(Callable＜V＞ callable, long delay, TimeUnit unit)"></a>6.1.1.3.2. ＜V＞ ScheduledFuture＜V＞ schedule(Callable＜V＞ callable, long delay, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">   <span class="hljs-type">long</span> delay,</span><br><span class="hljs-params">   TimeUnit unit)</span> &#123;<br><span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;V&gt;(callable,<br>   triggerTime(delay, unit),<br>   sequencer.getAndIncrement()));<br>delayedExecute(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-3-3-ScheduledFuture＜-＞-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit"><a href="#6-1-1-3-3-ScheduledFuture＜-＞-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit" class="headerlink" title="6.1.1.3.3. ScheduledFuture＜?＞ scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)"></a>6.1.1.3.3. ScheduledFuture＜?＞ scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>  <span class="hljs-type">long</span> initialDelay,<br>  <span class="hljs-type">long</span> period,<br>  TimeUnit unit) &#123;<br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>ScheduledFutureTask&lt;Void&gt; sft =<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>  <span class="hljs-literal">null</span>,<br>  triggerTime(initialDelay, unit),<br>  unit.toNanos(period),<br>  sequencer.getAndIncrement());<br>RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br>sft.outerTask = t;<br>delayedExecute(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-3-4-ScheduledFuture＜-＞-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit"><a href="#6-1-1-3-4-ScheduledFuture＜-＞-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit" class="headerlink" title="6.1.1.3.4. ScheduledFuture＜?＞ scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)"></a>6.1.1.3.4. ScheduledFuture＜?＞ scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br> <span class="hljs-type">long</span> initialDelay,<br> <span class="hljs-type">long</span> delay,<br> TimeUnit unit) &#123;<br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>ScheduledFutureTask&lt;Void&gt; sft =<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>  <span class="hljs-literal">null</span>,<br>  triggerTime(initialDelay, unit),<br>  -unit.toNanos(delay),<br>  sequencer.getAndIncrement());<br>RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br>sft.outerTask = t;<br>delayedExecute(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.AbstractExecutorService源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractExecutorService-概述"><a href="#3-1-AbstractExecutorService-概述" class="headerlink" title="3.1. AbstractExecutorService 概述"></a>3.1. AbstractExecutorService 概述</h3><p><code>AbstractExecutorService</code> 是一个抽象类，实现了 <code>java.util.concurrent.ExecutorService</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>AbstractExecutorService</code> 为 <code>ExecutorService</code> 中的部分通用逻辑提供了实现</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-实例方法"><a href="#4-实例方法" class="headerlink" title="4. 实例方法"></a>4. 实例方法</h2><h3 id="4-1-实例具体方法"><a href="#4-1-实例具体方法" class="headerlink" title="4.1. 实例具体方法"></a>4.1. 实例具体方法</h3><h4 id="4-1-1-具体方法（普通）"><a href="#4-1-1-具体方法（普通）" class="headerlink" title="4.1.1. 具体方法（普通）"></a>4.1.1. 具体方法（普通）</h4><h5 id="4-1-1-1-＜T＞-RunnableFuture＜T＞-newTaskFor-Callable＜T＞-callable"><a href="#4-1-1-1-＜T＞-RunnableFuture＜T＞-newTaskFor-Callable＜T＞-callable" class="headerlink" title="4.1.1.1. ＜T＞ RunnableFuture＜T＞ newTaskFor(Callable＜T＞ callable)"></a>4.1.1.1. ＜T＞ RunnableFuture＜T＞ newTaskFor(Callable＜T＞ callable)</h5><p>该方法用于非阻塞将 <code>Callable</code> 任务封装成 <code>RunnableFuture</code> 类型（实则是封装成 <code>FutureTask</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="4-1-1-2-＜T＞-RunnableFuture＜T＞-newTaskFor-Runnable-runnable-T-value"><a href="#4-1-1-2-＜T＞-RunnableFuture＜T＞-newTaskFor-Runnable-runnable-T-value" class="headerlink" title="4.1.1.2. ＜T＞ RunnableFuture＜T＞ newTaskFor(Runnable runnable, T value)"></a>4.1.1.2. ＜T＞ RunnableFuture＜T＞ newTaskFor(Runnable runnable, T value)</h5><p>该方法用于非阻塞将 <code>Runnable</code> 任务封装成 <code>RunnableFuture</code> 类型（实则是封装成 <code>FutureTask</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-2-具体方法（实现）"><a href="#4-1-2-具体方法（实现）" class="headerlink" title="4.1.2. 具体方法（实现）"></a>4.1.2. 具体方法（实现）</h4><h5 id="4-1-2-1-ExecutorService-中接口方法的实现"><a href="#4-1-2-1-ExecutorService-中接口方法的实现" class="headerlink" title="4.1.2.1. ExecutorService 中接口方法的实现"></a>4.1.2.1. ExecutorService 中接口方法的实现</h5><h6 id="4-1-2-1-1-Future＜-＞-submit-Runnable-task"><a href="#4-1-2-1-1-Future＜-＞-submit-Runnable-task" class="headerlink" title="4.1.2.1.1. Future＜?＞ submit(Runnable task)"></a>4.1.2.1.1. Future＜?＞ submit(Runnable task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 实例具体方法（ExecutorService 接口方法 实现）：</span><br><span class="hljs-comment"> * public Future&lt;?&gt; submit(Runnable task)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. Runnable task</span><br><span class="hljs-comment"> *          1. 提交的 Runnable 任务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. Runnable 任务封装成的 FutureTask 实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. NullPointerException</span><br><span class="hljs-comment"> *          1. 传入的 Runnable 任务为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br><br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-comment">// 调用 AbstractExecutorService#newTaskFor，将 Runnable 任务封装成一种 RunnableFuture（实则是封装成 FutureTask）</span><br>RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 调用 Executor#execute，提交一个 Runnable 任务</span><br>execute(ftask);<br><br><span class="hljs-comment">// 返回 Runnable 任务封装成的 FutureTask</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 之所以返回该 FutureTask 实例，是因为我们可能需要通过该 FutureTask 实例，调用 Future&lt;V&gt; 相关的方法，去对该任务进行一系才足以</span><br><span class="hljs-keyword">return</span> ftask;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="4-1-2-1-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result"><a href="#4-1-2-1-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result" class="headerlink" title="4.1.2.1.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)"></a>4.1.2.1.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br><br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br><br>execute(ftask);<br><br><span class="hljs-keyword">return</span> ftask;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="4-1-2-1-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task"><a href="#4-1-2-1-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task" class="headerlink" title="4.1.2.1.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)"></a>4.1.2.1.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br><br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br><br>execute(ftask);<br><br><span class="hljs-keyword">return</span> ftask;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.FutureTask＜V＞ 源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-FutureTask-概述"><a href="#3-1-FutureTask-概述" class="headerlink" title="3.1. FutureTask 概述"></a>3.1. FutureTask 概述</h3><p><code>FutureTask</code> 是一个具体类，继承了 <code>java.util.concurrent.RunnableFuture&lt;V&gt;</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>RunnableFuture&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-FutureTask-相关状态"><a href="#3-2-FutureTask-相关状态" class="headerlink" title="3.2. FutureTask 相关状态"></a>3.2. FutureTask 相关状态</h3><ol><li><code>NEW（0）</code><ol><li>表示任务的初始状态</li></ol></li><li><code>COMPLETING（1）</code><ol><li>表示任务已经执行完毕，在赋值最终结果</li><li>这是一个非常短暂的瞬间状态</li></ol></li><li><code>NORMAL（2）</code><ol><li>表示任务正常退出</li></ol></li><li><code>EXCEPTIONAL（3）</code><ol><li>表示任务异常退出</li></ol></li><li><code>CANCELLED（4）</code><ol><li>表示任务已被取消</li></ol></li><li><code>INTERRUPTING（5）</code><ol><li>表示任务正在被停止</li></ol></li><li><code>INTERRUPTED（6）</code><ol><li>表示任务已被停止</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>取消任务和停止任务还是有所区别的：取消任务是指取消那些尚未执行的任务。而停止任务则是任务正在执行时，你通过中断去让它停下来。如果任务能够响应中断，那就算是成功停止。但问题在于，如果任务没有响应中断，那么即使你发出了中断请求，它仍然会继续执行。所以 “停止任务” 并不一定能让它 “停止下来”</li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-WaitNode"><a href="#4-1-WaitNode" class="headerlink" title="4.1. WaitNode"></a>4.1. WaitNode</h3><p><code>FutureTask</code> 的 <code>WaitNode</code> 链表就是由 <code>WaitNode</code> 构建的单向链表。所有因为调用 <code>Future#get</code> 而阻塞的 Thread 实例都会被投递到该队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br><br><span class="hljs-keyword">volatile</span> Thread thread;<br><br><span class="hljs-keyword">volatile</span> WaitNode next;<br><br>WaitNode() &#123; thread = Thread.currentThread(); &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示 FutureTask 的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 NEW 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 COMPLETING 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 NORMAL 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 EXCEPTIONAL 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 CANCELLED 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 INTERRUPTING 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 INTERRUPTED 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">// 表示 FutureTask 封装的 Callable 任务</span><br><span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br><br><span class="hljs-comment">// 表示 FutureTask 封装的 Callable 任务的结果</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 需要注意的是，返回值是 Object 类型，说明既能应对正常退出，又能应对异常退出</span><br><span class="hljs-keyword">private</span> Object outcome; <br><br><span class="hljs-comment">// 表示执行 FutureTask 的 Thread 实例</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br><br><span class="hljs-comment">// 表示 FutureTask 的 WaitNode 链表（单向）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br></code></pre></td></tr></table></figure><hr><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6. 构造方法"></a>6. 构造方法</h2><h3 id="6-1-FutureTask-Callable＜V＞-callable"><a href="#6-1-FutureTask-Callable＜V＞-callable" class="headerlink" title="6.1. FutureTask(Callable＜V＞ callable)"></a>6.1. FutureTask(Callable＜V＞ callable)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br><br><span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-built_in">this</span>.callable = callable;<br><br><span class="hljs-built_in">this</span>.state = NEW;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-2-FutureTask-Runnable-runnable-V-result"><a href="#6-2-FutureTask-Runnable-runnable-V-result" class="headerlink" title="6.2. FutureTask(Runnable runnable, V result)"></a>6.2. FutureTask(Runnable runnable, V result)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br><br><span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br><br><span class="hljs-built_in">this</span>.state = NEW;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-实例方法"><a href="#7-实例方法" class="headerlink" title="7. 实例方法"></a>7. 实例方法</h2><h3 id="7-1-实例具体方法"><a href="#7-1-实例具体方法" class="headerlink" title="7.1. 实例具体方法"></a>7.1. 实例具体方法</h3><h4 id="7-1-1-具体方法（实现）"><a href="#7-1-1-具体方法（实现）" class="headerlink" title="7.1.1. 具体方法（实现）"></a>7.1.1. 具体方法（实现）</h4><h5 id="7-1-1-1-Runnable-中接口方法的实现"><a href="#7-1-1-1-Runnable-中接口方法的实现" class="headerlink" title="7.1.1.1. Runnable 中接口方法的实现"></a>7.1.1.1. Runnable 中接口方法的实现</h5><h6 id="7-1-1-1-1-void-run"><a href="#7-1-1-1-1-void-run" class="headerlink" title="7.1.1.1.1. void run()"></a>7.1.1.1.1. void run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (state != NEW ||<br>!RUNNER.compareAndSet(<span class="hljs-built_in">this</span>, <span class="hljs-literal">null</span>, Thread.currentThread()))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>Callable&lt;V&gt; c = callable;<br><span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>V result;<br><span class="hljs-type">boolean</span> ran;<br><span class="hljs-keyword">try</span> &#123;<br>result = c.call();<br>ran = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>result = <span class="hljs-literal">null</span>;<br>ran = <span class="hljs-literal">false</span>;<br>setException(ex);<br>&#125;<br><span class="hljs-keyword">if</span> (ran)<br>set(result);<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>runner = <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br><span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>handlePossibleCancellationInterrupt(s);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="7-1-1-2-Future-中接口方法的实现"><a href="#7-1-1-2-Future-中接口方法的实现" class="headerlink" title="7.1.1.2. Future 中接口方法的实现"></a>7.1.1.2. Future 中接口方法的实现</h5><h6 id="7-1-1-2-1-boolean-cancel-boolean-mayInterruptIfRunning"><a href="#7-1-1-2-1-boolean-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="7.1.1.2.1. boolean cancel(boolean mayInterruptIfRunning)"></a>7.1.1.2.1. boolean cancel(boolean mayInterruptIfRunning)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br><br><span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet<br>  (<span class="hljs-built_in">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>t.interrupt();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>STATE.setRelease(<span class="hljs-built_in">this</span>, INTERRUPTED);<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>finishCompletion();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-2-boolean-isCancelled"><a href="#7-1-1-2-2-boolean-isCancelled" class="headerlink" title="7.1.1.2.2. boolean isCancelled()"></a>7.1.1.2.2. boolean isCancelled()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-3-boolean-isDone"><a href="#7-1-1-2-3-boolean-isDone" class="headerlink" title="7.1.1.2.3. boolean isDone()"></a>7.1.1.2.3. boolean isDone()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> state != NEW;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-4-get"><a href="#7-1-1-2-4-get" class="headerlink" title="7.1.1.2.4. get()"></a>7.1.1.2.4. get()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br><br><span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><br><span class="hljs-keyword">return</span> report(s);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-5-get-long-timeout-TimeUnit-unit"><a href="#7-1-1-2-5-get-long-timeout-TimeUnit-unit" class="headerlink" title="7.1.1.2.5. get(long timeout, TimeUnit unit)"></a>7.1.1.2.5. get(long timeout, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br><br><span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br><br><span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>(s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br><br><span class="hljs-keyword">return</span> report(s);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RunnableFuture＜V＞ 源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-RunnableFuture-概述"><a href="#3-1-RunnableFuture-概述" class="headerlink" title="3.1. RunnableFuture 概述"></a>3.1. RunnableFuture 概述</h3><p><code>RunnableFuture</code> 是一个接口，继承了 <code>java.util.concurrent.Runnable</code>、<code>java.util.concurrent.Future&lt;V&gt;</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Future&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt; &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledExecutorService 源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledExecutorService-概述"><a href="#3-1-ScheduledExecutorService-概述" class="headerlink" title="3.1. ScheduledExecutorService 概述"></a>3.1. ScheduledExecutorService 概述</h3><p><code>ScheduledExecutorService</code> 是一个接口，继承了 <code>java.util.concurrent.ExecutorService</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ScheduledExecutorService</code> 在 <code>ExecutorService</code> 的基础上，为我们提供了以下方法：</p><ol><li>提交一个 <code>Runnable</code> 任务并延迟执行（非阻塞）</li><li>提交一个 <code>Runnable</code> 任务并以固定速率周期性执行（非阻塞）</li><li>提交一个 <code>Runnable</code> 任务并以固定延迟周期性执行（非阻塞）</li><li>提交一个 <code>Callable</code> 任务并延迟执行（非阻塞）</li></ol><p>简单来说，<code>ExecutorService</code> 提供的方法都是任务提交后 “立即执行”，但是 <code>ScheduledExecutorService</code> 允许我们延迟执行任务、周期性执行任务</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>所谓的 “延迟执行” 是指：在指定的延迟时间到达后，任务 “可以被执行”。但它是否会立即真正运行，还取决于是否有空闲线程可以执行该任务。因此在高并发场景下，任务的实际执行时间可能会比指定的延迟时间更晚。</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并延迟 delay unit 时间后再执行</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable comm<br>                                       <span class="hljs-type">long</span> delay, TimeUnit unit);<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Callable 任务，并延迟 delay unit 时间后再执行</span><br>    <span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                           <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并延迟 delay unit 时间后再执行，并以固定速率周期性执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 延迟 initialDelay unit 时间后首次执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 然后以 period unit 固定速率周期性执行，例如 initialDelay unit 为 0s，period unit 为 5s</span><br><span class="hljs-comment">//     1. 第一次执行开始的时间为 0s</span><br><span class="hljs-comment">//     2. 第二次执行快速的时间为 5s</span><br><span class="hljs-comment">//     3. 第三次执行开始的时间为 10s</span><br><span class="hljs-comment">//     4. 以此类推...</span><br><span class="hljs-comment">//     5. 如果第一次执行的任务，耗时 7s，则该任务执行完成后，需要再次立即执行，去弥补第二次的空缺</span><br><span class="hljs-comment">//     6. 如果第二次执行的任务，仍然耗时 7s，则该任务执行完成后，需要再次立即执行，去弥补第三次的空缺</span><br><span class="hljs-comment">//     7. 如果第三次执行的任务，依旧耗时 7s，则该任务执行完成后，需要再次立即执行，去弥补第四次的空缺</span><br><span class="hljs-comment">//     8. 以此类推...</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 需要注意的是，如果执行任务的耗时 ＞ period unit，后续的任务执行可能会开始比较晚，但是不会并发执行。这种情况下就成一种连续执行了，上一个任务刚结束，下一个任务就开始，中间没有任何停顿</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit);<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并延迟 delay unit 时间后再执行，并以固定延迟周期性执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 延迟 initialDelay unit 后首次执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 然后以 period unit 固定延迟周期性执行，例如 initialDelay unit 为 0s，period unit 为 5s</span><br><span class="hljs-comment">//     1. 第一次执行的时间为 0s，如果该任务耗时 7s</span><br><span class="hljs-comment">//     2. 第二次执行的时间为 7s + 5s，即 12s，如果该任务耗时 5s</span><br><span class="hljs-comment">//     3. 第三次执行的时间为 12s + 5s，即 17s</span><br><span class="hljs-comment">//     4. 以此类推...</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.io.Serializable 源码解析</title>
    <link href="/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Serializable-概述"><a href="#3-1-Serializable-概述" class="headerlink" title="3.1. Serializable 概述"></a>3.1. Serializable 概述</h3><p><code>Serializable</code> 是一个接口</p><p><code>Serializable</code> 是一个标记接口，只要我们 <code>Implements Serializable</code>，他就告诉 <code>JVM</code> 这个类的对象可以被序列化和反序列化</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>主要用于 <code>JDK</code> 序列化，其他序列化方式不需要实现该接口</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Object 源码解析</title>
    <link href="/2025/09/24/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/24/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Object-概述"><a href="#3-1-Object-概述" class="headerlink" title="3.1. Object 概述"></a>3.1. Object 概述</h3><p><code>Object</code> 是一个具体类</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Object</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-comment">// 用于非阻塞获取类对象</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br><span class="hljs-comment">// 用于非阻塞获取哈希码</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞比较是否 ”相等“</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 默认比较的是内存地址</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>    &#125;<br><br><span class="hljs-comment">// 用于配置克隆机制，详见笔记：GOF 设计模式（obsidian 内部链接：[笔记：GOF设计模式](笔记：GOF设计模式.md)，Hexo 链接：）</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br><br><span class="hljs-comment">// 用于非阻塞获取 ”字符串表示形式“</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 Monitor 的 WaitSet 中的 “任意” 一个 Thread 实例，被唤醒的 Thread 实例被直接投递到 Monitor 的 EntryList 队列</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 所谓的 “任意” 是指：既不是严格的随机，也不保证是第一个，不同的 JVM 实现可能采用不同的策略</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#notify 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#notify，必须先获取 Monitor 锁。</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 Monitor 的 WaitSet 中的所有 Thread 实例，被唤醒的 Thread 实例被直接投递到 Monitor 的 EntryList 队列</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#notify 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#notify，必须先获取 Monitor 锁。</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 Monitor 的 WaitSet 队列，等待被唤醒（Object#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#wait 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#wait，必须先获取 Monitor 锁。从 Object#wait 唤醒的本地线程，同样也需要先获取 Monitor 锁才能继续向下执行。从 Object#wait 响应中断的本地线程，同样也需要先获取 Monitor 锁才能抛出InterruptedException 异常。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        wait(<span class="hljs-number">0L</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 的 WaitSet 队列，等待被唤醒（Object#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#wait 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#wait，必须先获取 Monitor 锁。从 Object#wait 唤醒的本地线程，同样也需要先获取 Monitor 锁才能继续向下执行。从 Object#wait 响应中断的本地线程，同样也需要先获取 Monitor 锁才能抛出InterruptedException 异常。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 推荐使用 TimeUnit#timedWait 替代该方法，因为其可读性更好：TimeUnit.SECONDES.timedWait(obj, 5)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutMillis)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 的 WaitSet 队列，等待被唤醒（Object#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#wait 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#wait，必须先获取 Monitor 锁。从 Object#wait 唤醒的本地线程，同样也需要先获取 Monitor 锁才能继续向下执行。从 Object#wait 响应中断的本地线程，同样也需要先获取 Monitor 锁才能抛出InterruptedException 异常。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 推荐使用 TimeUnit#timedWait 替代该方法，因为其可读性更好：TimeUnit.SECONDES.timedWait(obj, 5)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutMillis, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (timeoutMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeoutMillis value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span> || nanos &gt; <span class="hljs-number">999999</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                                <span class="hljs-string">&quot;nanosecond timeout value out of range&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span> &amp;&amp; timeoutMillis &lt; Long.MAX_VALUE) &#123;<br>            timeoutMillis++;<br>        &#125;<br><br>        wait(timeoutMillis);<br>    &#125;<br><br><span class="hljs-comment">// 用于配置实例的 finalization 机制，详见笔记：JVM（obsidian 内部链接：[笔记：JVM](笔记：JVM.md)，Hexo 链接：）</span><br>    <span class="hljs-meta">@Deprecated(since=&quot;9&quot;)</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ExecutorService 源码解析</title>
    <link href="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="ExecutorService-概述"><a href="#ExecutorService-概述" class="headerlink" title="ExecutorService 概述"></a>ExecutorService 概述</h3><p><code>ExecutorService</code> 是一个接口，继承了 <code>java.util.concurrent.Executor</code><br><img src="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ExecutorService</code> 在 <code>Executor</code> 的基础上，为我们提供了以下方法：</p><ol><li>关闭线程池（非阻塞）</li><li>等待线程池关闭（限时阻塞）</li><li>查看线程池是否关闭（非阻塞）</li><li>查看线程池是否被执行过 <code>ExecutorService#shutdown</code> 或 <code>ExecutorService#shutdownNow</code>（非阻塞）</li><li>提交一个 <code>Callable</code> 任务（非阻塞）</li><li>提交一个 <code>Runnable</code> 任务（非阻塞）</li><li>提交一批 <code>Callable</code> 任务（阻塞、限时阻塞）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Executor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Executor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br><br><span class="hljs-comment">// 用于非阻塞有序关闭线程池</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 已提交的任务会继续执行，但线程池不会再接收新的任务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞强制关闭线程池</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 正在运行的任务会被停止，并且返回还没开始执行的 Runnable 任务列表，线程池不会再接收新的任务</span><br>    List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看线程池是否被执行过 ExecutorService#shutdown 或 ExecutorService#shutdownNow</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看线程池是否关闭</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于限时阻塞等待线程池关闭</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br><span class="hljs-comment">//     1. 如果超时，返回 false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果线程池未关闭，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 ExecutorService 接口的具体实现类维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Callable 任务</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并手动指定一个任务结果</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 因为 Runnable 任务没有返回结果，如果你需要一个返回结果的话，可以手动指定</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该方法与 Executor#execute 的区别在于：</span><br><span class="hljs-comment">//     1. Executor#execute 只管提交，不问结果。它没有返回值，你无法知道任务是否执行成功，也无法知道任务的执行结果</span><br><span class="hljs-comment">//     2. 而 ExecutorService.submit 是提交任务，返回该任务对应的 Future 接口的具体实现类实例。我们可以根据返回的 Future 接口的具体实现类实例对该任务进行一系列操作</span><br><span class="hljs-comment">//     3. 需要注意的是，如果你提交的是 Runnable 任务，即便你使用 Future 接口的具体实现类实例获取该任务的结果，也只会是 null 或我们手动指定的任务结果。我们通常使用 Future 接口的具体实现类实例获取 Callable 任务的结果</span><br>    Future&lt;?&gt; submit(Runnable task);<br>    <br>    <span class="hljs-comment">// 用于阻塞提交一批 Callable 任务，并等待所有任务执行完毕（正常退出、异常退出、取消任务）后，再返回这些任务对应的 Future接口的具体实现类实例列表</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 在等待任务执行完毕的过程中，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：</span><br>    <span class="hljs-comment">//     1. 它并不像传统模式那样将任务统一投递到某个固定的数据结构中，而是循环调用每个 Future 接口的具体实现类实例的 Future#get</span><br>    <span class="hljs-comment">//     2. 因此 Thread 实例可能被投递到多个 Future 接口的具体实现类实例维护的某数据结构</span><br>    <span class="hljs-comment">//     3. 除此之外，这还意味着阻塞状态也是一段一段的，而不是从头到尾一直阻塞</span><br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">// 用于限时阻塞提交一批 Callable 任务，并等待所有任务执行完毕（正常退出、异常退出、取消任务）后，再返回这些任务对应的 Future 接口的具体实现类实例列表</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br>    <span class="hljs-comment">//     1. 如果超时，会撤销尚未执行的任务</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 在等待任务执行完毕的过程中，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：</span><br>    <span class="hljs-comment">//     1. 它并不像传统模式那样将任务统一投递到某个固定的数据结构中，而是循环调用每个 Future 接口的具体实现类实例的 Future#get</span><br>    <span class="hljs-comment">//     2. 因此 Thread 实例可能被投递到多个 Future 接口的具体实现类实例维护的某数据结构</span><br>    <span class="hljs-comment">//     3. 除此之外，这还意味着阻塞状态也是一段一段的，而不是从头到尾一直阻塞</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">  <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于阻塞提交一批 Callable 任务，等待 “任意” 且 “第一个” 任务执行成功（正常退出），立即返回该任务的结果（并不是该任务对应的 Future 接口的具体实现类实例），并撤销尚未执行的任务和停止正在执行的任务</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在等待 “任意” 且 “第一个” 任务执行程序的过程中，本地线程进入 WAITING 状态，并被投递到 ExecutorCompletionService 维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果所有任务都执行失败，会抛出 ExecutionException 异常</span><br>    &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 用于限时阻塞提交一批 Callable 任务，等待 “任意” 且 “第一个” 任务执行成功（正常退出），立即返回该任务的结果（并不是该任务对应的 Future 实例），并 “尽力” 取消未执行的任务和停止正在执行的任务</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br><span class="hljs-comment">//     1. 如果超时，会抛出 TimeoutException 异常</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 在等待 “任意” 且 “第一个” 任务执行程序的过程中，本地线程进入 TIMED_WAITING 状态，并被投递到 ExecutorCompletionService 维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果所有任务都执行失败，会抛出 ExecutionException 异常</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params"><span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>取消任务和停止任务还是有所区别的：取消任务是指取消那些尚未执行的任务。而停止任务则是任务正在执行时，你通过中断去让它停下来。如果任务能够响应中断，那就算是成功停止。但问题在于，如果任务没有响应中断，那么即使你发出了中断请求，它仍然会继续执行。所以 “停止任务” 并不一定能让它 “停止下来”</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ThreadPoolExecutor源码解析</title>
    <link href="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ThreadPoolExecutor-概述"><a href="#3-1-ThreadPoolExecutor-概述" class="headerlink" title="3.1. ThreadPoolExecutor 概述"></a>3.1. ThreadPoolExecutor 概述</h3><p><code>ThreadPoolExecutor</code> 是一个具体类，继承了 <code>java.util.concurrent.AbstractExecutorService</code><br><img src="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.AbstractExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-ThreadPoolExecutor-相关状态"><a href="#3-2-ThreadPoolExecutor-相关状态" class="headerlink" title="3.2. ThreadPoolExecutor 相关状态"></a>3.2. ThreadPoolExecutor 相关状态</h3><ol><li><code>TERMINATED</code>（<code>011</code>）<ol><li>表示线程池关闭</li></ol></li><li><code>TIDYING</code>（<code>010</code>）<ol><li>表示线程池终止前的过渡状态</li><li>只有任务队列为空、所有任务停止、工作线程的数量为 <code>0</code></li></ol></li><li><code>STOP</code>（<code>001</code>）<ol><li>表示因为调用了 <code>ExecutorService#shutdownNow</code> 而进入的状态</li><li>正在运行的任务会被停止，并且返回还没开始执行的 <code>Runnable</code> 任务列表，线程池不会再接收新的任务</li><li>需要注意的是：<ol><li>如果任务本身并没有响应中断，那么正在执行任务的线程可能不会立刻停下，直到执行完这个任务</li></ol></li></ol></li><li><code>SHUTDOWN</code>（<code>000</code>）<ol><li>表示因为调用了 <code>ExecutorService#shutdown</code> 而进入的状态</li><li>已提交的任务会继续执行，但线程池不会再接收新的任务</li></ol></li><li><code>RUNNING</code>（<code>111</code>）<ol><li>表示线程池的初始状态</li><li>已提交的任务会继续执行，线程池也接收新的任务</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>ThreadPoolExecutor</code> 的状态，我们更常把他叫做 “线程池的状态”</li><li>线程池的状态，根据严重程度来看：<code>TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</code></li><li>取消任务和停止任务还是有所区别的：取消任务是指取消那些尚未执行的任务。而停止任务则是任务正在执行时，你通过中断去让它停下来。如果任务能够响应中断，那就算是成功停止。但问题在于，如果任务没有响应中断，那么即使你发出了中断请求，它仍然会继续执行。所以 “停止任务” 并不一定能让它 “停止下来”</li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Worker"><a href="#4-1-Worker" class="headerlink" title="4.1. Worker"></a>4.1. Worker</h3><p>详见源码：<code>ThreadPoolExecutor.Worker</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ThreadPoolExecutor.Worker源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p><code>AbortPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于直接抛出 <code>RejectedExecutionException</code> 非受检异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br> <span class="hljs-string">&quot; rejected from &quot;</span> +<br> e.toString());<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p><code>DiscardPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于直接丢弃该任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p><code>CallerRunsPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于让调用 <code>Executor#execute</code> 的线程自己去执行这个任务。简单来说就是：谁派来的活，谁自己去干</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>r.run();<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p><code>DiscardOldestPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于直接丢弃任务队列中排队最久的任务，然后尝试把这个任务投递到任务队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>e.getQueue().poll();<br>e.execute(r);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int COUNT_MASK</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 表示 ThreadPoolExecutor 的状态和工作线程的个数</span><br><span class="hljs-comment"> *      2. ThreadPoolExecutor 的状态，我们更常把他叫做 “线程池的状态”</span><br><span class="hljs-comment"> *      </span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. 线程池的状态为 RUNNING，工作线程为 0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ctl 是一个 int 类型的变量，共有 32 bit，其中高 3 bit 表示线程池的状态，低 29 bit 表示工作线程的个数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 表示保存线程池个数的位数（低 bit）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int COUNT_MASK</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 表示保存线程池状态的位数（高 bit）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. (1 &lt;&lt; COUNT_BITS) - 1</span><br><span class="hljs-comment"> *      2. 即 00011111 11111111 11111111 11111111</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 的二进制：</span><br><span class="hljs-comment"> * 00000000 00000000 00000000 00000001</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1  &lt;&lt; 29：</span><br><span class="hljs-comment"> * 把二进制数整体往左挪 29 位，左边溢出的丢掉，右边空出来的补零</span><br><span class="hljs-comment"> * 00100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (1 &lt;&lt; 29) - 1：</span><br><span class="hljs-comment"> * 00011111 11111111 11111111 11111111</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int RUNNING</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 用于界定线程池的 RUNNING 状态</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. -1 &lt;&lt; COUNT_BITS</span><br><span class="hljs-comment"> *      2. 即 11100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * -1 的二进制：</span><br><span class="hljs-comment"> * 11111111 11111111 11111111 11111111</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * -1 &lt;&lt; 29：</span><br><span class="hljs-comment"> * 11100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 SHUTDOWN 状态（000）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 STOP 状态（001）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 TIDYING 状态（010）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 TERMINATED 状态（011）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 表示 TPE 的任务队列（单向队列），如果任务不能作为核心工作线程的 &quot;启动任务&quot;，则被投递到该队列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">// 表示 TPE 的 Worker 集合，所有 Worker 都会被投递到该集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-comment">// 表示 TPE 使用 AQS 创建的条件队列（双向），所有因为调用 ExecutorService#awaitTermination 而阻塞的 Thread 实例会被投递到该队列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">termination</span> <span class="hljs-operator">=</span> mainLock.newCondition();<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> largestPoolSize;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> completedTaskCount;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> keepAliveTime;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> allowCoreThreadTimeOut;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">defaultHandler</span> <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RuntimePermission</span> <span class="hljs-variable">shutdownPerm</span> <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimePermission</span>(<span class="hljs-string">&quot;modifyThread&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6. 构造方法"></a>6. 构造方法</h2><h3 id="6-1-ThreadPoolExecutor-int-corePoolSize-int-maximumPoolSize-long-keepAliveTime-TimeUnit-unit-BlockingQueue＜Runnable＞-workQueue-ThreadFactory-threadFactory-RejectedExecutionHandler-handler"><a href="#6-1-ThreadPoolExecutor-int-corePoolSize-int-maximumPoolSize-long-keepAliveTime-TimeUnit-unit-BlockingQueue＜Runnable＞-workQueue-ThreadFactory-threadFactory-RejectedExecutionHandler-handler" class="headerlink" title="6.1. ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue＜Runnable＞ workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)"></a>6.1. ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue＜Runnable＞ workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</h3><p><code>ThreadPoolExecutor</code> 虽然提供了 <code>4</code> 个构造方法，但是本质上都是调用这个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：</span><br><span class="hljs-comment"> * public ThreadPoolExecutor(</span><br><span class="hljs-comment"> *         int corePoolSize,</span><br><span class="hljs-comment"> *         int maximumPoolSize,</span><br><span class="hljs-comment"> *         long keepAliveTime,</span><br><span class="hljs-comment"> *         TimeUnit unit,</span><br><span class="hljs-comment"> *         BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-comment"> *         ThreadFactory threadFactory,</span><br><span class="hljs-comment"> *         RejectedExecutionHandler handler</span><br><span class="hljs-comment"> * )</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. int corePoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中的核心工作线程被允许的最大数量</span><br><span class="hljs-comment"> *          2. 需要注意的是：</span><br><span class="hljs-comment"> *              1. 该参数可以为 0</span><br><span class="hljs-comment"> *      2. int maximumPoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中的工作线程被允许的最大数量</span><br><span class="hljs-comment"> *          2. 需要注意的是：</span><br><span class="hljs-comment"> *              1. 工作线程的数量 = 核心工作线程的数量 + 非核心工作线程的数量</span><br><span class="hljs-comment"> *      3. long keepAliveTime</span><br><span class="hljs-comment"> *          1. 指定非核心工作线程 “空闲” 被允许的最长时间为 keepAliveTime unit</span><br><span class="hljs-comment"> *          2. 需要注意的是：</span><br><span class="hljs-comment"> *              1. 非核心线程 “空闲” 超时后会被销毁</span><br><span class="hljs-comment"> *              2. 核心线程 “空闲” 超时后不会被销毁</span><br><span class="hljs-comment"> *      4. TimeUnit unit</span><br><span class="hljs-comment"> *          1. 指定非核心工作线程 “空闲” 被允许的最长时间为 keepAliveTime unit</span><br><span class="hljs-comment"> *      5. BlockingQueue＜Runnable＞ workQueue</span><br><span class="hljs-comment"> *          1. 任务在没有核心工作线程处理时，先被投递到这个队列中</span><br><span class="hljs-comment"> *          2. 需要注意的是，是没有核心工作线程处理，而不是工作线程处理</span><br><span class="hljs-comment"> *      6. ThreadFactory threadFactory</span><br><span class="hljs-comment"> *          1. 指定创建 Thread 实例的线程工厂</span><br><span class="hljs-comment"> *      7. RejectedExecutionHandler handler</span><br><span class="hljs-comment"> *          1. 指定拒绝策略</span><br><span class="hljs-comment"> *          2. 当任务队列已满并且线程池中的工作线程数量已经达到了 maximumPoolSize，这时候再投递任务，就需要执行拒绝策略</span><br><span class="hljs-comment"> *          3. 需要注意的是：ThreadPoolExecutor 内置了 4 个拒绝策略，分别是</span><br><span class="hljs-comment"> *              1. ThreadPoolExecutor.AbortPolicy</span><br><span class="hljs-comment"> *              2. ThreadPoolExecutor.DiscardPolicy</span><br><span class="hljs-comment"> *              3. ThreadPoolExecutor.CallerRunsPolicy</span><br><span class="hljs-comment"> *              4. ThreadPoolExecutor.DiscardOldestPolicy</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 构造实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="hljs-comment"> *     2,</span><br><span class="hljs-comment"> *     4,</span><br><span class="hljs-comment"> *     10,</span><br><span class="hljs-comment"> *     TimeUnit.SECONDS,</span><br><span class="hljs-comment"> *     new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="hljs-comment"> *     new ThreadFactory() &#123;</span><br><span class="hljs-comment"> *         private int count = 1;</span><br><span class="hljs-comment"> *         public Thread newThread(Runnable r) &#123;</span><br><span class="hljs-comment"> *             return new Thread(r, &quot;Worker-&quot; + count++);</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *     &#125;,</span><br><span class="hljs-comment"> *     new ThreadPoolExecutor.AbortPolicy()</span><br><span class="hljs-comment"> * );</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">  <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">  <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">  TimeUnit unit,</span><br><span class="hljs-params">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">  ThreadFactory threadFactory,</span><br><span class="hljs-params">  RejectedExecutionHandler handler)</span> &#123;<br><br><span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt; corePoolSize ||<br>keepAliveTime &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><br><span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br><br><span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br><br><span class="hljs-built_in">this</span>.workQueue = workQueue;<br><br><span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br><br><span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br><br><span class="hljs-built_in">this</span>.handler = handler;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-实例方法"><a href="#7-实例方法" class="headerlink" title="7. 实例方法"></a>7. 实例方法</h2><h3 id="7-1-实例具体方法"><a href="#7-1-实例具体方法" class="headerlink" title="7.1. 实例具体方法"></a>7.1. 实例具体方法</h3><h4 id="7-1-1-具体方法（普通）"><a href="#7-1-1-具体方法（普通）" class="headerlink" title="7.1.1. 具体方法（普通）"></a>7.1.1. 具体方法（普通）</h4><h5 id="7-1-1-1-boolean-addWorker-Runnable-firstTask-boolean-core"><a href="#7-1-1-1-boolean-addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="7.1.1.1. boolean addWorker(Runnable firstTask, boolean core)"></a>7.1.1.1. boolean addWorker(Runnable firstTask, boolean core)</h5><p>该方法用于创建并启动一个 <code>Worder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br><br><span class="hljs-comment">// 为循环起一个 Label</span><br>retry:<br><br><span class="hljs-comment">// 不断调用 AtomicInteger#get 获取 ctl 属性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();;) &#123;<br><br><span class="hljs-comment">// 如果</span><br><span class="hljs-comment">//     1. 调用 ThreadPoolExecutor#runStateAtLeast，发现线程池的状态至少为 SHUTDOWN（即 TERMINATED、TIDYING、STOP、SHUTDOWN）</span><br><span class="hljs-comment">//     2. 并且</span><br><span class="hljs-comment">//         1. 要么调用 ThreadPoolExecutor#runStateAtLeast，发现线程池的状态至少为 STOP（即 TERMINATED、TIDYING、STOP）</span><br><span class="hljs-comment">//         2. 要么 firstTask 方法参数为 null</span><br><span class="hljs-comment">//         3. 要么调用 Collection#isEmpty，发现任务队列为空</span><br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>&amp;&amp; (runStateAtLeast(c, STOP) || firstTask != <span class="hljs-literal">null</span>|| workQueue.isEmpty()))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><br><span class="hljs-comment">// 如果调用 ThreadPoolExecutor#workerCountOf，发现线程池中的工作线程的数量 &gt; 本次检查的线程数量上限</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// (core ? corePoolSize : maximumPoolSize) 是指：如果 core 为 true，本次检查的线程数量上限为核心工作线程被允许的最大数量。如果 core 为 false，本次检查的线程数量上限为工作线程被允许的最大数量</span><br><span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 如果调用 ThreadPoolExecutor#compareAndIncrementWorkerCount，成功将工作线程 + 1</span><br><span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br><span class="hljs-keyword">break</span> retry;<br><br><span class="hljs-comment">// 调用 AtomicInteger#get 获取 ctl 属性</span><br>c = ctl.get();<br><br><span class="hljs-comment">// 如果调用 ThreadPoolExecutor#runStateAtLeast，发现线程池的状态至少为 SHUTDOWN（即 TERMINATED、TIDYING、STOP、SHUTDOWN）</span><br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))<br><span class="hljs-keyword">continue</span> retry;<br>&#125;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-comment">// 创建 Worker 实例</span><br>w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br><br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br><br>mainLock.lock();<br><br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br><span class="hljs-keyword">if</span> (isRunning(c) ||<br>(runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br><br><span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><br><span class="hljs-comment">// 调用 HashSet#add，向 ThreadPoolExecutor-&gt;workers 添加新创建的 Worker 实例</span><br>workers.add(w);<br><br>workerAdded = <span class="hljs-literal">true</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br><br><span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>largestPoolSize = s;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>mainLock.unlock();<br>&#125;<br><span class="hljs-keyword">if</span> (workerAdded) &#123;<br><br><span class="hljs-comment">// 启动 Thread 实例</span><br>t.start();<br><br>workerStarted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br><span class="hljs-keyword">if</span> (! workerStarted)<br>addWorkerFailed(w);<br>&#125;<br><span class="hljs-keyword">return</span> workerStarted;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="7-1-1-2-void-runWorker-Worker-w"><a href="#7-1-1-2-void-runWorker-Worker-w" class="headerlink" title="7.1.1.2. void runWorker(Worker w)"></a>7.1.1.2. void runWorker(Worker w)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br><br>w.firstTask = <span class="hljs-literal">null</span>;<br><br>w.unlock();<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br><br>w.lock();<br><br><span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br> (Thread.interrupted() &amp;&amp;<br>  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>!wt.isInterrupted())<br>wt.interrupt();<br><br><span class="hljs-keyword">try</span> &#123;<br>beforeExecute(wt, task);<br><span class="hljs-keyword">try</span> &#123;<br>task.run();<br>afterExecute(task, <span class="hljs-literal">null</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>afterExecute(task, ex);<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>task = <span class="hljs-literal">null</span>;<br>w.completedTasks++;<br>w.unlock();<br>&#125;<br>&#125;<br>completedAbruptly = <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>processWorkerExit(w, completedAbruptly);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="7-1-2-具体方法（实现）"><a href="#7-1-2-具体方法（实现）" class="headerlink" title="7.1.2. 具体方法（实现）"></a>7.1.2. 具体方法（实现）</h4><h5 id="7-1-2-1-Executor-中接口方法的实现"><a href="#7-1-2-1-Executor-中接口方法的实现" class="headerlink" title="7.1.2.1. Executor 中接口方法的实现"></a>7.1.2.1. Executor 中接口方法的实现</h5><h6 id="7-1-2-1-1-void-execute-Runnable-command"><a href="#7-1-2-1-1-void-execute-Runnable-command" class="headerlink" title="7.1.2.1.1. void execute(Runnable command)"></a>7.1.2.1.1. void execute(Runnable command)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br><span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br><span class="hljs-keyword">return</span>;<br>c = ctl.get();<br>&#125;<br><span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>reject(command);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>reject(command);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="7-1-2-2-ExecutorService-中接口方法的实现"><a href="#7-1-2-2-ExecutorService-中接口方法的实现" class="headerlink" title="7.1.2.2. ExecutorService 中接口方法的实现"></a>7.1.2.2. ExecutorService 中接口方法的实现</h5><h6 id="7-1-2-2-1-void-shutdown"><a href="#7-1-2-2-1-void-shutdown" class="headerlink" title="7.1.2.2.1. void shutdown()"></a>7.1.2.2.1. void shutdown()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>checkShutdownAccess();<br>advanceRunState(SHUTDOWN);<br>interruptIdleWorkers();<br>onShutdown();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br>tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-2-2-2-List＜Runnable＞-shutdownNow"><a href="#7-1-2-2-2-List＜Runnable＞-shutdownNow" class="headerlink" title="7.1.2.2.2. List＜Runnable＞ shutdownNow()"></a>7.1.2.2.2. List＜Runnable＞ shutdownNow()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>checkShutdownAccess();<br>advanceRunState(STOP);<br>interruptWorkers();<br>tasks = drainQueue();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-2-2-3-boolean-awaitTermination-long-timeout-TimeUnit-unit"><a href="#7-1-2-2-3-boolean-awaitTermination-long-timeout-TimeUnit-unit" class="headerlink" title="7.1.2.2.3. boolean awaitTermination(long timeout, TimeUnit unit)"></a>7.1.2.2.3. boolean awaitTermination(long timeout, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">while</span> (runStateLessThan(ctl.get(), TERMINATED)) &#123;<br><span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>nanos = termination.awaitNanos(nanos);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurren.Future＜V＞源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Future-概述"><a href="#3-1-Future-概述" class="headerlink" title="3.1. Future 概述"></a>3.1. Future 概述</h3><p><code>Future</code> 是一个接口</p><p><code>Future</code> 为我们提供了以下方法：</p><ol><li>取消还未执行的任务、停止正在执行的任务（非阻塞）</li><li>查看任务是否已经被撤销或停止（非阻塞）</li><li>查看任务是否已经执行完毕（非阻塞）</li><li>获取任务的结果（阻塞、限时阻塞）</li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞取消还未执行的任务，停止正在执行的任务</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看任务是否已经被撤销或停止</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看任务是否已经执行完毕（正常退出、异常退出、取消任务）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于阻塞获取任务的结果</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 如果任务还没有执行完，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 Future 接口的具体实现类实例中维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 用于限时阻塞获取任务的结果</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br><span class="hljs-comment">//     1. 如果超时，抛出 TimeoutException 异常</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果任务还没有执行完，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Future 接口的具体实现类实例维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Callable＜V＞ 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Callable-概述"><a href="#3-1-Callable-概述" class="headerlink" title="3.1. Callable 概述"></a>3.1. Callable 概述</h3><p><code>Callable</code> 是一个接口</p><p>实现 <code>Callable</code> 接口的具体实现类，表示一个可被线程执行的任务，我们称之为 “<code>Callable</code> 任务”</p><p>与 <code>Runnable</code> 任务相比，<code>Callable</code> 任务既可以有返回值，也可以抛出异常</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 <code>Java</code> 中，线程执行的任务，通常是指 <code>Runnable</code> 任务和 <code>Callable</code> 任务</li><li><code>Runnable</code> 在 <code>Java1</code> 就出现了，但是 <code>Runnable</code> 任务既不能抛出受检异常，也没有返回值。执行 <code>Runnable</code> 就感觉进入了一个黑盒子，没有一点反馈，于是我们在 <code>Java5</code> 引入了 <code>Callable</code></li><li>需要注意的是，这里有一个 “坑”：<ol><li><code>Thread</code> 在设计之初就是只能用来执行 <code>Runnable</code> 任务，不能直接执行  <code>Callable</code> 任务（即 <code>本地线程 ➔ Thread#run ➔ target#run</code>，这里的 <code>target</code> 就是一个 <code>Runnable</code> 任务）</li><li>除此之外，即便能执行 <code>Callable</code> 任务，如何拿到这个 <code>Callable</code> 任务的返回值，也是一个问题</li><li>我们的解决思路通常是：<ol><li>将实现 <code>Callable</code> 接口的具体实现类，作为实现 <code>Runnable</code> 接口的具体实现类的属性，当线程调用实现 <code>Runnable</code> 接口的具体实现类时，会调用其 <code>run</code>，我们在 <code>run</code> 中再去调用实现 <code>Callable</code> 接口的具体实现类的 <code>call</code>，然后将 <code>call</code> 的返回值，也作为实现 <code>Runnable</code> 接口的具体实现类的属性</li><li><code>FutureTask</code> 就是这样做的，详见源码：<code>FutureTask</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.FutureTask＜V＞源码解析</a>，<code>Hexo</code> 链接：）</li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br><br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Runnable 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Runnable-概述"><a href="#3-1-Runnable-概述" class="headerlink" title="3.1. Runnable 概述"></a>3.1. Runnable 概述</h3><p><code>Runnable</code> 是一个接口</p><p>实现 <code>Runnable</code> 接口的具体实现类，表示一个可被线程执行的任务，我们称之为 “<code>Runnable</code> 任务”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 <code>Java</code> 中，线程执行的任务，通常是指 <code>Runnable</code> 任务和 <code>Callable</code> 任务</li><li><code>Runnable</code> 在 <code>Java1</code> 就出现了，但是 <code>Runnable</code> 任务既不能抛出受检异常，也没有返回值。执行 <code>Runnable</code> 就感觉进入了一个黑盒子，没有一点反馈，于是我们在 <code>Java5</code> 引入了 <code>Callable&lt;V&gt;</code></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>接口中的接口方法却写 <code>abstract</code> 非访问修饰符，这是早期遗留的写法和部分人的编码习惯</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locksAbstractOwnableSynchronizer 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractOwnableSynchronizer-概述"><a href="#3-1-AbstractOwnableSynchronizer-概述" class="headerlink" title="3.1. AbstractOwnableSynchronizer 概述"></a>3.1. AbstractOwnableSynchronizer 概述</h3><p><code>AbstractOwnableSynchronizer</code> 是一个接口</p><p><code>AbstractOwnableSynchronizer</code> 提供了以下方法：</p><ol><li>记录当前独占该独占模式同步器资源的线程（非阻塞）</li><li>获取当前独占该独占模式同步器资源的线程（非阻塞）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>AOS</code> 仅用于独占模式同步器，如果基于 <code>AQS</code> 实现的是共享模式的同步器或状态机，那么 <code>AOS</code> 根本用不到</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-comment">// 表示当前独占该独占模式同步器资源的线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br><br><span class="hljs-comment">// 用于非阻塞记录当前独占该独占模式同步器资源的线程</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        exclusiveOwnerThread = thread;<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞获取当前独占该独占模式同步器资源的线程</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReentrantLock.Sync 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReentrantLock-Sync-概述"><a href="#3-1-ReentrantLock-Sync-概述" class="headerlink" title="3.1. ReentrantLock.Sync 概述"></a>3.1. ReentrantLock.Sync 概述</h3><p><code>Sync</code> 是一个抽象类，是 <code>java.util.concurrent.locks.ReentrantLock</code> 的静态内部类，继承了 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code><br><img src="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ReentrantLock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-keyword">if</span> (++c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!initialTryLock())<br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-keyword">if</span> (!initialTryLock())<br>acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLockNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-keyword">return</span> initialTryLock() || tryAcquireNanos(<span class="hljs-number">1</span>, nanos);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br><span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> (c == <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (free)<br>setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>&#125;<br><br><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>&#125;<br><br><span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getOwner</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : getExclusiveOwnerThread();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHoldCount</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> isHeldExclusively() ? getState() : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>s.defaultReadObject();<br>setState(<span class="hljs-number">0</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</title>
    <link href="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedSynchronizer-概述"><a href="#3-1-AbstractQueuedSynchronizer-概述" class="headerlink" title="3.1. AbstractQueuedSynchronizer 概述"></a>3.1. AbstractQueuedSynchronizer 概述</h3><p><code>AbstractQueuedSynchronizer</code> 是一个抽象类，继承了 <code>java.util.concurrent.locks.AbstractOwnableSynchronizer</code>，实现了 <code>java.io.Serializable</code><br><img src="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractOwnableSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>需要注意的是：<ol><li><code>Java8</code> 的 <code>AQS</code> 是只有 <code>Node</code> 的，没有 <code>ExclusiveNode</code>、<code>SharedNode</code>、<code>ConditionNode</code> 的</li></ol></li></ol></blockquote><hr><h3 id="3-2-AbstractQueuedSynchronizer-应用场景"><a href="#3-2-AbstractQueuedSynchronizer-应用场景" class="headerlink" title="3.2. AbstractQueuedSynchronizer 应用场景"></a>3.2. AbstractQueuedSynchronizer 应用场景</h3><h4 id="3-2-1-同步器"><a href="#3-2-1-同步器" class="headerlink" title="3.2.1. 同步器"></a>3.2.1. 同步器</h4><p>同步器是一种协调多个线程执行的工具。它通过内部维护的状态（<code>State</code>），用于控制多个线程对一个或多个共享资源的访问，从而实现线程间的同步与协作</p><p>简单来说，多个线程需要先竞争同步器资源（即 <code>State</code>），只有竞争成功的线程才能访问共享资源。而 <code>AQS</code> 提供了一系列机制，使得多个线程能够 “高效且安全” 地竞争、释放 <code>State</code></p><p>在基于 <code>AQS</code> 的同步器实现中，通常需要维护两种队列：</p><ol><li>一条同步队列<ol><li>同步队列用于管理那些尝试获取同步器资源，但暂时失败并暂时进入阻塞（<code>WAITING</code>、<code>TIMED_WAITING</code>）的线程</li><li><code>AQS</code> 已经封装好了相关的节点类型（即 <code>Node</code>、<code>ExclusiveNode</code>、<code>SharedNode</code>），并且提供了首尾哨兵节点。因此，我们的 <code>AQS</code> 实现类只需要在此基础上维护同步队列即可</li></ol></li><li>多条条件队列<ol><li>条件队列用于管理那些已经获取同步器资源，但因业务条件不满足，而调用了 <code>Condition.await</code>，释放同步器资源并暂时进入阻塞（<code>WAITING</code>、<code>TIMED_WAITING</code>）的线程</li><li><code>AQS</code> 已经封装好了 <code>ConditionObject</code> 和相关的节点类型（即 <code>ConditionNode</code>），一个 <code>ConditionObject</code> 实例就是一条条件队列。因此，我们的 <code>AQS</code> 实现类只需要根据自己的需要，创建并维护 <code>ConditionObject</code> 实例即可<br><img src="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1.png"></li></ol></li></ol><p>在不同的同步器实现中，<code>State</code> 和共享资源有不同的含义，例如在 <code>ReentrantLock</code> 中：</p><ol><li><code>State</code> 表示锁的重入次数<ol><li><code>0</code><ol><li>表示锁空闲，线程可以尝试获取</li></ol></li><li><code>1</code><ol><li>表示锁已被某个线程持有</li></ol></li><li><code>n（n &gt; 1）</code><ol><li>表示同一线程对该锁进行了 <code>n</code> 次重入</li></ol></li></ol></li><li>共享资源表示加锁期间的操作</li></ol><p>在使用 <code>AQS</code> 时，绝大多数情况下（约 <code>99%</code>）都是用来实现各种同步器（例如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>）。在这种情况下，我们可能需要使用到的以下内容：</p><ol><li><code>AOS</code><ol><li>如果基于 <code>AQS</code> 实现的是独占模式的同步器（例如 <code>ReentrantLock</code>），就需要使用 <code>AOS</code> 记录当前独占该资源的线程</li><li>但是如果基于 <code>AQS</code> 实现的是共享模式的同步器（例如 <code>Semaphore</code>），那么 <code>AOS</code> 根本就用不到</li></ol></li><li><code>AQS</code><ol><li><code>State</code></li><li>同步队列</li><li>条件队列</li></ol></li></ol><p>在使用 <code>AQS</code> 实现同步器时，通常的做法是：在同步器内部定义一个静态内部类（一般命名为 <code>Sync</code>），并让 <code>Sync</code> 继承 <code>AbstractQueuedSynchronizer</code>，而不是让同步器直接继承 <code>AQS</code></p><p>当外部调用同步器的方法时，执行的流程大致为：<code>外部调用同步器的方法 → 同步器调用 Sync 的方法 → Sync 调用 AQS 的方法</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>在使用 <code>AQS</code> 实现同步器时，为什么不直接让同步器直接继承 <code>AQS</code>？<ol><li>其实这里实际使用了 <code>GOF</code> 设计模式之策略模式，以 <code>ReentrangLock</code> 为例</li><li><code>RenntrantLock</code> 需要支持 “公平锁” 和 “非公平锁” 两种模式，而两者在竞争 <code>State</code> 的逻辑上完全不同</li><li>但是 <code>AQS</code> 只提供了竞争 <code>State</code> 的方法，因此具体的竞争逻辑必须由 <code>AQS</code> 的实现类来定义。</li><li>如果同步器直接继承 <code>AQS</code>，就需要在每次操作中使用 <code>if...else if...else</code> 或 <code>switch...case...default</code> 判断公平锁或非公平锁，然后执行不同的竞争逻辑</li><li>为了避免大量的 <code>if...else if...else</code> 或 <code>switch...case...default</code> 判断，<code>ReentrantLock</code> 就采用了策略模式</li><li><code>ReentrantLock</code> 内部定义了两个静态内部类（即 <code>FairSync</code>、<code>NonFairSync</code>），这两个类分别实现各自的竞争逻辑</li></ol></li></ol></li></ol></blockquote><hr><h4 id="3-2-2-状态机"><a href="#3-2-2-状态机" class="headerlink" title="3.2.2. 状态机"></a>3.2.2. 状态机</h4><p>状态机通过内部维护的状态（<code>State</code>），用于表示其实例在生命周期中可能经历的各个阶段</p><p>在使用 <code>AQS</code> 时，有少数情况（约 <code>1%</code>）会用来实现状态机（例如 <code>ThreadPoolExecutor.Worker</code>）。在这种情况下，我们可能需要使用到以下内容：</p><ol><li><code>AQS</code><ol><li><code>State</code></li></ol></li></ol><p>在不同的状态机实现中，<code>State</code> 有不同的含义，例如在 <code>ThreadPoolExecutor.Worker</code> 中：</p><ol><li><code>-1</code><ol><li><code>Worker</code> 正在被实例化</li></ol></li><li><code>0</code><ol><li><code>Worker</code> 并没有 “执行” 任务（正在从任务队列中获取任务）</li></ol></li><li><code>1</code><ol><li><code>Worker</code> 正在 “执行” 任务</li></ol></li></ol><p>在使用 <code>AQS</code> 实现状态机时，通常的做法是：直接让状态机继承 <code>AQS</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code><ol><li>为什么实现状态机还要使用 <code>AQS</code>？我们直接在状态机内部维护一个 <code>State</code> 不就行了嘛？<ol><li>因为 <code>AQS</code> 提供了一系列机制，使得多个线程能够 “高效且安全” 地竞争、释放 <code>State</code></li><li>而我们自己实现不一定能做到这么稳妥，而且只是在走 “<code>AQS</code>” 的老路，不如直接复用最省心</li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Node"><a href="#4-1-Node" class="headerlink" title="4.1. Node"></a>4.1. Node</h3><p>详见源码：<code>AbstractQueuedSynchronizer.Node</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h3 id="4-2-ExclusiveNode"><a href="#4-2-ExclusiveNode" class="headerlink" title="4.2. ExclusiveNode"></a>4.2. ExclusiveNode</h3><p><code>AbstractQueuedSynchronizer.ExclusiveNode</code> 只是简单地继承了 <code>AbstractQueuedSynchronizer.Node</code>，为 <code>AbstractQueuedSynchronizer.Node</code> 增加了一层 “独占模式节点” 的标签，用来明确区分节点所处的语义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果基于 <code>AQS</code> 实现的是独占模式同步器（例如 <code>ReentrantLock</code>），那么同步队列中的 <code>Node</code> 就应该是 <code>ExclusiveNode</code></li></ol></blockquote><hr><h3 id="4-3-SharedNode"><a href="#4-3-SharedNode" class="headerlink" title="4.3. SharedNode"></a>4.3. SharedNode</h3><p><code>AbstractQueuedSynchronizer.SharedNode</code> 也只是简单地继承了 <code>AbstractQueuedSynchronizer.Node</code>，为 <code>AbstractQueuedSynchronizer.Node</code> 增加了一层 “共享模式节点” 的标签，用来明确区分节点所处的语义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果基于 <code>AQS</code> 实现的是共享模式同步器（例如 <code>Semaphore</code>），那么同步队列中的 <code>Node</code> 就应该是 <code>SharedNode</code></li></ol></blockquote><hr><h3 id="4-4-ConditionObject"><a href="#4-4-ConditionObject" class="headerlink" title="4.4. ConditionObject"></a>4.4. ConditionObject</h3><p>详见源码：<code>AbstractQueuedSynchronizer.ConditionObject</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h3 id="4-5-ConditionNode"><a href="#4-5-ConditionNode" class="headerlink" title="4.5. ConditionNode"></a>4.5. ConditionNode</h3><p>详见源码：<code>AbstractQueuedSynchronizer.ConditionNode</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示 AQS 的同步队列的首哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 表示 AQS 的同步队列的尾哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 表示 AQS 的核心状态位（State）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Executor 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Executor-概述"><a href="#3-1-Executor-概述" class="headerlink" title="3.1. Executor 概述"></a>3.1. Executor 概述</h3><p><code>Executor</code> 是一个接口，为我们提供了以下方法：</p><ol><li>提交一个 <code>Runnable</code> 任务（非阻塞）</li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="5-实现示例"><a href="#5-实现示例" class="headerlink" title="5. 实现示例"></a>5. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Runnable 不能为 null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(command).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoExecutor</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行任务 &quot;</span> + id + <span class="hljs-string">&quot; 的线程: &quot;</span> + Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-概述"><a href="#3-概述" class="headerlink" title="3. 概述"></a>3. 概述</h2><p><code>AbstractQueuedSynchronizer.ConditionNode</code> 是一个具体类，是 <code>AQS</code> 的 静态内部类，继承了 <code>AbstractQueuedSynchronizer.Node</code>，实现了 <code>ForkJoinPool.ManagedBlocker</code></p><p><code>AQS</code> 的条件队列就是是由 <code>AbstractQueuedSynchronizer.ConditionNode</code> 构建的，基于单向链表的队列</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedSynchronizer.Node</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker &#123;<br><br><span class="hljs-comment">// 表示该节点在 AQS 的条件队列中的后驱节点</span><br>ConditionNode nextWaiter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> status &lt;= <span class="hljs-number">1</span> || Thread.currentThread().isInterrupted();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (!isReleasable()) LockSupport.park();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedSynchronizer-ConditionObject-概述"><a href="#3-1-AbstractQueuedSynchronizer-ConditionObject-概述" class="headerlink" title="3.1. AbstractQueuedSynchronizer.ConditionObject 概述"></a>3.1. AbstractQueuedSynchronizer.ConditionObject 概述</h3><p><code>ConditionObject</code> 是一个具体类，是 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>. 的普通内部类，实现了 <code>java.util.concurrent.locks.Condition</code>、<code>java.io.Serializable</code><br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ConditionObject</code> 维护了一个由 <code>AbstractQueuedSynchronizer.ConditionNode</code> 构建的，基于单向链表的队列。所谓的 “<code>AQS</code> 的条件队列” 其实就是在说 <code>ConditionObject</code> 维护的这条件队列<br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Condition</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Condition源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示 AQS 的条件队列的首哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode firstWaiter;<br><br><span class="hljs-comment">// 表示 AQS 的条件队列的尾哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode lastWaiter;<br></code></pre></td></tr></table></figure><hr><h2 id="5-具体方法"><a href="#5-具体方法" class="headerlink" title="5. 具体方法"></a>5. 具体方法</h2><h3 id="5-1-具体方法（无）"><a href="#5-1-具体方法（无）" class="headerlink" title="5.1. 具体方法（无）"></a>5.1. 具体方法（无）</h3><h4 id="5-1-1-private-int-enableWait-ConditionNode-node"><a href="#5-1-1-private-int-enableWait-ConditionNode-node" class="headerlink" title="5.1.1. private int enableWait(ConditionNode node)"></a>5.1.1. private int enableWait(ConditionNode node)</h4><p><code>private int enableWait(ConditionNode node)</code> 用于 把当前线程包装成一个 <code>ConditionNode</code>，然后将该节点链接到条件队列（单向链表）中，并释放锁资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. ConditionNode node</span><br><span class="hljs-comment"> *          1. 一个空的 ConditionNode，当前线程就是包装在这个 Node 中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 在进入 await() 之前，同步器（AQS）的 state 值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. IllegalMonitorStateException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enableWait</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br><br><span class="hljs-comment">// 如果独占锁是否被当前线程持有（Condition 是专门用于独占锁的）</span><br><span class="hljs-keyword">if</span> (isHeldExclusively()) &#123;<br><br><span class="hljs-comment">// 将当前线程封装到 Node 的 waiter 中</span><br>node.waiter = Thread.currentThread();<br><br><span class="hljs-comment">// 将 node 的状态设置为 COND（条件队列） + 等待中</span><br>node.setStatusRelaxed(COND | WAITING);<br><br><span class="hljs-comment">// 将 Node 链接到条件队列中（单向链表）</span><br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> lastWaiter;<br><span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>firstWaiter = node;<br><span class="hljs-keyword">else</span><br>last.nextWaiter = node;<br>lastWaiter = node;<br><br><span class="hljs-comment">// 记录当前 state</span><br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br><br><span class="hljs-comment">// 让 state 清零，彻底释放</span><br><span class="hljs-keyword">if</span> (release(savedState))<br><span class="hljs-keyword">return</span> savedState;<br>&#125;<br><span class="hljs-comment">// 如果独占锁不是被当前线程持有，则将该 Node 的状态设置为 CANCELLED 并抛出 throw new IllegalMonitorStateException();</span><br>node.status = CANCELLED;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="5-1-2-private-boolean-canReacquire-ConditionNode-node"><a href="#5-1-2-private-boolean-canReacquire-ConditionNode-node" class="headerlink" title="5.1.2. private boolean canReacquire(ConditionNode node)"></a>5.1.2. private boolean canReacquire(ConditionNode node)</h4><p><code>private boolean canReacquire(ConditionNode node)</code> 用于 判断某个在 <code>Condition</code> 上等待的节点，被 <code>Condition</code> 的 <code>signal</code> 后，是否已经链接到同步队列中</p><p>需要注意的是，线程在被 <code>Condition</code> 的 <code>signal()</code> 唤醒后，按设计一定会转移到同步队列中去竞争锁。但在高并发环境下，节点的入队过程并非一步到位，可能出现链表指针尚未完全修复或节点已被取消等等 “中间态”。因此，需要通过这个方法进行校验，确保节点确实已经稳定地进入同步队列，才算真正具备重新竞争锁的资格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canReacquire</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br>Node p;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * node != null 是最基础的检查，传入 Node 不能为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (p = node.prev) != null 用于检查这个节点是否有前驱，</span><br><span class="hljs-comment"> * 因为在 AQS 的同步队列中，除了头节点，其他节点都必须有 prev</span><br><span class="hljs-comment"> * 如果 prev 为 null，说明它不在同步队列里</span><br><span class="hljs-comment"> * 不要猜测该节点是否是队头节点，因为同步队列一定会存在一个头节点，而且是一个哑节点</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (p.next == node || isEnqueued(node)) 中的 p.next == node</span><br><span class="hljs-comment"> * 是看这个节点的前驱节点的 next 是否正确指向自己，如果是，说明这个节点确实在同步队列中</span><br><span class="hljs-comment"> * 但是因为在高并发下，节点刚被加进队列，可能还没来得及完全修复 p.next，这种情况下，单靠这个判断会出错</span><br><span class="hljs-comment"> * 所以通过 isEnqueued(node) 来遍历确认它确实在同步队列中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; (p = node.prev) != <span class="hljs-literal">null</span> &amp;&amp;<br>(p.next == node || isEnqueued(node));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="5-1-3-private-void-doSignal-ConditionNode-first-boolean-all"><a href="#5-1-3-private-void-doSignal-ConditionNode-first-boolean-all" class="headerlink" title="5.1.3. private void doSignal(ConditionNode first, boolean all)"></a>5.1.3. private void doSignal(ConditionNode first, boolean all)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(ConditionNode first, <span class="hljs-type">boolean</span> all)</span> &#123;<br><span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br><span class="hljs-comment">// 把 firstWaiter 指向第二个节点</span><br><span class="hljs-keyword">if</span> ((firstWaiter = next) == <span class="hljs-literal">null</span>)<br>lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把 first 节点上的 COND 标志清掉，并返回旧值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 如果返回 COND，说明 first 节点还处于条件等待队列，进行 if 逻辑</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 进行这个检查的原因是，节点可能在 signal 之前就被取消了（超时/中断），就没资格进入同步队列了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 将 first 节点从条件队列转移到同步队列</span><br>enqueue(first);<br><span class="hljs-comment">// 如果不是 signalAll，不需要唤醒其他节点，退出 while 循环</span><br><span class="hljs-keyword">if</span> (!all)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 如果是 signalAll，将 first = next，继续 while 循环</span><br>first = next;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-具体方法（实现）"><a href="#5-2-具体方法（实现）" class="headerlink" title="5.2. 具体方法（实现）"></a>5.2. 具体方法（实现）</h3><h4 id="5-2-1-Condition-中的方法实现"><a href="#5-2-1-Condition-中的方法实现" class="headerlink" title="5.2.1. Condition 中的方法实现"></a>5.2.1. Condition 中的方法实现</h4><h5 id="5-2-1-1-Condition-源码解析"><a href="#5-2-1-1-Condition-源码解析" class="headerlink" title="5.2.1.1. Condition 源码解析"></a>5.2.1.1. Condition 源码解析</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Condition源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h5 id="5-2-1-2-public-final-void-await"><a href="#5-2-1-2-public-final-void-await" class="headerlink" title="5.2.1.2. public final void await()"></a>5.2.1.2. public final void await()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, cancelled = <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> (interrupted |= Thread.interrupted()) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (interrupted) &#123;<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125;<br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-3-public-final-void-awaitUninterruptibly"><a href="#5-2-1-3-public-final-void-awaitUninterruptibly" class="headerlink" title="5.2.1.3. public final void awaitUninterruptibly()"></a>5.2.1.3. public final void awaitUninterruptibly()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-comment">// 把当前线程包装成一个 ConditionNode，然后将该节点链接到条件队列（单向链表）中，并释放锁资源</span><br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><br><span class="hljs-comment">// 把 “阻塞原因” 对象（arg）写到当前 Thread 对象的内部字段 parkBlocker 上</span><br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 如果某个在 Condition 上等待的节点，还没有被链接到同步队列中</span><br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><br><span class="hljs-comment">// 如果被中断，设置中断标志位</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>interrupted = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 如果 Node 的 Status 还有 COND，说明确实还在条件队列中，进入循环</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 如果不是使用 ForkJoinPool 只能控制何时阻塞，则立即进行阻塞</span><br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-comment">// 否则说明使用了 ForkJoinPool，使用 ForkJoinPool 的 managedBlock 智能控制何时阻塞</span><br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 如果 Node 的 status 不含 COND，可能是已移出条件队列进入同步队列了（因为这个流程可能非常快，上一刻还在条件队列，下一刻就在同步队列了）</span><br><span class="hljs-comment">* 在这种临界状态，调用 Thread.onSpinWait() 提示 CPU 进入高效自旋，再次调用 canReacquire(node) 看是否已经在同步队列了</span><br><span class="hljs-comment">*/</span><br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br><span class="hljs-comment">// 如果某个在 Condition 上等待的节点，已经被链接到同步队列中，继续执行</span><br><span class="hljs-comment">// 把当前 Thread 对象的内部字段 parkBlocker 上的 “阻塞原因” 对象置为 null</span><br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 清除 Node 的 Status</span><br>node.clearStatus();<br><br><span class="hljs-comment">// 不断重试获取锁</span><br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><br><span class="hljs-comment">// 在方法执行过程中，可能导致中断标志位被清除，这里恢复中断标志位</span><br><span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-4-public-final-long-awaitNanos-long-nanosTimeout"><a href="#5-2-1-4-public-final-long-awaitNanos-long-nanosTimeout" class="headerlink" title="5.2.1.4. public final long awaitNanos(long nanosTimeout)"></a>5.2.1.4. public final long awaitNanos(long nanosTimeout)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime(); <span class="hljs-comment">// avoid overflow</span><br><span class="hljs-keyword">return</span> (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-5-public-final-boolean-await-long-time-TimeUnit-unit"><a href="#5-2-1-5-public-final-boolean-await-long-time-TimeUnit-unit" class="headerlink" title="5.2.1.5. public final boolean await(long time, TimeUnit unit)"></a>5.2.1.5. public final boolean await(long time, TimeUnit unit)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">nanosTimeout</span> <span class="hljs-operator">=</span> unit.toNanos(time);<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-6-public-final-boolean-awaitUntil-Date-deadline"><a href="#5-2-1-6-public-final-boolean-awaitUntil-Date-deadline" class="headerlink" title="5.2.1.6. public final boolean awaitUntil(Date deadline)"></a>5.2.1.6. public final boolean awaitUntil(Date deadline)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">abstime</span> <span class="hljs-operator">=</span> deadline.getTime();<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>System.currentTimeMillis() &gt;= abstime) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkUntil(<span class="hljs-built_in">this</span>, abstime);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-7-public-final-void-signal"><a href="#5-2-1-7-public-final-void-signal" class="headerlink" title="5.2.1.7. public final void signal()"></a>5.2.1.7. public final void signal()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-8-public-final-void-signalAll"><a href="#5-2-1-8-public-final-void-signalAll" class="headerlink" title="5.2.1.8. public final void signalAll()"></a>5.2.1.8. public final void signalAll()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedSynchronizer-Node-概述"><a href="#3-1-AbstractQueuedSynchronizer-Node-概述" class="headerlink" title="3.1. AbstractQueuedSynchronizer.Node 概述"></a>3.1. AbstractQueuedSynchronizer.Node 概述</h3><p><code>AbstractQueuedSynchronizer.Node</code> 是一个抽象类，是 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 的静态内部类</p><p><code>AQS</code> 的同步队列就是由 <code>AbstractQueuedSynchronizer.Node</code> 构建的，基于双向链表的队列</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>在最初的设计里，<code>Node</code> 只是一个具体类，职责非常单纯，充当同步队列中的节点。但随着并发框架的发展，设计者意识到队列节点本身需要承载两种不同的语义：独占 (<code>exclusive</code>) 和 共享 (<code>shared</code>)<ol><li>为了更好地表达这一点，他们将 <code>Node</code> 改为抽象类。尽管 <code>Node</code> 中并没有抽象方法，看起来 “抽象” 似乎多此一举，但这样设计的核心目的，是阻止开发者直接去实例化一个原始的 <code>Node</code></li><li>取而代之的是，框架定义了两个具体子类：<code>ExclusiveNode</code> 和 <code>SharedNode</code>。这两个类除了继承 <code>Node</code> 外没有任何额外逻辑，但却起到了“标记” 的作用，明确区分了节点的语义。这样一来，开发者所创建的不是一个模糊的 “队列节点”，而是一个语义清晰的 “独占节点” 或 “共享节点”</li></ol></li></ol></blockquote><hr><h3 id="3-2-AbstractQueuedSynchronizer-Node-相关状态"><a href="#3-2-AbstractQueuedSynchronizer-Node-相关状态" class="headerlink" title="3.2. AbstractQueuedSynchronizer.Node 相关状态"></a>3.2. AbstractQueuedSynchronizer.Node 相关状态</h3><ol><li><code>0</code><ol><li>表示节点的初始状态</li></ol></li><li><code>1</code><ol><li>表示 <code>Thread</code> 实例可能因为阻塞超时、被中断后响应中断而结束阻塞</li><li>我们可以简单的理解为：节点已经结束等待了</li></ol></li><li><code>-1</code><ol><li>表示节点的后驱节点需要被唤醒</li><li>该状态是由后驱节点为该节点设置的，当该节点释放 <code>State</code> 时，需要负责唤醒后驱节点</li></ol></li><li><code>-2</code><ol><li>表示节点不在 <code>AQS</code> 的同步队列，而是在 <code>AQS</code> 的条件队列</li></ol></li><li><code>-3</code><ol><li>该状态仅用于共享模式的同步器，因为共享模式中可能会有多个线程同时尝试获取共享资源</li><li>当该节点被唤醒后，会继续唤醒后续节点。被唤醒的后续节点会再唤醒后续节点，形成 “级联唤醒”</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>这一套相关状态是在 <code>Java8</code> 下的相关状态，在 <code>Java17+</code> 发生了较大变化</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><br><span class="hljs-comment">// 表示该节点在 AQS 的同步队列中的前驱节点</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-comment">// 表示该节点在 AQS 的同步队列中的后驱节点</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">// 表示该节点封装的 Thread 实例</span><br>Thread waiter;<br><br><span class="hljs-comment">// 表示该节点的状态</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casPrev</span><span class="hljs-params">(Node c, Node v)</span> &#123;<br><span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, PREV, c, v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node c, Node v)</span> &#123;<br><span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, NEXT, c, v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUnsetStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br><span class="hljs-keyword">return</span> U.getAndBitwiseAndInt(<span class="hljs-built_in">this</span>, STATUS, ~v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrevRelaxed</span><span class="hljs-params">(Node p)</span> &#123;<br>U.putReference(<span class="hljs-built_in">this</span>, PREV, p);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatusRelaxed</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;<br>U.putInt(<span class="hljs-built_in">this</span>, STATUS, s);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearStatus</span><span class="hljs-params">()</span> &#123;<br>U.putIntOpaque(<span class="hljs-built_in">this</span>, STATUS, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">STATUS</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;status&quot;</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">NEXT</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;next&quot;</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">PREV</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;prev&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>方法的实现涉及到了 <code>Unsafe</code>，先不看</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.Condition 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Condition-概述"><a href="#3-1-Condition-概述" class="headerlink" title="3.1. Condition 概述"></a>3.1. Condition 概述</h3><p><code>Condition</code> 是一个接口</p><p>想象这样一个问题：<code>Monitor</code> 中只有一个等待队列（即 <code>WaitSet</code>）如果你有多个条件需要等待，你就无法精确控制唤醒哪一类等待者，因为他们都在同一个队列中等待</p><p>为了解决这一问题，我们可以创建多个 <code>Condition</code> 接口的具体实现类实例，每一个 <code>Condition</code> 接口的具体实现类就是一个队列</p><p><code>Condition + LockSupport</code> 相当于 <code>Object#wait</code>、<code>Object#notify</code> 的 <code>Plus</code> 版</p><p><code>Condition</code> 为我们提供了以下方法：</p><ol><li>让本地线程进入阻塞状态，<code>Thread</code> 示例进入 <code>WAITING</code> 状态</li><li>让本地线程进入限时阻塞状态，<code>Thread</code> 示例进入 <code>TIMED_WAITING</code> 状态</li><li>唤醒 AQS 的条件队列中的 “首个”  <code>Thread</code> 实例（非阻塞）</li><li>唤醒 AQS 的条件队列中的所有 <code>Thread</code> 实例（非阻塞）</li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 示例进入 WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 示例进入 WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，不能能响应中断。线程会继续阻塞，并会保留 Thread 示例的中断状态。当线程被唤醒后，会继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于让本地线程进入限时阻塞状态，Thread 示例进入 TIMED_WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时超时被允许的最长时间为：nanosTimeout ns</span><br><span class="hljs-comment">//     1. 如果超时，false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入限时阻塞状态，Thread 示例进入 TIMED_WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：time unit</span><br><span class="hljs-comment">//     1. 如果超时，返回 false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入限时阻塞状态，Thread 示例进入 TIMED_WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许到 deadline</span><br><span class="hljs-comment">//     1. 如果超时，返回 false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 AQS 的条件队列中的 “首个”  Thread 实例，被唤醒的 Thread 实例被直接投递到 AQS 的同步队列</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 所谓的 “首个” 是指：首个 Thread 实例可能因为阻塞超时、被中断后响应中断而结束阻塞，所以会依次向后查找，直到找到仍处于阻塞状态的 Thread 实例</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 AQS 的条件队列中的所有 Thread 实例，被唤醒的 Thread 实例被直接投递到 AQS 的同步队列</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-内置实现"><a href="#5-内置实现" class="headerlink" title="5. 内置实现"></a>5. 内置实现</h2><h3 id="5-1-ConditionObject"><a href="#5-1-ConditionObject" class="headerlink" title="5.1. ConditionObject"></a>5.1. ConditionObject</h3><p>详见源码：<code>AbstractQueuedSynchronizer.ConditionObject</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReentrantLock 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReentrantLock-概述"><a href="#3-1-ReentrantLock-概述" class="headerlink" title="3.1. ReentrantLock 概述"></a>3.1. ReentrantLock 概述</h3><p><code>ReentrantLock</code> 是一个具体类，实现了 <code>java.util.concurrent.locks.Lock</code>、<code>java.io.Serializable</code><br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ReentrantLock</code> 是一种可重入、悲观、公平或非公平、互斥的锁，并且是使用 <code>AQS</code> 实现的独占模式的同步器。<code>State</code> 和共享资源表示以下含义：</p><ol><li><code>State</code> 表示锁的重入次数<ol><li><code>0</code><ol><li>表示锁空闲，线程可以尝试获取</li></ol></li><li><code>1</code><ol><li>表示锁已被某个线程持有</li></ol></li><li><code>n（n &gt; 1）</code><ol><li>表示同一线程对该锁进行了 <code>n</code> 次重入</li></ol></li></ol></li><li>共享资源表示加锁期间的操作</li></ol><p><code>ReentrantLock</code> 功能类似于 <code>synchronized</code>，但更灵活、功能更强大，主要包括：</p><ol><li><code>ReentrantLock</code> 支持阻塞竞争锁、限时阻塞竞争锁、非阻塞竞争锁，而 <code>synchronized</code> 只支持阻塞竞争锁</li><li><code>ReentrantLock</code> 在阻塞竞争锁、限时阻塞竞争锁时能响应中断，而 <code>synchronized</code> 在阻塞竞争锁时不能响应中断</li><li><code>ReentrantLock</code> 既可以是公平锁，也可以是非公平锁，而 <code>synchronized</code> 只能是非公平锁</li><li><code>ReentrantLock</code> 支持多条条件队列，而 <code>synchronized</code> 只支持一条条件队列（即 <code>waitSet</code>，因为在语义上，<code>EntryList</code> 不属于条件队列）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Lock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Lock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>锁竞争激烈的场景，建议优先使用 <code>ReentrantLock</code>，因为它没有 “锁升级” 的额外开销：<ol><li><code>synchronized</code> 在偏向锁、轻量级锁时，效率的确很高</li><li>但是，一旦升级为重量级锁，就无法降级，而且在锁竞争激烈的场景下性能会受到影响</li></ol></li><li>如果你对并发机制掌握不深，建议优先使用 <code>synchronized</code>，因为它语法简洁、出错率低。但如果你需要更强的灵活性，并且熟悉并发编程，<code>ReentrantLock</code> 会更合适</li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Sync"><a href="#4-1-Sync" class="headerlink" title="4.1. Sync"></a>4.1. Sync</h3><p>详见源码：<code>ReentrantLock.Sync</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantLock.Sync源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol><hr><h3 id="4-2-NonfairSync"><a href="#4-2-NonfairSync" class="headerlink" title="4.2. NonfairSync"></a>4.2. NonfairSync</h3><p><code>NonfairSync</code> 用于实现非公平锁的加锁策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123; <br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span> &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-FairSync"><a href="#4-3-FairSync" class="headerlink" title="4.3. FairSync"></a>4.3. FairSync</h3><p><code>FairSync</code> 用于实现公平锁的加锁策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!hasQueuedThreads() &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-keyword">if</span> (++c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;<br>compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-ReentrantLock"><a href="#5-1-ReentrantLock" class="headerlink" title="5.1. ReentrantLock()"></a>5.1. ReentrantLock()</h3><p>该方法用于构造一个非公平锁的 &#96;ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br><br>sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-ReentrantLock-boolean-fair"><a href="#5-2-ReentrantLock-boolean-fair" class="headerlink" title="5.2. ReentrantLock(boolean fair)"></a>5.2. ReentrantLock(boolean fair)</h3><p>该方法构造一个公平锁或非公平锁的 <code>ReentrantLock</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br><br>sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h2><h3 id="6-1-实例具体方法"><a href="#6-1-实例具体方法" class="headerlink" title="6.1. 实例具体方法"></a>6.1. 实例具体方法</h3><h4 id="6-1-1-具体方法（实现）"><a href="#6-1-1-具体方法（实现）" class="headerlink" title="6.1.1. 具体方法（实现）"></a>6.1.1. 具体方法（实现）</h4><h5 id="6-1-1-1-Lock-中接口方法的实现"><a href="#6-1-1-1-Lock-中接口方法的实现" class="headerlink" title="6.1.1.1. Lock 中接口方法的实现"></a>6.1.1.1. Lock 中接口方法的实现</h5><h6 id="6-1-1-1-1-void-lock"><a href="#6-1-1-1-1-void-lock" class="headerlink" title="6.1.1.1.1. void lock()"></a>6.1.1.1.1. void lock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><br>sync.lock();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-2-void-lockInterruptibly"><a href="#6-1-1-1-2-void-lockInterruptibly" class="headerlink" title="6.1.1.1.2. void lockInterruptibly()"></a>6.1.1.1.2. void lockInterruptibly()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>sync.lockInterruptibly();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-3-boolean-tryLock"><a href="#6-1-1-1-3-boolean-tryLock" class="headerlink" title="6.1.1.1.3. boolean tryLock()"></a>6.1.1.1.3. boolean tryLock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> sync.tryLock();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-4-boolean-tryLock-long-timeout-TimeUnit-unit"><a href="#6-1-1-1-4-boolean-tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="6.1.1.1.4. boolean tryLock(long timeout, TimeUnit unit)"></a>6.1.1.1.4. boolean tryLock(long timeout, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br><span class="hljs-keyword">return</span> sync.tryLockNanos(unit.toNanos(timeout));<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-5-void-unlock"><a href="#6-1-1-1-5-void-unlock" class="headerlink" title="6.1.1.1.5. void unlock()"></a>6.1.1.1.5. void unlock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br><br>sync.release(<span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-6-Condition-newCondition"><a href="#6-1-1-1-6-Condition-newCondition" class="headerlink" title="6.1.1.1.6. Condition newCondition()"></a>6.1.1.1.6. Condition newCondition()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> sync.newCondition();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
