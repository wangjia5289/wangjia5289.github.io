<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>笔记：Netty 服务器</title>
    <link href="/2025/09/04/%E7%AC%94%E8%AE%B0%EF%BC%9ANetty%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2025/09/04/%E7%AC%94%E8%AE%B0%EF%BC%9ANetty%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>Netty 服务器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：ExecutorService 源码解析</title>
    <link href="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9AExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9AExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ExecutorService</code> 是一个接口，继承了 <code>Executor</code>，在 <code>Executor</code> 的基础上增加了任务生命周期管理的能力，同时扩展了任务提交、任务结果获取、任务批量执行等功能</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>Executor 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Executor源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br><br><span class="hljs-comment">// 有序关闭，已提交的任务会继续执行，但不会接收新的任务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 强制关闭，停止正在运行的任务，并且返回还没开始执行的任务列表</span><br>    List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 判断是否执行过 shutdown/shutdownNow</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 判断是否彻底终止</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 最多阻塞 timeout unit，看线程池是否彻底终止。如果当前线程被中断，抛出 InterruptedException</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 Callable 任务</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><br><span class="hljs-comment">// 提交 Runnable 任务，但是要手动指定一个固定结果</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><br><span class="hljs-comment">// 提交 Runnable 任务</span><br>    Future&lt;?&gt; submit(Runnable task);<br><br><span class="hljs-comment">// 提交一批 Callable 任务，等所有任务都执行完再统一返回结果列表。如果当前线程被中断，抛出 InterruptedException</span><br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交一批 Callable 任务，等所有任务都执行完再统一返回结果列表，最多阻塞 timeout unit，超时未完成的任务会取消。如果当前线程被中断，抛出 InterruptedException</span><br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                  <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交一批 Callable 任务，只要有一个成功完成，就立刻返回它的结果，并取消其他任务。如果当前线程被中断，抛出 InterruptedException。如果所有任务都执行失败，抛出 ExecutionException</span><br>    &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 提交一批 Callable 任务，只要有一个成功完成，就立刻返回它的结果，并取消其他任务，最多阻塞 timeout unit。如果当前线程被中断，抛出 InterruptedException。如果等待时间内所有任务都执行失败，抛出 ExecutionException。如果超时一个任务都未执行成功，抛出 TimeoutException</span><br>    &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                    <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：AbstractExecutorService源码解析</title>
    <link href="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>AbstractExecutorService</code> 是一个抽象类，实现了 <code>ExecutorService</code>，实现了 <code>ExecutorService</code> 中的大部分通用逻辑</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>ExecutorService 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ExecutorService源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><hr><h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h2><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *      1. protected</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟 + 子女特权</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，同包兄弟是做不成了，只能尝试类的内部方法或子女特权</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，同包兄弟是做不成了，只能尝试类的内部方法</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *      1. volatile</span><br><span class="hljs-comment"> *          1. 保证该属性的可见性和有序性</span><br><span class="hljs-comment"> *      1. transient</span><br><span class="hljs-comment"> *          1. 对象序列化时，忽略这个属性。反序列化之后，采用默认值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br> <br> <br> <span class="hljs-comment">// XXXXXXXXXXXXXXXXX</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><hr><h2 id="6-抽象方法"><a href="#6-抽象方法" class="headerlink" title="6. 抽象方法"></a>6. 抽象方法</h2><hr><h2 id="7-具体方法"><a href="#7-具体方法" class="headerlink" title="7. 具体方法"></a>7. 具体方法</h2><h3 id="7-1-具体方法（无）"><a href="#7-1-具体方法（无）" class="headerlink" title="7.1. 具体方法（无）"></a>7.1. 具体方法（无）</h3><h4 id="＜T＞-RunnableFuture＜T＞-newTaskFor-Callable＜T＞-callable"><a href="#＜T＞-RunnableFuture＜T＞-newTaskFor-Callable＜T＞-callable" class="headerlink" title="＜T＞ RunnableFuture＜T＞ newTaskFor(Callable＜T＞ callable)"></a>＜T＞ RunnableFuture＜T＞ newTaskFor(Callable＜T＞ callable)</h4><p><code>＜T＞ RunnableFuture＜T＞ newTaskFor(Callable＜T＞ callable)</code>  用于 将 <code>Callable</code> 包装成 <code>RunnableFuture</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br><br><span class="hljs-comment">// 将 Callable 包装成 RunnableFuture（FutureTask）</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="0-1-1-＜T＞-RunnableFuture＜T＞-newTaskFor-Runnable-runnable-T-value"><a href="#0-1-1-＜T＞-RunnableFuture＜T＞-newTaskFor-Runnable-runnable-T-value" class="headerlink" title="0.1.1. ＜T＞ RunnableFuture＜T＞ newTaskFor(Runnable runnable, T value)"></a>0.1.1. ＜T＞ RunnableFuture＜T＞ newTaskFor(Runnable runnable, T value)</h4><p><code>＜T＞ RunnableFuture＜T＞ newTaskFor(Runnable runnable, T value)</code> 用于 将 <code>Runnable</code> 包装成 <code>RunnableFuture</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br><br><span class="hljs-comment">// 将 Runnable 包装成 RunnableFuture（FutureTask）</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="＜T＞-T-doInvokeAny-Collection＜-extends-Callable＜T＞＞-tasks-boolean-timed-long-nanos"><a href="#＜T＞-T-doInvokeAny-Collection＜-extends-Callable＜T＞＞-tasks-boolean-timed-long-nanos" class="headerlink" title="＜T＞ T doInvokeAny(Collection＜? extends Callable＜T＞＞ tasks, boolean timed, long nanos)"></a>＜T＞ T doInvokeAny(Collection＜? extends Callable＜T＞＞ tasks, boolean timed, long nanos)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">doInvokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">  <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br><br><span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">ntasks</span> <span class="hljs-operator">=</span> tasks.size();<br><br><span class="hljs-keyword">if</span> (ntasks == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><br>ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(ntasks);<br><br>ExecutorCompletionService&lt;T&gt; ecs =<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorCompletionService</span>&lt;T&gt;(<span class="hljs-built_in">this</span>);<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">ExecutionException</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>Iterator&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; it = tasks.iterator();<br><br>futures.add(ecs.submit(it.next()));<br>--ntasks;<br><span class="hljs-type">int</span> <span class="hljs-variable">active</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>Future&lt;T&gt; f = ecs.poll();<br><span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (ntasks &gt; <span class="hljs-number">0</span>) &#123;<br>--ntasks;<br>futures.add(ecs.submit(it.next()));<br>++active;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (active == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>f = ecs.poll(nanos, NANOSECONDS);<br><span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>nanos = deadline - System.nanoTime();<br>&#125;<br><span class="hljs-keyword">else</span><br>f = ecs.take();<br>&#125;<br><span class="hljs-keyword">if</span> (f != <span class="hljs-literal">null</span>) &#123;<br>--active;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> f.get();<br>&#125; <span class="hljs-keyword">catch</span> (ExecutionException eex) &#123;<br>ee = eex;<br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException rex) &#123;<br>ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(rex);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ee == <span class="hljs-literal">null</span>)<br>ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>();<br><span class="hljs-keyword">throw</span> ee;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>cancelAll(futures);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-具体方法（重写）"><a href="#7-2-具体方法（重写）" class="headerlink" title="7.2. 具体方法（重写）"></a>7.2. 具体方法（重写）</h3><hr><h3 id="7-3-具体方法（实现）"><a href="#7-3-具体方法（实现）" class="headerlink" title="7.3. 具体方法（实现）"></a>7.3. 具体方法（实现）</h3><h4 id="0-1-1-ExecutorService-中的方法实现"><a href="#0-1-1-ExecutorService-中的方法实现" class="headerlink" title="0.1.1. ExecutorService 中的方法实现"></a>0.1.1. ExecutorService 中的方法实现</h4><h5 id="0-1-1-1-ExecutorService-源码解析"><a href="#0-1-1-1-ExecutorService-源码解析" class="headerlink" title="0.1.1.1. ExecutorService 源码解析"></a>0.1.1.1. ExecutorService 源码解析</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ExecutorService源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h5 id="0-1-1-2-＜T＞-Future＜T＞-submit-Callable＜T＞-task"><a href="#0-1-1-2-＜T＞-Future＜T＞-submit-Callable＜T＞-task" class="headerlink" title="0.1.1.2. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)"></a>0.1.1.2. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. Callable&lt;T&gt; task</span><br><span class="hljs-comment"> *          1. 要执行的任务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. task 包装成的 RunnableFuture</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. NullPointerException</span><br><span class="hljs-comment"> *          1. 传入 task 为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br><br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-comment">// 将 Callable 类型的 task 包装成 RunnableFuture</span><br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br><br><span class="hljs-comment">// 将任务交给线程池执行</span><br>execute(ftask);<br><br><span class="hljs-comment">// 返回包装好的 RunnableFuture</span><br><span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>所以 <code>AbstractExecutorService</code> 对于 <code>ExecutorService</code> 的 <code>submit</code> 的实现，本质上就是将 <code>Callable/Runnable</code> 封装成 <code>RunnableFuture</code>，然后 调用 <code>Executor</code> 的 <code>execute</code> 执行</li></ol></blockquote><hr><h5 id="Future＜-＞-submit-Runnable-task"><a href="#Future＜-＞-submit-Runnable-task" class="headerlink" title="Future＜?＞ submit(Runnable task)"></a>Future＜?＞ submit(Runnable task)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>execute(ftask);<br><span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="＜T＞-Future＜T＞-submit-Runnable-task-T-result"><a href="#＜T＞-Future＜T＞-submit-Runnable-task-T-result" class="headerlink" title="＜T＞ Future＜T＞ submit(Runnable task, T result)"></a>＜T＞ Future＜T＞ submit(Runnable task, T result)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>execute(ftask);<br><span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：ThreadPoolExecutor源码解析</title>
    <link href="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9AThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9AThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ThreadPoolExecutor</code> 是一个具体类，继承了 <code>AbstractExecutorService</code>，实现了线程池的核心执行逻辑，把抽象的调度框架变成了真正能跑的线程池</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>AbstractExecutorService 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AAbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：AbstractExecutorService源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><hr><h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h2><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *      1. protected</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟 + 子女特权</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，同包兄弟是做不成了，只能尝试类的内部方法或子女特权</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，同包兄弟是做不成了，只能尝试类的内部方法</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *      1. volatile</span><br><span class="hljs-comment"> *          1. 保证该属性的可见性和有序性</span><br><span class="hljs-comment"> *      1. transient</span><br><span class="hljs-comment"> *          1. 对象序列化时，忽略这个属性。反序列化之后，采用默认值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br> <br> <br> <span class="hljs-comment">// XXXXXXXXXXXXXXXXX</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><hr><h2 id="6-具体方法"><a href="#6-具体方法" class="headerlink" title="6. 具体方法"></a>6. 具体方法</h2><h3 id="6-1-具体方法（无）"><a href="#6-1-具体方法（无）" class="headerlink" title="6.1. 具体方法（无）"></a>6.1. 具体方法（无）</h3><h4 id="0-1-1-private-boolean-addWorker-Runnable-firstTask-boolean-core"><a href="#0-1-1-private-boolean-addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="0.1.1. private boolean addWorker(Runnable firstTask, boolean core)"></a>0.1.1. private boolean addWorker(Runnable firstTask, boolean core)</h4><p><code>private boolean addWorker(Runnable firstTask, boolean core)</code> 用于 尝试创建并启动一个新的 核心&#x2F;非核心 线程，把它加入线程池中，并立即执行 <code>Runnable</code> 任务</p><p>执行该 <code>Runnable</code> 任务后，该线程会进入循环，从工作队列里不断取任务继续执行，直到线程池关闭或线程被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *      1. protected</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟 + 子女特权</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，只能尝试子女特权</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，访问和操作是做不到了</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 子类不能重写该方法</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接调用该方法</span><br><span class="hljs-comment"> *      1. abstract</span><br><span class="hljs-comment"> *          1. 非抽象子类必须重写该方法</span><br><span class="hljs-comment"> *      1. default</span><br><span class="hljs-comment"> *          1. 接口方法的默认实现</span><br><span class="hljs-comment"> *      1. native</span><br><span class="hljs-comment"> *          1. 非 Java 语言实现的方法</span><br><span class="hljs-comment"> *      1. synchronized</span><br><span class="hljs-comment"> *          1. 方法加 synchronized 锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br><span class="hljs-comment">// 在 Java 中可以给循环或语句块起个 label，例如下面的 break retry 直接跳出带这个标签的循环，而不只是跳出 for (;;) 循环</span><br>retry:<br><span class="hljs-comment">// for 循环，不断获取最新的 ctl</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();;) &#123;<br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>&amp;&amp; (runStateAtLeast(c, STOP)<br>|| firstTask != <span class="hljs-literal">null</span><br>|| workQueue.isEmpty()))<br><span class="hljs-comment">// 拒绝添加 Worker，方法执行完毕</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">// 线程池通过比较当前工作线程总数与 corePoolSize 或 maximumPoolSize 来决定是否允许创建新线程（Doug Lea 并没有严格保证核心线程的数量）</span><br><span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))<br><span class="hljs-comment">// 如果大于，则拒绝添加 Worker，方法执行完毕</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 使用 CAS 尝试将 worker 加 1</span><br><span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br><span class="hljs-comment">// 加 1 失败，跳出 retry 大循环，执行下面创建线程的逻辑</span><br><span class="hljs-keyword">break</span> retry;<br><span class="hljs-comment">// 加 1 失败，重新获取 ctl</span><br>c = ctl.get();<br><span class="hljs-comment">// 如果线程池的状态变了</span><br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))<br><span class="hljs-comment">// 回到 retry 大循环，重新执行</span><br><span class="hljs-keyword">continue</span> retry;<br><span class="hljs-comment">// 如果线程池的状态没变，则只是计数冲突，回到 for(;;) 重新执行</span><br>&#125;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br><span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-keyword">if</span> (isRunning(c) ||<br>(runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br><span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>workers.add(w);<br>workerAdded = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br><span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>largestPoolSize = s;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br><span class="hljs-keyword">if</span> (workerAdded) &#123;<br>t.start();<br>workerStarted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (! workerStarted)<br>addWorkerFailed(w);<br>&#125;<br><span class="hljs-keyword">return</span> workerStarted;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><p>1. </p></blockquote><ol><li>XXXX 源码解析<ol><li>obsidian 内部链接：<br> 1. </li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol><h3 id="6-2-具体方法（重写）"><a href="#6-2-具体方法（重写）" class="headerlink" title="6.2. 具体方法（重写）"></a>6.2. 具体方法（重写）</h3><hr><h3 id="6-3-具体方法（实现）"><a href="#6-3-具体方法（实现）" class="headerlink" title="6.3. 具体方法（实现）"></a>6.3. 具体方法（实现）</h3><h4 id="0-1-1-Executor-中的方法实现"><a href="#0-1-1-Executor-中的方法实现" class="headerlink" title="0.1.1. Executor 中的方法实现"></a>0.1.1. Executor 中的方法实现</h4><h5 id="0-1-1-1-Executor-源码解析"><a href="#0-1-1-1-Executor-源码解析" class="headerlink" title="0.1.1.1. Executor 源码解析"></a>0.1.1.1. Executor 源码解析</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Executor源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h5 id="0-1-1-2-void-execute-Runnable-command"><a href="#0-1-1-2-void-execute-Runnable-command" class="headerlink" title="0.1.1.2. void execute(Runnable command)"></a>0.1.1.2. void execute(Runnable command)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br><span class="hljs-comment">// 如果 线程池现有线程数量 ＜ 核心线程数量，进入 if 代码块</span><br><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br><span class="hljs-comment">// 如果 尝试创建并启动一个新的 核心/非核心 线程，把它加入线程池中，并立即执行 Runnable 任务 成功，进入 if 代码块</span><br><span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 如果执行失败，重新获取 ctl</span><br>c = ctl.get();<br>&#125;<br><br><span class="hljs-comment">// 如果 线程池还在运行，则 将任务放到任务队列。如果 两 者都执行成功，进入 if 代码块</span><br><span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br><span class="hljs-comment">// 二次检查线程池的状态，因为线程池可能刚好在提交 Runnable 后关闭了</span><br><span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-comment">// 如果 线程池已关闭，则 移除 Runnable。如果 两 者都执行成功，进入 if 代码块</span><br><span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br><span class="hljs-comment">// 走拒绝执行 Runnable 流程</span><br>reject(command);<br><span class="hljs-comment">// 如果 线程池现有线程数量为 0，进入 else if 代码块</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 尝试创建并启动一个新的 非核心 线程，把它加入线程池中</span><br>addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 如果 尝试创建并启动一个新的 非核心 线程，把它加入线程池中，并立即执行 Runnable 任务 未成功，进入 else if 代码块</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br><span class="hljs-comment">// 走拒绝执行 Runnable 流程</span><br>reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>流程是：优先创建核心线程执行 Runnable ➔ 将任务放到任务队列 ➔ 创建一个非核心线程执行 Runnable ➔ 触发拒绝执行 Runnable 流程</li></ol></blockquote><hr><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ThreadPoolExecutor</code> 是一个具体类，是一个用来管理和复用一组线程来执行多个并发任务的工具</p><hr><h2 id="2-源码部分-1"><a href="#2-源码部分-1" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="private-final-class-Worker"><a href="#private-final-class-Worker" class="headerlink" title="private final class Worker"></a>private final class Worker</h3><p><code>Worker</code> 是 <code>ThreadPoolExecutor</code> 的 成员 内部类，在 <code>ThreadPoolExecutor</code> 里，每一个运行中的线程都对应一个 <code>Worker</code> 对象，相当于是个 线程包装器 + 控制锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br><span class="hljs-comment">// 这个类永远不会被序列化，只是为了消除 javac 警告而写了一个 serialVersionUID</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br><span class="hljs-comment">/** Thread this worker is running in.  Null if factory fails. */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="hljs-comment">// Unlikely to be serializable</span><br><span class="hljs-keyword">final</span> Thread thread;<br><span class="hljs-comment">/** Initial task to run.  Possibly null. */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="hljs-comment">// Not statically typed as Serializable</span><br>Runnable firstTask;<br><span class="hljs-comment">/** Per-thread task counter */</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> switch to AbstractQueuedLongSynchronizer and move</span><br><span class="hljs-comment">// completedTasks into the lock word.</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment"> */</span><br>Worker(Runnable firstTask) &#123;<br>setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br><span class="hljs-built_in">this</span>.firstTask = firstTask;<br><span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">/** Delegates main run loop to outer runWorker. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>runWorker(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// Lock methods</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The value 0 represents the unlocked state.</span><br><span class="hljs-comment">// The value 1 represents the locked state.</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>setState(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>Thread t;<br><span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.interrupt();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int COUNT_MASK</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 表示线程池的状态和工作线程的个数</span><br><span class="hljs-comment"> *      </span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. 线程池的状态为 RUNNING，工作线程为 0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ctl 是一个 int 类型的变量，共有 32 bit，其中高 3 bit 表示线程池的个数，低 29 bit 表示工作线程的个数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><br><span class="hljs-comment">// 保存线程池个数的位数（低 bit）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int COUNT_MASK</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 保存线程池状态的位数（高 bit）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. (1 &lt;&lt; COUNT_BITS) - 1</span><br><span class="hljs-comment"> *      2. 即 00011111 11111111 11111111 11111111</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 的二进制：</span><br><span class="hljs-comment"> * 00000000 00000000 00000000 00000001</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1  &lt;&lt; 29：</span><br><span class="hljs-comment"> * 把二进制数整体往左挪 29 位，左边溢出的丢掉，右边空出来的补零</span><br><span class="hljs-comment"> * 00100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (1 &lt;&lt; 29) - 1：</span><br><span class="hljs-comment"> * 00011111 11111111 11111111 11111111</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int RUNNING</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 线程池的 RUNNING 状态</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. -1 &lt;&lt; COUNT_BITS</span><br><span class="hljs-comment"> *      2. 即 11100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * -1 的二进制：</span><br><span class="hljs-comment"> * 11111111 11111111 11111111 11111111</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * -1 &lt;&lt; 29：</span><br><span class="hljs-comment"> * 11100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><br><span class="hljs-comment">// 线程池的 SHUTDOWN 状态（000）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><br><span class="hljs-comment">// 线程池的 STOP 状态（001）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><br><span class="hljs-comment">// 线程池的 TIDYING 状态（010）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><br><span class="hljs-comment">// 线程池的 TERMINATED 状态（011）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><hr><h2 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h2><h3 id="public-ThreadPoolExecutor-int-corePoolSize-int-maximumPoolSize-long-keepAliveTime-TimeUnit-unit-BlockingQueue＜Runnable＞-workQueue-ThreadFactory-threadFactory-RejectedExecutionHandler-handler"><a href="#public-ThreadPoolExecutor-int-corePoolSize-int-maximumPoolSize-long-keepAliveTime-TimeUnit-unit-BlockingQueue＜Runnable＞-workQueue-ThreadFactory-threadFactory-RejectedExecutionHandler-handler" class="headerlink" title="public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue＜Runnable＞ workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)"></a>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue＜Runnable＞ workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</h3><p><code>ThreadPoolExecutor</code> 虽然提供了 4 中构造方法，但是本质上都还是调用了这一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：public ThreadPoolExecutor(int corePoolSize,</span><br><span class="hljs-comment"> *                                   int maximumPoolSize,</span><br><span class="hljs-comment"> *                                   long keepAliveTime,</span><br><span class="hljs-comment"> *                                   TimeUnit unit,</span><br><span class="hljs-comment"> *                                   BlockingQueue＜Runnable＞ workQueue,</span><br><span class="hljs-comment"> *                                   ThreadFactory threadFactory,</span><br><span class="hljs-comment"> *                                   RejectedExecutionHandler handler)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. int corePoolSize</span><br><span class="hljs-comment"> *          1. 核心工作线程数量，任务执行结束后，不会被销毁</span><br><span class="hljs-comment"> *      2. int maximumPoolSize</span><br><span class="hljs-comment"> *          1. 最大工作线程数量</span><br><span class="hljs-comment"> *          2. 最大工作线程数量 = 核心工作线程数量 + 超时销毁的非核心工作线程数量</span><br><span class="hljs-comment"> *      3. long keepAliveTime</span><br><span class="hljs-comment"> *          1. 非核心工作线程等待 keepAliveTime 时间</span><br><span class="hljs-comment"> *      4. TimeUnit unit</span><br><span class="hljs-comment"> *          1. keepAliveTime 的单位</span><br><span class="hljs-comment"> *      5. BlockingQueue＜Runnable＞ workQueue</span><br><span class="hljs-comment"> *          1. 任务在没有核心工作线程处理时，先投递到那个阻塞队列中</span><br><span class="hljs-comment"> *      6. ThreadFactory threadFactory</span><br><span class="hljs-comment"> *          1. 构建 Thread 的线程工厂</span><br><span class="hljs-comment"> *      7. RejectedExecutionHandler handler</span><br><span class="hljs-comment"> *          1. 线程池无法处理投递过来的任务时，执行那个拒绝策略</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. IllegalArgumentException</span><br><span class="hljs-comment"> *      2. NullPointerException</span><br><span class="hljs-comment"> *      3. 拒绝策略抛出的异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 核心工作线程数量可以为 0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 使用实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="hljs-comment"> *     2,</span><br><span class="hljs-comment"> *     4,</span><br><span class="hljs-comment"> *     10,</span><br><span class="hljs-comment"> *     TimeUnit.SECONDS,</span><br><span class="hljs-comment"> *     new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="hljs-comment"> *     new ThreadFactory() &#123;</span><br><span class="hljs-comment"> *         private int count = 1;</span><br><span class="hljs-comment"> *         public Thread newThread(Runnable r) &#123;</span><br><span class="hljs-comment"> *             return new Thread(r, &quot;Worker-&quot; + count++);</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *     &#125;,</span><br><span class="hljs-comment"> *     new ThreadPoolExecutor.AbortPolicy()</span><br><span class="hljs-comment"> * );</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">  <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">  <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">  TimeUnit unit,</span><br><span class="hljs-params">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">  ThreadFactory threadFactory,</span><br><span class="hljs-params">  RejectedExecutionHandler handler)</span> &#123;<br><span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt; corePoolSize ||<br>keepAliveTime &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br><span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br><span class="hljs-built_in">this</span>.workQueue = workQueue;<br><span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br><span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br><span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>RejectedExecutionHandler 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ARejectedExecutionHandler%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：RejectedExecutionHandler 源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="5-接口方法"><a href="#5-接口方法" class="headerlink" title="5. 接口方法"></a>5. 接口方法</h2><h3 id="5-1-接口方法（无）"><a href="#5-1-接口方法（无）" class="headerlink" title="5.1. 接口方法（无）"></a>5.1. 接口方法（无）</h3><hr><h3 id="5-2-接口方法（default）"><a href="#5-2-接口方法（default）" class="headerlink" title="5.2. 接口方法（default）"></a>5.2. 接口方法（default）</h3><hr><h3 id="5-3-接口方法（default-重写）"><a href="#5-3-接口方法（default-重写）" class="headerlink" title="5.3. 接口方法（default 重写）"></a>5.3. 接口方法（default 重写）</h3><hr><h2 id="6-具体方法-1"><a href="#6-具体方法-1" class="headerlink" title="6. 具体方法"></a>6. 具体方法</h2><h3 id="6-1-具体方法（无）-1"><a href="#6-1-具体方法（无）-1" class="headerlink" title="6.1. 具体方法（无）"></a>6.1. 具体方法（无）</h3><h4 id="private-boolean-addWorker-Runnable-firstTask-boolean-core"><a href="#private-boolean-addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="private boolean addWorker(Runnable firstTask, boolean core)"></a>private boolean addWorker(Runnable firstTask, boolean core)</h4><p>该方法负责向线程池中添加一个新的工作线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br><br>retry:<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();;) &#123;<br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>&amp;&amp; (runStateAtLeast(c, STOP)<br>|| firstTask != <span class="hljs-literal">null</span><br>|| workQueue.isEmpty()))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br><span class="hljs-keyword">break</span> retry;<br>c = ctl.get();<br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))<br><span class="hljs-keyword">continue</span> retry;<br>&#125;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br><span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-keyword">if</span> (isRunning(c) ||<br>(runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br><span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>workers.add(w);<br>workerAdded = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br><span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>largestPoolSize = s;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br><span class="hljs-keyword">if</span> (workerAdded) &#123;<br>t.start();<br>workerStarted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (! workerStarted)<br>addWorkerFailed(w);<br>&#125;<br><span class="hljs-keyword">return</span> workerStarted;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-2-具体方法（重写）-1"><a href="#6-2-具体方法（重写）-1" class="headerlink" title="6.2. 具体方法（重写）"></a>6.2. 具体方法（重写）</h3><hr><h3 id="6-3-具体方法（实现）-1"><a href="#6-3-具体方法（实现）-1" class="headerlink" title="6.3. 具体方法（实现）"></a>6.3. 具体方法（实现）</h3><h4 id="Executor-中方法实现"><a href="#Executor-中方法实现" class="headerlink" title="Executor 中方法实现"></a>Executor 中方法实现</h4><h5 id="public-void-execute-Runnable-command"><a href="#public-void-execute-Runnable-command" class="headerlink" title="public void execute(Runnable command)"></a>public void execute(Runnable command)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><br><span class="hljs-comment">// 任务不能为 null</span><br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-comment">// 获取核心属性 ctl</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br><span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br><span class="hljs-keyword">return</span>;<br>c = ctl.get();<br>&#125;<br><br><span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>reject(command);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>reject(command);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：AbstractOwnableSynchronizer源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">3737899427754241961L</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：protected AbstractOwnableSynchronizer()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. protected</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟 + 子女特权</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，只能尝试子女特权</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 构造一个 AbstractOwnableSynchronizer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 抽象类不能直接 new，但这并不意味着抽象类不能拥有自己的构造方法</span><br><span class="hljs-comment"> *      2. 毕竟子类在继承抽象类时，实例化过程一定会调用父类构造方法。要是抽象类没有构造方法，那岂不是 “子类无门可走” ？</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private transient Thread exclusiveOwnerThread</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 只能使用类内部的方法才能访问和操作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. transient</span><br><span class="hljs-comment"> *          1. 对象序列化时，忽略这个属性。反序列化后，会采用默认值</span><br><span class="hljs-comment"> *          2. 这是因为线程对象跟 JVM 运行状况紧密相关，无法序列化</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 表示当前独占资源的线程</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 具体方法：protected final void setExclusiveOwnerThread(Thread thread)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. protected</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟 + 子女特权</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，只能尝试子女特权</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 子类不能重写该方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. Thread thread</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. void</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 设置哪个线程现在拥有独占资源</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> &#123;<br>exclusiveOwnerThread = thread;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 具体方法：protected final Thread getExclusiveOwnerThread()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. protected</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟 + 子女特权</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，只能尝试子女特权</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 子类不能重写该方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 获取拥有独占资源的线程</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>AbstractOwnableSynchronizer</code> 是一个接口，记录当前独占同步器资源的线程</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然 AQS 继承了 AOS，如果基于 AQS 的实现是独占模式同步器（例如 ReentrantLock），就需要记录当前独占同步器资源的线程。但是如果基于 AQS 的实现是共享模式同步器（例如 Semaphore），那 AOS 根本就用不到。</li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><hr><h3 id="3-2-接口方法（default）"><a href="#3-2-接口方法（default）" class="headerlink" title="3.2. 接口方法（default）"></a>3.2. 接口方法（default）</h3><hr><h3 id="3-3-接口方法（default-重写）"><a href="#3-3-接口方法（default-重写）" class="headerlink" title="3.3. 接口方法（default 重写）"></a>3.3. 接口方法（default 重写）</h3><hr><h2 id="4-实现示例"><a href="#4-实现示例" class="headerlink" title="4. 实现示例"></a>4. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><hr><h2 id="5-内置实现"><a href="#5-内置实现" class="headerlink" title="5. 内置实现"></a>5. 内置实现</h2><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Callable源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9ACallable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9ACallable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>Callable</code> 是一个接口，可以用来定义一个可以被线程执行的任务，该任务可以有带返回值，并且可以抛异常的 <code>V call()</code> 方法</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Callable</code> 通常会和 <code>Future&lt;B&gt;</code> 搭配使用。前者定义任务逻辑，后者用来查询执行状态和获取结果。</li><li>但是，由于 <code>Thread</code> 的构造方法只接收 <code>Runnable</code> 类型的任务对象，因此 <code>Callable</code> 不能像 <code>Runnable</code> 那样被直接传递给 <code>Thread</code> 来运行。</li><li>于是就引出了 <code>FutureTask&lt;V&gt;</code>。它既实现了 <code>Runnable</code>，又实现了 <code>Future&lt;V&gt;</code>，还能把<code>Runnable</code>&#x2F;<code>Callable</code> 以参数的形式包装起来。<ol><li>解决了 <code>Callable</code> 不能被 <code>Thread</code> 直接执行的问题</li><li>既能够使用 <code>Runnable</code>&#x2F;<code>Callable</code> 定义任务逻辑，也能够使用 <code>Future&lt;V&gt;</code> 查询 <code>Callable</code> 的执行状态和获取结果</li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br><br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-call-throws-Exception"><a href="#3-1-1-call-throws-Exception" class="headerlink" title="3.1.1. call() throws Exception"></a>3.1.1. call() throws Exception</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>V call() throws Exception</code> 是一个接口方法，必须由具体的实现类进行实现，用于 定义任务执行的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-1-2-方法实现"><a href="#3-1-1-2-方法实现" class="headerlink" title="3.1.1.2. 方法实现"></a>3.1.1.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 lambda，创建实现 Callable 接口的匿名内部类</span><br>Callable&lt;String&gt; task = () -&gt; &#123;<br><span class="hljs-comment">// 要执行的任务的逻辑</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Future＜V＞源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9AFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9AFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>Future&lt;V&gt;</code> 是一个接口，表示一个异步计算的结果</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-boolean-cancel-boolean-mayInterruptIfRunning"><a href="#3-1-1-boolean-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="3.1.1. boolean cancel(boolean mayInterruptIfRunning)"></a>3.1.1. boolean cancel(boolean mayInterruptIfRunning)</h4><p><code>boolean cancel(boolean mayInterruptIfRunning)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 取消正在执行&#x2F;还未执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-2-boolean-isCancelled"><a href="#3-1-2-boolean-isCancelled" class="headerlink" title="3.1.2. boolean isCancelled()"></a>3.1.2. boolean isCancelled()</h4><p><code>boolean isCancelled()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 检查当前任务是否被取消</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-3-boolean-isDone"><a href="#3-1-3-boolean-isDone" class="headerlink" title="3.1.3. boolean isDone()"></a>3.1.3. boolean isDone()</h4><p><code>boolean isDone()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 检查当前任务是否已经完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-4-get"><a href="#3-1-4-get" class="headerlink" title="3.1.4. get()"></a>3.1.4. get()</h4><p><code>V get()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 返回计算结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-5-get-long-timeout-TimeUnit-unit"><a href="#3-1-5-get-long-timeout-TimeUnit-unit" class="headerlink" title="3.1.5. get(long timeout, TimeUnit unit)"></a>3.1.5. get(long timeout, TimeUnit unit)</h4><p><code>V get(long timeout, TimeUnit unit)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 在 timeout unit 时间内返回计算结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="4-实现示例"><a href="#4-实现示例" class="headerlink" title="4. 实现示例"></a>4. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFuture</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> V result;<br>    <br>    <span class="hljs-keyword">private</span> Exception exception;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isDone</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isCancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">// 模拟异步执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyFuture</span><span class="hljs-params">(Callable&lt;V&gt; task)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">V</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> task.call();<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    result = res;<br>                    isDone = <span class="hljs-literal">true</span>;<br>                    lock.notifyAll(); <span class="hljs-comment">// 通知等待的线程</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    exception = e;<br>                    isDone = <span class="hljs-literal">true</span>;<br>                    lock.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>        <span class="hljs-comment">// 为简单起见，这里不真正中断线程</span><br>        <span class="hljs-keyword">if</span> (isDone) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        isCancelled = <span class="hljs-literal">true</span>;<br>        isDone = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            lock.notifyAll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> isCancelled;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> isDone;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (!isDone) &#123;<br>                lock.wait(); <span class="hljs-comment">// 等待任务完成</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isCancelled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(exception);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis() + unit.toMillis(timeout);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (!isDone &amp;&amp; System.currentTimeMillis() &lt; end) &#123;<br>                lock.wait(unit.toMillis(timeout));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isDone) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>(<span class="hljs-string">&quot;任务超时啦！&quot;</span>);<br>        <span class="hljs-keyword">if</span> (isCancelled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(exception);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Runnable源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9ARunnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9ARunnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Runnable 是一个接口，用来定义一个可以被线程执行的任务</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 JUC 编程中，线程执行的任务通常通过 Runnable 或 Callable 来定义</li><li><code>Runnable</code> 在 Java 1.0 就出现了，但是 <code>Runnable</code> 既不能抛出受检异常，也没有返回值，调用了就感觉进入了一个黑盒子，没有一点反馈，所以在 Java 5 开始引入了 <code>Callable</code></li><li>Callable 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ACallable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Callable源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-public-abstract-void-run"><a href="#3-1-1-public-abstract-void-run" class="headerlink" title="3.1.1. public abstract void run()"></a>3.1.1. public abstract void run()</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>public abstract void run()</code> 是一个接口方法，必须由具体的实现类进行实现，用于 定义线程执行的任务的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>接口方法却写 <code>abstract</code> 非访问修饰符，这是早期遗留的写法和部分人的编码习惯</li></ol></blockquote><hr><h5 id="3-1-1-2-方法实现"><a href="#3-1-1-2-方法实现" class="headerlink" title="3.1.1.2. 方法实现"></a>3.1.1.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 lambda 表达式，创建实现 Runnable 接口的匿名内部类</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br><span class="hljs-comment">// 要执行的任务的逻辑</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Sync 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9ASync%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9ASync%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>Sync</code> 是一个抽象类，是 <code>ReentrantLock</code> 的 静态 内部类，继承了 <code>AbstractQueuedSynchronizer</code>，基于 <code>AQS</code> 封装了 <code>ReentrantLock</code> 的加锁&#x2F;解锁核心逻辑（使用了模板方法模式）</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5179523762034025860L</span>;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-keyword">if</span> (++c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!initialTryLock())<br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-keyword">if</span> (!initialTryLock())<br>acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLockNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-keyword">return</span> initialTryLock() || tryAcquireNanos(<span class="hljs-number">1</span>, nanos);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br><span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> (c == <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (free)<br>setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>&#125;<br><br><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>&#125;<br><br><span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getOwner</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : getExclusiveOwnerThread();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHoldCount</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> isHeldExclusively() ? getState() : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>s.defaultReadObject();<br>setState(<span class="hljs-number">0</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h2><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *      1. protected</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟 + 子女特权</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，同包兄弟是做不成了，只能尝试类的内部方法或子女特权</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，同包兄弟是做不成了，只能尝试类的内部方法</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *      1. volatile</span><br><span class="hljs-comment"> *          1. 保证该属性的可见性和有序性</span><br><span class="hljs-comment"> *      1. transient</span><br><span class="hljs-comment"> *          1. 对象序列化时，忽略这个属性。反序列化之后，采用默认值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br> <br> <br> <span class="hljs-comment">// XXXXXXXXXXXXXXXXX</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><hr><h2 id="6-抽象方法"><a href="#6-抽象方法" class="headerlink" title="6. 抽象方法"></a>6. 抽象方法</h2><h3 id="abstract-boolean-initialTryLock"><a href="#abstract-boolean-initialTryLock" class="headerlink" title="abstract boolean initialTryLock()"></a>abstract boolean initialTryLock()</h3><p><code>abstract boolean initialTryLock()</code> 是一个抽象方法，必须由具体的实现类进行重写，用于 XXXX</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h2 id="7-具体方法"><a href="#7-具体方法" class="headerlink" title="7. 具体方法"></a>7. 具体方法</h2><h3 id="7-1-具体方法（无）"><a href="#7-1-具体方法（无）" class="headerlink" title="7.1. 具体方法（无）"></a>7.1. 具体方法（无）</h3><h4 id="0-1-1-final-void-lock"><a href="#0-1-1-final-void-lock" class="headerlink" title="0.1.1. final void lock()"></a>0.1.1. final void lock()</h4><p><code>final void lock()</code> 用于 XXXX</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 initialTryLock，如果加锁失败，进入 if 逻辑。</span><br><span class="hljs-comment"> * 由于 initialTryLock 是抽象方法，显然使用了模板方法模式，由实现类进行重写</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!initialTryLock())<br><span class="hljs-comment">// 调用 Sync 的父类 AQS 的 acquire 把当前线程包装成一个 Node，然后将该节点链接到同步队列（双向链表）中，然后不断尝试获取锁</span><br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="0-1-1-final-void-lockInterruptibly"><a href="#0-1-1-final-void-lockInterruptibly" class="headerlink" title="0.1.1. final void lockInterruptibly()"></a>0.1.1. final void lockInterruptibly()</h4><p><code>final void lockInterruptibly()</code> 和 <code>final void lock()</code> 类似，只不过 XXXX，用于 XXXX</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-keyword">if</span> (!initialTryLock())<br>acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-具体方法（重写）"><a href="#7-2-具体方法（重写）" class="headerlink" title="7.2. 具体方法（重写）"></a>7.2. 具体方法（重写）</h3><hr><h3 id="7-3-具体方法（实现）"><a href="#7-3-具体方法（实现）" class="headerlink" title="7.3. 具体方法（实现）"></a>7.3. 具体方法（实现）</h3><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：AbstractQueuedSynchronizer源码解析</title>
    <link href="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>AbstractQueuedSynchronizer</code> 是一个抽象类，继承了 <code>AbstractOwnableSynchronizer</code>，实现了 <code>Serializable</code>，是一个同步器框架，用来构建锁和其他同步器。</p><p>AQS 的核心属性是一个 <code>state</code> 字段，线程对同步器资源的竞争，本质上就是对这个 <code>state</code> 的修改尝试。不同的同步器对 <code>state</code> 的定义不同，例如在 <strong>ReentrantLock</strong> 中，<code>state</code> 表示锁的重入次数：</p><ol><li>0<ol><li>表示锁空闲，线程可以尝试获取。</li></ol></li><li>1<ol><li>表示锁已被某个线程持有</li></ol></li><li>n &gt; 1<ol><li>表示同一线程对该锁进行了 n 次重入</li></ol></li></ol><p>在基于 AQS 的同步器实现里，会维护：</p><ol><li>一条同步队列<ol><li>用于管理所有尝试获取同步器资源但暂时失败的线程节点</li></ol></li><li>多条条件队列<ol><li>每个 <code>Condition</code> 对象都会对应一条，用于管理那些因为等待特定条件而暂时挂起的线程节点</li></ol></li></ol><p><img src="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt="|1050x580"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>AbstractOwnableSynchronizer 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AAbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：AbstractOwnableSynchronizer源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>虽然 AQS 继承了 AOS，如果基于 AQS 实现的是独占模式同步器（例如 ReentrantLock），就需要记录当前独占同步器资源的线程。但是如果基于 AQS 实现的是共享模式同步器（例如 Semaphore），那 AOS 根本就用不到。</li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><hr><h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p><code>Node</code> 是 AQS 的 静态 内部类</p><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ANode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Node源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h3 id="ExclusiveNode"><a href="#ExclusiveNode" class="headerlink" title="ExclusiveNode"></a>ExclusiveNode</h3><p><code>ExclusiveNode</code> 是 AQS 的 静态 内部类，它只是简单地继承了 <code>Node</code>，为 <code>Node</code> 增加了一层 “独占模式节点” 的标签，用来明确区分节点所处的语义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果基于 AQS 实现的是独占模式同步器（例如 ReentrantLock），那么同步队列中的 Node 就应该是 ExclusiveNode</li></ol></blockquote><hr><h3 id="SharedNode"><a href="#SharedNode" class="headerlink" title="SharedNode"></a>SharedNode</h3><p><code>SharedNode</code> 是 AQS 的 静态 内部类，它只是简单地继承了 <code>Node</code>，为 <code>Node</code> 增加了一层 “共享模式节点” 的标签，用来明确区分节点所处的语义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果基于 AQS 实现的是共享模式同步器（例如 Semaphore），那么同步队列中的 Node 就应该是 SharedNode</li></ol></blockquote><hr><h3 id="ConditionNode"><a href="#ConditionNode" class="headerlink" title="ConditionNode"></a>ConditionNode</h3><p><code>ConditionNode</code> 是 AQS 的 静态 内部类</p><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ConditionNode源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p><code>ConditionObject</code> 是 AQS 的 成员 内部类</p><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ConditionObject源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 中维护的同步队列的首尾指针</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><br><span class="hljs-comment">// 同步器的核心状态位，在 AQS 中，所谓的抢同步器资源抢的就是这个 state，在不同的实现有不同的含义</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * WAITING、CANCELLED、COND 都是标记在 Node 的 Status 上的状态标识符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * WAITING 表示节点正在正常获取锁（同步队列）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * COND 表示节点在条件队列中，正在等待 Condition 的 signal（条件队列）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * CANCELLED 表示节点已经被取消（同步队列、条件队列）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x80000000</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COND</span>      <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="protected-AbstractQueuedSynchronizer"><a href="#protected-AbstractQueuedSynchronizer" class="headerlink" title="protected AbstractQueuedSynchronizer()"></a>protected AbstractQueuedSynchronizer()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractQueuedSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-抽象方法"><a href="#6-抽象方法" class="headerlink" title="6. 抽象方法"></a>6. 抽象方法</h2><hr><h2 id="7-具体方法"><a href="#7-具体方法" class="headerlink" title="7. 具体方法"></a>7. 具体方法</h2><h3 id="7-1-具体方法（无）"><a href="#7-1-具体方法（无）" class="headerlink" title="7.1. 具体方法（无）"></a>7.1. 具体方法（无）</h3><h4 id="0-1-1-final-int-acquire-Node-node-int-arg-boolean-shared-boolean-interruptible-boolean-timed-long-time"><a href="#0-1-1-final-int-acquire-Node-node-int-arg-boolean-shared-boolean-interruptible-boolean-timed-long-time" class="headerlink" title="0.1.1. final int acquire(Node node, int arg, boolean shared, boolean interruptible, boolean timed, long time)"></a>0.1.1. final int acquire(Node node, int arg, boolean shared, boolean interruptible, boolean timed, long time)</h4><p><code>final int acquire(Node node, int arg, boolean shared, boolean interruptible, boolean timed, long time)</code> 用于 把当前线程包装成一个 Node，然后将该节点链接到同步队列（双向链表）中，然后不断尝试获取锁</p><p>需要注意的是，如果节点已经被链接到同步队列上，则不重复进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 子类不能重写该方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. Node node</span><br><span class="hljs-comment"> *          1. 当前线程在同步队列里的节点</span><br><span class="hljs-comment"> *          2. 可以为 null，会自动创建</span><br><span class="hljs-comment"> *      2. int arg</span><br><span class="hljs-comment"> *          1. 申请锁时使用的参数</span><br><span class="hljs-comment"> *          2. 独占锁为 1</span><br><span class="hljs-comment"> *          3. 共享锁为 n</span><br><span class="hljs-comment"> *      3. boolean shared</span><br><span class="hljs-comment"> *          1. 是否共享模式</span><br><span class="hljs-comment"> *          2. true</span><br><span class="hljs-comment"> *              1. 共享模式</span><br><span class="hljs-comment"> *          3. false</span><br><span class="hljs-comment"> *              1. 非共享模式</span><br><span class="hljs-comment"> *      4. boolean interruptible</span><br><span class="hljs-comment"> *          1. 是否允许中断</span><br><span class="hljs-comment"> *          1. true</span><br><span class="hljs-comment"> *              1. 允许中断</span><br><span class="hljs-comment"> *          2. false</span><br><span class="hljs-comment"> *              1. 不允许中断</span><br><span class="hljs-comment"> *      5. boolean timed</span><br><span class="hljs-comment"> *          1. 是否限时</span><br><span class="hljs-comment"> *          2. true</span><br><span class="hljs-comment"> *              1. 限时</span><br><span class="hljs-comment"> *          3. false</span><br><span class="hljs-comment"> *              1. 不限时</span><br><span class="hljs-comment"> *      6. long time</span><br><span class="hljs-comment"> *          1. 限时 time 纳秒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> arg, <span class="hljs-type">boolean</span> shared, <span class="hljs-type">boolean</span> interruptible, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> time)</span> &#123;<br>  <br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br><span class="hljs-type">byte</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, postSpins = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, first = <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : node.prev) != <span class="hljs-literal">null</span> &amp;&amp;<br>!(first = (head == pred))) &#123;<br><span class="hljs-keyword">if</span> (pred.status &lt; <span class="hljs-number">0</span>) &#123;<br>cleanQueue();<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred.prev == <span class="hljs-literal">null</span>) &#123;<br>Thread.onSpinWait();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (first || pred == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">boolean</span> acquired;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (shared)<br>acquired = (tryAcquireShared(arg) &gt;= <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br>acquired = tryAcquire(arg);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>cancelAcquire(node, interrupted, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">if</span> (acquired) &#123;<br><span class="hljs-keyword">if</span> (first) &#123;<br>node.prev = <span class="hljs-literal">null</span>;<br>head = node;<br>pred.next = <span class="hljs-literal">null</span>;<br>node.waiter = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (shared)<br>signalNextIfShared(node);<br><span class="hljs-keyword">if</span> (interrupted)<br>current.interrupt();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (shared)<br>node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedNode</span>();<br><span class="hljs-keyword">else</span><br>node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExclusiveNode</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>) &#123;<br>node.waiter = current;<br><span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>node.setPrevRelaxed(t);<br><span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>tryInitializeHead();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!casTail(t, node))<br>node.setPrevRelaxed(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">else</span><br>t.next = node;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first &amp;&amp; spins != <span class="hljs-number">0</span>) &#123;<br>--spins;<br>Thread.onSpinWait();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.status == <span class="hljs-number">0</span>) &#123;<br>node.status = WAITING;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">long</span> nanos;<br>spins = postSpins = (<span class="hljs-type">byte</span>)((postSpins &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!timed)<br>LockSupport.park(<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="hljs-number">0L</span>)<br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">break</span>;<br>node.clearStatus();<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cancelAcquire(node, interrupted, interruptible);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="7-2-具体方法（重写）"><a href="#7-2-具体方法（重写）" class="headerlink" title="7.2. 具体方法（重写）"></a>7.2. 具体方法（重写）</h3><hr><h3 id="7-3-具体方法（实现）"><a href="#7-3-具体方法（实现）" class="headerlink" title="7.3. 具体方法（实现）"></a>7.3. 具体方法（实现）</h3><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：LockSupport 源码解析</title>
    <link href="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9ALockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9ALockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>LockSupport</code> 是一个具体类，是整个 AQS 阻塞&#x2F;唤醒机制的基石，几乎所有同步器的 “挂起线程&#x2F;唤醒线程” 都是靠它完成的。</p><p>之所以不使用 <code>Object</code> 的 <code>wait</code>&#x2F;<code>notify</code>&#x2F;<code>notifyAll</code>，是因为在 <code>Object</code> 中，这些方法必须在 <code>synchronized</code> 块里调用，因为调用线程必须持有该对象的锁</p><p>而 <code>LockSupport</code> 没这个限制，任何线程在任何地方都能 <code>park()</code>&#x2F;<code>unpark()</code>，这让 AQS（同步器）不需要依赖 <code>synchronized</code>，而是用 <code>CAS + LockSupport</code> 就能造出高性能的同步器。</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LockSupport</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlocker</span><span class="hljs-params">(Thread t, Object arg)</span> &#123;<br>        U.putReferenceOpaque(t, PARKBLOCKER, arg);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentBlocker</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        U.putReferenceOpaque(Thread.currentThread(), PARKBLOCKER, blocker);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            U.unpark(thread);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            setBlocker(t, blocker);<br>            U.park(<span class="hljs-literal">false</span>, nanos);<br>            setBlocker(t, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-literal">true</span>, deadline);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBlocker</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> U.getReferenceOpaque(t, PARKBLOCKER);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>        U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>)<br>            U.park(<span class="hljs-literal">false</span>, nanos);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span> &#123;<br>        U.park(<span class="hljs-literal">true</span>, deadline);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getThreadId</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">return</span> U.getLong(thread, TID);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">U</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">PARKBLOCKER</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(Thread.class, <span class="hljs-string">&quot;parkBlocker&quot;</span>);<br>        <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">TID</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(Thread.class, <span class="hljs-string">&quot;tid&quot;</span>);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h2><h3 id="3-1-private-LockSupport"><a href="#3-1-private-LockSupport" class="headerlink" title="3.1. private LockSupport()"></a>3.1. private LockSupport()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">LockSupport</span><span class="hljs-params">()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-具体方法"><a href="#4-具体方法" class="headerlink" title="4. 具体方法"></a>4. 具体方法</h2><h3 id="4-1-具体方法（无）"><a href="#4-1-具体方法（无）" class="headerlink" title="4.1. 具体方法（无）"></a>4.1. 具体方法（无）</h3><h4 id="4-1-1-private-static-void-setBlocker-Thread-t-Object-arg"><a href="#4-1-1-private-static-void-setBlocker-Thread-t-Object-arg" class="headerlink" title="4.1.1. private static void setBlocker(Thread t, Object arg)"></a>4.1.1. private static void setBlocker(Thread t, Object arg)</h4><p><code>private static void setBlocker(Thread t, Object arg)</code> 用于 在一个线程即将因为 <code>LockSupport.park</code> 挂起前，把 “阻塞原因” 对象（arg）写到该 <code>Thread</code> 对象的内部字段 <code>parkBlocker</code> 上。</p><p>需要注意的是，由于该方法是 <code>private static</code>，所以作为应用层开发者，你是不能直接用它的，不管它是不是 <code>static</code>，它其实是 <code>park</code> 的小助手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接调用该方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. Thread t</span><br><span class="hljs-comment"> *          1. 阻塞的 Thread</span><br><span class="hljs-comment"> *      2. Object arg</span><br><span class="hljs-comment"> *          1. 阻塞原因对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlocker</span><span class="hljs-params">(Thread t, Object arg)</span> &#123;<br>U.putReferenceOpaque(t, PARKBLOCKER, arg);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-2-public-static-void-setCurrentBlocker-Object-blocker"><a href="#4-1-2-public-static-void-setCurrentBlocker-Object-blocker" class="headerlink" title="4.1.2. public static void setCurrentBlocker(Object blocker)"></a>4.1.2. public static void setCurrentBlocker(Object blocker)</h4><p><code>public static void setCurrentBlocker(Object blocker)</code> 与 <code>private static void setBlocker(Thread t, Object arg)</code> 类似，只不过是作用于当前线程</p><p>需要注意的是，该方法可以被应用层开发者使用，并且通常在线程阻塞前设置。因为如果你等到真正进入阻塞方法才设置 blocker，就会有一点小时间差，调试工具在那微小的窗口里看到线程挂起了，却没有任何解释，信息就不完整了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlocker</span><span class="hljs-params">(Thread t, Object arg)</span> &#123;<br>U.putReferenceOpaque(t, PARKBLOCKER, arg);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-3-public-static-Object-getBlocker-Thread-t"><a href="#4-1-3-public-static-Object-getBlocker-Thread-t" class="headerlink" title="4.1.3. public static Object getBlocker(Thread t)"></a>4.1.3. public static Object getBlocker(Thread t)</h4><p><code>public static Object getBlocker(Thread t)</code> 用于 获取某线程的阻塞原因对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBlocker</span><span class="hljs-params">(Thread t)</span> &#123;<br><span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-keyword">return</span> U.getReferenceOpaque(t, PARKBLOCKER);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-4-public-static-void-park"><a href="#4-1-4-public-static-void-park" class="headerlink" title="4.1.4. public static void park()"></a>4.1.4. public static void park()</h4><p><code>public static void park()</code> 用于 让当前线程进入阻塞状态（<code>WAITING</code>）直到：</p><ol><li>被中断<ol><li>不同于 <code>Thread</code> 的 <code>sleep</code> 和 <code>Object</code> 的 <code>wait</code> 不同，线程在阻塞期间若被中断，当进入可运行态并重新获得 CPU 时间片后，会<strong>主动响应中断</strong>，并抛出 <code>InterruptedException</code>。</li><li>而 <code>park</code> 的线程在阻塞期间若被中断，当进入可运行态并重新获得 CPU 时间片后，不会响应中断</li></ol></li><li>被 <code>unpark</code><ol><li>不同于 <code>Thread</code> 的 <code>sleep</code> 和 <code>Object</code> 的 <code>wait</code> 不同，<code>unpark</code> 的线程可用被提前唤醒（即 <code>unpark</code> 可以在 <code>park</code> 之前就调用）</li></ol></li><li>线程虚假唤醒<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="4-1-5-public-static-void-parkNanos-long-nanos"><a href="#4-1-5-public-static-void-parkNanos-long-nanos" class="headerlink" title="4.1.5. public static void parkNanos(long nanos)"></a>4.1.5. public static void parkNanos(long nanos)</h4><p><code>public static void parkNanos(long nanos)</code> 和 <code>public static void park()</code> 类似，只不过让当前线程进入的阻塞状态是 <code>TIMED_WAITING</code>，等待 <code>nanos</code> 纳秒，超时后线程自动进入可运行态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> &#123;<br><span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>)<br>U.park(<span class="hljs-literal">false</span>, nanos);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-6-public-static-void-parkUntil-long-deadline"><a href="#4-1-6-public-static-void-parkUntil-long-deadline" class="headerlink" title="4.1.6. public static void parkUntil(long deadline)"></a>4.1.6. public static void parkUntil(long deadline)</h4><p><code>public static void parkUntil(long deadline)</code> 和 <code>public static void parkNanos(long nanos)</code> 类似，让当前线程进入的阻塞状态是 <code>TIMED_WAITING</code>，等待到指定时间点，超时后线程自动进入可运行态</p><p>需要注意的是，传入的参数是 Unix 毫秒级时间戳，例如 <code>System.currentTimeMillis() + 3000</code> 是暂停三秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span> &#123;<br>U.park(<span class="hljs-literal">true</span>, deadline);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-7-public-static-void-park-Object-blocker"><a href="#4-1-7-public-static-void-park-Object-blocker" class="headerlink" title="4.1.7. public static void park(Object blocker)"></a>4.1.7. public static void park(Object blocker)</h4><p><code>public static void park(Object blocker)</code> 和 <code>public static void park()</code> 类似，只不过 设置了阻塞原因对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>setBlocker(t, blocker);<br>U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>setBlocker(t, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-8-public-static-void-parkNanos-Object-blocker-long-nanos"><a href="#4-1-8-public-static-void-parkNanos-Object-blocker-long-nanos" class="headerlink" title="4.1.8. public static void parkNanos(Object blocker, long nanos)"></a>4.1.8. public static void parkNanos(Object blocker, long nanos)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span> &#123;<br><span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>setBlocker(t, blocker);<br>U.park(<span class="hljs-literal">false</span>, nanos);<br>setBlocker(t, <span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-9-public-static-void-parkUntil-Object-blocker-long-deadline"><a href="#4-1-9-public-static-void-parkUntil-Object-blocker-long-deadline" class="headerlink" title="4.1.9. public static void parkUntil(Object blocker, long deadline)"></a>4.1.9. public static void parkUntil(Object blocker, long deadline)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>setBlocker(t, blocker);<br>U.park(<span class="hljs-literal">true</span>, deadline);<br>setBlocker(t, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="public-static-void-unpark-Thread-thread"><a href="#public-static-void-unpark-Thread-thread" class="headerlink" title="public static void unpark(Thread thread)"></a>public static void unpark(Thread thread)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            U.unpark(thread);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：ManagedBlocker源码解析</title>
    <link href="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9AManagedBlocker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9AManagedBlocker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ManagedBlocker</code> 是一个接口，是 <code>ForkJoinPool</code> 的 静态 接口，用于 向 <code>ForkJoinPool</code> 声明 “这里可能会发生阻塞”，以便池子在 <code>Worker</code> 暂停时 临时补充线程，保证吞吐量不下降</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ManagedBlocker</span> &#123;<br><br><span class="hljs-comment">// 执行实际的阻塞操作</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 测试是否已经可以继续</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-内置实现"><a href="#5-内置实现" class="headerlink" title="5. 内置实现"></a>5. 内置实现</h2><h3 id="0-1-ConditionNode"><a href="#0-1-ConditionNode" class="headerlink" title="0.1. ConditionNode"></a>0.1. ConditionNode</h3><p>ConditionNode 是 AQS 的 静态 内部类</p><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ConditionNode源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：ConditionNode 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ConditionNode</code> 是一个具体类，是 AQS 的 静态 内部类，继承了 <code>Node</code>，实现了 <code>ForkJoinPool.ManagedBlocker</code>，是 AQS 在 <code>Condition Queue</code> 的节点，是一个比 <code>Node</code> 更简单的<strong>单向链表节点</strong></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>AQS 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：AbstractQueuedSynchronizer源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>Node 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ANode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Node源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>ManagedBlocker 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AManagedBlocker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ManagedBlocker源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker &#123;<br><br>ConditionNode nextWaiter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> status &lt;= <span class="hljs-number">1</span> || Thread.currentThread().isInterrupted();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (!isReleasable()) LockSupport.park();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-核心属性"><a href="#3-核心属性" class="headerlink" title="3. 核心属性"></a>3. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，同包兄弟是做不成了，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 指向同一条件队列中的下一个 ConditionNode</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 虽然 ConditionNode 继承自 Node，自然也继承了 prev 和 next 字段</span><br><span class="hljs-comment"> * 但在实现条件队列时，并没有直接复用它们，而是单独维护了一个 nextWaiter 属性</span><br><span class="hljs-comment"> * 之所以这样设计，主要有以下原因：</span><br><span class="hljs-comment"> *      1. 同步队列是双向链表，需要前驱和后继；而条件队列只是单向链表，只需一个后继指针即可</span><br><span class="hljs-comment"> *      2. prev 和 next 在 AQS 中已经明确表示了同步队列的指针含义，若直接挪作条件队列使用，会造成语义混乱</span><br><span class="hljs-comment"> *      3. 当节点从条件队列转移到同步队列时，prev 和 next 必须重新赋值。与其在原字段上反复调整，不如通过额外的 nextWaiter 来简化管理，逻辑更清晰、避免歧义。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>ConditionNode nextWaiter;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Node 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9ANode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9ANode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Node 是一个抽象类，是 AQS 的 静态 内部类，是 AQS 在 <code>Sync Queue</code> 的节点，是一个双向链表节点</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>AQS 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：AbstractQueuedSynchronizer源码解析</a></li></ol></li><li>Hexo 内部链接：<ol><li></li></ol></li></ol></li><li>在最初的设计里，<code>Node</code> 只是一个具体类，职责非常单纯，充当同步队列中的链表节点。但随着并发框架的发展，设计者意识到队列节点本身需要承载两种不同的语义：<strong>独占 (exclusive)</strong> 和 **共享 (shared)**。<ol><li>为了更好地表达这一点，他们将 <code>Node</code> 改为抽象类。尽管 <code>Node</code> 中并没有抽象方法，看起来“抽象”似乎多此一举，但这样设计的核心目的，是阻止开发者直接去实例化一个原始的 <code>Node</code>。</li><li>取而代之的是，框架定义了两个具体子类：<code>ExclusiveNode</code> 和 <code>SharedNode</code>。这两个类除了继承 <code>Node</code> 外没有任何额外逻辑，但却起到了“标记” 的作用，明确区分了节点的语义。这样一来，开发者所创建的不是一个模糊的 “队列节点”，而是一个语义清晰的 “独占节点” 或 “共享节点”。</li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-keyword">volatile</span> Node next;<br><br>Thread waiter;<br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casPrev</span><span class="hljs-params">(Node c, Node v)</span> &#123;<br><span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, PREV, c, v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node c, Node v)</span> &#123;<br><span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, NEXT, c, v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUnsetStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br><span class="hljs-keyword">return</span> U.getAndBitwiseAndInt(<span class="hljs-built_in">this</span>, STATUS, ~v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrevRelaxed</span><span class="hljs-params">(Node p)</span> &#123;<br>U.putReference(<span class="hljs-built_in">this</span>, PREV, p);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatusRelaxed</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;<br>U.putInt(<span class="hljs-built_in">this</span>, STATUS, s);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearStatus</span><span class="hljs-params">()</span> &#123;<br>U.putIntOpaque(<span class="hljs-built_in">this</span>, STATUS, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">STATUS</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;status&quot;</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">NEXT</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;next&quot;</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">PREV</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;prev&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>方法的实现涉及到了 <code>Unsafe</code>，先不看</li></ol></blockquote><hr><h2 id="3-核心属性"><a href="#3-核心属性" class="headerlink" title="3. 核心属性"></a>3. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前驱节点，指向前一个 Node</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><br><span class="hljs-comment">// 后驱节点，指向后一个 Node</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><br><span class="hljs-comment">// 本 Node 封装的 Thread 对象</span><br>Thread waiter;<br><br><br><span class="hljs-comment">// 表示当前 Node 的状态，不同值有不同的意义，具体由外层算法定义</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Condition 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9ACondition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9ACondition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>Condition</code> 是一个接口，定义了线程间等待与唤醒的协调机制，配合 <code>Lock</code> 使用，相当于 <code>Object</code> 的 <code>wait</code>&#x2F;<code>notify</code>&#x2F;<code>notifyAll</code> 的升级版。</p><p>我们先来想象以下 <code>synchronized</code> 锁，它配合 <code>Object</code> 的 <code>wait</code>&#x2F;<code>notify</code>&#x2F;<code>notifyAll</code> 使用。但是有一个关键限制，一个 <code>synchronized</code> 锁（即一个对象监视器）只有一个等待队列（<code>WaitSet</code>），如果你有多个条件需要等待，你就无法精确控制唤醒哪一类等待者，因为他们都在同一个队列中等待。</p><p>而一个实现了 <code>Lock</code> 接口的对象中，可以创建出多个实现了 <code>Condition</code> 接口的对象，每个实现了 <code>Condition</code> 接口的对象都拥有自己独立的等待队列，可以根据情况想唤醒哪个 <code>Condition</code> 队列中的线程，就唤醒哪个 <code>Condition</code> 队列中的线程</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>实现了 <code>Condition</code> 接口的类，必须自己维护一个等待队列<ol><li>在 JUC 中，队列一般分为两种<ol><li>同步队列：<ol><li>竞争锁失败的线程，在这里阻塞</li><li>例如 AQS 中的 <code>Sync Queue</code>，<code>Monitor</code> 中的 <code>EntryList</code></li></ol></li><li>条件队列<ol><li>条件未满足的线程，在这里阻塞</li><li>例如 AQS 中的 <code>Condition Queue</code>，<code>Monitor</code> 中的 <code>WaitSet</code></li></ol></li></ol></li><li>需要注意的是，这里所说的 <code>Condition Queue</code>，特指 AQS 内部类 <code>ConditionObject</code> 维护的那条等待队列，而并非所有实现了 <code>Condition</code> 接口的类都叫做 <code>Condition Queue</code></li><li>只不过，由于 AQS 的 <code>ConditionObject</code> 实现极具代表性，所以在各种资料和讨论中，所谓的 <code>Condition Queue</code> 往往都是在讲它。</li></ol></li><li><code>Condition</code> 为<code>Object</code> 的 <code>wait</code>&#x2F;<code>notify</code>&#x2F;<code>notifyAll</code> 的升级版，在 <code>Object</code> 中，这些方法必须在 <code>synchronized</code> 块里调用，因为调用线程必须持有该对象的锁。同理，<code>Condition</code> 的实现也必须依赖某个锁来保证调用的合法性，因此，<code>Condition</code> 的语义天然决定了它只能与独占锁配合使用，而不适用于共享锁</li><li>由于实现 <code>Condition</code> 接口相当繁琐，我们通常不会选择去实现它，而是去使用 Java 中的内置实现，即 AQS 中的 <code>ConditionObject</code></li><li>Lock 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ALock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Lock源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-void-await"><a href="#3-1-1-void-await" class="headerlink" title="3.1.1. void await()"></a>3.1.1. void await()</h4><p><code>void await()</code> 是一个接口方法，必须由具体的实现类进行实现，用于 线程进入条件队列，并释放当前持有的锁，直到被唤醒（<code>Condition</code> 的 <code>signal</code>&#x2F;<code>signalAll</code>）或被中断（<code>Thread</code> 的 <code>interrupted</code>）后响应中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-2-void-awaitUninterruptibly"><a href="#3-1-2-void-awaitUninterruptibly" class="headerlink" title="3.1.2. void awaitUninterruptibly()"></a>3.1.2. void awaitUninterruptibly()</h4><p><code>void awaitUninterruptibly()</code> 是一个接口方法，必须由具体的实现类进行实现，和 <code>await</code> 类似，但不会响应中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-3-long-awaitNanos-long-nanosTimeout"><a href="#3-1-3-long-awaitNanos-long-nanosTimeout" class="headerlink" title="3.1.3. long awaitNanos(long nanosTimeout)"></a>3.1.3. long awaitNanos(long nanosTimeout)</h4><p><code>long awaitNanos(long nanosTimeout)</code> 是一个接口方法，必须由具体的实现类进行实现，用于 等待 <code>nanosTimeout</code> 纳秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-4-boolean-await-long-time-TimeUnit-unit"><a href="#3-1-4-boolean-await-long-time-TimeUnit-unit" class="headerlink" title="3.1.4. boolean await(long time, TimeUnit unit)"></a>3.1.4. boolean await(long time, TimeUnit unit)</h4><p><code>boolean await(long time, TimeUnit unit)</code> 是一个接口方法，必须由具体的实现类进行实现，用于 等待 <code>time unit</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-5-boolean-awaitUntil-Date-deadline"><a href="#3-1-5-boolean-awaitUntil-Date-deadline" class="headerlink" title="3.1.5. boolean awaitUntil(Date deadline)"></a>3.1.5. boolean awaitUntil(Date deadline)</h4><p><code>boolean awaitUntil(Date deadline)</code> 是一个接口方法，必须由具体的实现类进行实现，用于 等待到指定时间点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-6-void-signal"><a href="#3-1-6-void-signal" class="headerlink" title="3.1.6. void signal()"></a>3.1.6. void signal()</h4><p><code>void signal()</code> 是一个接口方法，必须由具体的实现类进行实现，用于 唤醒一个等待在该 <code>Condition</code> 上的线程，该线程从条件队列转移到同步队列（同步器资源在此时释放这种极限情况下，也必须先转移到同步队列）</p><p>需要注意的是，唤醒的具体线程不保证是最早排队的，因为该节点可能在 signal 之前就被取消了（超时&#x2F;中断），就没资格进入同步队列了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-7-void-signalAll"><a href="#3-1-7-void-signalAll" class="headerlink" title="3.1.7. void signalAll()"></a>3.1.7. void signalAll()</h4><p><code>void signalAll()</code> 是一个接口方法，必须由具体的实现类进行实现，用于 唤醒在该 Condition 上等待的所有线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="4-内置实现"><a href="#4-内置实现" class="headerlink" title="4. 内置实现"></a>4. 内置实现</h2><h3 id="4-1-ConditionObject"><a href="#4-1-ConditionObject" class="headerlink" title="4.1. ConditionObject"></a>4.1. ConditionObject</h3><p><code>ConditionObject</code> 是 AQS 的 内部类</p><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ConditionObject源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：ConditionObject 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ConditionObject</code> 是一个具体类，是 AQS 的 内部类，实现了 <code>Condition</code>，维护了一个等待队列，实现了线程间等待与唤醒的协调机制</p><p><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9AConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>AQS 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：AbstractQueuedSynchronizer源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>Condition 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ACondition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Condition源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode firstWaiter;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode lastWaiter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConditionObject</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(ConditionNode first, <span class="hljs-type">boolean</span> all)</span> &#123;<br><span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br><span class="hljs-keyword">if</span> ((firstWaiter = next) == <span class="hljs-literal">null</span>)<br>lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>) &#123;<br>enqueue(first);<br><span class="hljs-keyword">if</span> (!all)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>first = next;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enableWait</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br><span class="hljs-keyword">if</span> (isHeldExclusively()) &#123;<br>node.waiter = Thread.currentThread();<br>node.setStatusRelaxed(COND | WAITING);<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> lastWaiter;<br><span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>firstWaiter = node;<br><span class="hljs-keyword">else</span><br>last.nextWaiter = node;<br>lastWaiter = node;<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (release(savedState))<br><span class="hljs-keyword">return</span> savedState;<br>&#125;<br>node.status = CANCELLED;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canReacquire</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br>Node p;<br><span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; (p = node.prev) != <span class="hljs-literal">null</span> &amp;&amp;<br>(p.next == node || isEnqueued(node));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span> || node.nextWaiter != <span class="hljs-literal">null</span> || node == lastWaiter) &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter, trail = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (w != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> w.nextWaiter;<br><span class="hljs-keyword">if</span> ((w.status &amp; COND) == <span class="hljs-number">0</span>) &#123;<br>w.nextWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)<br>firstWaiter = next;<br><span class="hljs-keyword">else</span><br>trail.nextWaiter = next;<br><span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>lastWaiter = trail;<br>&#125; <span class="hljs-keyword">else</span><br>trail = w;<br>w = next;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>interrupted = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, cancelled = <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> (interrupted |= Thread.interrupted()) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (interrupted) &#123;<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125;<br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime(); <span class="hljs-comment">// avoid overflow</span><br><span class="hljs-keyword">return</span> (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">abstime</span> <span class="hljs-operator">=</span> deadline.getTime();<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>System.currentTimeMillis() &gt;= abstime) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkUntil(<span class="hljs-built_in">this</span>, abstime);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">nanosTimeout</span> <span class="hljs-operator">=</span> unit.toNanos(time);<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOwnedBy</span><span class="hljs-params">(AbstractQueuedSynchronizer sync)</span> &#123;<br><span class="hljs-keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasWaiters</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;<br><span class="hljs-keyword">if</span> ((w.status &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWaitQueueLength</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;<br><span class="hljs-keyword">if</span> ((w.status &amp; COND) != <span class="hljs-number">0</span>)<br>++n;<br>&#125;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title function_">getWaitingThreads</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;<br><span class="hljs-keyword">if</span> ((w.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.waiter;<br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>list.add(t);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> list;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-核心属性"><a href="#3-核心属性" class="headerlink" title="3. 核心属性"></a>3. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br> <br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br></code></pre></td></tr></table></figure><hr><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h2><hr><h2 id="5-抽象方法"><a href="#5-抽象方法" class="headerlink" title="5. 抽象方法"></a>5. 抽象方法</h2><hr><h2 id="6-具体方法"><a href="#6-具体方法" class="headerlink" title="6. 具体方法"></a>6. 具体方法</h2><h3 id="6-1-具体方法（无）"><a href="#6-1-具体方法（无）" class="headerlink" title="6.1. 具体方法（无）"></a>6.1. 具体方法（无）</h3><h4 id="0-1-1-private-int-enableWait-ConditionNode-node"><a href="#0-1-1-private-int-enableWait-ConditionNode-node" class="headerlink" title="0.1.1. private int enableWait(ConditionNode node)"></a>0.1.1. private int enableWait(ConditionNode node)</h4><p><code>private int enableWait(ConditionNode node)</code> 用于 把当前线程包装成一个 <code>ConditionNode</code>，然后将该节点链接到条件队列（单向链表）中，并释放锁资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. ConditionNode node</span><br><span class="hljs-comment"> *          1. 一个空的 ConditionNode，当前线程就是包装在这个 Node 中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 在进入 await() 之前，同步器（AQS）的 state 值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. IllegalMonitorStateException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enableWait</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br><br><span class="hljs-comment">// 如果独占锁是否被当前线程持有（Condition 是专门用于独占锁的）</span><br><span class="hljs-keyword">if</span> (isHeldExclusively()) &#123;<br><br><span class="hljs-comment">// 将当前线程封装到 Node 的 waiter 中</span><br>node.waiter = Thread.currentThread();<br><br><span class="hljs-comment">// 将 node 的状态设置为 COND（条件队列） + 等待中</span><br>node.setStatusRelaxed(COND | WAITING);<br><br><span class="hljs-comment">// 将 Node 链接到条件队列中（单向链表）</span><br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> lastWaiter;<br><span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>firstWaiter = node;<br><span class="hljs-keyword">else</span><br>last.nextWaiter = node;<br>lastWaiter = node;<br><br><span class="hljs-comment">// 记录当前 state</span><br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br><br><span class="hljs-comment">// 让 state 清零，彻底释放</span><br><span class="hljs-keyword">if</span> (release(savedState))<br><span class="hljs-keyword">return</span> savedState;<br>&#125;<br><span class="hljs-comment">// 如果独占锁不是被当前线程持有，则将该 Node 的状态设置为 CANCELLED 并抛出 throw new IllegalMonitorStateException();</span><br>node.status = CANCELLED;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="0-1-1-private-boolean-canReacquire-ConditionNode-node"><a href="#0-1-1-private-boolean-canReacquire-ConditionNode-node" class="headerlink" title="0.1.1. private boolean canReacquire(ConditionNode node)"></a>0.1.1. private boolean canReacquire(ConditionNode node)</h4><p><code>private boolean canReacquire(ConditionNode node)</code> 用于 判断某个在 <code>Condition</code> 上等待的节点，被 <code>Condition</code> 的 <code>signal</code> 后，是否已经链接到同步队列中</p><p>需要注意的是，线程在被 <code>Condition</code> 的 <code>signal()</code> 唤醒后，按设计一定会转移到同步队列中去竞争锁。但在高并发环境下，节点的入队过程并非一步到位，可能出现链表指针尚未完全修复或节点已被取消等等 “中间态”。因此，需要通过这个方法进行校验，确保节点确实已经稳定地进入同步队列，才算真正具备重新竞争锁的资格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canReacquire</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br>Node p;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * node != null 是最基础的检查，传入 Node 不能为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (p = node.prev) != null 用于检查这个节点是否有前驱，</span><br><span class="hljs-comment"> * 因为在 AQS 的同步队列中，除了头节点，其他节点都必须有 prev</span><br><span class="hljs-comment"> * 如果 prev 为 null，说明它不在同步队列里</span><br><span class="hljs-comment"> * 不要猜测该节点是否是队头节点，因为同步队列一定会存在一个头节点，而且是一个哑节点</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (p.next == node || isEnqueued(node)) 中的 p.next == node</span><br><span class="hljs-comment"> * 是看这个节点的前驱节点的 next 是否正确指向自己，如果是，说明这个节点确实在同步队列中</span><br><span class="hljs-comment"> * 但是因为在高并发下，节点刚被加进队列，可能还没来得及完全修复 p.next，这种情况下，单靠这个判断会出错</span><br><span class="hljs-comment"> * 所以通过 isEnqueued(node) 来遍历确认它确实在同步队列中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; (p = node.prev) != <span class="hljs-literal">null</span> &amp;&amp;<br>(p.next == node || isEnqueued(node));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="private-void-doSignal-ConditionNode-first-boolean-all"><a href="#private-void-doSignal-ConditionNode-first-boolean-all" class="headerlink" title="private void doSignal(ConditionNode first, boolean all)"></a>private void doSignal(ConditionNode first, boolean all)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(ConditionNode first, <span class="hljs-type">boolean</span> all)</span> &#123;<br><span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br><span class="hljs-comment">// 把 firstWaiter 指向第二个节点</span><br><span class="hljs-keyword">if</span> ((firstWaiter = next) == <span class="hljs-literal">null</span>)<br>lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把 first 节点上的 COND 标志清掉，并返回旧值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 如果返回 COND，说明 first 节点还处于条件等待队列，进行 if 逻辑</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 进行这个检查的原因是，节点可能在 signal 之前就被取消了（超时/中断），就没资格进入同步队列了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 将 first 节点从条件队列转移到同步队列</span><br>enqueue(first);<br><span class="hljs-comment">// 如果不是 signalAll，不需要唤醒其他节点，退出 while 循环</span><br><span class="hljs-keyword">if</span> (!all)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 如果是 signalAll，将 first = next，继续 while 循环</span><br>first = next;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-2-具体方法（重写）"><a href="#6-2-具体方法（重写）" class="headerlink" title="6.2. 具体方法（重写）"></a>6.2. 具体方法（重写）</h3><hr><h3 id="6-3-具体方法（实现）"><a href="#6-3-具体方法（实现）" class="headerlink" title="6.3. 具体方法（实现）"></a>6.3. 具体方法（实现）</h3><h4 id="0-1-1-Condition-中的方法实现"><a href="#0-1-1-Condition-中的方法实现" class="headerlink" title="0.1.1. Condition 中的方法实现"></a>0.1.1. Condition 中的方法实现</h4><h5 id="Condition-源码解析"><a href="#Condition-源码解析" class="headerlink" title="Condition 源码解析"></a>Condition 源码解析</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ACondition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Condition源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h5 id="0-1-1-1-public-final-void-await"><a href="#0-1-1-1-public-final-void-await" class="headerlink" title="0.1.1.1. public final void await()"></a>0.1.1.1. public final void await()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, cancelled = <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> (interrupted |= Thread.interrupted()) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (interrupted) &#123;<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125;<br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>ConditionNode 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ConditionNode源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>LockSupport 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ALockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：LockSupport源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h5 id="0-1-1-public-final-void-awaitUninterruptibly"><a href="#0-1-1-public-final-void-awaitUninterruptibly" class="headerlink" title="0.1.1. public final void awaitUninterruptibly()"></a>0.1.1. public final void awaitUninterruptibly()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-comment">// 把当前线程包装成一个 ConditionNode，然后将该节点链接到条件队列（单向链表）中，并释放锁资源</span><br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><br><span class="hljs-comment">// 把 “阻塞原因” 对象（arg）写到当前 Thread 对象的内部字段 parkBlocker 上</span><br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 如果某个在 Condition 上等待的节点，还没有被链接到同步队列中</span><br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><br><span class="hljs-comment">// 如果被中断，设置中断标志位</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>interrupted = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 如果 Node 的 Status 还有 COND，说明确实还在条件队列中，进入循环</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 如果不是使用 ForkJoinPool 只能控制何时阻塞，则立即进行阻塞</span><br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-comment">// 否则说明使用了 ForkJoinPool，使用 ForkJoinPool 的 managedBlock 智能控制何时阻塞</span><br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 如果 Node 的 status 不含 COND，可能是已移出条件队列进入同步队列了（因为这个流程可能非常快，上一刻还在条件队列，下一刻就在同步队列了）</span><br><span class="hljs-comment">* 在这种临界状态，调用 Thread.onSpinWait() 提示 CPU 进入高效自旋，再次调用 canReacquire(node) 看是否已经在同步队列了</span><br><span class="hljs-comment">*/</span><br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br><span class="hljs-comment">// 如果某个在 Condition 上等待的节点，已经被链接到同步队列中，继续执行</span><br><span class="hljs-comment">// 把当前 Thread 对象的内部字段 parkBlocker 上的 “阻塞原因” 对象置为 null</span><br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 清除 Node 的 Status</span><br>node.clearStatus();<br><br><span class="hljs-comment">// 不断重试获取锁</span><br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><br><span class="hljs-comment">// 在方法执行过程中，可能导致中断标志位被清除，这里恢复中断标志位</span><br><span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>ConditionNode 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ConditionNode源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>LockSupport 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ALockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：LockSupport源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h5 id="0-1-1-1-public-final-long-awaitNanos-long-nanosTimeout"><a href="#0-1-1-1-public-final-long-awaitNanos-long-nanosTimeout" class="headerlink" title="0.1.1.1. public final long awaitNanos(long nanosTimeout)"></a>0.1.1.1. public final long awaitNanos(long nanosTimeout)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime(); <span class="hljs-comment">// avoid overflow</span><br><span class="hljs-keyword">return</span> (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="public-final-boolean-await-long-time-TimeUnit-unit"><a href="#public-final-boolean-await-long-time-TimeUnit-unit" class="headerlink" title="public final boolean await(long time, TimeUnit unit)"></a>public final boolean await(long time, TimeUnit unit)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">nanosTimeout</span> <span class="hljs-operator">=</span> unit.toNanos(time);<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="public-final-boolean-awaitUntil-Date-deadline"><a href="#public-final-boolean-awaitUntil-Date-deadline" class="headerlink" title="public final boolean awaitUntil(Date deadline)"></a>public final boolean awaitUntil(Date deadline)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">abstime</span> <span class="hljs-operator">=</span> deadline.getTime();<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>System.currentTimeMillis() &gt;= abstime) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkUntil(<span class="hljs-built_in">this</span>, abstime);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="public-final-void-signal"><a href="#public-final-void-signal" class="headerlink" title="public final void signal()"></a>public final void signal()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="public-final-void-signalAll"><a href="#public-final-void-signalAll" class="headerlink" title="public final void signalAll()"></a>public final void signalAll()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Executor 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>Executor</code> 是一个接口，定义了一种统一的方式提交线程任务</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br><br><span class="hljs-comment">// 定义提交任务的规范</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-实现示例"><a href="#3-实现示例" class="headerlink" title="3. 实现示例"></a>3. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Runnable 不能为 null&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 每次来一个任务就开一个新的线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(command).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoExecutor</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行任务 &quot;</span> + id + <span class="hljs-string">&quot; 的线程: &quot;</span> + Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Lock 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9ALock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9ALock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>Lock</code> 是一个接口，定义了显式锁的基本操作规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br><br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-void-lock"><a href="#3-1-1-void-lock" class="headerlink" title="3.1.1. void lock()"></a>3.1.1. void lock()</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>void lock() </code>是一个接口方法，必须由具体的实现类进行实现，用于 获取锁，如果锁已经被别的线程占用，会一直阻塞，直到锁释放，被中断（<code>Thread</code> 的 <code>interrupted</code>）后不会响应中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-2-void-lockInterruptibly"><a href="#3-1-2-void-lockInterruptibly" class="headerlink" title="3.1.2. void lockInterruptibly()"></a>3.1.2. void lockInterruptibly()</h4><h5 id="3-1-2-1-方法概述"><a href="#3-1-2-1-方法概述" class="headerlink" title="3.1.2.1. 方法概述"></a>3.1.2.1. 方法概述</h5><p><code>void lockInterruptibly()</code> 是一个接口方法，必须由具体的实现类进行实现，与 <code>lock</code> 类似，但被中断（<code>Thread</code> 的 <code>interrupted</code>）后可以响应中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-3-boolean-tryLock"><a href="#3-1-3-boolean-tryLock" class="headerlink" title="3.1.3. boolean tryLock()"></a>3.1.3. boolean tryLock()</h4><p><code>boolean tryLock()</code> 是一个接口方法，必须由具体的实现类进行实现，用于 尝试立即获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. true</span><br><span class="hljs-comment"> *          1. 成功获取锁</span><br><span class="hljs-comment"> *      2. false</span><br><span class="hljs-comment"> *          1. 未获取锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-4-boolean-tryLock-long-time-TimeUnit-unit"><a href="#3-1-4-boolean-tryLock-long-time-TimeUnit-unit" class="headerlink" title="3.1.4. boolean tryLock(long time, TimeUnit unit)"></a>3.1.4. boolean tryLock(long time, TimeUnit unit)</h4><p><code>boolean tryLock(long time, TimeUnit unit)</code> 是一个接口方法，必须由具体的实现类进行实现，用于 等待指定时间尝试获取锁</p><p>等待期间内，如果被中断（<code>Thread</code> 的 <code>interrupted</code>），可以响应中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. package-private</span><br><span class="hljs-comment"> *          1. 类内部 + 同包兄弟</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，同包兄弟是做不成了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. long timeout</span><br><span class="hljs-comment"> *          1. 阻塞等待多长时间</span><br><span class="hljs-comment"> *      2. TimeUnit unit</span><br><span class="hljs-comment"> *          1. timeout 的单位</span><br><span class="hljs-comment"> *          2. TimeUnit.NANOSECONDS</span><br><span class="hljs-comment"> *              1. 纳秒</span><br><span class="hljs-comment"> *          3. TimeUnit.MICROSECONDS</span><br><span class="hljs-comment"> *              1. 微秒</span><br><span class="hljs-comment"> *          4. TimeUnit.MILLISECONDS</span><br><span class="hljs-comment"> *              1. 毫秒</span><br><span class="hljs-comment"> *          5. TimeUnit.SECONDS</span><br><span class="hljs-comment"> *              1. 秒</span><br><span class="hljs-comment"> *          6. TimeUnit.MINUTES</span><br><span class="hljs-comment"> *              1. 分钟</span><br><span class="hljs-comment"> *          7. TimeUnit.HOURS</span><br><span class="hljs-comment"> *              1. 小时</span><br><span class="hljs-comment"> *          8. TimeUnit.DAYS</span><br><span class="hljs-comment"> *              1. 天</span><br><span class="hljs-comment"> *              </span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1， true</span><br><span class="hljs-comment"> *          1. 成功获取锁</span><br><span class="hljs-comment"> *      2. false</span><br><span class="hljs-comment"> *          1. 未获取锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-5-void-unlock"><a href="#3-1-5-void-unlock" class="headerlink" title="3.1.5. void unlock()"></a>3.1.5. void unlock()</h4><p><code>void unlock()</code> 是一个接口方法，必须由具体的实现类进行实现，用于 释放锁</p><p>需要注意的是，如果忘记释放锁，就会造成其他线程永远抢不到资源（死锁），一般都会写在 <code>finall</code> 代码块中避免意外</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-6-Condition-newCondition"><a href="#3-1-6-Condition-newCondition" class="headerlink" title="3.1.6. Condition newCondition()"></a>3.1.6. Condition newCondition()</h4><p><code>Condition newCondition()</code> 是一个接口方法，必须由具体的实现类进行实现，用于 创建一个 <code>Condition</code> 对象，实现更精细的线程等待&#x2F;唤醒</p><p>而一个实现了 <code>Lock</code> 接口的对象中，可以创建出多个实现了 <code>Condition</code> 接口的对象，每个实现了 <code>Condition</code> 接口的对象都拥有自己独立的等待队列，可以根据情况想唤醒哪个 <code>Condition</code> 队列中的线程，就唤醒哪个 <code>Condition</code> 队列中的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Condition 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ACondition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Condition源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-实现示例"><a href="#4-实现示例" class="headerlink" title="4. 实现示例"></a>4. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-comment">// 0 代表无锁，1 代表已加锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">// 用 ReentrantLock 来帮我们生成 Condition（正式场合，每个锁有独立的 Condition 队列）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">conditionLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 一直自旋直到获取到锁</span><br>        <span class="hljs-keyword">while</span> (!state.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 礼貌地让出 CPU</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 在等待的过程中，如果线程被中断，就抛出异常</span><br>        <span class="hljs-keyword">while</span> (!state.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 尝试一次，不等待</span><br>        <span class="hljs-keyword">return</span> state.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + unit.toNanos(time);<br>        <span class="hljs-keyword">while</span> (System.nanoTime() &lt; deadline) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 稍微睡一下，不要疯狂空转</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        state.set(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> conditionLock.newCondition();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9AReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ReentrantLock</code> 是一个具体类</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>Lock 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ALock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Lock源码解析</a></li></ol></li><li>Hexo 内部链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h2><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p><code>Sync</code> 是 <code>ReentrantLock</code> 的 静态 内部类</p><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ASync%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Sync 源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p><code>NonfairSync</code> 是 <code>ReentrantLock</code> 的 静态 内部类，用于实现非公平锁的加锁策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7316153563782823691L</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 获取当前线程</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 执行 compareAndSetState(0, 1) 成功，进入 if 逻辑</span><br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 setExclusiveOwnerThread(current) 将本线程设置为同步器的独占线程</span><br><span class="hljs-comment"> * 该方法是 Sync 的父类 AQS 的父类 AOS 提供的</span><br><span class="hljs-comment"> */</span><br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行 compareAndSetState(0, 1) 失败，执行 getExclusiveOwnerThread() == current</span><br><span class="hljs-comment"> * 看是否是重入，如果是重入，进入 else if 逻辑</span><br><span class="hljs-comment"> */</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-comment">// 将同步器的 State + 1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 如果两者都未执行成功，说明单纯是有别的线程独占该同步器，返回 false</span><br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span> &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><p><code>FairSync</code> 是 <code>ReentrantLock</code> 的 静态 内部类，用于实现公平锁的加锁策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">// 如果同步器的 State 为 0，进入 if 逻辑</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 如果同步队列中没有其他线程，并且该线程成功执行 compareAndSetState(0, 1)，进入 if 逻辑</span><br><span class="hljs-keyword">if</span> (!hasQueuedThreads() &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果同步器的 Statte 不为 0，执行 getExclusiveOwnerThread() == current</span><br><span class="hljs-comment"> * 看是否是重入，如果是重入，进入 else if 逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-comment">// 将同步器的 State + 1</span><br><span class="hljs-keyword">if</span> (++c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 如果两者都未执行成功，说明单纯是有别的线程独占该同步器，返回 false</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;<br>compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br> <br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> XXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="0-1-public-ReentrantLock"><a href="#0-1-public-ReentrantLock" class="headerlink" title="0.1. public ReentrantLock()"></a>0.1. public ReentrantLock()</h3><p><code>public ReentrantLock()</code> 用于构造一个 非公平锁的 <code>ReentrantLock</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 构造示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ReentrantLock reentrantLock = new ReentrantLock();</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="0-1-public-ReentrantLock-boolean-fair"><a href="#0-1-public-ReentrantLock-boolean-fair" class="headerlink" title="0.1. public ReentrantLock(boolean fair)"></a>0.1. public ReentrantLock(boolean fair)</h3><p><code>public ReentrantLock(boolean fair)</code> 用于构造一个 公平锁&#x2F;非公平锁的 <code>ReentrantLock</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. boolean fair</span><br><span class="hljs-comment"> *          1. 是否是公平锁</span><br><span class="hljs-comment"> *          2. true</span><br><span class="hljs-comment"> *              1. 公平锁</span><br><span class="hljs-comment"> *          3. false</span><br><span class="hljs-comment"> *              1. 非公平锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 构造示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ReentrantLock reentrantLock = new ReentrantLock(true);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-抽象方法"><a href="#6-抽象方法" class="headerlink" title="6. 抽象方法"></a>6. 抽象方法</h2><hr><h2 id="7-接口方法"><a href="#7-接口方法" class="headerlink" title="7. 接口方法"></a>7. 接口方法</h2><h3 id="7-1-接口方法（无）"><a href="#7-1-接口方法（无）" class="headerlink" title="7.1. 接口方法（无）"></a>7.1. 接口方法（无）</h3><hr><h3 id="7-2-接口方法（default）"><a href="#7-2-接口方法（default）" class="headerlink" title="7.2. 接口方法（default）"></a>7.2. 接口方法（default）</h3><hr><h3 id="7-3-接口方法（default-重写）"><a href="#7-3-接口方法（default-重写）" class="headerlink" title="7.3. 接口方法（default 重写）"></a>7.3. 接口方法（default 重写）</h3><hr><h2 id="8-具体方法"><a href="#8-具体方法" class="headerlink" title="8. 具体方法"></a>8. 具体方法</h2><h3 id="8-1-具体方法（无）"><a href="#8-1-具体方法（无）" class="headerlink" title="8.1. 具体方法（无）"></a>8.1. 具体方法（无）</h3><hr><h3 id="8-2-具体方法（重写）"><a href="#8-2-具体方法（重写）" class="headerlink" title="8.2. 具体方法（重写）"></a>8.2. 具体方法（重写）</h3><hr><h3 id="8-3-具体方法（实现）"><a href="#8-3-具体方法（实现）" class="headerlink" title="8.3. 具体方法（实现）"></a>8.3. 具体方法（实现）</h3><h4 id="0-1-1-Lock-中的方法实现"><a href="#0-1-1-Lock-中的方法实现" class="headerlink" title="0.1.1. Lock 中的方法实现"></a>0.1.1. Lock 中的方法实现</h4><h5 id="0-1-1-1-Lock-源码解析"><a href="#0-1-1-1-Lock-源码解析" class="headerlink" title="0.1.1.1. Lock 源码解析"></a>0.1.1.1. Lock 源码解析</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ALock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Lock源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h5 id="0-1-1-2-public-void-lock"><a href="#0-1-1-2-public-void-lock" class="headerlink" title="0.1.1.2. public void lock()"></a>0.1.1.2. public void lock()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>sync.lock();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Sync 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ASync%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Sync 源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h5 id="0-1-1-2-public-void-lockInterruptibly"><a href="#0-1-1-2-public-void-lockInterruptibly" class="headerlink" title="0.1.1.2. public void lockInterruptibly()"></a>0.1.1.2. public void lockInterruptibly()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>sync.lockInterruptibly();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Redis</title>
    <link href="/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/"/>
    <url>/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/</url>
    
    <content type="html"><![CDATA[<h1 id="一、脑图"><a href="#一、脑图" class="headerlink" title="一、脑图"></a>一、脑图</h1><ol><li><p>Xmind<br><img src="/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis.xmind"></p></li><li><p>Edraw<br><img src="/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis.eddx"></p></li></ol><hr><h1 id="二、Redis-基础"><a href="#二、Redis-基础" class="headerlink" title="二、Redis 基础"></a>二、Redis 基础</h1><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="数据类型一览图"><a href="#数据类型一览图" class="headerlink" title="数据类型一览图"></a>数据类型一览图</h3><p><img src="/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis-1.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里提到的数据类型，指的都是 值（<code>Value</code>）的数据类型。至于键（<code>Key</code>），在 <code>Redis</code> 中始终都是字符串类型</li></ol></blockquote><hr><h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><code>String</code> 是二进制安全的字符串，简单来说，它能存放各种数据，例如普通文本、数字、图片、序列化对象等等。表面上叫 “字符串”，实际上它能承载的内容远超字符串本身。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>单个 <code>String</code> 的最大大小是 512 MB。</li></ol></blockquote><hr><h3 id="位图（Bitmaps）"><a href="#位图（Bitmaps）" class="headerlink" title="位图（Bitmaps）"></a>位图（Bitmaps）</h3><p><code>Bitmaps</code> 就是把一个二进制字符串拿出来，按 <code>bit</code> 位进行操作<br><img src="/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis-3.png"></p><hr><h3 id="位域（Bitfield）"><a href="#位域（Bitfield）" class="headerlink" title="位域（Bitfield）"></a>位域（Bitfield）</h3><p><code>Bitfield</code> 就是把一个二进制字符串拿出来，把一段连续的 <code>bit</code> 位拼成一个小整数来操作</p><hr><h3 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h3><p><code>Hash</code> 就是一个键值对集合，它的键叫做 <code>field</code>，它的值叫做 <code>value</code></p><p><img src="/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis-4.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>单个 <code>Hash</code> 理论上可以存储 2<sup>32</sup>-1 个键值对，即 42_9496_7295 个 <code>field</code></li></ol></blockquote><hr><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p><code>List</code> 是一个有序的字符串集合，底层实现是双端链表，既支持从左端插入&#x2F;取出元素，也支持从右端插入&#x2F;取出元素。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>单个 <code>List</code> 最多可以存储 2<sup>32</sup>-1 个元素</li></ol></blockquote><hr><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p><code>Set</code> 是一个无序、去重的字符串集合，底层实现是哈希表</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>由于 <code>Set</code> 底层实现是哈希表，所以增删改查的复杂读都是 <code>O(1)</code></li><li>单个 <code>Set</code> 最多可以存储 2<sup>32</sup>-1 个元素</li></ol></blockquote><hr><h3 id="地理空间（Geospatial）"><a href="#地理空间（Geospatial）" class="headerlink" title="地理空间（Geospatial）"></a>地理空间（Geospatial）</h3><h2 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h2><h3 id="连接命令"><a href="#连接命令" class="headerlink" title="连接命令"></a>连接命令</h3><p><font color="#92d050">1. 心跳命令</font><br>心跳命令用于检测该客户端与 <code>Redis</code> 的连接是正常</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span><br></code></pre></td></tr></table></figure><hr><h3 id="Key-命令"><a href="#Key-命令" class="headerlink" title="Key 命令"></a>Key 命令</h3><p><font color="#92d050">1. 删除 Key</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 阻塞删除</span><br>DEL key<br><br><br><span class="hljs-comment"># 2. 非阻塞删除，仅将 Key 从 KeySpace 元数据中删除，真正的删除会在后续异步操作中进行</span><br>UNLINK key<br><br><br><span class="hljs-comment"># 3. 清空当前库</span><br>flushdb<br><br><br><span class="hljs-comment"># 4. 清空所有库</span><br>flushall<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 序列化 Key，并返回其序列化值</font></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DUMP key</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 查找 Key</font></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 1. 检查 Key 是否存在</span><br><span class="hljs-keyword">EXISTS</span> key<br><br><br><span class="hljs-comment"># 2. 查找所有 Key</span><br>keys *<br><br><br><span class="hljs-comment"># 3. 模糊匹配查找 Key</span><br>KEYS pattern<br><br><br><span class="hljs-comment"># 4. 查看当前数据库 Key 的数量</span><br>dbsize<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 为 Key 设置过期时间</font></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 1. 设置 秒级 过期时间</span><br>EXPIRE <span class="hljs-built_in">key</span> seconds<br><br><br><span class="hljs-meta"># 2. 设置 秒级 Unix 过期时间</span><br>EXPIREAT <span class="hljs-built_in">key</span> timestamp<br><br><br><span class="hljs-meta"># 3. 设置 毫秒级 过期时间</span><br>PEXPIRE <span class="hljs-built_in">key</span> milliseconds<br><br><br><span class="hljs-meta"># 4. 设置 毫秒级 Unix 过期时间</span><br>PEXPIREAT <span class="hljs-built_in">key</span> milliseconds-timestamp<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 移除 Key 的过期时间</font></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 1. 将 Key 设置为持久化</span><br>PERSIST <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">6. 查看 Key 的剩余过期时间</font></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 1. 查看 毫秒级 Key 的剩余过期时间</span><br>PTTL <span class="hljs-built_in">key</span><br><br><br><span class="hljs-meta"># 2. 查看 秒级 Key 的剩余过期时间</span><br>TTL <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>-1 代表永不过期，-2 代表已过期</li></ol></blockquote><p><font color="#92d050">7. 将 Key 移动到指定 DB</font></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">MOVE</span> key <span class="hljs-keyword">db</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">8. 查看 Key 储存的值类型</font></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">TYPE</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><hr><h1 id="三、搭建-Redis-环境"><a href="#三、搭建-Redis-环境" class="headerlink" title="三、搭建 Redis 环境"></a>三、搭建 Redis 环境</h1><h2 id="单机测试环境"><a href="#单机测试环境" class="headerlink" title="单机测试环境"></a>单机测试环境</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="创建宿主机数据挂载目录"><a href="#创建宿主机数据挂载目录" class="headerlink" title="创建宿主机数据挂载目录"></a>创建宿主机数据挂载目录</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mkdir -p /mystudy/data/redis<br></code></pre></td></tr></table></figure><hr><h4 id="启动-Redis-容器"><a href="#启动-Redis-容器" class="headerlink" title="启动 Redis 容器"></a>启动 Redis 容器</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --name redis <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v /mystudy/data/redis:/data <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  redis:latest <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  redis-server --appendonly yes --bind <span class="hljs-number">0.0.0.0</span> --requirepass wq666666<br></code></pre></td></tr></table></figure><p><font color="#92d050">1. – appendonly yes</font><br>开启 AOF（Append Only File）持久化模式，简单可靠，适合这个场景</p><p><font color="#92d050">2. –bind 0.0.0.0</font><br>Redis 默认只监听 127.0.0.1，也就是说只有通过本机地址 127.0.0.1:6379 才能访问它，哪怕你用本机的其他 IP 地址，例如 192.168.136.8：6379 也无法连接</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>设置代理</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 命令行临时代理<br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$http_proxy</span> &amp;&amp;<span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> NO_PROXY=<span class="hljs-variable">$no_proxy</span><br><br><br>// docker 代理<br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.96.0.1,192.168.136.0/24,10.244.0.0/16,.svc,.cluster.local&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><hr><h2 id="Redis-Cluster-环境"><a href="#Redis-Cluster-环境" class="headerlink" title="Redis Cluster 环境"></a>Redis Cluster 环境</h2><h3 id="0-1-环境概述"><a href="#0-1-环境概述" class="headerlink" title="0.1. 环境概述"></a>0.1. 环境概述</h3><hr><h3 id="0-2-环境特性"><a href="#0-2-环境特性" class="headerlink" title="0.2. 环境特性"></a>0.2. 环境特性</h3><h4 id="0-2-1-集群总体架构"><a href="#0-2-1-集群总体架构" class="headerlink" title="0.2.1. 集群总体架构"></a>0.2.1. 集群总体架构</h4><hr><h4 id="0-2-2-集群线程特点"><a href="#0-2-2-集群线程特点" class="headerlink" title="0.2.2. 集群线程特点"></a>0.2.2. 集群线程特点</h4><p>并非所有分布式系统的线程都能总结出鲜明特征，没有独到之处的，也不必刻意总结</p><hr><h4 id="0-2-3-节点角色与关系"><a href="#0-2-3-节点角色与关系" class="headerlink" title="0.2.3. 节点角色与关系"></a>0.2.3. 节点角色与关系</h4><p>集群各节点之间是对等关系：</p><ol><li>无中心节点<ol><li>集群中没有所谓的 “主” 节点来统一调度，所有节点彼此平等，地位对等、功能对等。</li></ol></li><li>元数据全量同步<ol><li>任何一个节点上的元数据操作，都会被实时同步到整个集群，确保所有节点信息一致</li></ol></li><li>平等的客户端接入点<ol><li>客户端可以直接连接集群中的<strong>任意节点</strong>来执行操作，每个节点都是一个功能完备的入口。</li></ol></li></ol><hr><h4 id="0-2-4-节点部署与启动"><a href="#0-2-4-节点部署与启动" class="headerlink" title="0.2.4. 节点部署与启动"></a>0.2.4. 节点部署与启动</h4><h5 id="0-2-4-1-核心前提"><a href="#0-2-4-1-核心前提" class="headerlink" title="0.2.4.1. 核心前提"></a>0.2.4.1. 核心前提</h5><p>在开始之前，所有希望加入集群的节点必须满足 X 个基本条件：</p><ol><li>各节点必须相互解析<ol><li>因为每个 RabbitMQ 节点都有一个唯一名称，格式为 <code>rabbit@hostname</code>，其中 hostname 就是所在主机的主机名，例如：<code>rabbit@rbmq-node1</code></li><li>在搭建集群时，RabbitMQ 会取出主机名（如 <code>rbmq-node1</code>），通过网络解析成对应的 IP 地址，然后发起连接</li></ol></li></ol><hr><h5 id="0-2-4-2-首个节点启动的流程"><a href="#0-2-4-2-首个节点启动的流程" class="headerlink" title="0.2.4.2. 首个节点启动的流程"></a>0.2.4.2. 首个节点启动的流程</h5><hr><h5 id="0-2-4-3-后续节点加入的流程"><a href="#0-2-4-3-后续节点加入的流程" class="headerlink" title="0.2.4.3. 后续节点加入的流程"></a>0.2.4.3. 后续节点加入的流程</h5><hr><h4 id="0-2-5-数据写入机制"><a href="#0-2-5-数据写入机制" class="headerlink" title="0.2.5. 数据写入机制"></a>0.2.5. 数据写入机制</h4><h5 id="0-2-5-1-元数据写入"><a href="#0-2-5-1-元数据写入" class="headerlink" title="0.2.5.1. 元数据写入"></a>0.2.5.1. 元数据写入</h5><p>RabbitMQ 的元数据存储在 Mnesia 数据库中。Mnesia 是 Erlang 内置的分布式数据库，专为 Erlang 应用设计。每个 RabbitMQ 节点都会运行一个独立的 Mnesia 实例，这些实例共同组成一个集群。因此，这里描述的主要是 Mnesia 的写入流程。</p><p>元数据写入在四个维度上的选择如下：</p><ol><li>维度一：同步复制（全同）</li><li>维度二：多主复制（同步多主）</li><li>维度三<ol><li>底层技术：快照 + 增量同步（基于日志）</li><li>实现方式：类 2PC 的事务机制</li><li>详细流程：<ol><li>客户端会将元数据变更请求发送到集群中的任一节点，我们把它称为 <strong>协调节点</strong>。</li><li>协调节点在收到请求后，会首先启动一个 <strong>Mnesia 事务</strong>，为了保证隔离性和一致性，协调节点会主动向所有持有该表副本的节点发送<strong>锁请求</strong>。<ol><li>并不是像标准 2PC 那样先进入 “准备阶段”，而是先尝试把相关资源的锁都拿到手</li><li>一般数据库都是边执行边逐步申请锁，而 Mnesia 是以访问模式尝试获取相应的锁</li></ol></li><li>等所有相关节点都成功加锁后，协议才会继续进入接近传统 <strong>2PC</strong> 流程的后续阶段</li></ol></li></ol></li><li>维度四：整体保存<ol><li>元数据会被完整的复制到每一个节点上</li></ol></li></ol><hr><h5 id="0-2-5-2-数据写入"><a href="#0-2-5-2-数据写入" class="headerlink" title="0.2.5.2. 数据写入"></a>0.2.5.2. 数据写入</h5><p>在 RabbitMQ 中，数据就是队列中的消息</p><p>在普通集群模式下，消息队列中的数据仅存储于本地副本，没有什么好讲的</p><hr><h4 id="0-2-6-数据读取机制"><a href="#0-2-6-数据读取机制" class="headerlink" title="0.2.6. 数据读取机制"></a>0.2.6. 数据读取机制</h4><h5 id="0-2-6-1-元数据读取"><a href="#0-2-6-1-元数据读取" class="headerlink" title="0.2.6.1. 元数据读取"></a>0.2.6.1. 元数据读取</h5><hr><h5 id="0-2-6-2-数据读取"><a href="#0-2-6-2-数据读取" class="headerlink" title="0.2.6.2. 数据读取"></a>0.2.6.2. 数据读取</h5><hr><h4 id="0-2-7-数据冗余机制"><a href="#0-2-7-数据冗余机制" class="headerlink" title="0.2.7. 数据冗余机制"></a>0.2.7. 数据冗余机制</h4><h5 id="0-2-7-1-元数据冗余"><a href="#0-2-7-1-元数据冗余" class="headerlink" title="0.2.7.1. 元数据冗余"></a>0.2.7.1. 元数据冗余</h5><hr><h5 id="0-2-7-2-数据冗余"><a href="#0-2-7-2-数据冗余" class="headerlink" title="0.2.7.2. 数据冗余"></a>0.2.7.2. 数据冗余</h5><hr><h4 id="0-2-8-数据事务支持"><a href="#0-2-8-数据事务支持" class="headerlink" title="0.2.8. 数据事务支持"></a>0.2.8. 数据事务支持</h4><h5 id="0-2-8-1-元数据事务支持"><a href="#0-2-8-1-元数据事务支持" class="headerlink" title="0.2.8.1. 元数据事务支持"></a>0.2.8.1. 元数据事务支持</h5><hr><h5 id="0-2-8-2-数据事务支持"><a href="#0-2-8-2-数据事务支持" class="headerlink" title="0.2.8.2. 数据事务支持"></a>0.2.8.2. 数据事务支持</h5><hr><h4 id="0-2-9-负载均衡策略"><a href="#0-2-9-负载均衡策略" class="headerlink" title="0.2.9. 负载均衡策略"></a>0.2.9. 负载均衡策略</h4><p>不存在内置负载均衡策略，依靠外部负载均衡组件</p><hr><h4 id="0-2-10-故障转移机制"><a href="#0-2-10-故障转移机制" class="headerlink" title="0.2.10. 故障转移机制"></a>0.2.10. 故障转移机制</h4><p>不存在故障转移机制</p><hr><h3 id="0-3-环境限制"><a href="#0-3-环境限制" class="headerlink" title="0.3. 环境限制"></a>0.3. 环境限制</h3><hr><h3 id="0-4-环境要求"><a href="#0-4-环境要求" class="headerlink" title="0.4. 环境要求"></a>0.4. 环境要求</h3><h4 id="0-4-1-操作系统要求"><a href="#0-4-1-操作系统要求" class="headerlink" title="0.4.1. 操作系统要求"></a>0.4.1. 操作系统要求</h4><p>不依赖特定操作系统，支持在 Linux、macOS 和 Windows 环境下运行</p><hr><h4 id="0-4-2-节点要求"><a href="#0-4-2-节点要求" class="headerlink" title="0.4.2. 节点要求"></a>0.4.2. 节点要求</h4><ol><li>最小节点数量</li><li>最大节点数量<ol><li>没有硬性限制，但有软性上限</li></ol></li><li>推荐节点数量<ol><li>轻量级场景</li><li>微生产级场景</li><li>中生产级场景</li><li>高并发、高吞吐、高容量生产级场景</li></ol></li><li>节点数量奇偶<ol><li>奇数节点</li></ol></li><li>最小存活节点数量</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>为什么最大节点数量没有硬性限制，但有软性上限？<ol><li>元数据同步开销大<ol><li>当节点数量过度，每一次修改元数据的延迟都会变得非常明显</li></ol></li><li>运维成本上升<ol><li>节点越多，需要监控的就越多，运维复杂度上升，运维成本上升</li></ol></li></ol></li></ol></blockquote><hr><h4 id="0-4-3-磁盘要求"><a href="#0-4-3-磁盘要求" class="headerlink" title="0.4.3. 磁盘要求"></a>0.4.3. 磁盘要求</h4><ol><li>最小磁盘容量</li><li>推荐磁盘容量</li></ol><hr><h4 id="0-4-4-CPU-要求"><a href="#0-4-4-CPU-要求" class="headerlink" title="0.4.4. CPU 要求"></a>0.4.4. CPU 要求</h4><ol><li>最小 CPU 核心数</li><li>推荐 CPU 核心数</li></ol><hr><h4 id="0-4-5-内存要求"><a href="#0-4-5-内存要求" class="headerlink" title="0.4.5. 内存要求"></a>0.4.5. 内存要求</h4><ol><li>最小内存大小</li><li>推荐内存大小<ol><li>轻量级场景</li><li>微生产级场景</li><li>中生产级场景</li><li>高并发、高吞吐、高容量生产级场景</li></ol></li></ol><hr><h4 id="0-4-6-时间要求"><a href="#0-4-6-时间要求" class="headerlink" title="0.4.6. 时间要求"></a>0.4.6. 时间要求</h4><p>Redis 集群中的各节点之间必须保持时间同步。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在跨多集群时，时间同步更加敏感，必须进行时间同步。</li></ol></blockquote><hr><h4 id="0-4-7-用户要求"><a href="#0-4-7-用户要求" class="headerlink" title="0.4.7. 用户要求"></a>0.4.7. 用户要求</h4><p>安全起见，在生产环境中，建议新建一个专门的系统用户（例如命名为 <code>redis</code>）来运行 Redis 服务，不建议赋予其过高权限（如 root 权限），以降低安全风险。通过限制权限，可以有效防止因服务漏洞导致整个系统被攻破。</p><hr><h4 id="0-4-8-端口要求"><a href="#0-4-8-端口要求" class="headerlink" title="0.4.8. 端口要求"></a>0.4.8. 端口要求</h4><table><thead><tr><th align="center">端口</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>6379</strong></td><td align="center">TCP</td><td align="center">客户端访问端口</td></tr><tr><td align="center"><strong>6380</strong></td><td align="center">TCP</td><td align="center">客户端访问端口</td></tr><tr><td align="center"><strong>6381</strong></td><td align="center">TCP</td><td align="center">客户端访问端口</td></tr><tr><td align="center"><strong>16379</strong></td><td align="center">TCP</td><td align="center">Redis 节点间通信端口</td></tr><tr><td align="center"><strong>16380</strong></td><td align="center">TCP</td><td align="center">Redis 节点间通信端口</td></tr><tr><td align="center"><strong>16381</strong></td><td align="center">TCP</td><td align="center">Redis 节点间通信端口</td></tr></tbody></table><blockquote><p>[!NOTE] 注意事项</p><ol><li>由于我们只搭建三台服务器的集群，因此只需开放端口至 6381 和 16381。若有四台，则需开放至 6382 和 16382，以此类推</li></ol></blockquote><hr><h4 id="0-4-9-扩容要求"><a href="#0-4-9-扩容要求" class="headerlink" title="0.4.9. 扩容要求"></a>0.4.9. 扩容要求</h4><hr><h4 id="0-4-10-Swap-分区要求"><a href="#0-4-10-Swap-分区要求" class="headerlink" title="0.4.10. Swap 分区要求"></a>0.4.10. Swap 分区要求</h4><p>swap 分区，简单来说，是操作系统在系统内存不足时，将某些程序不活跃或暂时不需要的数据移动到 swap 分区（位于硬盘），以释放内存资源供当前活跃程序使用。</p><p>由于 swap 分区依赖硬盘，其读写速度远低于内存。如果系统频繁使用 swap，会造成大量磁盘 I&#x2F;O，严重影响系统性能，甚至导致系统响应迟缓或无响应。因此，在性能敏感的场景（如数据库、实时计算、大内存服务器）中，通常建议禁用 swap，确保数据始终在高速内存中运行。</p><p>我们推荐 Redis 服务器关闭 Swap 分区</p><hr><h4 id="0-4-11-节点相互解析要求"><a href="#0-4-11-节点相互解析要求" class="headerlink" title="0.4.11. 节点相互解析要求"></a>0.4.11. 节点相互解析要求</h4><p>Redis Cluster 各节点并不强制必须相互解析</p><hr><h3 id="0-5-环境准备"><a href="#0-5-环境准备" class="headerlink" title="0.5. 环境准备"></a>0.5. 环境准备</h3><h4 id="0-5-1-查看-Ubuntu-版本"><a href="#0-5-1-查看-Ubuntu-版本" class="headerlink" title="0.5.1. 查看 Ubuntu 版本"></a>0.5.1. 查看 Ubuntu 版本</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">lsb_release -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><hr><h4 id="0-5-2-节点列表"><a href="#0-5-2-节点列表" class="headerlink" title="0.5.2. 节点列表"></a>0.5.2. 节点列表</h4><table><thead><tr><th align="center">IP</th><th align="center">磁盘</th><th align="center">CPU</th><th align="center">内存</th><th align="center">主机名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">192.168.136.8</td><td align="center">Root 盘</td><td align="center">2 核</td><td align="center">4GB</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">192.168.136.9</td><td align="center">Root 盘</td><td align="center">2 核</td><td align="center">4GB</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">192.168.136.10</td><td align="center">Root 盘</td><td align="center">2 核</td><td align="center">4GB</td><td align="center"></td><td align="center"></td></tr></tbody></table><hr><h4 id="0-5-3-时间同步"><a href="#0-5-3-时间同步" class="headerlink" title="0.5.3. 时间同步"></a>0.5.3. 时间同步</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> -v chrony &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-built_in">sudo</span> apt-get install -y chrony<br><br><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> chrony &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl start chrony<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>设置代理</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 命令行临时代理<br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$http_proxy</span> &amp;&amp;<span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> NO_PROXY=<span class="hljs-variable">$no_proxy</span><br><br><br>// docker 代理<br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.96.0.1,192.168.136.0/24,10.244.0.0/16,.svc,.cluster.local&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><hr><h4 id="0-5-4-开放端口"><a href="#0-5-4-开放端口" class="headerlink" title="0.5.4. 开放端口"></a>0.5.4. 开放端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 1833<br><span class="hljs-built_in">sudo</span> ufw allow 1833/tcp<br><br>// 4369<br><span class="hljs-built_in">sudo</span> ufw allow 4369/tcp<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果使用云服务器，同样需要开放安全组</li></ol></blockquote><hr><h4 id="0-5-6-关闭-Swap-分区"><a href="#0-5-6-关闭-Swap-分区" class="headerlink" title="0.5.6. 关闭 Swap 分区"></a>0.5.6. 关闭 Swap 分区</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1. 编辑 /etc/fstab</span><br>vim <span class="hljs-regexp">/etc/</span>fstab<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># 将此内容进行注释（/swap 开头的）</span><br><span class="hljs-string"># /swap.img       none    swap    sw      0       0</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-comment"># 2. 立即关闭 Swap 分区</span><br>swapoff -a<br></code></pre></td></tr></table></figure><hr><h4 id="0-5-8-安装需要的工具"><a href="#0-5-8-安装需要的工具" class="headerlink" title="0.5.8. 安装需要的工具"></a>0.5.8. 安装需要的工具</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt <span class="hljs-keyword">install </span>-y <span class="hljs-keyword">build-essential </span>pkg-<span class="hljs-built_in">config</span> tcl make libjemalloc-dev<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>设置代理</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 命令行临时代理<br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$http_proxy</span> &amp;&amp;<span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> NO_PROXY=<span class="hljs-variable">$no_proxy</span><br><br><br>// docker 代理<br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.96.0.1,192.168.136.0/24,10.244.0.0/16,.svc,.cluster.local&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><hr><h3 id="0-6-环境搭建"><a href="#0-6-环境搭建" class="headerlink" title="0.6. 环境搭建"></a>0.6. 环境搭建</h3><h4 id="下载-Redis-安装包"><a href="#下载-Redis-安装包" class="headerlink" title="下载 Redis 安装包"></a>下载 Redis 安装包</h4><p>在 <a href="https://redis.io/downloads/#software">Redis 官方下载地址</a> 选择合适的版本（8.0），下载 <code>Redis</code> 安装包（后缀为 <code>tar.gz</code>）<br><img src="/2025/08/31/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis.png"></p><hr><h4 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h4><p>在每个节点上进行 Redis 安装：</p><p><font color="#92d050">1. 创建 &#x2F;mystudy&#x2F;redis 目录并进入</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mystudy/redis<br><br><br><span class="hljs-built_in">cd</span> /mystudy/redis<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 上传安装包</font><br>上传 <code>redis-8.0.0.tar.gz</code> 到 <code>/mystudy/redis</code></p><p><font color="#92d050">3. 解压安装包</font></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> tar -xvf redis-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.tar.gz<br><br><br><span class="hljs-attribute">mv</span> redis-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> redis<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 编译第三方库</font></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /mystudy/redis/redis/deps<br><br><br><span class="hljs-keyword">make</span> hiredis linenoise <span class="hljs-keyword">lua</span> hdr_histogram fpconv jemalloc<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 安装 Redis</font></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /mystudy/redis/redis<br><br><br><span class="hljs-keyword">make</span> &amp;&amp; <span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><p><font color="#92d050">6. 查看 Redis 是否已安装且可执行</font></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">which redis-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Redis 最终被安装到 <code>/mystudy/redis/redis</code> 目录下，但 <code>make &amp;&amp; make install</code> 会把一些 可执行文件  安装到 <code>/usr/local/bin/</code> 下：<ol><li>redis-server：<ol><li>Redis 服务器启动命令</li></ol></li><li>redis-cli：<ol><li>Redis 客户端工具</li></ol></li><li>redis-benchmark：<ol><li>Redis 性能测试工具</li></ol></li><li>redis-sentinel：<ol><li>Redis 集群相关</li></ol></li><li>redis-check-aof：<ol><li>修复有问题的 AOF 文件</li></ol></li><li>redis-check-dump：<ol><li>修复有问题的 dump.rdb 文件</li></ol></li></ol></li><li>如果编译失败，请先执行以下命令清理旧文件，然后重新安装：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mystudy/redis/redis<br><br><br>make distclean<br></code></pre></td></tr></table></figure><hr><h1 id="四、Spring-Data-Redis"><a href="#四、Spring-Data-Redis" class="headerlink" title="四、Spring Data Redis"></a>四、Spring Data Redis</h1><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="配置类配置"><a href="#配置类配置" class="headerlink" title="配置类配置"></a>配置类配置</h3><h4 id="启用注解式缓存"><a href="#启用注解式缓存" class="headerlink" title="启用注解式缓存"></a>启用注解式缓存</h4><h3 id="yml-配置"><a href="#yml-配置" class="headerlink" title="yml 配置"></a>yml 配置</h3><h4 id="数据源连接配置"><a href="#数据源连接配置" class="headerlink" title="数据源连接配置"></a>数据源连接配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:  <br>  data:  <br>    redis:  <br>      host: <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.8</span>  <br>      port: <span class="hljs-number">6379</span>  <br>      password:  <br>      database: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">1. database</font><br>database 是指 Redis 的数据库编号，其默认有 16 个逻辑库，设计初衷是用于区分不同业务，比如库 1 存 Session，库 2 存验证码，避免数据混淆。</p><p>但在实际生产中，大多数项目只用 DB 0，然后通过 Key 前缀来区分业务，例如：</p><ol><li><code>user:session:123</code></li><li><code>order:lock:456</code></li><li><code>sms:code:789</code></li></ol><p>主要原因包括：</p><ol><li>多个库并不是真正的环境隔离，仅是命令作用的划分</li><li>Redis Cluster 模式只支持 DB 0</li><li>很多客户端或中间件默认只能使用 DB 0</li></ol><hr><h4 id="连接池配置"><a href="#连接池配置" class="headerlink" title="连接池配置"></a>连接池配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">data:</span>  <br>    <span class="hljs-attr">redis:</span>  <br>      <span class="hljs-attr">lettuce:</span>  <br>        <span class="hljs-attr">pool:</span>  <br>          <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>  <br>          <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>  <br>          <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>  <br>          <span class="hljs-attr">max-wait:</span> <span class="hljs-string">-1ms</span><br></code></pre></td></tr></table></figure><hr><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><h3 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a>@EnableCaching</h3><p>在 启动类或配置类 上添加<code> @EnableCaching</code> 注解，用于 启动注解式缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MallTinyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MallTinyApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h3><p>在 类 上添加 <code>@CacheConfig</code> 注解，用于 在类级别配置统一的缓存属性，让这个类的方法在使用缓存注解时，自动继承里面设置的默认值，避免重复填写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CacheConfig &#123;<br><br>    <span class="hljs-meta">@AliasFor(&quot;cacheNames&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] cacheNames() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String <span class="hljs-title function_">keyGenerator</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">cacheResolver</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h3><p>在 方法 上 添加 <code>@Cacheable</code> 注解，用于 在方法执行前，先根据 <code>Key</code> 查询缓存，通常用于 查询 方法</p><ol><li>如果缓存中有数据，则直接取缓存，不会执行方法</li><li>如果缓存中没有数据，就正常执行方法，并把方法的返回值放进缓存中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Reflective</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Cacheable &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 指定缓存的命名空间</span><br><span class="hljs-comment">     *      2. 命名空间会与具体的业务 key 组合，形成在 Redis 中实际存储使用的完整 Key</span><br><span class="hljs-comment">     *      3. 例如 user::123，其中 user 来自命名空间（value），而 123 来自业务 key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *      1. 如果在配置类中额外设置了统一前缀，那么最终存入 Redis 的 key 可能为：mall:user::123</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     *      1. <span class="hljs-doctag">@Cacheable</span>(value = &quot;user&quot;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@AliasFor(&quot;cacheNames&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 命名空间中的业务 key（SpEL 表达式）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *      1. # 表示从上下文里取值，多数情况下就是方法参数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     *      1. <span class="hljs-doctag">@Cacheable</span>(key = &quot;#id&quot;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 指定我们自定义的业务 key 生产策略类，用来替代 SpEL 表达式生产的业务 key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Cacheable</span>(keyGenerator = &quot;myKeyGenerator&quot;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Component</span>(&quot;myKeyGenerator&quot;)</span><br><span class="hljs-comment">     * public class MyKeyGenerator implements KeyGenerator &#123;</span><br><span class="hljs-comment">     *     <span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment">     *     public Object generate(Object target, Method method, Object... params) &#123;</span><br><span class="hljs-comment">     *         // 这里我们拼一个 key，比如： 类名 + 方法名 + 第一个参数</span><br><span class="hljs-comment">     *         return target.getClass().getSimpleName() + &quot;_&quot; +</span><br><span class="hljs-comment">     *                method.getName() + &quot;_&quot; +</span><br><span class="hljs-comment">     *                (params.length &gt; 0 ? params[0] : &quot;noArg&quot;);</span><br><span class="hljs-comment">     *     &#125;</span><br><span class="hljs-comment">     * &#125;</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">keyGenerator</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 指定缓存管理器</span><br><span class="hljs-comment">     *      2. 当项目中存在多种缓存实现（例如 Redis、Caffeine 混用）时，需要通过该属性明确选择实际使用的缓存方案</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     *      1. <span class="hljs-doctag">@Cacheable</span>(cacheManager = &quot;redisCacheManager&quot;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 指定我们自定义的 CacheResolver，用于在运行时动态决定使用哪个 CacheManager</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Cacheable</span>(cacheResolver = &quot;dynamicCacheResolver&quot;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Configuration</span></span><br><span class="hljs-comment">     * public class CacheConfig &#123;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *     // 定义两个 CacheManager</span><br><span class="hljs-comment">     *     <span class="hljs-doctag">@Bean</span></span><br><span class="hljs-comment">     *     public CacheManager evenCacheManager() &#123;</span><br><span class="hljs-comment">     *         return new ConcurrentMapCacheManager(&quot;evenCache&quot;);</span><br><span class="hljs-comment">     *     &#125;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *     <span class="hljs-doctag">@Bean</span></span><br><span class="hljs-comment">     *     public CacheManager oddCacheManager() &#123;</span><br><span class="hljs-comment">     *         return new ConcurrentMapCacheManager(&quot;oddCache&quot;);</span><br><span class="hljs-comment">     *     &#125;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *     // 定义 DynamicCacheResolver</span><br><span class="hljs-comment">     *     <span class="hljs-doctag">@Bean</span></span><br><span class="hljs-comment">     *     public CacheResolver dynamicCacheResolver(CacheManager evenCacheManager, CacheManager oddCacheManager) &#123;</span><br><span class="hljs-comment">     *         return new CacheResolver() &#123;</span><br><span class="hljs-comment">     *             <span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment">     *             public Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context) &#123;</span><br><span class="hljs-comment">     *                 // 假设方法的第一个参数是 Long 型</span><br><span class="hljs-comment">     *                 Object arg = context.getArgs()[0];</span><br><span class="hljs-comment">     *                 if (arg instanceof Long &amp;&amp; ((Long) arg) % 2 == 0) &#123;</span><br><span class="hljs-comment">     *                     // 偶数 -&gt; 使用 evenCache</span><br><span class="hljs-comment">     *                     return Collections.singleton(evenCacheManager.getCache(&quot;evenCache&quot;));</span><br><span class="hljs-comment">     *                 &#125; else &#123;</span><br><span class="hljs-comment">     *                     // 其他情况 -&gt; 使用 oddCache</span><br><span class="hljs-comment">     *                     return Collections.singleton(oddCacheManager.getCache(&quot;oddCache&quot;));</span><br><span class="hljs-comment">     *                 &#125;</span><br><span class="hljs-comment">     *             &#125;</span><br><span class="hljs-comment">     *         &#125;;</span><br><span class="hljs-comment">     *     &#125;</span><br><span class="hljs-comment">     * &#125;</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">cacheResolver</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 缓存生效的条件（SpEL 表达式）</span><br><span class="hljs-comment">     *      2. 默认情况下，使用缓存注解标注的方法，每次调用都会触发缓存逻辑.但如果配置了该属性，则仅当表达式结果为 true 时才触发缓存逻辑，否则只是正常执行方法，不做缓存处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     *      1. <span class="hljs-doctag">@Cacheable</span>(condition = &quot;#id &gt; 1000&quot;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">condition</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 缓存排除条件（SpEL 表达式）</span><br><span class="hljs-comment">     *      2. 如果说 condition 是方法执行前，判断是不是走缓存逻辑，那么 unless 是方法执行后，决定返回值是否放入缓存</span><br><span class="hljs-comment">     *      3. 如果配置了该属性，当表达式为 true 时不允许返回值放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *      1. 如果只配置了 condition 而没有 unless，符合 condition 条件的方法返回值会始终写入缓存</span><br><span class="hljs-comment">     *      2. #result 统一表示方法的返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     *      1. <span class="hljs-doctag">@Cacheable</span>(unless = &quot;#result == null&quot;),如果 result 为 null，则不放入缓存</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">unless</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 作用</span><br><span class="hljs-comment">     *      1. 是否开启同步缓存模式，也就是当多个线程同时调用同一个 key 时，如果缓存不存在会不会 “一窝蜂” 都去执行方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 常用值</span><br><span class="hljs-comment">     *      1. true</span><br><span class="hljs-comment">     *          1. 同一时间只有一个线程执行方法，其他线程阻塞等待结果</span><br><span class="hljs-comment">     *      2. false</span><br><span class="hljs-comment">     *          1. 多个线程同时击穿缓存，全部查数据库</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 注意事项</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 使用示例</span><br><span class="hljs-comment">     *      1. <span class="hljs-doctag">@Cacheable</span>(sync = true)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h3><p>在 方法 上添加 <code>@CachePut</code> 注解，用于 在方法执行后，根据 <code>Key</code> 将方法返回值强制写入缓存，并覆盖已有缓存内容，通常用于 新增或更新 方法</p><p>需要注意的是，它与 <code>@Cacheable</code> 不同，即使缓存中已存在对应数据，标注了 <code>@CachePut</code> 的方法也一定会被执行，不会因缓存命中而跳过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Reflective</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CachePut &#123;<br><br>    <span class="hljs-meta">@AliasFor(&quot;cacheNames&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">keyGenerator</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">cacheResolver</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">condition</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">unless</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h3><p>在 方法 上添加 <code>@CacheEvict</code> 注解，用于 在方法执行后，根据 <code>Key</code> 将缓存删除，通常用于 删除 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Reflective</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CacheEvict &#123;<br><br>    <span class="hljs-meta">@AliasFor(&quot;cacheNames&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] cacheNames() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">keyGenerator</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">cacheResolver</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">condition</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 作用</span><br><span class="hljs-comment"> *      1. 是否清空整个命名空间里的所有 key</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 常用值</span><br><span class="hljs-comment"> *      1. true</span><br><span class="hljs-comment"> *          1. 清空整个命名空间里的所有业务 key 对应的缓存</span><br><span class="hljs-comment"> *      2. false</span><br><span class="hljs-comment"> *          1. 只清空当前业务 key 对应的缓存</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 使用示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CacheEvict</span>(allEntries = true)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">allEntries</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 作用</span><br><span class="hljs-comment"> *      1. 是否在方法执行前就清空缓存</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 常用值</span><br><span class="hljs-comment"> *      1. true</span><br><span class="hljs-comment"> *          1. 在方法执行前就清空缓存</span><br><span class="hljs-comment"> *      2. false</span><br><span class="hljs-comment"> *          1. 在方法执行后清空缓存</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CacheEvict</span>(key = &quot;#id&quot;, beforeInvocation = true)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">beforeInvocation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h3><p>由于在同一个方法上，Spring 不支持直接标注多个相同的注解，例如标注多个 @Cacheable，后面的会覆盖前面的</p><p>在 方法 上添加 @Caching 注解，用于 将多个注解打包在一起，在一个方法上同时标注多个相同的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Reflective</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Caching &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 作用</span><br><span class="hljs-comment"> *      1. 打包多个 <span class="hljs-doctag">@Cacheable</span> 注解</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 常用值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Caching</span>(</span><br><span class="hljs-comment"> *     cacheable = &#123;</span><br><span class="hljs-comment"> *         <span class="hljs-doctag">@Cacheable</span>(value = &quot;userCache&quot;, key = &quot;#id&quot;),</span><br><span class="hljs-comment"> *         <span class="hljs-doctag">@Cacheable</span>(value = &quot;userNameCache&quot;, key = &quot;#id&quot;)</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * )</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br>    Cacheable[] cacheable() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    CachePut[] put() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    CacheEvict[] evict() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h3><p>创建时：</p><ol><li>Web：<ol><li>Spring Web</li></ol></li><li>NoSQL<ol><li>Spring Data Redis</li></ol></li></ol><hr><h3 id="进行相关配置"><a href="#进行相关配置" class="headerlink" title="进行相关配置"></a>进行相关配置</h3><p>详见上文：相关配置</p><hr><h3 id="执行业务逻辑"><a href="#执行业务逻辑" class="headerlink" title="执行业务逻辑"></a>执行业务逻辑</h3><hr><h2 id="业务处理"><a href="#业务处理" class="headerlink" title="业务处理"></a>业务处理</h2><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><h4 id="缓存预热概述"><a href="#缓存预热概述" class="headerlink" title="缓存预热概述"></a>缓存预热概述</h4><p>在系统刚启动或者 Redis 刚部署&#x2F;重启后，就提前把热点数据加载到 Redis 缓存里，而不是等用户第一次访问时才去查询数据库再写入缓存</p><hr><h4 id="缓存预热实现方式"><a href="#缓存预热实现方式" class="headerlink" title="缓存预热实现方式"></a>缓存预热实现方式</h4><h5 id="定时任务预热"><a href="#定时任务预热" class="headerlink" title="定时任务预热"></a>定时任务预热</h5><hr><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="缓存雪崩概述"><a href="#缓存雪崩概述" class="headerlink" title="缓存雪崩概述"></a>缓存雪崩概述</h4><p>在 Redis 中，缓存的数据通常会设置过期时间（TTL），如果某一类数据（比如热点商品、热门文章）<strong>同一时间大批量过期</strong>，短时间内所有请求都查不到缓存，于是全部请求都去数据库，数据库压力激增，可能直接崩溃</p><hr><h4 id="缓存雪崩解决方案"><a href="#缓存雪崩解决方案" class="headerlink" title="缓存雪崩解决方案"></a>缓存雪崩解决方案</h4><h5 id="缓存过期时间随机化"><a href="#缓存过期时间随机化" class="headerlink" title="缓存过期时间随机化"></a>缓存过期时间随机化</h5><p>给缓存设置过期时间时，加上一个随机值（比如 <code>random(0, 300)</code>），避免大量 key 在同一时间点集中失效</p><hr><ul><li><p><strong>过期时间随机化（错峰过期）</strong></p><ul><li><p>给缓存设置过期时间时，加上一个随机值（比如 <code>+ random(0, 300)</code> 秒）</p></li><li><p>避免大量 key 在同一时间点集中失效</p></li></ul></li><li><p><strong>缓存永不过期 + 后台异步更新</strong></p><ul><li><p>Redis 层面不设置过期时间</p></li><li><p>用定时任务&#x2F;消息通知去更新缓存</p></li><li><p>前端查询时永远有数据，不会出现大面积空缓存</p></li></ul></li><li><p><strong>热点数据加锁重建（互斥锁）</strong></p><ul><li><p>当缓存失效时，只有第一个线程去数据库加载数据</p></li><li><p>其他线程等待，避免同时打 DB</p></li><li><p>可以用 Redis 的分布式锁实现</p></li></ul></li><li><p><strong>多级缓存（本地缓存 + 分布式缓存）</strong></p><ul><li><p>比如 Guava Caffeine（JVM 内存） + Redis</p></li><li><p>当 Redis 数据过期，本地缓存还能顶一顶，缓冲数据库压力</p></li></ul></li><li><p><strong>缓存预热</strong>（结合前面说的）</p><ul><li><p>在系统上线或缓存重启后，提前加载热点数据到缓存</p></li><li><p>避免冷启动时，全部请求穿透到数据库</p></li></ul></li><li><p><strong>服务限流 &amp; 降级</strong></p><ul><li><p>在极端情况下，限制流量进入数据库</p></li><li><p>或者直接返回兜底数据（比如提示“系统繁忙”）</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>非关系型数据库</category>
      
      <category>键值型</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：RejectedExecutionHandler 源码解析</title>
    <link href="/2025/08/30/%E6%BA%90%E7%A0%81%EF%BC%9ARejectedExecutionHandler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/30/%E6%BA%90%E7%A0%81%EF%BC%9ARejectedExecutionHandler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>RejectedExecutionHandler</code> 是一个接口。是专门用来处理 <strong>线程池无法接受新任务时该怎么办</strong> 的策略</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-接口方法"><a href="#4-接口方法" class="headerlink" title="4. 接口方法"></a>4. 接口方法</h2><h3 id="4-1-接口方法（无）"><a href="#4-1-接口方法（无）" class="headerlink" title="4.1. 接口方法（无）"></a>4.1. 接口方法（无）</h3><h4 id="void-rejectedExecution-Runnable-r-ThreadPoolExecutor-executor"><a href="#void-rejectedExecution-Runnable-r-ThreadPoolExecutor-executor" class="headerlink" title="void rejectedExecution(Runnable r, ThreadPoolExecutor executor)"></a>void rejectedExecution(Runnable r, ThreadPoolExecutor executor)</h4><h5 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h5><p><code>void rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 编写拒绝策略的具体逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoREH</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;<br>        <span class="hljs-comment">// 这里我们做一个简单处理：输出提示信息</span><br>        System.err.println(<span class="hljs-string">&quot;任务 &quot;</span> + r.toString() + <span class="hljs-string">&quot; 被拒绝执行！&quot;</span> +<br>                <span class="hljs-string">&quot; 当前线程池大小: &quot;</span> + executor.getPoolSize() +<br>                <span class="hljs-string">&quot;, 活跃线程数: &quot;</span> + executor.getActiveCount() +<br>                <span class="hljs-string">&quot;, 队列长度: &quot;</span> + executor.getQueue().size());<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-实现示例"><a href="#5-实现示例" class="headerlink" title="5. 实现示例"></a>5. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoREH</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;<br>        <span class="hljs-comment">// 这里我们做一个简单处理：输出提示信息</span><br>        System.err.println(<span class="hljs-string">&quot;任务 &quot;</span> + r.toString() + <span class="hljs-string">&quot; 被拒绝执行！&quot;</span> +<br>                <span class="hljs-string">&quot; 当前线程池大小: &quot;</span> + executor.getPoolSize() +<br>                <span class="hljs-string">&quot;, 活跃线程数: &quot;</span> + executor.getActiveCount() +<br>                <span class="hljs-string">&quot;, 队列长度: &quot;</span> + executor.getQueue().size());<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-内置实现"><a href="#6-内置实现" class="headerlink" title="6. 内置实现"></a>6. 内置实现</h2><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p><code>AbortPolicy</code> 是 <code>ThreadPoolExecutor</code> 的静态内部类，直接抛出 <code>RejectedExecutionException</code> 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br> <span class="hljs-string">&quot; rejected from &quot;</span> +<br> e.toString());<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p><code>CallerRunsPolicy</code> 是 <code>ThreadPoolExecutor</code> 的静态内部类，如果线程池没关闭，<code>CallerRunsPolicy</code> 会让提交任务的线程（当前线程）直接执行，而不去线程池中找线程执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>r.run();<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p><code>DiscardPolicy</code> 是 <code>ThreadPoolExecutor</code> 的静态内部类，直接将任务丢弃，适用于允许丢任务的场景（例如日志采集，不必 100% 保证）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p><code>DiscardOldestPolicy</code> 是 <code>ThreadPoolExecutor</code> 的静态内部类，如果线程池没关闭，<code>DiscardOldestPolicy</code> 会踢掉队列里最老的任务，再尝试把新任务塞进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>e.getQueue().poll();<br>e.execute(r);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：ThreadFactory 源码解析</title>
    <link href="/2025/08/30/%E6%BA%90%E7%A0%81%EF%BC%9AThreadFactory%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/30/%E6%BA%90%E7%A0%81%EF%BC%9AThreadFactory%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>ThreadFactory</code> 是一个接口。负责如何创建线程</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-接口方法"><a href="#6-接口方法" class="headerlink" title="6. 接口方法"></a>6. 接口方法</h2><h3 id="6-1-接口方法（无）"><a href="#6-1-接口方法（无）" class="headerlink" title="6.1. 接口方法（无）"></a>6.1. 接口方法（无）</h3><h4 id="Thread-newThread-Runnable-r"><a href="#Thread-newThread-Runnable-r" class="headerlink" title="Thread newThread(Runnable r)"></a>Thread newThread(Runnable r)</h4><h5 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h5><p><code>Thread newThread(Runnable r)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 编写如何创建线程的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部类实现</span><br><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;Worker-&quot;</span> + count++);<br>&#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：IDEA</title>
    <link href="/2025/08/30/%E7%AC%94%E8%AE%B0%EF%BC%9AIDEA/"/>
    <url>/2025/08/30/%E7%AC%94%E8%AE%B0%EF%BC%9AIDEA/</url>
    
    <content type="html"><![CDATA[<h2 id="Code-Copy-To-Obsidian"><a href="#Code-Copy-To-Obsidian" class="headerlink" title="Code Copy To Obsidian"></a>Code Copy To Obsidian</h2><p><img src="/2025/08/30/%E7%AC%94%E8%AE%B0%EF%BC%9AIDEA/%E7%AC%94%E8%AE%B0%EF%BC%9AIDEA.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>办公工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Windows</title>
    <link href="/2025/08/30/%E7%AC%94%E8%AE%B0%EF%BC%9AWindows/"/>
    <url>/2025/08/30/%E7%AC%94%E8%AE%B0%EF%BC%9AWindows/</url>
    
    <content type="html"><![CDATA[<h2 id="输入法显示"><a href="#输入法显示" class="headerlink" title="输入法显示"></a>输入法显示</h2><p>详见笔记：输入法显示小工具<br>    1. obsidian 内部链接：<br>        1. <a href="%E8%BE%93%E5%85%A5%E6%B3%95%E6%98%BE%E7%A4%BA%E5%B0%8F%E5%B7%A5%E5%85%B7.md">输入法显示小工具</a><br>    2. Hexo 链接：<br>        1. </p><hr>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>输入法显示小工具</title>
    <link href="/2025/08/30/%E8%BE%93%E5%85%A5%E6%B3%95%E6%98%BE%E7%A4%BA%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2025/08/30/%E8%BE%93%E5%85%A5%E6%B3%95%E6%98%BE%E7%A4%BA%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Py-代码"><a href="#1-Py-代码" class="headerlink" title="1. Py 代码"></a>1. Py 代码</h2><p>创建 <code>输入法显示小工具.py</code> 并编写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ime_status_tk.py</span><br><span class="hljs-comment"># Windows only. Cute floating IME + Caps widget using tkinter + ctypes. No 3rd-party deps.</span><br><span class="hljs-comment"># Fix: remove global KB low-level hook; use WinEvent foreground hook; never touch Tk outside main thread.</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> ctypes<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> wintypes<br><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass<br><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">if</span> sys.platform != <span class="hljs-string">&quot;win32&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This widget currently supports Windows only.&quot;</span>)<br>    sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># ---------------- Windows APIs ----------------</span><br>user32 = ctypes.WinDLL(<span class="hljs-string">&quot;user32&quot;</span>, use_last_error=<span class="hljs-literal">True</span>)<br>imm32 = ctypes.WinDLL(<span class="hljs-string">&quot;imm32&quot;</span>, use_last_error=<span class="hljs-literal">True</span>)<br>kernel32 = ctypes.WinDLL(<span class="hljs-string">&quot;kernel32&quot;</span>, use_last_error=<span class="hljs-literal">True</span>)<br><br>HWND = wintypes.HWND<br>DWORD = wintypes.DWORD<br>BOOL = wintypes.BOOL<br>HKL = <span class="hljs-built_in">getattr</span>(wintypes, <span class="hljs-string">&quot;HKL&quot;</span>, wintypes.HANDLE)<br>HIMC = wintypes.HANDLE<br>UINT = wintypes.UINT<br>LONG = wintypes.LONG<br>HMODULE = wintypes.HMODULE<br>HANDLE = wintypes.HANDLE<br><br><span class="hljs-comment"># Foreground window + keyboard layout</span><br>user32.GetForegroundWindow.restype = HWND<br>user32.GetForegroundWindow.argtypes = []<br><br>user32.GetWindowThreadProcessId.restype = DWORD<br>user32.GetWindowThreadProcessId.argtypes = [HWND, ctypes.POINTER(DWORD)]<br><br>user32.GetKeyboardLayout.restype = HKL<br>user32.GetKeyboardLayout.argtypes = [DWORD]<br><br>user32.GetKeyState.restype = ctypes.c_short<br>user32.GetKeyState.argtypes = [ctypes.c_int]<br><br><span class="hljs-comment"># IMM32</span><br>imm32.ImmGetContext.restype = HIMC<br>imm32.ImmGetContext.argtypes = [HWND]<br><br>imm32.ImmReleaseContext.restype = BOOL<br>imm32.ImmReleaseContext.argtypes = [HWND, HIMC]<br><br>imm32.ImmGetOpenStatus.restype = BOOL<br>imm32.ImmGetOpenStatus.argtypes = [HIMC]<br><br>imm32.ImmGetConversionStatus.restype = BOOL<br>imm32.ImmGetConversionStatus.argtypes = [HIMC, ctypes.POINTER(DWORD), ctypes.POINTER(DWORD)]<br><br>imm32.ImmGetDefaultIMEWnd.restype = HWND<br>imm32.ImmGetDefaultIMEWnd.argtypes = [HWND]<br><br><span class="hljs-comment"># Messages</span><br>user32.SendMessageW.restype = wintypes.LPARAM<br>user32.SendMessageW.argtypes = [HWND, UINT, wintypes.WPARAM, wintypes.LPARAM]<br><br><span class="hljs-comment"># WinEvent hook for foreground window changes (Alt+Tab / Win+Tab)</span><br>WINEVENTPROC = ctypes.WINFUNCTYPE(<span class="hljs-literal">None</span>, HANDLE, DWORD, HWND, LONG, LONG, DWORD, DWORD)<br>user32.SetWinEventHook.restype = HANDLE<br>user32.SetWinEventHook.argtypes = [DWORD, DWORD, HMODULE, WINEVENTPROC, DWORD, DWORD, DWORD]<br>user32.UnhookWinEvent.restype = BOOL<br>user32.UnhookWinEvent.argtypes = [HANDLE]<br><br>EVENT_SYSTEM_FOREGROUND = <span class="hljs-number">0x0003</span><br>WINEVENT_OUTOFCONTEXT = <span class="hljs-number">0x0000</span><br>WINEVENT_SKIPOWNPROCESS = <span class="hljs-number">0x0002</span><br><br><span class="hljs-comment"># Constants</span><br>VK_CAPITAL = <span class="hljs-number">0x14</span><br><br><span class="hljs-comment"># IMM32 conversion flag</span><br>IME_CMODE_NATIVE = <span class="hljs-number">0x0001</span><br><br><span class="hljs-comment"># WM_IME_CONTROL</span><br>WM_IME_CONTROL = <span class="hljs-number">0x0283</span><br>IMC_GETCONVERSIONMODE = <span class="hljs-number">0x0001</span><br>IMC_GETOPENSTATUS = <span class="hljs-number">0x0005</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loword</span>(<span class="hljs-params">dword</span>):<br>    <span class="hljs-keyword">return</span> dword &amp; <span class="hljs-number">0xFFFF</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_lang_tag_from_hkl</span>(<span class="hljs-params">hkl_val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    lang = loword(hkl_val)<br>    mapping = &#123;<br>        <span class="hljs-number">0x0804</span>: <span class="hljs-string">&quot;ZH&quot;</span>, <span class="hljs-number">0x0004</span>: <span class="hljs-string">&quot;ZH&quot;</span>, <span class="hljs-number">0x0404</span>: <span class="hljs-string">&quot;ZH&quot;</span>, <span class="hljs-number">0x0C04</span>: <span class="hljs-string">&quot;ZH&quot;</span>,<br>        <span class="hljs-number">0x0409</span>: <span class="hljs-string">&quot;EN&quot;</span>, <span class="hljs-number">0x0809</span>: <span class="hljs-string">&quot;EN&quot;</span>,<br>        <span class="hljs-number">0x0411</span>: <span class="hljs-string">&quot;JA&quot;</span>, <span class="hljs-number">0x0412</span>: <span class="hljs-string">&quot;KO&quot;</span>,<br>        <span class="hljs-number">0x0C0A</span>: <span class="hljs-string">&quot;ES&quot;</span>, <span class="hljs-number">0x0407</span>: <span class="hljs-string">&quot;DE&quot;</span>, <span class="hljs-number">0x040C</span>: <span class="hljs-string">&quot;FR&quot;</span>, <span class="hljs-number">0x0419</span>: <span class="hljs-string">&quot;RU&quot;</span>,<br>    &#125;<br>    <span class="hljs-keyword">return</span> mapping.get(lang, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;lang:04X&#125;</span>&quot;</span>)<br><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyboardState</span>:<br>    lang_tag: <span class="hljs-built_in">str</span><br>    is_zh_layout: <span class="hljs-built_in">bool</span><br>    ime_open: <span class="hljs-built_in">bool</span><br>    ime_native: <span class="hljs-built_in">bool</span><br>    caps_on: <span class="hljs-built_in">bool</span><br>    hkl: <span class="hljs-built_in">int</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query_ime_via_himc</span>(<span class="hljs-params">hwnd: HWND</span>):<br>    ime_open = <span class="hljs-literal">None</span><br>    ime_native = <span class="hljs-literal">None</span><br>    himc = imm32.ImmGetContext(hwnd)<br>    <span class="hljs-keyword">if</span> himc:<br>        <span class="hljs-keyword">try</span>:<br>            open_status = imm32.ImmGetOpenStatus(himc)<br>            ime_open = <span class="hljs-built_in">bool</span>(open_status)<br>            <span class="hljs-keyword">if</span> ime_open:<br>                conv = DWORD(<span class="hljs-number">0</span>)<br>                sent = DWORD(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> imm32.ImmGetConversionStatus(himc, ctypes.byref(conv), ctypes.byref(sent)):<br>                    ime_native = <span class="hljs-built_in">bool</span>(conv.value &amp; IME_CMODE_NATIVE)<br>        <span class="hljs-keyword">finally</span>:<br>            imm32.ImmReleaseContext(hwnd, himc)<br>    <span class="hljs-keyword">return</span> ime_open, ime_native<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query_ime_via_imewnd</span>(<span class="hljs-params">hwnd: HWND</span>):<br>    ime_wnd = imm32.ImmGetDefaultIMEWnd(hwnd)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ime_wnd:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>    open_status = user32.SendMessageW(ime_wnd, WM_IME_CONTROL, IMC_GETOPENSTATUS, <span class="hljs-number">0</span>)<br>    conv_mode = user32.SendMessageW(ime_wnd, WM_IME_CONTROL, IMC_GETCONVERSIONMODE, <span class="hljs-number">0</span>)<br>    ime_open = <span class="hljs-built_in">bool</span>(open_status)<br>    ime_native = <span class="hljs-built_in">bool</span>(conv_mode &amp; IME_CMODE_NATIVE)<br>    <span class="hljs-keyword">return</span> ime_open, ime_native<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_keyboard_state</span>() -&gt; KeyboardState:<br>    hwnd = user32.GetForegroundWindow()<br>    pid = DWORD(<span class="hljs-number">0</span>)<br>    thread_id = user32.GetWindowThreadProcessId(hwnd, ctypes.byref(pid))<br>    hkl = user32.GetKeyboardLayout(thread_id)<br>    hkl_val = ctypes.cast(hkl, ctypes.c_void_p).value <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br><br>    lang_tag = get_lang_tag_from_hkl(hkl_val)<br>    is_zh_layout = lang_tag == <span class="hljs-string">&quot;ZH&quot;</span><br><br>    caps_on = <span class="hljs-built_in">bool</span>(user32.GetKeyState(VK_CAPITAL) &amp; <span class="hljs-number">0x0001</span>)<br><br>    ime_open, ime_native = (<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">if</span> hwnd:<br>        o1, n1 = query_ime_via_himc(hwnd)<br>        <span class="hljs-keyword">if</span> o1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> n1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            o2, n2 = query_ime_via_imewnd(hwnd)<br>            <span class="hljs-keyword">if</span> o2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: ime_open = o2<br>            <span class="hljs-keyword">if</span> n2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: ime_native = n2<br>        <span class="hljs-keyword">else</span>:<br>            ime_open, ime_native = o1, n1<br><br>    <span class="hljs-keyword">return</span> KeyboardState(<br>        lang_tag=lang_tag,<br>        is_zh_layout=is_zh_layout,<br>        ime_open=<span class="hljs-built_in">bool</span>(ime_open),<br>        ime_native=<span class="hljs-built_in">bool</span>(ime_native),<br>        caps_on=caps_on,<br>        hkl=hkl_val,<br>    )<br><br><span class="hljs-comment"># ---------------- UI (tkinter) ----------------</span><br><br>THEMES = &#123;<br>    <span class="hljs-string">&quot;Milk&quot;</span>:   &#123;<span class="hljs-string">&quot;bg&quot;</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>, <span class="hljs-string">&quot;face&quot;</span>: <span class="hljs-string">&quot;#f5f5f5&quot;</span>, <span class="hljs-string">&quot;outline&quot;</span>: <span class="hljs-string">&quot;#e9e9ef&quot;</span>, <span class="hljs-string">&quot;face_fg&quot;</span>: <span class="hljs-string">&quot;#444&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;Glass&quot;</span>:  &#123;<span class="hljs-string">&quot;bg&quot;</span>: <span class="hljs-string">&quot;#f4f7ff&quot;</span>, <span class="hljs-string">&quot;face&quot;</span>: <span class="hljs-string">&quot;#eef1f7&quot;</span>, <span class="hljs-string">&quot;outline&quot;</span>: <span class="hljs-string">&quot;#dbe3ff&quot;</span>, <span class="hljs-string">&quot;face_fg&quot;</span>: <span class="hljs-string">&quot;#445&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;Mint&quot;</span>:   &#123;<span class="hljs-string">&quot;bg&quot;</span>: <span class="hljs-string">&quot;#eefaf5&quot;</span>, <span class="hljs-string">&quot;face&quot;</span>: <span class="hljs-string">&quot;#e4f3ec&quot;</span>, <span class="hljs-string">&quot;outline&quot;</span>: <span class="hljs-string">&quot;#cfe8db&quot;</span>, <span class="hljs-string">&quot;face_fg&quot;</span>: <span class="hljs-string">&quot;#355&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;Blush&quot;</span>:  &#123;<span class="hljs-string">&quot;bg&quot;</span>: <span class="hljs-string">&quot;#fff4f7&quot;</span>, <span class="hljs-string">&quot;face&quot;</span>: <span class="hljs-string">&quot;#ffeaf0&quot;</span>, <span class="hljs-string">&quot;outline&quot;</span>: <span class="hljs-string">&quot;#ffd6e1&quot;</span>, <span class="hljs-string">&quot;face_fg&quot;</span>: <span class="hljs-string">&quot;#544&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;Ink&quot;</span>:    &#123;<span class="hljs-string">&quot;bg&quot;</span>: <span class="hljs-string">&quot;#2b2f3a&quot;</span>, <span class="hljs-string">&quot;face&quot;</span>: <span class="hljs-string">&quot;#3a404f&quot;</span>, <span class="hljs-string">&quot;outline&quot;</span>: <span class="hljs-string">&quot;#151821&quot;</span>, <span class="hljs-string">&quot;face_fg&quot;</span>: <span class="hljs-string">&quot;#eef&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CuteIMEWidget</span>(tk.Tk):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.title(<span class="hljs-string">&quot;IME Status&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.overrideredirect(<span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.wm_attributes(<span class="hljs-string">&quot;-topmost&quot;</span>, <span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.wm_attributes(<span class="hljs-string">&quot;-toolwindow&quot;</span>, <span class="hljs-literal">True</span>)<br><br>        <span class="hljs-variable language_">self</span>.TRANSPARENT = <span class="hljs-string">&quot;#11FF11&quot;</span><br>        <span class="hljs-variable language_">self</span>.configure(bg=<span class="hljs-variable language_">self</span>.TRANSPARENT)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-variable language_">self</span>.wm_attributes(<span class="hljs-string">&quot;-transparentcolor&quot;</span>, <span class="hljs-variable language_">self</span>.TRANSPARENT)<br>        <span class="hljs-keyword">except</span> tk.TclError:<br>            <span class="hljs-variable language_">self</span>.TRANSPARENT = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># Base metrics -&gt; scalable</span><br>        <span class="hljs-variable language_">self</span>.base = &#123;<br>            <span class="hljs-string">&quot;margin&quot;</span>: <span class="hljs-number">12</span>, <span class="hljs-string">&quot;gap&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&quot;h&quot;</span>: <span class="hljs-number">56</span>, <span class="hljs-string">&quot;radius&quot;</span>: <span class="hljs-number">18</span>,<br>            <span class="hljs-string">&quot;face_w&quot;</span>: <span class="hljs-number">38</span>, <span class="hljs-string">&quot;chip1_w&quot;</span>: <span class="hljs-number">84</span>, <span class="hljs-string">&quot;chip2_w&quot;</span>: <span class="hljs-number">84</span>,<br>            <span class="hljs-string">&quot;font_main&quot;</span>: <span class="hljs-number">11</span>, <span class="hljs-string">&quot;font_face&quot;</span>: <span class="hljs-number">16</span>,<br>        &#125;<br>        <span class="hljs-variable language_">self</span>.scale = <span class="hljs-number">1.0</span><br>        <span class="hljs-variable language_">self</span>._apply_metrics()<br><br>        <span class="hljs-comment"># Theme</span><br>        <span class="hljs-variable language_">self</span>.theme_name = <span class="hljs-string">&quot;Milk&quot;</span><br>        <span class="hljs-variable language_">self</span>.theme = THEMES[<span class="hljs-variable language_">self</span>.theme_name]<br><br>        <span class="hljs-comment"># Canvas</span><br>        <span class="hljs-variable language_">self</span>.canvas = tk.Canvas(<span class="hljs-variable language_">self</span>, width=<span class="hljs-variable language_">self</span>.total_w, height=<span class="hljs-variable language_">self</span>.total_h,<br>                                bg=<span class="hljs-variable language_">self</span>.TRANSPARENT <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.TRANSPARENT <span class="hljs-keyword">else</span> <span class="hljs-variable language_">self</span>.theme[<span class="hljs-string">&quot;bg&quot;</span>],<br>                                highlightthickness=<span class="hljs-number">0</span>, bd=<span class="hljs-number">0</span>)<br>        <span class="hljs-variable language_">self</span>.canvas.pack()<br><br>        <span class="hljs-comment"># Initial position near top-right</span><br>        <span class="hljs-variable language_">self</span>.update_idletasks()<br>        sw = <span class="hljs-variable language_">self</span>.winfo_screenwidth()<br>        x = sw - <span class="hljs-built_in">int</span>(<span class="hljs-variable language_">self</span>.total_w) - <span class="hljs-number">24</span><br>        y = <span class="hljs-number">24</span><br>        <span class="hljs-variable language_">self</span>.geometry(<span class="hljs-string">f&quot;+<span class="hljs-subst">&#123;x&#125;</span>+<span class="hljs-subst">&#123;y&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># Move / resize state</span><br>        <span class="hljs-variable language_">self</span>._drag_offset = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._resizing = <span class="hljs-literal">False</span><br>        <span class="hljs-variable language_">self</span>._resize_start = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># Context menu</span><br>        <span class="hljs-variable language_">self</span>.menu = tk.Menu(<span class="hljs-variable language_">self</span>, tearoff=<span class="hljs-number">0</span>)<br>        theme_menu = tk.Menu(<span class="hljs-variable language_">self</span>.menu, tearoff=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># Use a shared tk variable so radio marks reflect current theme</span><br>        <span class="hljs-variable language_">self</span>._theme_var = tk.StringVar(value=<span class="hljs-variable language_">self</span>.theme_name)<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> THEMES.keys():<br>            theme_menu.add_radiobutton(<br>                label=name, variable=<span class="hljs-variable language_">self</span>._theme_var, value=name,<br>                command=<span class="hljs-keyword">lambda</span> n=name: <span class="hljs-variable language_">self</span>.set_theme(n)<br>            )<br>        <span class="hljs-variable language_">self</span>.menu.add_cascade(label=<span class="hljs-string">&quot;主题&quot;</span>, menu=theme_menu)<br>        <span class="hljs-variable language_">self</span>.menu.add_separator()<br>        <span class="hljs-variable language_">self</span>.menu.add_command(label=<span class="hljs-string">&quot;退出&quot;</span>, command=<span class="hljs-variable language_">self</span>.destroy)<br><br>        <span class="hljs-comment"># Draw UI</span><br>        <span class="hljs-variable language_">self</span>._draw_ui()<br><br>        <span class="hljs-comment"># State + loop scheduler</span><br>        <span class="hljs-variable language_">self</span>._last_key = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._burst_ticks = <span class="hljs-number">0</span>  <span class="hljs-comment"># when &gt;0, loop interval becomes faster</span><br>        <span class="hljs-variable language_">self</span>._loop()           <span class="hljs-comment"># start update loop</span><br><br>        <span class="hljs-comment"># Bindings</span><br>        <span class="hljs-variable language_">self</span>.canvas.bind(<span class="hljs-string">&quot;&lt;Button-1&gt;&quot;</span>, <span class="hljs-variable language_">self</span>._on_press)<br>        <span class="hljs-variable language_">self</span>.canvas.bind(<span class="hljs-string">&quot;&lt;B1-Motion&gt;&quot;</span>, <span class="hljs-variable language_">self</span>._on_drag)<br>        <span class="hljs-variable language_">self</span>.canvas.bind(<span class="hljs-string">&quot;&lt;ButtonRelease-1&gt;&quot;</span>, <span class="hljs-variable language_">self</span>._on_release)<br>        <span class="hljs-variable language_">self</span>.canvas.bind(<span class="hljs-string">&quot;&lt;Button-3&gt;&quot;</span>, <span class="hljs-variable language_">self</span>._on_context)<br>        <span class="hljs-variable language_">self</span>.canvas.bind(<span class="hljs-string">&quot;&lt;Motion&gt;&quot;</span>, <span class="hljs-variable language_">self</span>._on_motion)<br>        <span class="hljs-variable language_">self</span>.bind(<span class="hljs-string">&quot;&lt;Escape&gt;&quot;</span>, <span class="hljs-keyword">lambda</span> e: <span class="hljs-variable language_">self</span>.destroy())<br><br>        <span class="hljs-comment"># Install foreground WinEvent hook (Alt+Tab / Win+Tab)</span><br>        <span class="hljs-variable language_">self</span>._we_hook = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._we_proc = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._install_foreground_hook()<br><br>        <span class="hljs-comment"># Cleanups</span><br>        <span class="hljs-variable language_">self</span>.protocol(<span class="hljs-string">&quot;WM_DELETE_WINDOW&quot;</span>, <span class="hljs-variable language_">self</span>.destroy)<br><br>    <span class="hljs-comment"># ----- metrics and layout -----</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_apply_metrics</span>(<span class="hljs-params">self</span>):<br>        s = <span class="hljs-variable language_">self</span>.scale<br>        b = <span class="hljs-variable language_">self</span>.base<br>        <span class="hljs-variable language_">self</span>.margin = <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;margin&quot;</span>] * s)<br>        <span class="hljs-variable language_">self</span>.gap = <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;gap&quot;</span>] * s)<br>        <span class="hljs-variable language_">self</span>.h = <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;h&quot;</span>] * s)<br>        <span class="hljs-variable language_">self</span>.radius = <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;radius&quot;</span>] * s)<br>        <span class="hljs-variable language_">self</span>.face_w = <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;face_w&quot;</span>] * s)<br>        <span class="hljs-variable language_">self</span>.chip1_w = <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;chip1_w&quot;</span>] * s)<br>        <span class="hljs-variable language_">self</span>.chip2_w = <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;chip2_w&quot;</span>] * s)<br>        <span class="hljs-variable language_">self</span>.font_main = <span class="hljs-built_in">max</span>(<span class="hljs-number">9</span>, <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;font_main&quot;</span>] * s))<br>        <span class="hljs-variable language_">self</span>.font_face = <span class="hljs-built_in">max</span>(<span class="hljs-number">12</span>, <span class="hljs-built_in">int</span>(b[<span class="hljs-string">&quot;font_face&quot;</span>] * s))<br><br>        <span class="hljs-variable language_">self</span>.total_w = <span class="hljs-variable language_">self</span>.margin*<span class="hljs-number">2</span> + <span class="hljs-variable language_">self</span>.face_w + <span class="hljs-variable language_">self</span>.gap + <span class="hljs-variable language_">self</span>.chip1_w + <span class="hljs-variable language_">self</span>.gap + <span class="hljs-variable language_">self</span>.chip2_w<br>        <span class="hljs-variable language_">self</span>.total_h = <span class="hljs-variable language_">self</span>.h + <span class="hljs-variable language_">self</span>.margin*<span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_theme</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-variable language_">self</span>.theme_name = name<br>        <span class="hljs-variable language_">self</span>._theme_var.<span class="hljs-built_in">set</span>(name)<br>        <span class="hljs-variable language_">self</span>.theme = THEMES[name]<br>        <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.container, fill=<span class="hljs-variable language_">self</span>.theme[<span class="hljs-string">&quot;bg&quot;</span>])<br>        <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.face_rect, fill=<span class="hljs-variable language_">self</span>.theme[<span class="hljs-string">&quot;face&quot;</span>])<br><br>    <span class="hljs-comment"># ----- drawing helpers -----</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">round_rect</span>(<span class="hljs-params">self, x1, y1, x2, y2, r, fill, outline=<span class="hljs-string">&quot;&quot;</span>, width=<span class="hljs-number">1</span>, tags=(<span class="hljs-params"></span>)</span>):<br>        points = [<br>            x1+r, y1, x2-r, y1, x2, y1, x2, y1+r,<br>            x2, y2-r, x2, y2, x2-r, y2, x1+r, y2,<br>            x1, y2, x1, y2-r, x1, y1+r, x1, y1<br>        ]<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.canvas.create_polygon(<br>            points, smooth=<span class="hljs-literal">True</span>, fill=fill, outline=outline, width=width, tags=tags<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_draw_ui</span>(<span class="hljs-params">self</span>):<br>        m, h, r = <span class="hljs-variable language_">self</span>.margin, <span class="hljs-variable language_">self</span>.h, <span class="hljs-variable language_">self</span>.radius<br>        total_w, total_h = <span class="hljs-variable language_">self</span>.total_w, <span class="hljs-variable language_">self</span>.total_h<br><br>        <span class="hljs-variable language_">self</span>.container = <span class="hljs-variable language_">self</span>.round_rect(m, m, total_w-m, total_h-m, r,<br>                                         fill=<span class="hljs-variable language_">self</span>.theme[<span class="hljs-string">&quot;bg&quot;</span>], outline=<span class="hljs-string">&quot;&quot;</span>, width=<span class="hljs-number">1</span>, tags=(<span class="hljs-string">&quot;container&quot;</span>,))<br>        <span class="hljs-variable language_">self</span>.container_outline = <span class="hljs-variable language_">self</span>.round_rect(m-<span class="hljs-number">1</span>, m-<span class="hljs-number">1</span>, total_w-m+<span class="hljs-number">1</span>, total_h-m+<span class="hljs-number">1</span>, r+<span class="hljs-number">2</span>,<br>                                                 fill=<span class="hljs-string">&quot;&quot;</span>, outline=<span class="hljs-string">&quot;&quot;</span>, width=<span class="hljs-number">2</span>, tags=(<span class="hljs-string">&quot;outline&quot;</span>,))<br><br>        face_h = <span class="hljs-built_in">int</span>(<span class="hljs-number">36</span> * <span class="hljs-variable language_">self</span>.scale)<br>        face_y1 = m + (h - face_h) // <span class="hljs-number">2</span><br>        <span class="hljs-variable language_">self</span>.face_rect = <span class="hljs-variable language_">self</span>.round_rect(m, face_y1, m + <span class="hljs-variable language_">self</span>.face_w, face_y1 + face_h, <span class="hljs-built_in">int</span>(<span class="hljs-number">16</span>*<span class="hljs-variable language_">self</span>.scale),<br>                                         fill=<span class="hljs-variable language_">self</span>.theme[<span class="hljs-string">&quot;face&quot;</span>], outline=<span class="hljs-string">&quot;&quot;</span>, tags=(<span class="hljs-string">&quot;face_rect&quot;</span>,))<br>        x_face = m + <span class="hljs-variable language_">self</span>.face_w/<span class="hljs-number">2</span><br>        y_center = m + h/<span class="hljs-number">2</span><br>        <span class="hljs-variable language_">self</span>.face_text = <span class="hljs-variable language_">self</span>.canvas.create_text(x_face, y_center, text=<span class="hljs-string">&quot;🐼&quot;</span>,<br>                                                 font=(<span class="hljs-string">&quot;Segoe UI Emoji&quot;</span>, <span class="hljs-variable language_">self</span>.font_face, <span class="hljs-string">&quot;bold&quot;</span>),<br>                                                 fill=<span class="hljs-variable language_">self</span>.theme[<span class="hljs-string">&quot;face_fg&quot;</span>], tags=(<span class="hljs-string">&quot;face&quot;</span>,))<br><br>        <span class="hljs-comment"># IME chip</span><br>        chip1_x1 = m + <span class="hljs-variable language_">self</span>.face_w + <span class="hljs-variable language_">self</span>.gap<br>        chip1_x2 = chip1_x1 + <span class="hljs-variable language_">self</span>.chip1_w<br>        chip_h = <span class="hljs-built_in">int</span>(<span class="hljs-number">34</span> * <span class="hljs-variable language_">self</span>.scale)<br>        chip_y1 = m + (h - chip_h) // <span class="hljs-number">2</span><br>        <span class="hljs-variable language_">self</span>.ime_rect = <span class="hljs-variable language_">self</span>.round_rect(chip1_x1, chip_y1, chip1_x2, chip_y1 + chip_h,<br>                                        <span class="hljs-built_in">int</span>(<span class="hljs-number">16</span>*<span class="hljs-variable language_">self</span>.scale), fill=<span class="hljs-string">&quot;#f77062&quot;</span>, outline=<span class="hljs-string">&quot;&quot;</span>, tags=(<span class="hljs-string">&quot;ime_rect&quot;</span>,))<br>        <span class="hljs-variable language_">self</span>.ime_text = <span class="hljs-variable language_">self</span>.canvas.create_text((chip1_x1+chip1_x2)//<span class="hljs-number">2</span>, y_center, text=<span class="hljs-string">&quot;ZH 中&quot;</span>,<br>                                                font=(<span class="hljs-string">&quot;Segoe UI&quot;</span>, <span class="hljs-variable language_">self</span>.font_main, <span class="hljs-string">&quot;bold&quot;</span>),<br>                                                fill=<span class="hljs-string">&quot;#ffffff&quot;</span>, tags=(<span class="hljs-string">&quot;ime_text&quot;</span>,))<br><br>        <span class="hljs-comment"># CAPS chip</span><br>        chip2_x1 = chip1_x2 + <span class="hljs-variable language_">self</span>.gap<br>        chip2_x2 = chip2_x1 + <span class="hljs-variable language_">self</span>.chip2_w<br>        <span class="hljs-variable language_">self</span>.caps_rect = <span class="hljs-variable language_">self</span>.round_rect(chip2_x1, chip_y1, chip2_x2, chip_y1 + chip_h,<br>                                         <span class="hljs-built_in">int</span>(<span class="hljs-number">16</span>*<span class="hljs-variable language_">self</span>.scale), fill=<span class="hljs-string">&quot;#8e9eab&quot;</span>, outline=<span class="hljs-string">&quot;&quot;</span>, tags=(<span class="hljs-string">&quot;caps_rect&quot;</span>,))<br>        <span class="hljs-variable language_">self</span>.caps_text = <span class="hljs-variable language_">self</span>.canvas.create_text((chip2_x1+chip2_x2)//<span class="hljs-number">2</span>, y_center, text=<span class="hljs-string">&quot;↓ caps&quot;</span>,<br>                                                 font=(<span class="hljs-string">&quot;Segoe UI&quot;</span>, <span class="hljs-variable language_">self</span>.font_main, <span class="hljs-string">&quot;bold&quot;</span>),<br>                                                 fill=<span class="hljs-string">&quot;#ffffff&quot;</span>, tags=(<span class="hljs-string">&quot;caps_text&quot;</span>,))<br><br>        <span class="hljs-variable language_">self</span>._draw_grip()<br>        <span class="hljs-variable language_">self</span>.canvas.config(width=<span class="hljs-variable language_">self</span>.total_w, height=<span class="hljs-variable language_">self</span>.total_h)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_draw_grip</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.canvas.delete(<span class="hljs-string">&quot;grip&quot;</span>)<br>        x2 = <span class="hljs-variable language_">self</span>.total_w - <span class="hljs-variable language_">self</span>.margin<br>        y2 = <span class="hljs-variable language_">self</span>.total_h - <span class="hljs-variable language_">self</span>.margin<br>        step = <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span> * <span class="hljs-variable language_">self</span>.scale))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            <span class="hljs-variable language_">self</span>.canvas.create_line(x2 - i*<span class="hljs-number">6</span>, y2, x2, y2 - i*<span class="hljs-number">6</span>,<br>                                    fill=<span class="hljs-string">&quot;#c8c8c8&quot;</span>, width=step, tags=(<span class="hljs-string">&quot;grip&quot;</span>,))<br><br>    <span class="hljs-comment"># ----- interactions -----</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_in_resize_zone</span>(<span class="hljs-params">self, x, y</span>):<br>        zone = <span class="hljs-built_in">max</span>(<span class="hljs-number">18</span>, <span class="hljs-built_in">int</span>(<span class="hljs-number">18</span> * <span class="hljs-variable language_">self</span>.scale))<br>        <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">self</span>.total_w - <span class="hljs-variable language_">self</span>.margin - zone) &lt;= x &lt;= (<span class="hljs-variable language_">self</span>.total_w - <span class="hljs-variable language_">self</span>.margin) <span class="hljs-keyword">and</span> \<br>               (<span class="hljs-variable language_">self</span>.total_h - <span class="hljs-variable language_">self</span>.margin - zone) &lt;= y &lt;= (<span class="hljs-variable language_">self</span>.total_h - <span class="hljs-variable language_">self</span>.margin)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_on_motion</span>(<span class="hljs-params">self, e</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._in_resize_zone(e.x, e.y):<br>            <span class="hljs-variable language_">self</span>.canvas.config(cursor=<span class="hljs-string">&quot;sizing&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.canvas.config(cursor=<span class="hljs-string">&quot;fleur&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._drag_offset <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_on_press</span>(<span class="hljs-params">self, e</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._in_resize_zone(e.x, e.y):<br>            <span class="hljs-variable language_">self</span>._resizing = <span class="hljs-literal">True</span><br>            <span class="hljs-variable language_">self</span>._resize_start = (e.x_root, e.y_root, <span class="hljs-variable language_">self</span>.scale, <span class="hljs-variable language_">self</span>.total_w)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>._drag_offset = (e.x_root - <span class="hljs-variable language_">self</span>.winfo_x(), e.y_root - <span class="hljs-variable language_">self</span>.winfo_y())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_on_drag</span>(<span class="hljs-params">self, e</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._resizing <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>._resize_start:<br>            x0, y0, s0, w0 = <span class="hljs-variable language_">self</span>._resize_start<br>            dx = e.x_root - x0<br>            s = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.8</span>, <span class="hljs-built_in">min</span>(<span class="hljs-number">1.8</span>, s0 * (<span class="hljs-number">1.0</span> + dx / <span class="hljs-built_in">max</span>(<span class="hljs-number">120</span>, w0))))<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(s - <span class="hljs-variable language_">self</span>.scale) &gt; <span class="hljs-number">0.01</span>:<br>                <span class="hljs-variable language_">self</span>.scale = s<br>                <span class="hljs-variable language_">self</span>._apply_metrics()<br>                <span class="hljs-variable language_">self</span>.canvas.config(width=<span class="hljs-variable language_">self</span>.total_w, height=<span class="hljs-variable language_">self</span>.total_h)<br>                <span class="hljs-variable language_">self</span>.canvas.delete(<span class="hljs-string">&quot;all&quot;</span>)<br>                <span class="hljs-variable language_">self</span>._draw_ui()<br>                <span class="hljs-variable language_">self</span>.geometry(<span class="hljs-string">f&quot;+<span class="hljs-subst">&#123;self.winfo_x()&#125;</span>+<span class="hljs-subst">&#123;self.winfo_y()&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>._drag_offset:<br>            dx, dy = <span class="hljs-variable language_">self</span>._drag_offset<br>            <span class="hljs-variable language_">self</span>.geometry(<span class="hljs-string">f&quot;+<span class="hljs-subst">&#123;e.x_root - dx&#125;</span>+<span class="hljs-subst">&#123;e.y_root - dy&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_on_release</span>(<span class="hljs-params">self, e</span>):<br>        <span class="hljs-variable language_">self</span>._drag_offset = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._resizing = <span class="hljs-literal">False</span><br>        <span class="hljs-variable language_">self</span>._resize_start = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_on_context</span>(<span class="hljs-params">self, e</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-variable language_">self</span>.menu.tk_popup(e.x_root, e.y_root)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-variable language_">self</span>.menu.grab_release()<br><br>    <span class="hljs-comment"># ----- state update loop -----</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_loop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._update_state()<br>        interval = <span class="hljs-number">70</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._burst_ticks &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">140</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._burst_ticks &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>._burst_ticks -= <span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.after(interval, <span class="hljs-variable language_">self</span>._loop)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_state</span>(<span class="hljs-params">self</span>):<br>        st = get_keyboard_state()<br><br>        <span class="hljs-comment"># IME display</span><br>        <span class="hljs-keyword">if</span> st.is_zh_layout:<br>            <span class="hljs-keyword">if</span> st.ime_open <span class="hljs-keyword">and</span> st.ime_native:<br>                ime_text = <span class="hljs-string">&quot;ZH 中&quot;</span><br>                ime_color = <span class="hljs-string">&quot;#f77062&quot;</span><br>                face = <span class="hljs-string">&quot;🐼&quot;</span><br>            <span class="hljs-keyword">else</span>:<br>                ime_text = <span class="hljs-string">&quot;ZH 英&quot;</span><br>                ime_color = <span class="hljs-string">&quot;#4facfe&quot;</span><br>                face = <span class="hljs-string">&quot;🫧&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            tag = st.lang_tag<br>            ime_text = tag<br>            <span class="hljs-keyword">if</span> tag == <span class="hljs-string">&quot;EN&quot;</span>:<br>                ime_color = <span class="hljs-string">&quot;#3aa99f&quot;</span><br>                face = <span class="hljs-string">&quot;🟦&quot;</span><br>            <span class="hljs-keyword">elif</span> tag <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;JA&quot;</span>, <span class="hljs-string">&quot;KO&quot;</span>):<br>                ime_color = <span class="hljs-string">&quot;#a18cd1&quot;</span><br>                face = <span class="hljs-string">&quot;🌸&quot;</span><br>            <span class="hljs-keyword">else</span>:<br>                ime_color = <span class="hljs-string">&quot;#9fa5d5&quot;</span><br>                face = <span class="hljs-string">&quot;⭐&quot;</span><br><br>        <span class="hljs-comment"># Caps</span><br>        <span class="hljs-keyword">if</span> st.caps_on:<br>            caps_text = <span class="hljs-string">&quot;⇪ CAPS&quot;</span><br>            caps_color = <span class="hljs-string">&quot;#42e695&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            caps_text = <span class="hljs-string">&quot;↓ caps&quot;</span><br>            caps_color = <span class="hljs-string">&quot;#8e9eab&quot;</span><br><br>        key = (ime_text, ime_color, caps_text, caps_color, face)<br>        <span class="hljs-keyword">if</span> key != <span class="hljs-variable language_">self</span>._last_key:<br>            <span class="hljs-variable language_">self</span>._last_key = key<br>            <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.ime_text, text=ime_text)<br>            <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.ime_rect, fill=ime_color)<br>            <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.caps_text, text=caps_text)<br>            <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.caps_rect, fill=caps_color)<br>            <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.face_text, text=face)<br>            <span class="hljs-variable language_">self</span>._pulse()<br>            <span class="hljs-comment"># 当状态有变化时再短暂进入“加速模式”，捕捉紧随其后的翻转</span><br>            <span class="hljs-variable language_">self</span>._burst_ticks = <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>._burst_ticks, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_pulse</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.container_outline, outline=<span class="hljs-variable language_">self</span>.theme[<span class="hljs-string">&quot;outline&quot;</span>])<br>        <span class="hljs-variable language_">self</span>.after(<span class="hljs-number">120</span>, <span class="hljs-keyword">lambda</span>: <span class="hljs-variable language_">self</span>.canvas.itemconfigure(<span class="hljs-variable language_">self</span>.container_outline, outline=<span class="hljs-string">&quot;&quot;</span>))<br><br>    <span class="hljs-comment"># ----- foreground change hook -----</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_install_foreground_hook</span>(<span class="hljs-params">self</span>):<br><span class="hljs-meta">        @WINEVENTPROC</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_proc</span>(<span class="hljs-params">hWinEventHook, event, hwnd, idObject, idChild, idThread, dwmsEventTime</span>):<br>            <span class="hljs-comment"># 不要在这里碰 tkinter，只设置“加速刷新”的计数</span><br>            <span class="hljs-keyword">if</span> event == EVENT_SYSTEM_FOREGROUND:<br>                <span class="hljs-variable language_">self</span>._burst_ticks = <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>._burst_ticks, <span class="hljs-number">8</span>)<br><br>        <span class="hljs-variable language_">self</span>._we_proc = _proc<br>        <span class="hljs-variable language_">self</span>._we_hook = user32.SetWinEventHook(<br>            EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND,<br>            <span class="hljs-literal">None</span>, <span class="hljs-variable language_">self</span>._we_proc, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>            WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS<br>        )<br><br>    <span class="hljs-comment"># ----- cleanup -----</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&quot;_we_hook&quot;</span>, <span class="hljs-literal">None</span>):<br>            <span class="hljs-keyword">try</span>:<br>                user32.UnhookWinEvent(<span class="hljs-variable language_">self</span>._we_hook)<br>            <span class="hljs-keyword">except</span> Exception:<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-variable language_">self</span>._we_hook = <span class="hljs-literal">None</span><br>        <span class="hljs-built_in">super</span>().destroy()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = CuteIMEWidget()<br>    app.mainloop()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><hr><h2 id="2-打包为-exe"><a href="#2-打包为-exe" class="headerlink" title="2. 打包为 exe"></a>2. 打包为 exe</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 1. 安装打包工具</span><br>pip install pyinstaller<br><br><br><span class="hljs-comment"># 2. 打包代码</span><br>pyinstaller <span class="hljs-operator">-</span>-onefile <span class="hljs-operator">-</span>-windowed <span class="hljs-operator">-</span>-icon<span class="hljs-operator">=</span><span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\I</span>CO<span class="hljs-char escape_">\输</span>入法显示小工具.ico&quot;</span> <span class="hljs-operator">-</span>-distpath <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合&quot;</span> <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\输</span>入法显示小工具.py&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-设置开机自启动"><a href="#3-设置开机自启动" class="headerlink" title="3. 设置开机自启动"></a>3. 设置开机自启动</h2><p>Win + R 输入 <code>shell:startup</code> 打开 “启动” 文件夹，然后将你的 <code>输入法显示小工具.exe</code> 文件（或它的快捷方式）复制到这个目录下，这样每次开机就自动运行这个程序了。</p>]]></content>
    
    
    <categories>
      
      <category>自研小工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：ArrayBlockingQueue 常用方法</title>
    <link href="/2025/08/29/%E6%96%B9%E6%B3%95%EF%BC%9AArrayBlockingQueue%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/29/%E6%96%B9%E6%B3%95%EF%BC%9AArrayBlockingQueue%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><h3 id="1-1-public-ArrayBlockingQueue-int-capacity"><a href="#1-1-public-ArrayBlockingQueue-int-capacity" class="headerlink" title="1.1. public ArrayBlockingQueue(int capacity)"></a>1.1. public ArrayBlockingQueue(int capacity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个固定容量的 ArrayBlockingQueue</span><br>ArrayBlockingQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="1-2-public-ArrayBlockingQueue-int-capacity-boolean-fair"><a href="#1-2-public-ArrayBlockingQueue-int-capacity-boolean-fair" class="headerlink" title="1.2. public ArrayBlockingQueue(int capacity, boolean fair)"></a>1.2. public ArrayBlockingQueue(int capacity, boolean fair)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：public ArrayBlockingQueue(int capacity, boolean fair)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. int capacity</span><br><span class="hljs-comment"> *          1. 容量</span><br><span class="hljs-comment"> *      2. boolean fair</span><br><span class="hljs-comment"> *          1. 锁的公平性</span><br><span class="hljs-comment"> *          2. true</span><br><span class="hljs-comment"> *              1. 公平锁</span><br><span class="hljs-comment"> *          3. false</span><br><span class="hljs-comment"> *              1. 非公平锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 创建一个固定容量的 ArrayBlockingQueue，并指定其锁的公平性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>ArrayBlockingQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="1-3-public-ArrayBlockingQueue-int-capacity-boolean-fair-Collection＜-extends-E＞-c"><a href="#1-3-public-ArrayBlockingQueue-int-capacity-boolean-fair-Collection＜-extends-E＞-c" class="headerlink" title="1.3. public ArrayBlockingQueue(int capacity, boolean fair, Collection＜? extends E＞ c)"></a>1.3. public ArrayBlockingQueue(int capacity, boolean fair, Collection＜? extends E＞ c)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：public ArrayBlockingQueue(int capacity, boolean fair, Collection＜? extends E＞ c)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. int capacity</span><br><span class="hljs-comment"> *          1. 容量</span><br><span class="hljs-comment"> *      2. boolean fair</span><br><span class="hljs-comment"> *          1. 锁的公平性</span><br><span class="hljs-comment"> *          2. true</span><br><span class="hljs-comment"> *              1. 公平锁</span><br><span class="hljs-comment"> *          3. false</span><br><span class="hljs-comment"> *              1. 非公平锁</span><br><span class="hljs-comment"> *      3. Collection＜? extends E＞ c</span><br><span class="hljs-comment"> *          1. 初始化集合</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 创建一个固定容量的 ArrayBlockingQueue，指定其锁的公平性，并将初始化集合中的元素复制到该队列</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>List&lt;String&gt; init = Arrays.asList(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>);<br><br>BlockingQueue&lt;String&gt; q2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>, init);<br></code></pre></td></tr></table></figure><hr><h2 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h2><h3 id="2-1-插入方法"><a href="#2-1-插入方法" class="headerlink" title="2.1. 插入方法"></a>2.1. 插入方法</h3><h4 id="2-1-1-public-boolean-add-E-e"><a href="#2-1-1-public-boolean-add-E-e" class="headerlink" title="2.1.1. public boolean add(E e)"></a>2.1.1. public boolean add(E e)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public boolean add(E e)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. true</span><br><span class="hljs-comment"> *          1. 插入成功</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. IllegalStateException</span><br><span class="hljs-comment"> *          1. 队列已满</span><br><span class="hljs-comment"> *      2. NullPointerException</span><br><span class="hljs-comment"> *          1. 传入元素为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 作用</span><br><span class="hljs-comment"> *      1. 向队列插入一个元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 注意事项  </span><br><span class="hljs-comment"> *      1. 插入失败直接抛出 IllegalStateException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> queue.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="2-1-2-public-boolean-offer-E-e"><a href="#2-1-2-public-boolean-offer-E-e" class="headerlink" title="2.1.2. public boolean offer(E e)"></a>2.1.2. public boolean offer(E e)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public boolean offer(E e)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. true</span><br><span class="hljs-comment"> *          1. 插入成功</span><br><span class="hljs-comment"> *      2. false</span><br><span class="hljs-comment"> *          1. 插入失败</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. NullPointerException</span><br><span class="hljs-comment"> *          1. 传入元素为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 作用</span><br><span class="hljs-comment"> *      1. 向队列插入一个元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> queue.offer(<span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="2-1-3-public-boolean-offer-E-e-long-timeout-TimeUnit-unit"><a href="#2-1-3-public-boolean-offer-E-e-long-timeout-TimeUnit-unit" class="headerlink" title="2.1.3. public boolean offer(E e, long timeout, TimeUnit unit)"></a>2.1.3. public boolean offer(E e, long timeout, TimeUnit unit)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. E e</span><br><span class="hljs-comment"> *          1. 插入元素</span><br><span class="hljs-comment"> *      2. long timeout</span><br><span class="hljs-comment"> *          1. 等待 timeout 时间</span><br><span class="hljs-comment"> *      3. TimeUnit unit</span><br><span class="hljs-comment"> *          1. timeout 的单位</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. true</span><br><span class="hljs-comment"> *          1. 插入成功</span><br><span class="hljs-comment"> *      2. false</span><br><span class="hljs-comment"> *          1. 插入失败（超时未插入）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. InterruptedException</span><br><span class="hljs-comment"> *          1. 被 xxThread.interrupted()</span><br><span class="hljs-comment"> *      2. NullPointerException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 作用</span><br><span class="hljs-comment"> *      1. 向队列插入一个元素，队列满时会等待一段时间</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> queue.offer(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><hr><h4 id="2-1-4-public-void-put-E-e"><a href="#2-1-4-public-void-put-E-e" class="headerlink" title="2.1.4. public void put(E e)"></a>2.1.4. public void put(E e)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public void put(E e)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. InterruptedException</span><br><span class="hljs-comment"> *      2. NullPointerException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 作用</span><br><span class="hljs-comment"> *      1. 向队列插入一个元素，如果队列满，则一直阻塞，直到出现空位被唤醒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>queue.put(<span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="2-2-移除方法"><a href="#2-2-移除方法" class="headerlink" title="2.2. 移除方法"></a>2.2. 移除方法</h3><h4 id="2-2-1-public-E-remove"><a href="#2-2-1-public-E-remove" class="headerlink" title="2.2.1. public E remove()"></a>2.2.1. public E remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public E remove()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. NoSuchElementException</span><br><span class="hljs-comment"> *          1. 队空时抛出</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 移除并返回头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 使用实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> queue.remove();<br></code></pre></td></tr></table></figure><hr><h4 id="2-2-2-public-E-poll"><a href="#2-2-2-public-E-poll" class="headerlink" title="2.2.2. public E poll()"></a>2.2.2. public E poll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public E poll()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 头元素</span><br><span class="hljs-comment"> *      2. null</span><br><span class="hljs-comment"> *          1. 队空返回 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 移除并返回头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 使用实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br></code></pre></td></tr></table></figure><hr><h4 id="2-2-3-public-E-poll-long-timeout-TimeUnit-unit"><a href="#2-2-3-public-E-poll-long-timeout-TimeUnit-unit" class="headerlink" title="2.2.3. public E poll(long timeout, TimeUnit unit)"></a>2.2.3. public E poll(long timeout, TimeUnit unit)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public E poll(long timeout, TimeUnit unit)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. long timeout</span><br><span class="hljs-comment"> *          1. 等待 timeout 时间</span><br><span class="hljs-comment"> *      2. TimeUnit unit</span><br><span class="hljs-comment"> *          1. timeout 的单位</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 头元素</span><br><span class="hljs-comment"> *      2. null</span><br><span class="hljs-comment"> *          1. 超时未有元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. InterruptedException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1.移除并返回头元素，队列空时会等待一段时间</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 使用实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">poll1</span> <span class="hljs-operator">=</span> queue.poll(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><hr><h4 id="2-2-4-public-E-take"><a href="#2-2-4-public-E-take" class="headerlink" title="2.2.4. public E take()"></a>2.2.4. public E take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public E take()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. InterruptedException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 移除并返回头元素，如果队列空，则一直阻塞，直到出现元素被唤醒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 使用实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">take</span> <span class="hljs-operator">=</span> queue.take();<br></code></pre></td></tr></table></figure><hr><h3 id="2-3-查看方法"><a href="#2-3-查看方法" class="headerlink" title="2.3. 查看方法"></a>2.3. 查看方法</h3><h4 id="2-3-1-public-E-element"><a href="#2-3-1-public-E-element" class="headerlink" title="2.3.1. public E element()"></a>2.3.1. public E element()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public E element()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. NoSuchElementException、</span><br><span class="hljs-comment"> *          1. 队空时抛出</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 查看头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 不会移除头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 8. 使用实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> queue.element();<br></code></pre></td></tr></table></figure><hr><h4 id="2-3-2-public-E-peek"><a href="#2-3-2-public-E-peek" class="headerlink" title="2.3.2. public E peek()"></a>2.3.2. public E peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * public E peek()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 头元素</span><br><span class="hljs-comment"> *      2. null</span><br><span class="hljs-comment"> *          1. 队列空时返回</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 查看头元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 不会移除头元素</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 8. 使用实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> queue.peek();<br></code></pre></td></tr></table></figure><hr><h3 id="2-4-清空方法"><a href="#2-4-清空方法" class="headerlink" title="2.4. 清空方法"></a>2.4. 清空方法</h3><h4 id="void-clear"><a href="#void-clear" class="headerlink" title="void clear()"></a>void clear()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.clear();<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：IntFunction＜R＞ 源码解析</title>
    <link href="/2025/08/29/%E6%BA%90%E7%A0%81%EF%BC%9AIntFunction%EF%BC%9CR%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/29/%E6%BA%90%E7%A0%81%EF%BC%9AIntFunction%EF%BC%9CR%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>XXXX 是一个接口，定义了 “XXXX” 的规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IntFunction</span>&lt;R&gt; &#123;  <br><br>       R <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>;  <br>       <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-接口方法"><a href="#5-接口方法" class="headerlink" title="5. 接口方法"></a>5. 接口方法</h2><h3 id="5-1-接口方法（无）"><a href="#5-1-接口方法（无）" class="headerlink" title="5.1. 接口方法（无）"></a>5.1. 接口方法（无）</h3><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Queue＜E＞ 源码解析</title>
    <link href="/2025/08/29/%E6%BA%90%E7%A0%81%EF%BC%9AQueue%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/29/%E6%BA%90%E7%A0%81%EF%BC%9AQueue%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Queue＜E＞ 是一个接口，定义了 “如何操作队列这种数据结构” 的规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br>    <br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>    <br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br><br>    E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-boolean-offer-E-e"><a href="#3-1-1-boolean-offer-E-e" class="headerlink" title="3.1.1. boolean offer(E e)"></a>3.1.1. boolean offer(E e)</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>boolean offer(E e)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 向队尾添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-2-remove"><a href="#3-1-2-remove" class="headerlink" title="3.1.2. remove()"></a>3.1.2. remove()</h4><h5 id="3-1-2-1-方法概述"><a href="#3-1-2-1-方法概述" class="headerlink" title="3.1.2.1. 方法概述"></a>3.1.2.1. 方法概述</h5><p><code>E remove()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 取出队头并删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-3-poll"><a href="#3-1-3-poll" class="headerlink" title="3.1.3. poll()"></a>3.1.3. poll()</h4><h5 id="3-1-3-1-方法概述"><a href="#3-1-3-1-方法概述" class="headerlink" title="3.1.3.1. 方法概述"></a>3.1.3.1. 方法概述</h5><p><code>E poll()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 取出队头并删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-4-element"><a href="#3-1-4-element" class="headerlink" title="3.1.4. element()"></a>3.1.4. element()</h4><h5 id="3-1-4-1-方法概述"><a href="#3-1-4-1-方法概述" class="headerlink" title="3.1.4.1. 方法概述"></a>3.1.4.1. 方法概述</h5><p><code>E element()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 查看队头元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-5-peek"><a href="#3-1-5-peek" class="headerlink" title="3.1.5. peek()"></a>3.1.5. peek()</h4><h5 id="3-1-5-1-方法概述"><a href="#3-1-5-1-方法概述" class="headerlink" title="3.1.5.1. 方法概述"></a>3.1.5.1. 方法概述</h5><p><code>E peek()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 查看队头元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Excel</title>
    <link href="/2025/08/29/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel/"/>
    <url>/2025/08/29/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Obsidian-Table-⟷-Excel"><a href="#1-Obsidian-Table-⟷-Excel" class="headerlink" title="1. Obsidian Table ⟷ Excel"></a>1. Obsidian Table ⟷ Excel</h2><h3 id="1-1-Obsidian-Table-➔-Excel"><a href="#1-1-Obsidian-Table-➔-Excel" class="headerlink" title="1.1. Obsidian Table ➔ Excel"></a>1.1. Obsidian Table ➔ Excel</h3><h4 id="1-1-1-编写-VBA"><a href="#1-1-1-编写-VBA" class="headerlink" title="1.1.1. 编写 VBA"></a>1.1.1. 编写 VBA</h4><p>按 <code>ALT + F11</code>，新建模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs VBA">&#x27; ========= 剪贴板读取 =========<br>#If VBA7 Then<br>    Private Declare PtrSafe Function OpenClipboard Lib &quot;user32&quot; (ByVal hwnd As LongPtr) As Long<br>    Private Declare PtrSafe Function CloseClipboard Lib &quot;user32&quot; () As Long<br>    Private Declare PtrSafe Function GetClipboardData Lib &quot;user32&quot; (ByVal wFormat As Long) As LongPtr<br>    Private Declare PtrSafe Function GlobalLock Lib &quot;kernel32&quot; (ByVal hMem As LongPtr) As LongPtr<br>    Private Declare PtrSafe Function GlobalUnlock Lib &quot;kernel32&quot; (ByVal hMem As LongPtr) As Long<br>    Private Declare PtrSafe Function lstrcpy Lib &quot;kernel32&quot; Alias &quot;lstrcpyA&quot; (ByVal lpString1 As Any, ByVal lpString2 As Any) As LongPtr<br>#Else<br>    Private Declare Function OpenClipboard Lib &quot;user32&quot; (ByVal hwnd As Long) As Long<br>    Private Declare Function CloseClipboard Lib &quot;user32&quot; () As Long<br>    Private Declare Function GetClipboardData Lib &quot;user32&quot; (ByVal wFormat As Long) As Long<br>    Private Declare Function GlobalLock Lib &quot;kernel32&quot; (ByVal hMem As Long) As Long<br>    Private Declare Function GlobalUnlock Lib &quot;kernel32&quot; (ByVal hMem As Long) As Long<br>    Private Declare Function lstrcpy Lib &quot;kernel32&quot; Alias &quot;lstrcpyA&quot; (ByVal lpString1 As Any, ByVal lpString2 As Any) As Long<br>#End If<br><br>Private Const CF_TEXT As Long = 1<br><br>Private Function GetClipboardText() As String<br>    Dim hClipMemory As LongPtr<br>    Dim lpClipMemory As LongPtr<br>    Dim RetVal As LongPtr<br>    Dim tmp As String<br>    <br>    If OpenClipboard(0&amp;) = 0 Then Exit Function<br>    hClipMemory = GetClipboardData(CF_TEXT)<br>    If hClipMemory &lt;&gt; 0 Then<br>        lpClipMemory = GlobalLock(hClipMemory)<br>        If lpClipMemory &lt;&gt; 0 Then<br>            tmp = Space$(65535)<br>            RetVal = lstrcpy(ByVal tmp, ByVal lpClipMemory)<br>            GetClipboardText = Replace(tmp, Chr$(0), &quot;&quot;)<br>            RetVal = GlobalUnlock(hClipMemory)<br>        End If<br>    End If<br>    CloseClipboard<br>End Function<br><br><br>&#x27; ========= 主宏 =========<br>Sub PasteMarkdownTable()<br>    Dim rawText As String<br>    Dim rows As Variant<br>    Dim cols As Variant<br>    Dim i As Long, j As Long<br>    Dim rowIndex As Long<br>    Dim targetCell As Range<br>    <br>    &#x27; 从剪贴板取文本<br>    rawText = GetClipboardText()<br>    If rawText = &quot;&quot; Then<br>        MsgBox &quot;剪贴板没有内容，请先复制 Markdown 表格！&quot;<br>        Exit Sub<br>    End If<br>    <br>    &#x27; 统一换行符<br>    rawText = Replace(rawText, vbCr, &quot;&quot;)<br>    rows = Split(rawText, vbLf)<br>    <br>    &#x27; 起始粘贴位置<br>    Set targetCell = ActiveCell<br>    rowIndex = 0<br>    <br>    &#x27; 分行处理<br>    For i = LBound(rows) To UBound(rows)<br>        Dim line As String<br>        line = Trim(rows(i))<br>        <br>        &#x27; 跳过空行<br>        If line = &quot;&quot; Then GoTo SkipLine<br>        <br>        &#x27; 去掉起始结尾竖线<br>        If Left(line, 1) = &quot;|&quot; Then line = Mid(line, 2)<br>        If Right(line, 1) = &quot;|&quot; Then line = Left(line, Len(line) - 1)<br>        line = Trim(line)<br>        <br>        &#x27; 如果整行只有 -、:、|、空格，那就是分隔行<br>        If line &lt;&gt; &quot;&quot; Then<br>            If Len(Replace(Replace(Replace(Replace(line, &quot;-&quot;, &quot;&quot;), &quot;:&quot;, &quot;&quot;), &quot;|&quot;, &quot;&quot;), &quot; &quot;, &quot;&quot;)) = 0 Then<br>                GoTo SkipLine<br>            End If<br>        End If<br>        <br>        &#x27; 按竖线分列<br>        cols = Split(line, &quot;|&quot;)<br>        <br>        &#x27; 输出到 Excel<br>        For j = LBound(cols) To UBound(cols)<br>            targetCell.Offset(rowIndex, j).Value = Trim(cols(j))<br>        Next j<br>        <br>        rowIndex = rowIndex + 1<br>        <br>SkipLine:<br>    Next i<br>End Sub<br></code></pre></td></tr></table></figure><hr><h4 id="1-1-2-保存-Excel-为-xlsm-格式"><a href="#1-1-2-保存-Excel-为-xlsm-格式" class="headerlink" title="1.1.2. 保存 Excel 为 xlsm 格式"></a>1.1.2. 保存 Excel 为 xlsm 格式</h4><p><img src="/2025/08/29/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel-3.png"></p><hr><h4 id="1-1-3-复制-Obsidian-Table-到-Excel"><a href="#1-1-3-复制-Obsidian-Table-到-Excel" class="headerlink" title="1.1.3. 复制 Obsidian Table 到 Excel"></a>1.1.3. 复制 Obsidian Table 到 Excel</h4><p>复制 Obsidian Table，点击 Excel 起始单元格，按 <code>ALT + F8</code>，再按两次 <code>Enter</code><br><img src="/2025/08/29/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel.png"></p><hr><h3 id="1-2-Excel-➔-Obsidian-Table"><a href="#1-2-Excel-➔-Obsidian-Table" class="headerlink" title="1.2. Excel ➔ Obsidian Table"></a>1.2. Excel ➔ Obsidian Table</h3><h4 id="1-2-1-安装-Excel-to-Markdown-Table-插件"><a href="#1-2-1-安装-Excel-to-Markdown-Table-插件" class="headerlink" title="1.2.1. 安装 Excel to Markdown Table 插件"></a>1.2.1. 安装 Excel to Markdown Table 插件</h4><p><img src="/2025/08/29/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel-1.png"></p><hr><h4 id="1-2-2-复制-Excel-到-Obsidian-Table"><a href="#1-2-2-复制-Excel-到-Obsidian-Table" class="headerlink" title="1.2.2. 复制 Excel 到 Obsidian Table"></a>1.2.2. 复制 Excel 到 Obsidian Table</h4><p>复制时，需要将表格头一起复制<br><img src="/2025/08/29/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel/%E7%AC%94%E8%AE%B0%EF%BC%9AExcel-2.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>办公工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：JUC</title>
    <link href="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/"/>
    <url>/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/</url>
    
    <content type="html"><![CDATA[<h2 id="1-脑图"><a href="#1-脑图" class="headerlink" title="1. 脑图"></a>1. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.eddx"></p></li></ol><hr><h2 id="2-线程基础"><a href="#2-线程基础" class="headerlink" title="2. 线程基础"></a>2. 线程基础</h2><h3 id="2-1-串行、并发、并行"><a href="#2-1-串行、并发、并行" class="headerlink" title="2.1. 串行、并发、并行"></a>2.1. 串行、并发、并行</h3><p><font color="#92d050">1. 串行</font><br>串行是指任务按顺序一个接一个地执行，只有当前一个任务执行完成，后一个任务才会开始执行，严格遵循任务提交的先后顺序。即便系统拥有多个 CPU 核心，在串行模式下，任意时刻也只会有一个线程在运行。</p><p><font color="#92d050">2. 并发</font><br>并发是指多个线程看起来像是在同时运行，其是通过时间片轮转机制实现，通过快速切换线程，让每个线程都获得运行机会，因此并发特性在单核环境中体现得尤为明显。</p><p>而在多核 CPU 上，线程有可能被分配到不同的核心上并行执行，但当线程数量多于核心数量时，CPU 仍需通过时间片轮转进行调度，以确保所有线程都能获得执行机会。</p><p><font color="#92d050">3. 并行</font><br>并行是指多个线程在真正意义上同时运行，分别占用不同的 CPU 核心，在同一时刻执行各自的任务，体现出真正的同时处理能力。</p><hr><h3 id="2-2-线程的状态"><a href="#2-2-线程的状态" class="headerlink" title="2.2. 线程的状态"></a>2.2. 线程的状态</h3><h4 id="2-2-1-操作系统层面"><a href="#2-2-1-操作系统层面" class="headerlink" title="2.2.1. 操作系统层面"></a>2.2.1. 操作系统层面</h4><p>操作系统层面的线程状态，是<strong>操作系统内核对线程的实际调度反映</strong><br><img src="/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.png"></p><hr><h4 id="2-2-2-Java-层面"><a href="#2-2-2-Java-层面" class="headerlink" title="2.2.2. Java 层面"></a>2.2.2. Java 层面</h4><p>Java 层面的线程状态，是 JVM 对线程生命周期的抽象和管理，主要<strong>反映线程在 Java 内存模型中的行为</strong>：<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-1.png"></p><ol><li>线程状态<ol><li>NEW<ol><li>指线程对象已创建，但尚未调用 <code>start()</code> 方法处于未启动状态</li><li>在这一阶段，Java 中的线程对象尚未与底层操作系统的原生线程建立关联</li></ol></li><li>RUNNABLE<ol><li>可运行状态<ol><li>线程已经准备好运行，但能否真正运行，还要取决于操作系统的调度</li></ol></li><li>运行状态<ol><li>线程被分配到 CPU 时间片后开始执行代码</li></ol></li><li>阻塞状态<ol><li>在 Java 层面的 BLOCKED、WAITING、TIMED_WAITING、阻塞状态 在操作系统层面都属于阻塞状态，CPU 不再调用这个线程</li><li>Java 层面的阻塞状态，一般是我们执行的某些操作，涉及到操作系统层面的线程阻塞时，会进入阻塞状态，最常见的就是 I&#x2F;O 操作</li><li>虽然其在操作系统层面进入阻塞状态，CPU 不再调用这个线程，但是从 JVM 的角度看，执行 IO 操作的线程通常仍然停留在 <code>RUNNABLE</code> 状态</li></ol></li></ol></li><li>BLOCKED<ol><li>使用 <code>synchronized(Object)</code> 获取对象锁时，如果竞争失败，线程会被加入该对象的 EntryList 阻塞队列中等待唤醒</li></ol></li><li>WAITING<ol><li>线程正在等待被唤醒，它不会自动恢复，必须依赖外部条件</li></ol></li><li>TIMED_WAITING<ol><li>线程正在等待被唤醒，但只等待一段有限时间，超时后，线程进入可运行状态，准备等待 CPU 时间片继续向下执行</li></ol></li><li>TERMINATED<ol><li>当线程执行完代码后，会进入 <code>TERMINATED</code> 状态。</li><li>在 Java 层面上，线程是一个线程对象，当这个线程对象不再被引用时，会在下一次 GC 时被垃圾回收。</li></ol></li></ol></li><li>线程状态转换<ol><li>NEW —&gt; 可运行状态<ol><li>当通过 <code>new</code> 创建的线程对象调用 <code>start()</code> 方法后，Java 中的线程对象会与底层操作系统的原生线程建立关联，此时线程就进入了可运行状态</li></ol></li><li>可运行状态 —&gt; 运行状态<ol><li>线程被分配到 CPU 时间片后开始执行代码</li></ol></li><li>运行状态 —&gt; 可运行状态<ol><li>调用 <code>Thread.yield()</code></li><li>CPU 时间片到时</li></ol></li><li>运行状态 —&gt; 阻塞状态<ol><li>我们执行的某些操作，涉及到操作系统层面的线程阻塞时，会进入阻塞状态，最常见的就是 I&#x2F;O 操作</li></ol></li><li>阻塞状态 —&gt; 可运行状态<ol><li>I&#x2F;O 数据就绪后，内核通知线程继续执行</li></ol></li><li>运行状态 —&gt; BLOCKED<ol><li>竞争对象锁失败<ol><li>使用 <code>synchronized(Object)</code> 获取对象锁时，如果竞争失败，线程会被加入该对象的 EntryList 阻塞队列中等待唤醒</li></ol></li></ol></li><li>BLOCKED —&gt; 可运行状态<ol><li>拥有对象锁的线程执行完代码后，会通知处于 EntryList 中的线程，此时这些线程会被唤醒，尝试去争抢该对象的锁</li></ol></li><li>运行状态 —&gt; WAITING<ol><li>调用 <code>xxObject.wait()</code></li><li>调用 <code>xxThread.join()</code></li><li>调用 <code>LockSupport.park()</code></li></ol></li><li>WAITING —&gt; 可运行状态<ol><li>调用 <code>xxObject.notify()</code>、<code>xxObject.notifyAll()</code></li><li>调用 <code>xxThread.interrupt()</code></li><li>调用 <code>LockSupport.unpark(String)</code></li><li>注意事项：<ol><li>被 <code>xxObject.notify()</code>、<code>xxObject.notifyAll()</code>、<code>xxThread.interrupt()</code> 唤醒的 <code>wait</code> 线程，会尝试竞争对象锁</li><li>若成功获取锁，线程将进入可运行状态，准备等待 CPU 时间片继续向下进行（包括异常处理中的 <code>catch</code> 代码块）</li><li>若竞争失败，线程会进入 EntryList 阻塞队列，处于 <code>BLOCKED</code> 状态</li></ol></li></ol></li><li>运行状态 —&gt; TIMED_WAITING<ol><li>调用 <code>xxObject.wait(long)</code></li><li>调用 <code>xxThread.join(long)</code></li><li>调用 <code>Thread.sleep(long)</code></li><li>调用 <code>LockSupport.parkNanos(long)</code>、<code>LockSupport.parkUntil(long)</code></li></ol></li><li>TIMED_WAITING —&gt; 可运行状态<ol><li>等待时间到期，线程自动唤醒</li><li>调用 <code>xxObject.notify()</code>、<code>xxObject.notifyAll()</code></li><li>调用 <code>xxThread.interrupt()</code></li><li>调用 <code>LockSupport.unpark(String)</code></li><li>注意事项：<ol><li>被 <code>xxObject.notify()</code>、<code>xxObject.notifyAll()</code>、<code>xxThread.interrupt()</code> 唤醒的 <code>wait</code> 线程，会尝试竞争对象锁</li><li>若成功获取锁，线程将进入可运行状态，准备等待 CPU 时间片继续向下进行（包括异常处理中的 <code>catch</code> 代码块）</li><li>若竞争失败，线程会进入 EntryList 阻塞队列，处于 <code>BLOCKED</code> 状态</li></ol></li></ol></li></ol></li></ol><hr><h3 id="2-3-线程的活跃性"><a href="#2-3-线程的活跃性" class="headerlink" title="2.3. 线程的活跃性"></a>2.3. 线程的活跃性</h3><h4 id="2-3-1-死锁"><a href="#2-3-1-死锁" class="headerlink" title="2.3.1. 死锁"></a>2.3.1. 死锁</h4><h5 id="2-3-1-1-死锁概述"><a href="#2-3-1-1-死锁概述" class="headerlink" title="2.3.1.1. 死锁概述"></a>2.3.1.1. 死锁概述</h5><p>当一个线程需要同时获取多把锁时，就容易发生死锁。例如，线程 t1 先获得了 A 对象的锁，接下来试图获取 B 对象的锁。</p><p>与此同时，线程 t2 已经获得了 B 对象的锁，并准备去获取 A 对象的锁。此时两个线程互相等待对方释放锁，便形成了死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runT1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (A) &#123;<br>            System.out.println(<span class="hljs-string">&quot;t1 获得 A&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                System.out.println(<span class="hljs-string">&quot;t1 获得 B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;t1 执行操作...&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runT2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (B) &#123;<br>            System.out.println(<span class="hljs-string">&quot;t2 获得 B&quot;</span>);<br>            sleep(<span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                System.out.println(<span class="hljs-string">&quot;t2 获得 A&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;t2 执行操作...&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(millis);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Test::runT1, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Test::runT2, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-1-2-死锁解决方案"><a href="#2-3-1-2-死锁解决方案" class="headerlink" title="2.3.1.2. 死锁解决方案"></a>2.3.1.2. 死锁解决方案</h5><hr><h4 id="2-3-2-活锁"><a href="#2-3-2-活锁" class="headerlink" title="2.3.2. 活锁"></a>2.3.2. 活锁</h4><h5 id="2-3-2-1-活锁概述"><a href="#2-3-2-1-活锁概述" class="headerlink" title="2.3.2.1. 活锁概述"></a>2.3.2.1. 活锁概述</h5><p>活锁虽然名字中带有 “锁”，但它并不是由我们显式加上的锁造成的，而是指两个线程不断互相改变对方的终止条件，导致最终双方都无法完成或结束的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">double</span> seconds)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep((<span class="hljs-type">long</span>) (seconds * <span class="hljs-number">1000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count--;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望超过 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count++;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-2-2-活锁解决方案"><a href="#2-3-2-2-活锁解决方案" class="headerlink" title="2.3.2.2. 活锁解决方案"></a>2.3.2.2. 活锁解决方案</h5><hr><h4 id="2-3-3-饥饿"><a href="#2-3-3-饥饿" class="headerlink" title="2.3.3. 饥饿"></a>2.3.3. 饥饿</h4><h5 id="2-3-3-1-饥饿概述"><a href="#2-3-3-1-饥饿概述" class="headerlink" title="2.3.3.1. 饥饿概述"></a>2.3.3.1. 饥饿概述</h5><p>饥饿是指某个线程长期处于可运行状态（Runnable），但却一直无法获取所需资源（如 CPU 时间片或锁）进行执行</p><hr><h5 id="2-3-3-2-饥饿解决方案"><a href="#2-3-3-2-饥饿解决方案" class="headerlink" title="2.3.3.2. 饥饿解决方案"></a>2.3.3.2. 饥饿解决方案</h5><hr><h3 id="2-4-线程常用方法"><a href="#2-4-线程常用方法" class="headerlink" title="2.4. 线程常用方法"></a>2.4. 线程常用方法</h3><ol><li>Thread 相关方法<ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AThread%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%EF%BC%88JUC%EF%BC%89.md">方法：Thread相关方法（JUC）</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>Object 相关方法<ol><li>obsidian 内部链接：<br> 1. </li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>LockSupport 相关方法<ol><li>obsidian 内部链接：<br> 1. </li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol><hr><h2 id="3-并发编程三大特性"><a href="#3-并发编程三大特性" class="headerlink" title="3. 并发编程三大特性"></a>3. 并发编程三大特性</h2><h3 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1. 可见性"></a>3.1. 可见性</h3><h4 id="3-1-1-可见性概述"><a href="#3-1-1-可见性概述" class="headerlink" title="3.1.1. 可见性概述"></a>3.1.1. 可见性概述</h4><p>可见性是指：一个线程对共享变量的修改，能不能被其他线程及时看到。首先我们来看一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br><span class="hljs-keyword">while</span> (run) &#123;  <br><span class="hljs-comment">// 业务逻辑  </span><br>&#125;  <br>&#125;).start();  <br>  <br>Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>run = <span class="hljs-literal">false</span>;  <br>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>按理来说，<code>run = false</code> 应该能使线程退出循环，但是实际上，线程并不会立即退出循环，而是会继续执行循环体中的代码。这是因为，<code>run</code> 变量被修改后，线程并不知道这个变化，它仍然使用的是旧值，所以会继续执行循环体中的代码。</p><p>其实本质原因是，在线程初始化时，会将 <code>run</code> 变量的值从主内存复制到线程的工作内存中：<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-2.png"></p><p>执行一次就要从主内存中读取一次，如果线程频繁从主内存中读取run 的值，JIT 会将 run 变量的值缓存到线程的工作内存中的高速缓存中，避免每次都从主内存中读取，从而提高效率。<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-3.png"></p><p>这种优化本意是好的，但是也带来了可见性问题：main 线程修改了 <code>run</code> 变量的值，并同步至主内存，但是线程并不知道这个变化，它仍然使用的是旧值，所以会继续执行循环体中的代码。<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-4.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>并发编程的核心问题几乎都围绕着共享变量的操作展开的。因此，可见性、有序性和原子性这三大特性，主要是在操作共享变量时才需要特别关注的</li><li>当一段代码块中存在对共享资源的多线程读写操作，这段代码就称为<strong>临界区</strong>。例如：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) <br><span class="hljs-comment">// 临界区</span><br>&#123;<br>counter++;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) <br><span class="hljs-comment">// 临界区</span><br>&#123;<br>counter--;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>t1.start();<br>t2.start();<br>t1.join();<br>t2.join();<br>System.out.println(counter);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-2-可见性解决方案"><a href="#3-1-2-可见性解决方案" class="headerlink" title="3.1.2. 可见性解决方案"></a>3.1.2. 可见性解决方案</h4><h5 id="3-1-2-1-volatile-解决方案"><a href="#3-1-2-1-volatile-解决方案" class="headerlink" title="3.1.2.1. volatile 解决方案"></a>3.1.2.1. volatile 解决方案</h5><p>想解决这个问题其实很简单，我们只需为共享变量添加一个新的修饰符 <code>volatile</code>。这个关键字的含义是 “易变的”。也就是说，加上 <code>volatile</code> 之后，变量的值不能再从线程的本地缓存中读取，而是每次都必须从主内存中读取最新的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br><span class="hljs-keyword">while</span> (run) &#123;  <br><span class="hljs-comment">// 业务逻辑  </span><br>&#125;  <br>&#125;).start();  <br>  <br>Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>run = <span class="hljs-literal">false</span>;  <br>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>虽然这样做在性能上会有一定的损失，但它确保了多个线程之间对共享变量的可见性。也就是说，一个线程修改了变量的值，其他线程能够及时看到这个变化。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>volatile 可以用来修饰成员变量和静态变量，不能用来修饰局部变量，不需要用来修饰静态常量和普通常量</li><li>volatile 的本质是基于读写屏障来保证可见性的：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 写屏障（sefence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 当对被 volatile 修饰的成员变量或静态变量进行写操作时，编译器会在该语句之后插入一条写屏障指令</span><br><span class="hljs-comment"> * 2. 写屏障用于确保在该屏障之前，对所有共享变量的修改，都被刷新到主内存中，从而保证写操作对其他线程可见。</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span> &#123;<br>    num = <span class="hljs-number">1</span>; <span class="hljs-comment">// num 是普通的共享变量，也会被同步到主内存</span><br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 读屏障（lfence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 当对被 volatile 修饰的成员变量或静态变量进行读操作时，编译器会在该语句之前插入一条读屏障指令</span><br><span class="hljs-comment"> * 2. 读屏障用于确保在该屏障之后，对所有共享变量的读取操作，都能从主内存中获取最新的数据，避免读取到过期值</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-keyword">if</span> (ready) &#123;<br>        num = num + num; <span class="hljs-comment">// num 是普通的共享变量，也加载的是主内存中的最新数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在并发编程中，<code>ReentrantLock</code>、原子类、并发工具类、并发集合以及并发队列等组件，其内部实现通常都大量依赖 <code>volatile</code> 来保证可见性</li></ol></blockquote><hr><h5 id="3-1-2-2-synchronized-解决方案"><a href="#3-1-2-2-synchronized-解决方案" class="headerlink" title="3.1.2.2. synchronized 解决方案"></a>3.1.2.2. synchronized 解决方案</h5><p><code>synchronized</code> 解决可见性的原理是：</p><ol><li>加锁时<ol><li>线程在获取锁之前，会先从主内存中读取共享变量的值，然后将其复制到线程的工作内存中，保证了线程获取锁时，使用的是主内存中的最新值。</li></ol></li><li>解锁时<ol><li>线程在释放锁之前，会将线程的工作内存中所有修改的共享变量刷新到主内存中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 锁对象</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">Lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">synchronized</span> (Lock) &#123;<br>                <span class="hljs-keyword">if</span> (!run) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.start();<br><br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;停止 t&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (Lock) &#123;<br>        run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><hr><h5 id="3-1-2-3-final-解决方案"><a href="#3-1-2-3-final-解决方案" class="headerlink" title="3.1.2.3. final 解决方案"></a>3.1.2.3. final 解决方案</h5><p><code>JMM</code> 规定，当对象的构造函数执行完毕后，<code>final</code> 字段对其他线程立刻可见。因此，<code>final</code> 属性天然不存在可见性问题。</p><p>需要注意的是，如果 <code>final</code> 字段是 “引用类型”，则它所指向的对象本身也必须是不可变的，否则仍可能产生并发可见性风险。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>当一个类的所有属性都被声明为 <code>final</code>，且其引用类型字段所指向的对象也不可变时，这样的类称为不可变类，其实例即为不可变对象</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不可变类</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;<br>    Point(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-有序性"><a href="#3-2-有序性" class="headerlink" title="3.2. 有序性"></a>3.2. 有序性</h3><h4 id="3-2-1-有序性概述"><a href="#3-2-1-有序性概述" class="headerlink" title="3.2.1. 有序性概述"></a>3.2.1. 有序性概述</h4><p>有序性是指：程序的执行顺序与代码的先后顺序一致，以防止 CPU 进行指令重排所带来的不确定性。因为 JVM 在不影响程序最终正确性的前提下，可能会调整语句的实际执行顺序。例如，下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    a = <span class="hljs-number">1</span>;<br>    <br>    b = <span class="hljs-number">2</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>从语义上看，先执行 <code>a = 1</code>，还是先执行 <code>b = 2</code>，并不会改变程序的最终结果。因此，这段代码的实际执行顺序既可以是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">1</span><br><br>b = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>也可以是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">b = <span class="hljs-number">2</span><br><br>a = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这种行为称为<strong>指令重排</strong>，其本质目的是通过指令的重排序与组合，提升执行效率，实现指令级并行（流水线技术）。</p><p>在单线程环境下，指令重排不会改变程序的执行结果，因此通常是安全的。但在多线程场景下，指令重排可能会导致线程之间观察到的执行结果不一致，进而影响程序的正确性。</p><p>因此，在并发编程中，我们需要确保指令重排不会破坏程序逻辑和线程之间的数据可见性，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的列子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>System.out.println(a + b);<br><br><br><span class="hljs-comment">// 不能重排的例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrencyTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">// 一个线程执行这个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <br>        <span class="hljs-keyword">if</span> (ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>    &#125;<br><br><span class="hljs-comment">// 一个线程执行这个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <br>        num = <span class="hljs-number">3</span>;<br>        <br>        ready = <span class="hljs-literal">true</span>;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码在某些情况下可能输出结果为 0，这种现象通常只有在进行大量并发测试时才更容易复现，因此需要借助压测工具辅助观察。其根本原因在于，actor2 中的指令发生了重排，导致执行顺序被打乱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ready = <span class="hljs-literal">true</span>;<br><br>num = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>这种重排序还只是代码的整体执行顺序被打乱</li><li>真正令人头疼的是，如果连 <code>ready = true</code> 这一行指令内部都发生了重排，那后果就相当严重了。</li></ol></blockquote><hr><h4 id="3-2-2-有序性问题解决方案"><a href="#3-2-2-有序性问题解决方案" class="headerlink" title="3.2.2. 有序性问题解决方案"></a>3.2.2. 有序性问题解决方案</h4><h5 id="3-2-2-1-Happens-Before-规则"><a href="#3-2-2-1-Happens-Before-规则" class="headerlink" title="3.2.2.1. Happens-Before 规则"></a>3.2.2.1. Happens-Before 规则</h5><hr><h5 id="3-2-2-2-volatile-解决方案"><a href="#3-2-2-2-volatile-解决方案" class="headerlink" title="3.2.2.2. volatile 解决方案"></a>3.2.2.2. volatile 解决方案</h5><p>同样是为共享变量添加 volatile 关键字，既能够保证可见性，同时也能够禁止指令重排，其同样是基于读写屏障实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 写屏障（sefence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 当对被 volatile 修饰的成员变量或静态变量进行写操作时，编译器会在该语句之后插入一条写屏障指令</span><br><span class="hljs-comment"> * 2. 写屏障用于确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span> &#123;<br>    num = <span class="hljs-number">1</span>; <br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 读屏障（lfence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 当对被 volatile 修饰的成员变量或静态变量进行读操作时，译器会在该语句之前插入一条读屏障指令</span><br><span class="hljs-comment"> * 2. 读屏障用于确保指令重排序时，不会将读屏障之后的代码排在都屏障之前</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-keyword">if</span> (ready) &#123;<br>        num = num + num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="3-2-2-3-synchronized-解决方案"><a href="#3-2-2-3-synchronized-解决方案" class="headerlink" title="3.2.2.3. synchronized 解决方案"></a>3.2.2.3. synchronized 解决方案</h5><hr><h3 id="3-3-原子性"><a href="#3-3-原子性" class="headerlink" title="3.3. 原子性"></a>3.3. 原子性</h3><h4 id="3-3-1-原子性概述"><a href="#3-3-1-原子性概述" class="headerlink" title="3.3.1. 原子性概述"></a>3.3.1. 原子性概述</h4><p>原子性是指：某个操作或一系列操作，是否<strong>不可分割</strong>。简单来说，一个操作要么全部执行完，要么完全不执行，不能出现 “执行一半” 的情况。</p><p>例如这个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>counter++;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>counter--;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>t1.start();<br><br>t2.start();<br><br>t1.join();<br><br>t2.join();<br><br>System.out.println(counter);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>一个线程对 <code>counter</code> 执行 5000 次加法，另一个线程对 <code>counter</code> 执行 5000 次减法。<strong>按理来说，最终结果应该是 0</strong>，但实际上输出可能是正数、负数，甚至恰好为零。为什么会这样呢？</p><p>这是因为 Java 中对静态变量的自增、自减操作<strong>不是原子性的</strong>。要彻底理解这个问题，我们需要先了解 Java 的内存模型（JMM）：<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-5.png"></p><p>然后我们要从 字节码层面分析自增、自减的完整过程。以 <code>counter++</code> 为例，Java 编译器会生成以下 JVM 字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic       counter                <span class="hljs-comment">// 获取静态变量 counter 的值</span><br>iconst_1                               <span class="hljs-comment">// 准备常量 1</span><br>iadd                                   <span class="hljs-comment">// 自增</span><br>putstatic       counter                <span class="hljs-comment">// 将修改后的值存入静态变量 counter</span><br></code></pre></td></tr></table></figure><p>而 <code>counter--</code> 则会生成类似的指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic       counter                <span class="hljs-comment">// 获取静态变量 counter 的值</span><br>iconst_1                               <span class="hljs-comment">// 准备常量 1</span><br>isub                                   <span class="hljs-comment">// 自减</span><br>putstatic       counter                <span class="hljs-comment">// 将修改后的值存入静态变量 counter</span><br></code></pre></td></tr></table></figure><p>假设 <code>counter++</code> 的线程执行到了 <code>iadd</code>，此时 <code>counter</code> 的值为 5，准备通过 <code>putstatic</code> 写入主内存，但就在这一步之前，CPU 的时间片耗尽发生了线程上下文切换。</p><p>接着，另一个执行 <code>counter--</code> 的线程获得了 CPU 时间并执行了多次减法操作，将 <code>counter</code> 的值减到 2，并把 2 写回了主内存。之后 <code>counter++</code> 线程恢复执行，继续完成刚才的 <code>putstatic</code>，把原本准备写的 <strong>5</strong> 写回了主内存，覆盖了之前减到 2 的结果，导致最终结果不正确。</p><hr><h4 id="3-3-2-原子性问题解决"><a href="#3-3-2-原子性问题解决" class="headerlink" title="3.3.2. 原子性问题解决"></a>3.3.2. 原子性问题解决</h4><p>详见下文：锁</p><hr><h2 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h2><h3 id="4-1-锁的分类"><a href="#4-1-锁的分类" class="headerlink" title="4.1. 锁的分类"></a>4.1. 锁的分类</h3><h4 id="4-1-1-可重入锁、不可重入锁"><a href="#4-1-1-可重入锁、不可重入锁" class="headerlink" title="4.1.1. 可重入锁、不可重入锁"></a>4.1.1. 可重入锁、不可重入锁</h4><p>可重入锁是指当前线程获取到 A 锁，在获取之后尝试再次获取 A 锁是可以直接拿到的。Java 中提供的 synchronized、ReentrantLock、ReentrantReadWriteLock 都属于可重入锁的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> MiTest test;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MiTest</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MiTest <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <br>        <span class="hljs-keyword">if</span> (test == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (MiTest.class) &#123;<br>                <span class="hljs-keyword">if</span> (test == <span class="hljs-literal">null</span>) &#123;<br>                    test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiTest</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> test;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-2-乐观锁、悲观锁"><a href="#4-1-2-乐观锁、悲观锁" class="headerlink" title="4.1.2. 乐观锁、悲观锁"></a>4.1.2. 乐观锁、悲观锁</h4><p>乐观锁认为冲突是小概率事件，访问资源时不加锁，只有在更新时才进行校验。如果检测到资源已被其他线程修改，则放弃本次修改并重试，适用于读多写少的场景。</p><p>而悲观锁基于一种保守假设，只要存在多线程操作共享资源，就极有可能产生冲突。因此，每次访问资源前，线程都会先获取锁，以独占方式持有资源，直到操作完成后释放锁，其它线程需等待锁被释放后才能继续访问。</p><p>当无法获取到锁资源时，当前线程会被挂起（进入 BLOCKED 或 WAITING 状态）。线程挂起与唤醒涉及用户态与内核态之间的切换，这种上下文切换是较为耗费系统资源的。</p><ol><li>用户态：<ol><li>指 JVM 能独立完成的操作，不需要操作系统介入。</li></ol></li><li>内存态：<ol><li>指必须由操作系统参与、通过系统调用才能完成的操作。</li></ol></li></ol><p>Java 中提供的 CAS 操作，是乐观锁的一种实现方式，而 <code>Atomic</code> 原子类就是基于 CAS 实现的。而 <code>synchronized</code>、<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 都属于悲观锁的实现。</p><hr><h4 id="4-1-3-公平锁、非公平锁"><a href="#4-1-3-公平锁、非公平锁" class="headerlink" title="4.1.3. 公平锁、非公平锁"></a>4.1.3. 公平锁、非公平锁</h4><p>公平锁是指，当线程 A 获取到锁资源后，线程 B 竞争失败，便进入等待队列排队。此时如果线程 C 也来竞争锁，它会直接排在 B 的后面，只有当 B 获取到锁或取消等待后，C 才有机会尝试获取锁。即，先来先服务，遵循排队原则，防止线程饥饿</p><p>而非公平锁是指，线程 A 获取到锁资源，线程 B 竞争失败后进入等待队列。这时线程 C 到来，不会直接排队，而是会先尝试竞争一波：</p><ol><li>若成功获取锁：<ol><li>插队成功，直接执行，破坏了队列公平性。</li></ol></li><li>若竞争失败：<ol><li>才会排到 B 后面，继续等待获取锁或等 B 放弃后再次尝试。</li></ol></li></ol><p>Java 中的 <code>synchronized</code> 只能实现非公平锁，而 <code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 则支持公平锁和非公平锁两种模式。</p><hr><h4 id="4-1-4-互斥锁、共享锁"><a href="#4-1-4-互斥锁、共享锁" class="headerlink" title="4.1.4. 互斥锁、共享锁"></a>4.1.4. 互斥锁、共享锁</h4><p>互斥锁是指，在同一时刻，只有一个线程能够持有该锁，其它线程必须等待锁被释放后才能竞争获取。</p><p>而共享锁是指，在同一时刻，该锁可以被多个线程同时持有，多个线程可以并发访问共享资源（通常是只读操作）。</p><p>Java 中的 <code>synchronized</code>、<code>ReentrantLock</code> 只能实现互斥锁，而 <code>ReentrantReadWriteLock</code> 则支持互斥锁和共享锁两种模式。</p><hr><h3 id="4-2-synchronized"><a href="#4-2-synchronized" class="headerlink" title="4.2. synchronized"></a>4.2. synchronized</h3><h4 id="4-2-1-synchronized-基本使用"><a href="#4-2-1-synchronized-基本使用" class="headerlink" title="4.2.1. synchronized 基本使用"></a>4.2.1. synchronized 基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        counter++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        counter--;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCounter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>静态方法加 <code>synchronized static</code> 时，锁的是该类的 Class 对象</li><li>普通方法加 <code>synchronized</code> 时，锁的是当前对象（<code>this</code>），其可以简写为：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写法 1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>counter++;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 写法 2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>counter++;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>3. 对于下面的代码，虽然 <code>study()</code> 方法和 <code>sleep()</code> 方法本身没有逻辑上的交集，但如果某个线程调用了带有 <code>synchronized</code> 的 <code>sleep()</code> 方法，就会导致该对象，甚至可能是整个类被加锁。<br>4. 这样一来，其他线程即使只是想调用 <code>study()</code> 方法，也必须等到前一个线程释放锁后才能执行。这种做法不利于并发性能的提升，因此我们可以通过引入多把锁来进行优化：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 原代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2. 多把锁优化</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-2-2-synchronized-底层原理"><a href="#4-2-2-synchronized-底层原理" class="headerlink" title="4.2.2. synchronized 底层原理"></a>4.2.2. synchronized 底层原理</h4><h5 id="4-2-2-1-Java-对象头"><a href="#4-2-2-1-Java-对象头" class="headerlink" title="4.2.2.1. Java 对象头"></a>4.2.2.1. Java 对象头</h5><p>通常我们的一个 Java 对象，他在内存中由两部分组成，一部分是 Java 对象头，一部分是对象中的一些成员变量，对于 对象头而言，以 32 位虚拟机为例：<br><font color="#92d050">1. 普通对象</font><br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-12.png"></p><p><font color="#92d050">2. 数组对象</font><br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-13.png"></p><p><font color="#92d050">3. Mark Word</font><br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-14.png"></p><hr><h5 id="4-2-2-2-Monitor"><a href="#4-2-2-2-Monitor" class="headerlink" title="4.2.2.2. Monitor"></a>4.2.2.2. Monitor</h5><p>Monitor（可译为 “监视器” 或 “管程”）是 JVM 内部专门用于实现重量级锁的结构。当一个 Java 对象升级为重量级锁时，JVM 会为其关联一个 Monitor 对象，用于协调多线程之间对该对象的互斥访问。<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-15.png"></p><p>当 Thread 1 执行完临界区代码后，会根据线程中保存的指向 Object 的地址找到该对象，再通过对象头中指向的 Monitor 地址找到 Monitor 对象，将其 Owner 设置为 null，并唤醒 EntryList 中所有等待的线程，这些线程随后开始竞争锁的拥有权。</p><hr><h4 id="4-2-3-synchrnoized-锁升级"><a href="#4-2-3-synchrnoized-锁升级" class="headerlink" title="4.2.3. synchrnoized 锁升级"></a>4.2.3. synchrnoized 锁升级</h4><h5 id="4-2-3-1-轻量级锁"><a href="#4-2-3-1-轻量级锁" class="headerlink" title="4.2.3.1. 轻量级锁"></a>4.2.3.1. 轻量级锁</h5><p>考虑到重量级锁的性能问题，锁竞争时线程需要挂起与唤醒，会触发操作系统层面的上下文切换，代价极高，动辄消耗数万 CPU 周期。同时，频繁的线程阻塞还可能带来调度延迟、缓存失效等额外副作用。</p><p>而现实中，大多数锁的竞争程度其实并不高。很多临界区的代码执行极快，线程间访问呈错峰分布，根本不会产生真正的冲突；即便发生竞争，通常也只是短暂的、少数线程的重叠访问。这种情况下，一个线程已迅速完成执行，而另一个线程却仍在挂起、唤醒、重新调度的过程中。更何况，即使没有阻塞与唤醒，重量级锁的加锁与解锁过程本身也不轻。因此，为了提升并发性能，在这类 “低冲突、短执行” 的场景中，Java 官方将重量级锁优化为轻量级锁，语法不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        counter++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        counter--;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCounter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>现在有线程去调用 synchronized 的方法，会在其线程栈帧中创建一个锁记录（Lock Record）<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-6.png"></p><p>接着，线程尝试给对象加轻量级锁。操作流程是，先让 Object reference 指向对象地址，并使用 CAS（原子操作）尝试将锁记录的地址与对象头中的 Mark Word 交换。<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-7.png"></p><p>如果 CAS 替换成功，对象头中就存储了锁记录的地址（因为需要记录是哪个线程拥有该对象的锁），此时 Object 的状态为 00，表示对象持有轻量级锁。当临界区代码执行完毕，锁记录会被交换回对象头。<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-8.png"></p><p>如果 CAS 失败，但是是当前线程在执行 synchronized 发生重入，会添加一条新的锁记录作为重入计数。锁记录数量表示该线程对该对象加锁的次数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(obj) &#123;<br>        method2();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(obj) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-9.png"></p><p>如果 CAS 失败且发生线程竞争，当前线程会进行多次自旋尝试（赌其他线程能快速释放锁，避免像重量级锁一样直接挂起带来的性能损耗）。若多次尝试仍未成功，则发生锁膨胀，锁会升级为重量级锁。</p><p>假设 Thread 0 已持有轻量级锁，但 Thread 1 多次自旋均未成功，<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-10.png"></p><p>这时 JVM 会为该对象分配一个 Monitor 对象，将对象头中原先指向锁记录的 Mark Word 替换为指向 Monitor 的指针，Thread 1 被加入 Monitor 的 EntryList 队列挂起，Monitor 的 Owner 指向 Thread 0。<br><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-11.png"></p><p>当 Thread 0 执行完临界区代码，需要解锁时，会先尝试通过 CAS 将锁记录恢复到对象头（Mark Word），肯定发生失败，进入重量级锁解锁流程。  </p><p>解锁时，线程会根据线程中保存的指向 Object 的地址找到该对象，再通过对象头中指向的 Monitor 地址找到 Monitor 对象，将其 Owner 设置为 null，并唤醒 EntryList 中所有等待的线程，这些线程随后开始竞争锁的拥有权。</p><p>虽然轻量级锁相比不加锁确实带来了一些额外成本（但共享资源操作必须加锁），例如每次进入锁时需要创建锁记录、执行 CAS 操作，并且存在短暂的自旋，可能会消耗一些 CPU 周期；</p><p>但轻量级锁有效避免了线程阻塞和唤醒的开销，在大多数 “无锁竞争” 或 “低冲突” 的场景下，能够以极低的成本完成加锁与释放，因此整体性能远远优于重量级锁。</p><hr><h5 id="4-2-3-2-偏向锁"><a href="#4-2-3-2-偏向锁" class="headerlink" title="4.2.3.2. 偏向锁"></a>4.2.3.2. 偏向锁</h5><p>偏向锁是在轻量级锁基础上的进一步优化，其设计初衷是为了在无竞争的场景下提升锁操作的性能。</p><p>然而，随着硬件性能提升和虚拟机其他优化手段的发展，偏向锁带来的性能收益已逐渐减弱，同时其实现的复杂性也成为阻碍 JVM 进一步优化的负担。因此，Oracle 在 JDK 15 中将偏向锁标记为废弃，并在 JDK 17 中将其彻底移除。若使用的是 JDK8，偏向锁默认是开启的，我们需要通过在 JVM 启动参数中添加配置来显式禁止偏向锁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:-UseBiasedLocking<br></code></pre></td></tr></table></figure><hr><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><ol><li>AQS 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：AbstractQueuedSynchronizer源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol><hr><h4 id="ReentrantLock-概述"><a href="#ReentrantLock-概述" class="headerlink" title="ReentrantLock 概述"></a>ReentrantLock 概述</h4><p><code>ReentrantLock</code> 是 Java 提供的一种 <strong>显式锁</strong>，基于 AQS，功能类似于 <code>synchronized</code>，但更灵活、功能更强大。</p><ol><li>ReentrantLock 可以支持中断，而 synchronized 不支持中断（被 <code>xxThread.interrupted()</code>）</li><li>ReentrantLock 可以支持公平锁&#x2F;非公平锁，而 synchronized 只支持非公平锁</li><li>ReentrantLock 可以设置超时时间，而 synchronized 不能设置超时时间</li><li>ReentrantLock 可以支持多个条件等待，而 synchronized 只支持 wait 条件等待（ <code>xxObject.wait()</code>、<code>xxObject.wait(long)</code>、<code>xxObject.notify()</code>、<code>Object.notifyAll()</code> ）<ol><li>也就是说 ReentrantLock 中可以有多个等待队列，可以根据情况想唤醒那个队列中的线程，就唤醒那个队列中的线程</li><li>而 synchronized 只具有 <code>waitSet</code> 等待队列（在语义上，<code>EntryList</code> 属于竞争锁的队列，而不是条件等待的队列）</li></ol></li><li>ReentrantLock 可以轻松观察锁的状态，而 synchronized 完全就是黑盒</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>锁竞争激烈的场景，建议优先使用 ReentrantLock，因为它没有 “锁升级” 的额外开销<ol><li>synchronized 在偏向锁、轻量级锁情况下，的确效率很高</li><li>但一旦升级为重量级锁，就无法降级，而且在高竞争场景下性能会受到影响。</li></ol></li><li>如果你对并发机制掌握不深，优先使用 synchronized，语法简洁、出错率低。但如果你需要更强的灵活性（可中断、公平性、条件变量等），并且熟悉并发编程，ReentrantLock 会更合适</li><li>JUC 大神（Doug Lea 以及后续维护者们）在实现 线程池、阻塞队列、同步器 时，都会用 ReentrantLock 甚至更底层的 AQS，因为他们需要这些 “精细的控制力”</li></ol></blockquote><hr><h4 id="ReentrantLock-常用方法"><a href="#ReentrantLock-常用方法" class="headerlink" title="ReentrantLock 常用方法"></a>ReentrantLock 常用方法</h4><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AReentrantLock%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：ReentrantLock 常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h4 id="ReentrantLock-源码解析"><a href="#ReentrantLock-源码解析" class="headerlink" title="ReentrantLock 源码解析"></a>ReentrantLock 源码解析</h4><ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ReentrantLock源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><h4 id="ReentrantReadWriteLock-概述"><a href="#ReentrantReadWriteLock-概述" class="headerlink" title="ReentrantReadWriteLock 概述"></a>ReentrantReadWriteLock 概述</h4><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池基础体系"><a href="#线程池基础体系" class="headerlink" title="线程池基础体系"></a>线程池基础体系</h3><p><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-16.png"></p><ol><li>Executor 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Executor源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>ExecutorService 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ExecutorService源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>AbstractExecutorService 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AAbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：AbstractExecutorService源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>ThreadPoolExecutor 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：ThreadPoolExecutor源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool 是线程池体系中的三架马车，只学这三个，不仅够用，而且专业</li></ol></blockquote><hr><h3 id="ThreadPoolExecutor-使用示例"><a href="#ThreadPoolExecutor-使用示例" class="headerlink" title="ThreadPoolExecutor 使用示例"></a>ThreadPoolExecutor 使用示例</h3><hr><h3 id="ScheduledThreadPoolExecutor-使用示例"><a href="#ScheduledThreadPoolExecutor-使用示例" class="headerlink" title="ScheduledThreadPoolExecutor 使用示例"></a>ScheduledThreadPoolExecutor 使用示例</h3><hr><h3 id="ForkJoinPool-使用示例"><a href="#ForkJoinPool-使用示例" class="headerlink" title="ForkJoinPool 使用示例"></a>ForkJoinPool 使用示例</h3><hr><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="异步编程基础体系"><a href="#异步编程基础体系" class="headerlink" title="异步编程基础体系"></a>异步编程基础体系</h3><p><img src="/2025/08/28/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-19.png"></p><ol><li>Runnable 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ARunnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Runnable源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>Callable 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ACallable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Callable源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>Future＜V＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Future＜V＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol><hr><h3 id="异步编程实现方式"><a href="#异步编程实现方式" class="headerlink" title="异步编程实现方式"></a>异步编程实现方式</h3><h4 id="FutureTask＜V＞-线程池-实现方式"><a href="#FutureTask＜V＞-线程池-实现方式" class="headerlink" title="FutureTask＜V＞ + 线程池 实现方式"></a>FutureTask＜V＞ + 线程池 实现方式</h4><hr><h4 id="CompletableFuture-实现方式"><a href="#CompletableFuture-实现方式" class="headerlink" title="CompletableFuture 实现方式"></a>CompletableFuture 实现方式</h4><hr><h4 id="Reactive-响应式编程-实现方式"><a href="#Reactive-响应式编程-实现方式" class="headerlink" title="Reactive 响应式编程 实现方式"></a>Reactive 响应式编程 实现方式</h4><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：Selector 常用方法</title>
    <link href="/2025/08/27/%E6%96%B9%E6%B3%95%EF%BC%9ASelector%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/27/%E6%96%B9%E6%B3%95%EF%BC%9ASelector%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="static-Selector-open-（∈-Selector）"><a href="#static-Selector-open-（∈-Selector）" class="headerlink" title="static Selector open()（∈ Selector）"></a>static Selector open()（∈ Selector）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="轮询等待方法"><a href="#轮询等待方法" class="headerlink" title="轮询等待方法"></a>轮询等待方法</h3><h4 id="int-select"><a href="#int-select" class="headerlink" title="int select()"></a>int select()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int select()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 返回就绪的 Channel 数量（一瞬间可能有多个 Channel 就绪）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 阻塞等待，直到至少有一个 Channel 就绪，就立即返回</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 通常使用 while(true) 循环调用该方法，并根据 xxSelector.selectedKeys() 获取就绪事件的集合并进行处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">select</span> <span class="hljs-operator">=</span> selector.select();<br></code></pre></td></tr></table></figure><hr><h4 id="int-select-long-timeout"><a href="#int-select-long-timeout" class="headerlink" title="int select(long timeout)"></a>int select(long timeout)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int select(long timeout)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. long timeout</span><br><span class="hljs-comment"> *          1. 最多阻塞等待 timeout 毫秒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 返回就绪的 Channel 数量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 阻塞等待 timeout 毫秒，如果等待期间有 Channel 就绪，就立即返回。如果超时还未有 Channel 就绪，就会返回 0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 通常使用 while(true) 循环调用该方法，并根据 xxSelector.selectedKeys() 获取就绪事件的集合并进行处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">select</span> <span class="hljs-operator">=</span> selector.select(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="int-selectNow"><a href="#int-selectNow" class="headerlink" title="int selectNow()"></a>int selectNow()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 立即返回就绪的 Channel 数量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> selector.selectNow();<br></code></pre></td></tr></table></figure><hr><h4 id="Selector-wakeup"><a href="#Selector-wakeup" class="headerlink" title="Selector wakeup()"></a>Selector wakeup()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 唤醒阻塞在轮询等待的线程</span><br>selector.wakeup();<br></code></pre></td></tr></table></figure><hr><h3 id="就绪-Channel-管理方法"><a href="#就绪-Channel-管理方法" class="headerlink" title="就绪 Channel 管理方法"></a>就绪 Channel 管理方法</h3><h4 id="Set＜SelectionKey＞-selectedKeys"><a href="#Set＜SelectionKey＞-selectedKeys" class="headerlink" title="Set＜SelectionKey＞  selectedKeys()"></a>Set＜SelectionKey＞  selectedKeys()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取已就绪事件对应的 SelectionKey 集合</span><br>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>通常对其进行处理，然后使用完必须清理掉：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br><br><span class="hljs-keyword">for</span> (SelectionKey key : selectedKeys) &#123;<br>    <br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <span class="hljs-comment">// OP_ACCEPT：调用 accept() 方法，返回一个新的 SocketChannel</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>        <span class="hljs-comment">// OP_CONNECT：finishConnect() 一般要在这里调用</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>        <span class="hljs-comment">// OP_READ：通道有数据可读，比如从 SocketChannel 读取字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>        <span class="hljs-comment">// OP_WRITE：通道可写，可以往 SocketChannel 写数据</span><br>    &#125;<br>    <br>&#125;<br><br>selectedKeys.clear(); <br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close（）"><a href="#void-close（）" class="headerlink" title="void close（）"></a>void close（）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">selector.close();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Chrome</title>
    <link href="/2025/08/27/%E7%AC%94%E8%AE%B0%EF%BC%9AChrome/"/>
    <url>/2025/08/27/%E7%AC%94%E8%AE%B0%EF%BC%9AChrome/</url>
    
    <content type="html"><![CDATA[<h2 id="减少-CloudFlare-检查频率"><a href="#减少-CloudFlare-检查频率" class="headerlink" title="减少 CloudFlare 检查频率"></a>减少 CloudFlare 检查频率</h2><hr>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
      <category>Chrome</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：BufferedInputStream 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="BufferedInputStream-InputStream-in"><a href="#BufferedInputStream-InputStream-in" class="headerlink" title="BufferedInputStream(InputStream in)"></a>BufferedInputStream(InputStream in)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h3 id="BufferedInputStream-InputStream-in-int-size"><a href="#BufferedInputStream-InputStream-in-int-size" class="headerlink" title="BufferedInputStream(InputStream in, int size)"></a>BufferedInputStream(InputStream in, int size)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">9999</span>);<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：BufferedOutputStream 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="BufferedOutputStream-OutputStream-out"><a href="#BufferedOutputStream-OutputStream-out" class="headerlink" title="BufferedOutputStream(OutputStream out)"></a>BufferedOutputStream(OutputStream out)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bufferedOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h3 id="BufferedOutputStream-OutputStream-out-int-size"><a href="#BufferedOutputStream-OutputStream-out-int-size" class="headerlink" title="BufferedOutputStream(OutputStream out, int size)"></a>BufferedOutputStream(OutputStream out, int size)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bufferedOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">9999</span>);<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：Buffer 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABuffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABuffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><h3 id="1-1-获取直接缓冲区-Buffer"><a href="#1-1-获取直接缓冲区-Buffer" class="headerlink" title="1.1. 获取直接缓冲区 Buffer"></a>1.1. 获取直接缓冲区 Buffer</h3><p>直接缓冲区是指：Buffer 分配在操作系统的内存中，而不是 JVM 堆内存上。在 IO 操作中，直接缓冲区性能更高，因为它可以直接作用于本地系统的 IO。</p><p>从数据流的角度来看：</p><ol><li>直接缓冲区的数据流<ol><li>本地 IO ➔  直接缓存 ➔  本地 IO</li></ol></li><li>非直接缓冲区的数据流<ol><li>本地 IO ➔  直接内存 ➔  非直接内存 ➔  直接内存 ➔  本地 IO</li></ol></li></ol><p>需要注意的是，虽然 IO 性能更高，虽然直接缓冲区 IO 性能更高，但在分配和回收时开销较大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 ByteBuffer 类型的直接缓冲区</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>); <span class="hljs-comment">// 1024 字节</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>判断 Buffer 是否为直接缓冲区，可调用 <code>xxBuffer.isDirect()</code>，返回 <code>true</code> 就表示是直接缓冲区。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>System.out.println(buffer.isDirect());<br></code></pre></td></tr></table></figure><hr><h3 id="1-2-获取非直接缓冲区-Buffer"><a href="#1-2-获取非直接缓冲区-Buffer" class="headerlink" title="1.2. 获取非直接缓冲区 Buffer"></a>1.2. 获取非直接缓冲区 Buffer</h3><p>非直接缓冲区是指：Buffer 分配在JVM 堆内存上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 ByteBuffer 类型的非直接缓冲区</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h2><h3 id="2-1-写方法"><a href="#2-1-写方法" class="headerlink" title="2.1. 写方法"></a>2.1. 写方法</h3><h4 id="2-1-1-ByteBuffer-put-byte-b"><a href="#2-1-1-ByteBuffer-put-byte-b" class="headerlink" title="2.1.1. ByteBuffer put(byte b)"></a>2.1.1. ByteBuffer put(byte b)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将单个字节写入缓冲区的当前 position</span><br>byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">97</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="2-1-2-ByteBuffer-put-byte-src"><a href="#2-1-2-ByteBuffer-put-byte-src" class="headerlink" title="2.1.2. ByteBuffer put(byte[] src)"></a>2.1.2. ByteBuffer put(byte[] src)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将字节数组写入缓冲区的当前 position</span><br>byteBuffer.put(<span class="hljs-string">&quot;abc&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure><hr><h3 id="2-2-读方法"><a href="#2-2-读方法" class="headerlink" title="2.2. 读方法"></a>2.2. 读方法</h3><h4 id="2-2-1-byte-get"><a href="#2-2-1-byte-get" class="headerlink" title="2.2.1. byte get()"></a>2.2.1. byte get()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从缓冲区的当前 position 读取单个字节</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> byteBuffer.get();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>读完之后再想写，一般有两种方式：<ol><li>用 <code>xxBuffer.clwar()</code> 彻底重置，准备新一轮写</li><li>用 <code>xxBuffer.compact()</code> 保留没读完的，继续写</li></ol></li></ol></blockquote><hr><h4 id="2-2-2-ByteBuffer-get-byte-dst"><a href="#2-2-2-ByteBuffer-get-byte-dst" class="headerlink" title="2.2.2. ByteBuffer get(byte[] dst)"></a>2.2.2. ByteBuffer get(byte[] dst)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从缓冲区当前 position 读取字节数组</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer1</span> <span class="hljs-operator">=</span> byteBuffer.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><hr><h3 id="2-3-清空方法"><a href="#2-3-清空方法" class="headerlink" title="2.3. 清空方法"></a>2.3. 清空方法</h3><h4 id="2-3-1-ByteBuffer-clear"><a href="#2-3-1-ByteBuffer-clear" class="headerlink" title="2.3.1. ByteBuffer clear()"></a>2.3.1. ByteBuffer clear()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将 position 归零，将 limit 恢复成 capacity，取消设置的 mark，将数据标记为可覆盖</span><br>byteBuffer.clear();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>并没有 “清空数据”，只是标记为 “旧数据可以覆盖”</li></ol></blockquote><hr><h3 id="2-4-limit-管理方法"><a href="#2-4-limit-管理方法" class="headerlink" title="2.4. limit 管理方法"></a>2.4. limit 管理方法</h3><h4 id="2-4-1-ByteBuffer-flip"><a href="#2-4-1-ByteBuffer-flip" class="headerlink" title="2.4.1. ByteBuffer flip()"></a>2.4.1. ByteBuffer flip()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将 limit 设置为当前 position，然后将 position 归零</span><br>byteBuffer.flip();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>写完数据后，要先 <code>xxBuffer.flip()</code> ，否则无法读到正确的范围，因为 limit 还是 capacity，但实际上很多格子不一定写数据</li></ol></blockquote><hr><h4 id="2-4-2-int-limit"><a href="#2-4-2-int-limit" class="headerlink" title="2.4.2. int limit()"></a>2.4.2. int limit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回 limit 的位置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> byteBuffer.limit();<br></code></pre></td></tr></table></figure><hr><h4 id="2-4-3-ByteBuffer-limit-int-newLimit"><a href="#2-4-3-ByteBuffer-limit-int-newLimit" class="headerlink" title="2.4.3. ByteBuffer limit(int newLimit)"></a>2.4.3. ByteBuffer limit(int newLimit)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置 limit 的位置</span><br>byteBuffer.limit(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="2-4-4-int-position"><a href="#2-4-4-int-position" class="headerlink" title="2.4.4. int position()"></a>2.4.4. int position()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回 position 的位置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> byteBuffer.position();<br></code></pre></td></tr></table></figure><hr><h4 id="2-4-5-ByteBuffer-position-int-newPosition"><a href="#2-4-5-ByteBuffer-position-int-newPosition" class="headerlink" title="2.4.5. ByteBuffer position(int newPosition)"></a>2.4.5. ByteBuffer position(int newPosition)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置 position 的位置</span><br>byteBuffer.position(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="2-5-capacity-管理方法"><a href="#2-5-capacity-管理方法" class="headerlink" title="2.5. capacity 管理方法"></a>2.5. capacity 管理方法</h3><h4 id="2-5-1-int-capacity"><a href="#2-5-1-int-capacity" class="headerlink" title="2.5.1. int capacity()"></a>2.5.1. int capacity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回 Buffer 的 capacity 大小</span><br><span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> byteBuffer.capacity();<br></code></pre></td></tr></table></figure><hr><h3 id="2-6-position-管理方法"><a href="#2-6-position-管理方法" class="headerlink" title="2.6. position 管理方法"></a>2.6. position 管理方法</h3><h4 id="2-6-1-ByteBuffer-flip"><a href="#2-6-1-ByteBuffer-flip" class="headerlink" title="2.6.1. ByteBuffer flip()"></a>2.6.1. ByteBuffer flip()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将 limit 设置为当前 position，然后将 position 归零</span><br>byteBuffer.flip();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>写完数据后，要先 <code>xxBuffer.flip()</code> ，否则无法读到正确的范围，因为 limit 还是 capacity，但实际上很多格子不一定写数据</li></ol></blockquote><hr><h4 id="2-6-2-ByteBuffer-rewind"><a href="#2-6-2-ByteBuffer-rewind" class="headerlink" title="2.6.2. ByteBuffer rewind()"></a>2.6.2. ByteBuffer rewind()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把 position 归零，取消设置的 mark</span><br>byteBuffer.rewind();<br></code></pre></td></tr></table></figure><hr><h4 id="2-6-3-ByteBuffer-mark"><a href="#2-6-3-ByteBuffer-mark" class="headerlink" title="2.6.3. ByteBuffer mark()"></a>2.6.3. ByteBuffer mark()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记录当前 position</span><br>byteBuffer.mark();<br></code></pre></td></tr></table></figure><hr><h4 id="2-6-4-ByteBuffer-reset"><a href="#2-6-4-ByteBuffer-reset" class="headerlink" title="2.6.4. ByteBuffer reset()"></a>2.6.4. ByteBuffer reset()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// position 回到 mark 标记点</span><br>byteBuffer.reset();<br></code></pre></td></tr></table></figure><hr><h3 id="2-7-数据管理方法"><a href="#2-7-数据管理方法" class="headerlink" title="2.7. 数据管理方法"></a>2.7. 数据管理方法</h3><h4 id="2-7-1-ByteBuffer-compact"><a href="#2-7-1-ByteBuffer-compact" class="headerlink" title="2.7.1. ByteBuffer compact()"></a>2.7.1. ByteBuffer compact()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把未读取的数据 “挪到” 缓冲区前面，方便继续写</span><br>byteBuffer.compact();<br></code></pre></td></tr></table></figure><hr><h4 id="2-7-2-boolean-hasRemaining"><a href="#2-7-2-boolean-hasRemaining" class="headerlink" title="2.7.2. boolean hasRemaining()"></a>2.7.2. boolean hasRemaining()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断缓冲区是否还有元素未读/写</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> byteBuffer.hasRemaining();<br></code></pre></td></tr></table></figure><hr><h4 id="2-7-3-int-remaining"><a href="#2-7-3-int-remaining" class="headerlink" title="2.7.3. int remaining()"></a>2.7.3. int remaining()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回缓冲区剩余未读/写的元素个数，即 limit - position</span><br><span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> byteBuffer.remaining();<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：BufferedWriter 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedWriter%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedWriter%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="BufferedWriter-Writer-out"><a href="#BufferedWriter-Writer-out" class="headerlink" title="BufferedWriter(Writer out)"></a>BufferedWriter(Writer out)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h3 id="BufferedWriter-Writer-out-int-sz"><a href="#BufferedWriter-Writer-out-int-sz" class="headerlink" title="BufferedWriter(Writer out, int sz)"></a>BufferedWriter(Writer out, int sz)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">9999</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="换行方法"><a href="#换行方法" class="headerlink" title="换行方法"></a>换行方法</h3><h4 id="void-newLine"><a href="#void-newLine" class="headerlink" title="void newLine"></a>void newLine</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br><br>bufferedWriter.write(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>bufferedWriter.newLine();<br><br>bufferedWriter.write(<span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果正在使用 <code>BufferedWriter</code> 写入文件，推荐使用 <code>xxBufferedWriter.newLine()</code> 方法，一眼就知道是在干嘛</li><li>如果是字符串拼接等场景，推荐直接使用 <code>System.lineSeparator()</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span> + System.lineSeparator() + <span class="hljs-string">&quot;World&quot;</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：BufferedReader 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedReader%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ABufferedReader%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="BufferedReader-Reader-in"><a href="#BufferedReader-Reader-in" class="headerlink" title="BufferedReader(Reader in)"></a>BufferedReader(Reader in)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h3 id="BufferedReader-Reader-in-1"><a href="#BufferedReader-Reader-in-1" class="headerlink" title="BufferedReader(Reader in)"></a>BufferedReader(Reader in)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">9999</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="读方法"><a href="#读方法" class="headerlink" title="读方法"></a>读方法</h3><h4 id="String-readLine"><a href="#String-readLine" class="headerlink" title="String readLine()"></a>String readLine()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * String readLine()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 一整行数据的 String 类型</span><br><span class="hljs-comment"> *      2. null</span><br><span class="hljs-comment"> *          1. 流到达文件末尾，返回 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 读一行数据</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：FileReader 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AFileReader%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AFileReader%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="FileReader-String-fileName"><a href="#FileReader-String-fileName" class="headerlink" title="FileReader(String fileName)"></a>FileReader(String fileName)</h3><hr><h3 id="FileReader-String-fileName-Charset-charset"><a href="#FileReader-String-fileName-Charset-charset" class="headerlink" title="FileReader(String fileName, Charset charset)"></a>FileReader(String fileName, Charset charset)</h3><hr><h3 id="FileReader-File-file"><a href="#FileReader-File-file" class="headerlink" title="FileReader(File file)"></a>FileReader(File file)</h3><hr><h3 id="FileReader-File-file-Charset-charset"><a href="#FileReader-File-file-Charset-charset" class="headerlink" title="FileReader(File file, Charset charset)"></a>FileReader(File file, Charset charset)</h3><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="读方法"><a href="#读方法" class="headerlink" title="读方法"></a>读方法</h3><h4 id="int-read"><a href="#int-read" class="headerlink" title="int read()"></a>int read()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int read()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 读取的字符在指定解码规则解码后的整数（0 - 65535）</span><br><span class="hljs-comment"> *      2. -1</span><br><span class="hljs-comment"> *          1. 流到达文件末尾时，返回 -1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 读一个字符数据</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> fileReader.read();<br></code></pre></td></tr></table></figure><hr><h4 id="int-read-char-cbuf"><a href="#int-read-char-cbuf" class="headerlink" title="int read(char[] cbuf)"></a>int read(char[] cbuf)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int read(char[] cbuf)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. char[] cbuf</span><br><span class="hljs-comment"> *          1. 当缓冲容器的字符数组，数据先读到字符数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 本次读取的字符数量</span><br><span class="hljs-comment"> *      2. -1</span><br><span class="hljs-comment"> *          1. 流到达文件末尾时，返回 -1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> fileReader.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：FileWriter 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AFileWriter%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AFileWriter%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="FileWriter-String-fileName"><a href="#FileWriter-String-fileName" class="headerlink" title="FileWriter(String fileName)"></a>FileWriter(String fileName)</h3><hr><h3 id="FileWriter-String-fileName-boolean-append"><a href="#FileWriter-String-fileName-boolean-append" class="headerlink" title="FileWriter(String fileName, boolean append)"></a>FileWriter(String fileName, boolean append)</h3><hr><h3 id="FileWriter-String-fileName-Charset-charset"><a href="#FileWriter-String-fileName-Charset-charset" class="headerlink" title="FileWriter(String fileName, Charset charset)"></a>FileWriter(String fileName, Charset charset)</h3><hr><h3 id="FileWriter-String-fileName-Charset-charset-boolean-append"><a href="#FileWriter-String-fileName-Charset-charset-boolean-append" class="headerlink" title="FileWriter(String fileName, Charset charset, boolean append)"></a>FileWriter(String fileName, Charset charset, boolean append)</h3><hr><h3 id="FileWriter-File-file"><a href="#FileWriter-File-file" class="headerlink" title="FileWriter(File file)"></a>FileWriter(File file)</h3><hr><h3 id="FileWriter-File-file-boolean-append"><a href="#FileWriter-File-file-boolean-append" class="headerlink" title="FileWriter(File file, boolean append)"></a>FileWriter(File file, boolean append)</h3><hr><h3 id="FileWriter-File-file-Charset-charset"><a href="#FileWriter-File-file-Charset-charset" class="headerlink" title="FileWriter(File file, Charset charset)"></a>FileWriter(File file, Charset charset)</h3><hr><h3 id="FileWriter-File-file-Charset-charset-boolean-append"><a href="#FileWriter-File-file-Charset-charset-boolean-append" class="headerlink" title="FileWriter(File file, Charset charset, boolean append)"></a>FileWriter(File file, Charset charset, boolean append)</h3><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="写方法"><a href="#写方法" class="headerlink" title="写方法"></a>写方法</h3><h4 id="void-write-int-c"><a href="#void-write-int-c" class="headerlink" title="void write(int c)"></a>void write(int c)</h4><hr><h4 id="void-write-char-cbuf"><a href="#void-write-char-cbuf" class="headerlink" title="void write(char cbuf[])"></a>void write(char cbuf[])</h4><hr><h4 id="void-write-char-cbuf-int-off-int-len"><a href="#void-write-char-cbuf-int-off-int-len" class="headerlink" title="void write(char cbuf[], int off, int len)"></a>void write(char cbuf[], int off, int len)</h4><hr><h4 id="void-write-String-str"><a href="#void-write-String-str" class="headerlink" title="void write(String str)"></a>void write(String str)</h4><hr><h4 id="void-write-String-str-int-off-int-len"><a href="#void-write-String-str-int-off-int-len" class="headerlink" title="void write(String str, int off, int len)"></a>void write(String str, int off, int len)</h4><hr><h3 id="刷新方法"><a href="#刷新方法" class="headerlink" title="刷新方法"></a>刷新方法</h3><h4 id="void-flush"><a href="#void-flush" class="headerlink" title="void flush()"></a>void flush()</h4><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：ObjectInputStream 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AObjectInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AObjectInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="ObjectInputStream-InputStream-in"><a href="#ObjectInputStream-InputStream-in" class="headerlink" title="ObjectInputStream(InputStream in)"></a>ObjectInputStream(InputStream in)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="读方法"><a href="#读方法" class="headerlink" title="读方法"></a>读方法</h3><h4 id="Object-readObject"><a href="#Object-readObject" class="headerlink" title="Object readObject"></a>Object readObject</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> (Student) objectInputStream.readObject();<br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：Java Stream 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AJavaStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AJavaStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><h3 id="1-1-单列集合获取-Stream"><a href="#1-1-单列集合获取-Stream" class="headerlink" title="1.1. 单列集合获取 Stream"></a>1.1. 单列集合获取 Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建单列集合</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>Collections.addAll(list, <span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>);<br><br><span class="hljs-comment">// 2. 单列集合获取 Stream</span><br>Stream&lt;String&gt; stream1 = list.stream();<br></code></pre></td></tr></table></figure><hr><h3 id="1-2-双列集合获取-Stream"><a href="#1-2-双列集合获取-Stream" class="headerlink" title="1.2. 双列集合获取 Stream"></a>1.2. 双列集合获取 Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建双列集合</span><br>HashMap&lt;String,Integer&gt; hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// 2. 双列集合获取 Stream（Key）</span><br>hm.keySet().stream().forEach(s -&gt; System.out.println(s));<br><br><span class="hljs-comment">// 3. 双列集合获取 Stream（Key=Value）</span><br>hm.entrySet().stream().forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><hr><h3 id="1-3-数组获取-Stream"><a href="#1-3-数组获取-Stream" class="headerlink" title="1.3. 数组获取 Stream"></a>1.3. 数组获取 Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建数组 </span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;; <br><br><span class="hljs-comment">// 2. 数组获取 Stream</span><br>Arrays.stream(arr).forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><hr><h3 id="1-4-零散数据获取-Stream"><a href="#1-4-零散数据获取-Stream" class="headerlink" title="1.4. 零散数据获取 Stream"></a>1.4. 零散数据获取 Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>).forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>这一堆零散的数据，需要是同一数据类型的</li></ol></blockquote><hr><h2 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h2><h3 id="2-1-中间方法"><a href="#2-1-中间方法" class="headerlink" title="2.1. 中间方法"></a>2.1. 中间方法</h3><h4 id="2-1-1-过滤方法"><a href="#2-1-1-过滤方法" class="headerlink" title="2.1.1. 过滤方法"></a>2.1.1. 过滤方法</h4><h5 id="2-1-1-1-Stream＜T＞-filter-Predicate＜-super-T＞-predicate"><a href="#2-1-1-1-Stream＜T＞-filter-Predicate＜-super-T＞-predicate" class="headerlink" title="2.1.1.1. Stream＜T＞  filter(Predicate＜? super T＞  predicate)"></a>2.1.1.1. Stream＜T＞  filter(Predicate＜? super T＞  predicate)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list1.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里调用的 <code>s.startsWith</code> 方法属于 String 类型。换句话说，集合中元素是什么类型，就能调用该类型所提供的方法</li><li>这也正是为什么不建议在同一个集合中混放不同类型的数据</li></ol></blockquote><hr><h4 id="2-1-2-去重方法"><a href="#2-1-2-去重方法" class="headerlink" title="2.1.2. 去重方法"></a>2.1.2. 去重方法</h4><h5 id="2-1-2-1-Stream＜T＞-distinct"><a href="#2-1-2-1-Stream＜T＞-distinct" class="headerlink" title="2.1.2.1. Stream＜T＞  distinct();"></a>2.1.2.1. Stream＜T＞  distinct();</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list1.stream().distinct().forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>distinct()</code> 依赖 <code>Object.equals()</code> 和 <code>Object.hashCode()</code>，简单来说，流中的元素是放进一个 <code>HashSet</code> 做去重时，判断两个元素是否 “重复”，就是调用它们的 <code>equals()</code> 来比较是否相等，并通过 <code>hashCode()</code> 来加快判重效率</li><li>如果流中的元素没有好好重写 <code>equals()</code> 和 <code>hashCode()</code>，去重效果可能就不是你想的那样<ol><li>如果流中的元素是 String，去重会正常生效，因为 <code>String</code> 已经正确重写了 <code>equals()</code> 和 <code>hashCode()</code></li><li>如果流中的元素是我们自定义的类（如 <code>Student</code>），而没有重写这两个方法，则内容相同的对象也会被视为不同元素，导致无法去重。</li></ol></li></ol></blockquote><hr><h4 id="2-1-3-转换方法"><a href="#2-1-3-转换方法" class="headerlink" title="2.1.3. 转换方法"></a>2.1.3. 转换方法</h4><h5 id="2-1-3-1-＜R＞-Stream＜R＞-map-Function＜-super-T-extends-R＞-mapper"><a href="#2-1-3-1-＜R＞-Stream＜R＞-map-Function＜-super-T-extends-R＞-mapper" class="headerlink" title="2.1.3.1. ＜R＞  Stream＜R＞ map(Function＜? super T, ? extends R＞ mapper);"></a>2.1.3.1. ＜R＞  Stream＜R＞ map(Function＜? super T, ? extends R＞ mapper);</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list1.stream().map(s -&gt; s.charAt(<span class="hljs-number">0</span>)).forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>map</code> 与 <code>forEach</code> 的作用不同，<code>map</code> 用于<strong>元素转换</strong>，并会返回一个新的 <code>Stream</code></li></ol></blockquote><hr><h3 id="2-2-终结方法"><a href="#2-2-终结方法" class="headerlink" title="2.2. 终结方法"></a>2.2. 终结方法</h3><h4 id="2-2-1-遍历方法"><a href="#2-2-1-遍历方法" class="headerlink" title="2.2.1. 遍历方法"></a>2.2.1. 遍历方法</h4><h5 id="2-2-1-1-void-forEach-Consumer＜-super-T＞-action"><a href="#2-2-1-1-void-forEach-Consumer＜-super-T＞-action" class="headerlink" title="2.2.1.1. void forEach(Consumer＜? super T＞  action)"></a>2.2.1.1. void forEach(Consumer＜? super T＞  action)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list1.stream().forEach(name -&gt; System.out.println(name));<br></code></pre></td></tr></table></figure><hr><h4 id="2-2-2-聚合方法"><a href="#2-2-2-聚合方法" class="headerlink" title="2.2.2. 聚合方法"></a>2.2.2. 聚合方法</h4><h5 id="2-2-2-1-long-count"><a href="#2-2-2-1-long-count" class="headerlink" title="2.2.2.1. long count();"></a>2.2.2.1. long count();</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list1.stream().count();<br></code></pre></td></tr></table></figure><hr><h4 id="2-2-3-收集方法"><a href="#2-2-3-收集方法" class="headerlink" title="2.2.3. 收集方法"></a>2.2.3. 收集方法</h4><h5 id="2-2-3-1-Object-toArray"><a href="#2-2-3-1-Object-toArray" class="headerlink" title="2.2.3.1. Object[] toArray()"></a>2.2.3.1. Object[] toArray()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] array = list1.stream().toArray();<br></code></pre></td></tr></table></figure><hr><h5 id="2-2-3-2-＜A＞-A-toArray-IntFunction＜A-＞-generator"><a href="#2-2-3-2-＜A＞-A-toArray-IntFunction＜A-＞-generator" class="headerlink" title="2.2.3.2. ＜A＞  A[] toArray(IntFunction＜A[]＞  generator)"></a>2.2.3.2. ＜A＞  A[] toArray(IntFunction＜A[]＞  generator)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = list1.stream().toArray(value -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[value]);<br></code></pre></td></tr></table></figure><hr><h5 id="2-2-3-3-＜R-A＞-R-collect-Collector＜-super-T-A-R＞-collector"><a href="#2-2-3-3-＜R-A＞-R-collect-Collector＜-super-T-A-R＞-collector" class="headerlink" title="2.2.3.3. ＜R, A＞  R collect(Collector＜? super T, A, R＞  collector)"></a>2.2.3.3. ＜R, A＞  R collect(Collector＜? super T, A, R＞  collector)</h5><h6 id="2-2-3-3-1-收集到-List"><a href="#2-2-3-3-1-收集到-List" class="headerlink" title="2.2.3.3.1. 收集到 List"></a>2.2.3.3.1. 收集到 List</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; collect = list1.stream().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><hr><h6 id="2-2-3-3-2-收集到-Set"><a href="#2-2-3-3-2-收集到-Set" class="headerlink" title="2.2.3.3.2. 收集到 Set"></a>2.2.3.3.2. 收集到 Set</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; collect = list1.stream().collect(Collectors.toSet());<br></code></pre></td></tr></table></figure><hr><h6 id="2-2-3-3-3-收集到-Map"><a href="#2-2-3-3-3-收集到-Map" class="headerlink" title="2.2.3.3.3. 收集到 Map"></a>2.2.3.3.3. 收集到 Map</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Character, String&gt; collect = list1.stream().collect(Collectors.toMap(  <br>        s -&gt; s.charAt(<span class="hljs-number">0</span>),  <br>        s -&gt; s  <br>));<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>收集到 Map 时，需要明确哪个字段作为 Key，哪个字段作为 Value</li><li>Map 的 Key 必须唯一，不能重复，否则会抛异常</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：ObjectOutputStream 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AObjectOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AObjectOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="ObjectOutputStream-OutputStream-out"><a href="#ObjectOutputStream-OutputStream-out" class="headerlink" title="ObjectOutputStream(OutputStream out)"></a>ObjectOutputStream(OutputStream out)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="写方法"><a href="#写方法" class="headerlink" title="写方法"></a>写方法</h3><h4 id="void-writeObject-Object-obj"><a href="#void-writeObject-Object-obj" class="headerlink" title="void writeObject(Object obj)"></a>void writeObject(Object obj)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <br>  <br>student.setName(<span class="hljs-string">&quot;Bob&quot;</span>);  <br>  <br>student.setAge(<span class="hljs-number">18</span>);  <br>  <br>objectOutputStream.writeObject(student);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Student</code> 类不要忘记实现 <code>Serializable</code> 接口</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> String name;  <br>  <br>    <span class="hljs-keyword">private</span> String age;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(String age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：SelectionKey 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ASelectionKey%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ASelectionKey%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="就绪状态判断方法"><a href="#就绪状态判断方法" class="headerlink" title="就绪状态判断方法"></a>就绪状态判断方法</h3><h4 id="boolean-isAcceptable"><a href="#boolean-isAcceptable" class="headerlink" title="boolean isAcceptable()"></a>boolean isAcceptable()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断当前 SelectionKey 是否 accept 已就绪</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">acceptable</span> <span class="hljs-operator">=</span> selectionKey.isAcceptable();<br></code></pre></td></tr></table></figure><hr><h4 id="boolean-isConnectable"><a href="#boolean-isConnectable" class="headerlink" title="boolean isConnectable()"></a>boolean isConnectable()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断当前 SelectionKey 是否 connect 已就绪</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">connectable</span> <span class="hljs-operator">=</span> selectionKey.isConnectable();<br></code></pre></td></tr></table></figure><hr><h4 id="boolean-isReadable"><a href="#boolean-isReadable" class="headerlink" title="boolean isReadable()"></a>boolean isReadable()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断当前 SelectionKey 是否 read 已就绪</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">readable</span> <span class="hljs-operator">=</span> selectionKey.isReadable();<br></code></pre></td></tr></table></figure><hr><h4 id="boolean-isWritable"><a href="#boolean-isWritable" class="headerlink" title="boolean isWritable()"></a>boolean isWritable()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断当前 SelectionKey 是否 write 已就绪</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">writable</span> <span class="hljs-operator">=</span> selectionKey.isWritable();<br></code></pre></td></tr></table></figure><hr><h3 id="Key-有效性管理方法"><a href="#Key-有效性管理方法" class="headerlink" title="Key 有效性管理方法"></a>Key 有效性管理方法</h3>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：SocketChannel 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ASocketChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9ASocketChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="static-SocketChannel-open-（∈-SocketChannel）"><a href="#static-SocketChannel-open-（∈-SocketChannel）" class="headerlink" title="static SocketChannel open()（∈ SocketChannel）"></a>static SocketChannel open()（∈ SocketChannel）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个未连接的 SocketChannel</span><br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>使用这种方式构造的 SocketChannel，需要自己配合 <code>xxSocketChannel.connect(SocketAddress remote)</code> 来发起连接</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 让 SocketChannel 连接到指定 IP 地址和端口</span><br>socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br></code></pre></td></tr></table></figure><hr><h3 id="static-SocketChannel-open-SocketAddress-remote-（∈-SocketChannel）"><a href="#static-SocketChannel-open-SocketAddress-remote-（∈-SocketChannel）" class="headerlink" title="static SocketChannel open(SocketAddress remote)（∈ SocketChannel）"></a>static SocketChannel open(SocketAddress remote)（∈ SocketChannel）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="连接方法"><a href="#连接方法" class="headerlink" title="连接方法"></a>连接方法</h3><h4 id="boolean-connect-SocketAddress-remote"><a href="#boolean-connect-SocketAddress-remote" class="headerlink" title="boolean connect(SocketAddress remote)"></a>boolean connect(SocketAddress remote)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 让 SocketChannel 连接到指定 IP 地址和端口</span><br>socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br></code></pre></td></tr></table></figure><hr><h3 id="注册方法"><a href="#注册方法" class="headerlink" title="注册方法"></a>注册方法</h3><h4 id="SelectionKey-register-Selector-sel-int-ops"><a href="#SelectionKey-register-Selector-sel-int-ops" class="headerlink" title="SelectionKey register(Selector sel, int ops)"></a>SelectionKey register(Selector sel, int ops)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * SelectionKey register(Selector sel, int ops)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. Selector sel</span><br><span class="hljs-comment"> *          1. 要注册到那个 Selector</span><br><span class="hljs-comment"> *      2. int ops</span><br><span class="hljs-comment"> *          1. 关心的事件类型</span><br><span class="hljs-comment"> *          2. SelectionKey.OP_CONNECT</span><br><span class="hljs-comment"> *              1. 客户端发送连接就绪</span><br><span class="hljs-comment"> *          3. SelectionKey.OP_ACCEPT</span><br><span class="hljs-comment"> *              1. 服务端接收连接就绪</span><br><span class="hljs-comment"> *          4. SelectionKey.OP_READ</span><br><span class="hljs-comment"> *              1. 通道有数据可读</span><br><span class="hljs-comment"> *          5. SelectionKey.OP_WRITE</span><br><span class="hljs-comment"> *              1. 通道有数据可写</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 该 Channel 注册在某个 Selector 的关系对象（SelectionKey）</span><br><span class="hljs-comment"> *          1. 你可以使用该 Key 进行一系列操作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 将该 Channel 注册到某个 Selector</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">register</span> <span class="hljs-operator">=</span> socketChannel.register(xxSelector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们可以使用 SelectionKey 进行一系列操作<ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ASelectionKey%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：SelectionKey 常用方法</a></li></ol></li><li>Hexo 连接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h4 id="SelectionKey-keyFor-Selector-sel"><a href="#SelectionKey-keyFor-Selector-sel" class="headerlink" title="SelectionKey keyFor(Selector sel)"></a>SelectionKey keyFor(Selector sel)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取该 Channel 注册在某个 Selector 的关系对象（SelectionKey）</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> socketChannel.keyFor(xxSelector);<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：ReentrantLock 常用方法</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AReentrantLock%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AReentrantLock%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="public-ReentrantLock"><a href="#public-ReentrantLock" class="headerlink" title="public ReentrantLock()"></a>public ReentrantLock()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造非公平锁的 ReentrantLock</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="public-ReentrantLock-boolean-fair"><a href="#public-ReentrantLock-boolean-fair" class="headerlink" title="public ReentrantLock(boolean fair)"></a>public ReentrantLock(boolean fair)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：public ReentrantLock(boolean fair)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. boolean fair</span><br><span class="hljs-comment"> *          1. true</span><br><span class="hljs-comment"> *              1. 公平锁，先到先服务</span><br><span class="hljs-comment"> *          2. false</span><br><span class="hljs-comment"> *              2. 非公平锁，加锁时新线程可能插队</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 构造公平锁/非公平锁的 ReentrantLock</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="加锁方法"><a href="#加锁方法" class="headerlink" title="加锁方法"></a>加锁方法</h3><h4 id="public-void-lock"><a href="#public-void-lock" class="headerlink" title="public void lock()"></a>public void lock()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果拿不到锁，会一直阻塞，不管是否被 xxThread.interrupt()</span><br>reentrantLock.lock();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>线程的中断标志位仍然会被设置为 true</li></ol></blockquote><hr><h4 id="public-void-lockInterruptibly"><a href="#public-void-lockInterruptibly" class="headerlink" title="public void lockInterruptibly()"></a>public void lockInterruptibly()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果拿不到锁，会一直阻塞，可以被 xxThread.interrupt()</span><br>reentrantLock.lockInterruptibly();<br></code></pre></td></tr></table></figure><hr><h4 id="public-boolean-tryLock"><a href="#public-boolean-tryLock" class="headerlink" title="public boolean tryLock()"></a>public boolean tryLock()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 尝试获取锁，立即返回</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> reentrantLock.tryLock();<br></code></pre></td></tr></table></figure><hr><h4 id="public-boolean-tryLock-long-timeout-TimeUnit-unit"><a href="#public-boolean-tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="public boolean tryLock(long timeout, TimeUnit unit)"></a>public boolean tryLock(long timeout, TimeUnit unit)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 具体方法：public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. long timeout</span><br><span class="hljs-comment"> *          1. 阻塞等待多长时间</span><br><span class="hljs-comment"> *      2. TimeUnit unit</span><br><span class="hljs-comment"> *          1. timeout 的单位</span><br><span class="hljs-comment"> *          2. TimeUnit.NANOSECONDS</span><br><span class="hljs-comment"> *              1. 纳秒</span><br><span class="hljs-comment"> *          3. TimeUnit.MICROSECONDS</span><br><span class="hljs-comment"> *              1. 微秒</span><br><span class="hljs-comment"> *          4. TimeUnit.MILLISECONDS</span><br><span class="hljs-comment"> *              1. 毫秒</span><br><span class="hljs-comment"> *          5. TimeUnit.SECONDS</span><br><span class="hljs-comment"> *              1. 秒</span><br><span class="hljs-comment"> *          6. TimeUnit.MINUTES</span><br><span class="hljs-comment"> *              1. 分钟</span><br><span class="hljs-comment"> *          7. TimeUnit.HOURS</span><br><span class="hljs-comment"> *              1. 小时</span><br><span class="hljs-comment"> *          8. TimeUnit.DAYS</span><br><span class="hljs-comment"> *              1. 天</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. true</span><br><span class="hljs-comment"> *          1. 获取到锁</span><br><span class="hljs-comment"> *      2. false</span><br><span class="hljs-comment"> *          1. 未获取到锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 阻塞指定时间尝试获取锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 可以被 xxThread.interrupted()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> reentrantLock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><hr><h3 id="解锁方法"><a href="#解锁方法" class="headerlink" title="解锁方法"></a>解锁方法</h3><h4 id="public-void-unlock"><a href="#public-void-unlock" class="headerlink" title="public void unlock()"></a>public void unlock()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">reentrantLock.unlock();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>必须由持有锁的线程进行调用，否则会抛 <code>IllegalMonitorStateException</code></li><li>始终在 <code>finally</code> 块中调用 <code>unlock()</code>，这样才能保证无论加锁代码是否抛出异常，锁都能被正确释放。</li></ol></blockquote><hr><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="public-boolean-isLocked"><a href="#public-boolean-isLocked" class="headerlink" title="public boolean isLocked()"></a>public boolean isLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断这把锁是否被某个线程持有</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> reentrantLock.isLocked();<br></code></pre></td></tr></table></figure><hr><h4 id="public-boolean-isHeldByCurrentThread"><a href="#public-boolean-isHeldByCurrentThread" class="headerlink" title="public boolean isHeldByCurrentThread()"></a>public boolean isHeldByCurrentThread()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断当前线程是不是持有了这把锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">heldByCurrentThread</span> <span class="hljs-operator">=</span> reentrantLock.isHeldByCurrentThread();<br></code></pre></td></tr></table></figure><hr><h4 id="public-int-getHoldCount"><a href="#public-int-getHoldCount" class="headerlink" title="public int getHoldCount()"></a>public int getHoldCount()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查看当前线程对这把锁的重入次数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">holdCount</span> <span class="hljs-operator">=</span> reentrantLock.getHoldCount();<br></code></pre></td></tr></table></figure><hr><h4 id="public-final-boolean-hasQueuedThreads"><a href="#public-final-boolean-hasQueuedThreads" class="headerlink" title="public final boolean hasQueuedThreads()"></a>public final boolean hasQueuedThreads()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否有线程在排队等待这把锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> reentrantLock.hasQueuedThreads();<br></code></pre></td></tr></table></figure><hr><h4 id="public-final-boolean-hasQueuedThread-Thread-thread"><a href="#public-final-boolean-hasQueuedThread-Thread-thread" class="headerlink" title="public final boolean hasQueuedThread(Thread thread)"></a>public final boolean hasQueuedThread(Thread thread)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断指定线程是否在排队等待这把锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> reentrantLock.hasQueuedThread(myThread);<br></code></pre></td></tr></table></figure><hr><h4 id="public-final-int-getQueueLength"><a href="#public-final-int-getQueueLength" class="headerlink" title="public final int getQueueLength()"></a>public final int getQueueLength()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查看大概由多少线程在排队等待这把锁</span><br><span class="hljs-type">int</span> <span class="hljs-variable">queueLength</span> <span class="hljs-operator">=</span> reentrantLock.getQueueLength();<br></code></pre></td></tr></table></figure><hr><h4 id="public-final-boolean-isFair"><a href="#public-final-boolean-isFair" class="headerlink" title="public final boolean isFair()"></a>public final boolean isFair()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断这把锁是不是公平锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">fair</span> <span class="hljs-operator">=</span> reentrantLock.isFair();<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：Thread 相关方法（JUC）</title>
    <link href="/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AThread%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%EF%BC%88JUC%EF%BC%89/"/>
    <url>/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AThread%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%EF%BC%88JUC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><h3 id="1-1-继承-Thread-类，重写-run-方法"><a href="#1-1-继承-Thread-类，重写-run-方法" class="headerlink" title="1.1. 继承 Thread 类，重写 run 方法"></a>1.1. 继承 Thread 类，重写 run 方法</h3><p><font color="#92d050">1. 匿名内部类继承</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <br><span class="hljs-comment">// 创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;myThread&quot;</span>) &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-comment">// 本线程要执行的任务  </span><br>            &#125;  <br>        &#125;;  <br>          <br>        <span class="hljs-comment">// 启动线程  </span><br>        myThread.start();  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 显示声明类继承</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 显示声明类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 本线程要执行的任务  </span><br>  <br>    &#125;  <br>    <br>&#125;<br><br><br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-comment">// 1. 正常创建 MyThread 类型的线程对象  </span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>  <br>        <span class="hljs-comment">// 2. 向上转型创建 Thread 类型的线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>  <br>        <span class="hljs-comment">// 启动线程  </span><br>        myThread1.start();  <br>        <br>        myThread2.start();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="1-2-使用-Runnable-Thread"><a href="#1-2-使用-Runnable-Thread" class="headerlink" title="1.2. 使用 Runnable + Thread"></a>1.2. 使用 Runnable + Thread</h3><p>直接使用 <code>Thread</code> 相当于将线程控制与具体任务耦合在一起，为了具有更好的灵活性，也为了更容易与线程池等高级并发 API 配合使用，我们可以使用 <code>Runnable</code> 实现了线程与任务的分离。</p><p><code>Runnable</code> 是一个接口，其源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们可以通过如下方式创建一个线程对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 Runnable 接口对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 本 Runnable 要执行的任务</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 2. 创建线程对象，传入 Runnable 接口对象。线程将执行 Runnable 中指定的 run 方法</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br><span class="hljs-comment">// 3. 启动线程</span><br>myThread.start();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 Java 中，只包含一个抽象方法的接口可以加上 <code>@FunctionalInterface</code> 注解，表示该接口是一个函数式接口，从而可以使用 lambda 表达式进行简洁书写（只有一个抽象方法，但还可能存在几个 default 方法）</li><li>需要注意的是，如果 lambda 表达式中有多条语句，必须使用花括号 <code>&#123;&#125;</code> 包裹。如果只有一条语句，则可以省略花括号。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// lambda 表达式创建 Runnable</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br><span class="hljs-comment">// 本 Runnable 要执行的任务</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="1-3-使用-FutureTask-Thread"><a href="#1-3-使用-FutureTask-Thread" class="headerlink" title="1.3. 使用 FutureTask + Thread"></a>1.3. 使用 FutureTask + Thread</h3><h4 id="1-3-1-Runnable-的缺陷"><a href="#1-3-1-Runnable-的缺陷" class="headerlink" title="1.3.1. Runnable 的缺陷"></a>1.3.1. Runnable 的缺陷</h4><p>无论是使用 Runnable + Thread，还是直接使用 Thread，我们都会发现只能执行无返回值的方法。也就是说，方法执行完成后无法获取返回值，而有时我们确实需要返回值来进行错误处理。</p><p>除此之外，我们也发现，使用 Runnable 时也无法抛出受检异常（checked Exception）。</p><hr><h4 id="1-3-2-Callable-概述"><a href="#1-3-2-Callable-概述" class="headerlink" title="1.3.2. Callable 概述"></a>1.3.2. Callable 概述</h4><p>Callable 和 Runnable 类似，都是用来定义任务的接口。不同的是，Callable 定义了带返回值且可抛异常的 <code>V call()</code> 方法。</p><p>但需要注意的是，Thread 构造方法只能接收 Runnable 类型的对象，因此 Callable 不能像 Runnable 那样直接传给 Thread 使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="1-3-3-使用-FutureTask-Thread"><a href="#1-3-3-使用-FutureTask-Thread" class="headerlink" title="1.3.3. 使用 FutureTask + Thread"></a>1.3.3. 使用 FutureTask + Thread</h4><p>关于 Runnable、Callable、Future 的详细解释，详见下文：异步编程。这里我们先了解如何通过这种方式来创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 Callable 接口对象</span><br>Callable&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 2. 创建 FutureTask 对象，传入 Callable 接口对象。</span><br>FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(task);<br><br><span class="hljs-comment">// 3. 创建线程对象，传入 FutureTask 对象。线程将执行 Callable 中指定的 call 方法，并能调用 FutureTask 的方法进行相关操作</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br><span class="hljs-comment">// 4. 启动线程</span><br>myThread.start();<br><br><span class="hljs-comment">// 5. 调用 FutureTask  相关方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();  <span class="hljs-comment">// 阻塞等待任务执行完成，获取返回值</span><br>    System.out.println(<span class="hljs-string">&quot;任务返回结果: &quot;</span> + result);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>创建 FutureTask 对象时，可直接使用 Lambda 表达式，无需单独创建 Callable 接口对象</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; <span class="hljs-number">1</span> + <span class="hljs-number">2</span>);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br>myThread.start();<br></code></pre></td></tr></table></figure><hr><h3 id="1-4-使用线程池"><a href="#1-4-使用线程池" class="headerlink" title="1.4. 使用线程池"></a>1.4. 使用线程池</h3><p>详见笔记：JUC 下的线程池</p><hr><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="睡眠方法"><a href="#睡眠方法" class="headerlink" title="睡眠方法"></a>睡眠方法</h3><h4 id="static-native-void-sleep-long-millis"><a href="#static-native-void-sleep-long-millis" class="headerlink" title="static native void sleep(long millis)"></a>static native void sleep(long millis)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * static native void sleep(long millis)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. long millis</span><br><span class="hljs-comment"> *          1. 休眠 millis 毫秒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 让当前执行的线程，休眠 millis 毫秒。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 休眠时会从 运行状态 ➔ Timed_Waiting，让出 CPU 时间片给其他线程</span><br><span class="hljs-comment"> *      2. 其他线程可以通过 xxThread.interrupt() 方法打断某个正在 sleep 的线程</span><br><span class="hljs-comment"> *          1. 线程进入可运行状态，等待 CPU 时间片继续向下执行</span><br><span class="hljs-comment"> *          2. 线程进入运行状态后，会抛出 InterruptedException，并将中断标志位清除</span><br><span class="hljs-comment"> *          3. 如果你未捕获并处理该异常，线程可能直接终止</span><br><span class="hljs-comment"> *      3. 建议使用 TimeUnit 的 sleep 代替 Thread 的 sleep，两者功能相同，但前者可读性更强，单位更清晰</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>使用 TimeUnit 的 sleep 代替 Thread 的 sleep</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeUnit.HOURS.sleep(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. <code>Thread.sleep(long millis)</code> 能有效防止 CPU 空转<br>    1. CPU 空转是指线程持续进行无意义的轮询操作：既没有执行有价值的计算，也不是在等待某个条件或事件的变化，仅仅是在占用 CPU 做无用功。<br>    2. 在当前时间片内，CPU 使用率被拉满但是却没做任何有意义的事情，像这样毫无意义地持续运行，就是典型的 CPU 空转行为。<br>3. 防止 CPU 空转的常用方式有：<br>    1. Object.wait()<br>    2. 条件变量<br>    3. Thread.yield()<br>    4. Thread.sleep(long millis)<br>    5. 不过前两种方式都需要在加锁的前提下使用，并依赖其他线程进行唤醒，通常适用于涉及线程协作的同步场景<br>    6. 而 <code>Thread.sleep(50)</code> 和 <code>Thread.yield()</code> 则适合单线程控制节奏、减少空转的简单场景</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CPU 空转</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;程序正在运行中...&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>    <br>&#125;<br><br><br><span class="hljs-comment">// 防止 CPU 空转</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            System.out.println(<span class="hljs-string">&quot;程序正在运行中...&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="打断方法"><a href="#打断方法" class="headerlink" title="打断方法"></a>打断方法</h3><p>被打断的一定有这个流程吗？ *      2. 其他线程可以通过 xxThread.interrupt() 方法打断某个正在 sleep 的线程</p><ul><li><pre><code class="hljs">     1. 线程进入可运行状态，等待 CPU 时间片继续向下执行</code></pre></li><li><pre><code class="hljs">     2. 线程进入运行状态后，会抛出 InterruptedException，并将中断标志位清除</code></pre></li><li><pre><code class="hljs">     3. 如果你未捕获并处理该异常，线程可能直接终止</code></pre>一定会设置<strong>打断标志位</strong></li></ul><h3 id="让出-CPU-方法"><a href="#让出-CPU-方法" class="headerlink" title="让出 CPU 方法"></a>让出 CPU 方法</h3><h4 id="static-native-void-yield"><a href="#static-native-void-yield" class="headerlink" title="static native void yield()"></a>static native void yield()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * static native void yield()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 提示线程调度器让出当前线程的 CPU 时间片</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 线程会从 运行状态 ➔ 可运行状态</span><br><span class="hljs-comment"> *      2. 这个方法主要是为了测试和调试，并且仅是建议性提示，是否生效取决于具体的调度策略；</span><br><span class="hljs-comment"> *      3. 与 Thread.sleep(long millis) 方法的区别在于，Thread.yield() 让出时间片后，线程会处于可运行状态，如果没有其他可运行的线程，当前线程仍有可能被继续调度执行；</span><br><span class="hljs-comment"> *      4. 而 Thread.sleep(long millis) 会使线程进入 Timed_Waiting 状态，不能随即就被调度</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>Thread.<span class="hljs-keyword">yield</span>();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>该代码在多核处理器上效果可能不明显，但在单核环境中其调度行为将更为明显</li></ol></blockquote><hr><h3 id="获取-Thread-方法"><a href="#获取-Thread-方法" class="headerlink" title="获取 Thread 方法"></a>获取 Thread 方法</h3><h4 id="static-native-Thread-currentThread"><a href="#static-native-Thread-currentThread" class="headerlink" title="static native Thread currentThread()"></a>static native Thread currentThread()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前线程的 Thread 对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br></code></pre></td></tr></table></figure><hr><h3 id="获取中断标志位方法"><a href="#获取中断标志位方法" class="headerlink" title="获取中断标志位方法"></a>获取中断标志位方法</h3><h4 id="static-boolean-interrupted"><a href="#static-boolean-interrupted" class="headerlink" title="static boolean interrupted()"></a>static boolean interrupted()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * static boolean interrupted()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 当前线程是否具有打断标记</span><br><span class="hljs-comment"> *          1. true</span><br><span class="hljs-comment"> *              1. 具有打断标记</span><br><span class="hljs-comment"> *          2. false</span><br><span class="hljs-comment"> *              1. 不具有打断标记</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 获取当前线程的打断标记</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 获取后会清除打断标记</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> Thread.interrupted();<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Collection＜E＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9ACollection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9ACollection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Collection＜E＞-概述"><a href="#1-Collection＜E＞-概述" class="headerlink" title="1. Collection＜E＞ 概述"></a>1. Collection＜E＞ 概述</h2><p><code>Collection＜E＞</code> 是一个接口，定义了 “如何对一组对象（集合）进行操作” 的规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br><br>    Object[] toArray();<br><br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-keyword">default</span> &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) &#123;<br>        <span class="hljs-keyword">return</span> toArray(generator.apply(<span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>        Objects.requireNonNull(filter);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();<br>        <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>                each.remove();<br>                removed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Iterable＜E＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AIterable%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Iterable＜E＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-int-size"><a href="#3-1-1-int-size" class="headerlink" title="3.1.1. int size()"></a>3.1.1. int size()</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>int size()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 返回当前 Collection 的元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-1-2-方法实现"><a href="#3-1-1-2-方法实现" class="headerlink" title="3.1.1.2. 方法实现"></a>3.1.1.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.size();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-2-boolean-isEmpty"><a href="#3-1-2-boolean-isEmpty" class="headerlink" title="3.1.2. boolean isEmpty()"></a>3.1.2. boolean isEmpty()</h4><h5 id="3-1-2-1-方法概述"><a href="#3-1-2-1-方法概述" class="headerlink" title="3.1.2.1. 方法概述"></a>3.1.2.1. 方法概述</h5><p><code>boolean isEmpty()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 判断当前 Collection 是否为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-2-2-方法实现"><a href="#3-1-2-2-方法实现" class="headerlink" title="3.1.2.2. 方法实现"></a>3.1.2.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.isEmpty();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-3-boolean-contains-Object-o"><a href="#3-1-3-boolean-contains-Object-o" class="headerlink" title="3.1.3. boolean contains(Object o)"></a>3.1.3. boolean contains(Object o)</h4><h5 id="3-1-3-1-方法概述"><a href="#3-1-3-1-方法概述" class="headerlink" title="3.1.3.1. 方法概述"></a>3.1.3.1. 方法概述</h5><p><code>boolean contains(Object o)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 判断当前 Collection 是否包含某个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-3-2-方法实现"><a href="#3-1-3-2-方法实现" class="headerlink" title="3.1.3.2. 方法实现"></a>3.1.3.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.contains(o);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-4-Object-toArray"><a href="#3-1-4-Object-toArray" class="headerlink" title="3.1.4. Object[] toArray()"></a>3.1.4. Object[] toArray()</h4><h5 id="3-1-4-1-方法概述"><a href="#3-1-4-1-方法概述" class="headerlink" title="3.1.4.1. 方法概述"></a>3.1.4.1. 方法概述</h5><p><code>public Object[] toArray()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 将当前 Collection 转换成 Object[] 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] toArray();<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-4-2-方法实现"><a href="#3-1-4-2-方法实现" class="headerlink" title="3.1.4.2. 方法实现"></a>3.1.4.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> internalList.toArray();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-5-＜T＞-T-toArray-T-a"><a href="#3-1-5-＜T＞-T-toArray-T-a" class="headerlink" title="3.1.5. ＜T＞ T[] toArray(T[] a)"></a>3.1.5. ＜T＞ T[] toArray(T[] a)</h4><h5 id="3-1-5-1-方法概述"><a href="#3-1-5-1-方法概述" class="headerlink" title="3.1.5.1. 方法概述"></a>3.1.5.1. 方法概述</h5><p><code>public ＜T＞ T[] toArray(T[] a)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于将当前 Collection 转换成指定类型的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; T[] toArray(T[] a);<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-5-2-方法实现"><a href="#3-1-5-2-方法实现" class="headerlink" title="3.1.5.2. 方法实现"></a>3.1.5.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">return</span> internalList.toArray(a);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-6-boolean-add-E-e"><a href="#3-1-6-boolean-add-E-e" class="headerlink" title="3.1.6. boolean add(E e)"></a>3.1.6. boolean add(E e)</h4><h5 id="3-1-6-1-方法概述"><a href="#3-1-6-1-方法概述" class="headerlink" title="3.1.6.1. 方法概述"></a>3.1.6.1. 方法概述</h5><p><code>public boolean add(String string)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 向当前 Collection 添加一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-6-2-方法实现"><a href="#3-1-6-2-方法实现" class="headerlink" title="3.1.6.2. 方法实现"></a>3.1.6.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.add(string);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-7-boolean-remove-Object-o"><a href="#3-1-7-boolean-remove-Object-o" class="headerlink" title="3.1.7. boolean remove(Object o)"></a>3.1.7. boolean remove(Object o)</h4><h6 id="3-1-7-1-1-方法概述"><a href="#3-1-7-1-1-方法概述" class="headerlink" title="3.1.7.1.1. 方法概述"></a>3.1.7.1.1. 方法概述</h6><p><code>public boolean remove(Object o)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 向当前 Collection 移除一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-7-2-方法实现"><a href="#3-1-7-2-方法实现" class="headerlink" title="3.1.7.2. 方法实现"></a>3.1.7.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.remove(o);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-8-boolean-retainAll-Collection＜-＞-c"><a href="#3-1-8-boolean-retainAll-Collection＜-＞-c" class="headerlink" title="3.1.8. boolean retainAll(Collection＜?＞ c)"></a>3.1.8. boolean retainAll(Collection＜?＞ c)</h4><h5 id="3-1-8-1-方法概述"><a href="#3-1-8-1-方法概述" class="headerlink" title="3.1.8.1. 方法概述"></a>3.1.8.1. 方法概述</h5><p><code>boolean retainAll(Collection＜?＞ c)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 保留传入 Collection 中的元素与当前 Collection 中的元素的交集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-8-2-方法实现"><a href="#3-1-8-2-方法实现" class="headerlink" title="3.1.8.2. 方法实现"></a>3.1.8.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.containsAll(c);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-9-boolean-addAll-Collection＜-extends-E＞-c"><a href="#3-1-9-boolean-addAll-Collection＜-extends-E＞-c" class="headerlink" title="3.1.9. boolean addAll(Collection＜? extends E＞ c)"></a>3.1.9. boolean addAll(Collection＜? extends E＞ c)</h4><h5 id="3-1-9-1-方法概述"><a href="#3-1-9-1-方法概述" class="headerlink" title="3.1.9.1. 方法概述"></a>3.1.9.1. 方法概述</h5><p><code>boolean addAll(Collection＜? extends E＞ c)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 批量添加传入 Collection 中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-9-2-方法实现"><a href="#3-1-9-2-方法实现" class="headerlink" title="3.1.9.2. 方法实现"></a>3.1.9.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends String&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.addAll(c);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-10-boolean-removeAll-Collection＜-＞-c"><a href="#3-1-10-boolean-removeAll-Collection＜-＞-c" class="headerlink" title="3.1.10. boolean removeAll(Collection＜?＞ c)"></a>3.1.10. boolean removeAll(Collection＜?＞ c)</h4><h5 id="3-1-10-1-方法概述"><a href="#3-1-10-1-方法概述" class="headerlink" title="3.1.10.1. 方法概述"></a>3.1.10.1. 方法概述</h5><p> <code>boolean removeAll(Collection＜?＞ c)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 批量移除当前 Collection 中，与传入 Collection 中相同的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-10-2-方法实现"><a href="#3-1-10-2-方法实现" class="headerlink" title="3.1.10.2. 方法实现"></a>3.1.10.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.removeAll(c);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-11-boolean-retainAll-Collection＜-＞-c"><a href="#3-1-11-boolean-retainAll-Collection＜-＞-c" class="headerlink" title="3.1.11. boolean retainAll(Collection＜?＞ c)"></a>3.1.11. boolean retainAll(Collection＜?＞ c)</h4><h5 id="3-1-11-1-方法概述"><a href="#3-1-11-1-方法概述" class="headerlink" title="3.1.11.1. 方法概述"></a>3.1.11.1. 方法概述</h5><p><code>boolean retainAll(Collection&lt;?&gt; c)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 保留传入 Collection 中的元素与当前 Collection 中的元素的交集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-11-2-方法实现"><a href="#3-1-11-2-方法实现" class="headerlink" title="3.1.11.2. 方法实现"></a>3.1.11.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.retainAll(c);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-12-void-clear"><a href="#3-1-12-void-clear" class="headerlink" title="3.1.12. void clear()"></a>3.1.12. void clear()</h4><h5 id="3-1-12-1-方法概述"><a href="#3-1-12-1-方法概述" class="headerlink" title="3.1.12.1. 方法概述"></a>3.1.12.1. 方法概述</h5><p><code>void clear()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于 清除当前 Collection 中的所有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-12-2-方法实现"><a href="#3-1-12-2-方法实现" class="headerlink" title="3.1.12.2. 方法实现"></a>3.1.12.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        internalList.clear();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-接口方法（default）"><a href="#3-2-接口方法（default）" class="headerlink" title="3.2. 接口方法（default）"></a>3.2. 接口方法（default）</h3><h4 id="3-2-1-default-＜T＞-T-toArray-IntFunction＜T-＞-generator"><a href="#3-2-1-default-＜T＞-T-toArray-IntFunction＜T-＞-generator" class="headerlink" title="3.2.1. default ＜T＞ T[] toArray(IntFunction＜T[]＞ generator)"></a>3.2.1. default ＜T＞ T[] toArray(IntFunction＜T[]＞ generator)</h4><h5 id="3-2-1-1-方法概述"><a href="#3-2-1-1-方法概述" class="headerlink" title="3.2.1.1. 方法概述"></a>3.2.1.1. 方法概述</h5><p><code>default ＜T＞ T[] toArray(IntFunction＜T[]＞ generator)</code> 是一个接口方法的默认实现，用于 将当前 Collection 转换成指定类型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) &#123;<br><span class="hljs-keyword">return</span> toArray(generator.apply(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>IntFunction＜R＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AIntFunction%EF%BC%9CR%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：IntFunction＜R＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h4 id="3-2-2-default-boolean-removeIf-Predicate＜-super-E＞-filter"><a href="#3-2-2-default-boolean-removeIf-Predicate＜-super-E＞-filter" class="headerlink" title="3.2.2. default boolean removeIf(Predicate＜? super E＞ filter)"></a>3.2.2. default boolean removeIf(Predicate＜? super E＞ filter)</h4><h5 id="3-2-2-1-方法概述"><a href="#3-2-2-1-方法概述" class="headerlink" title="3.2.2.1. 方法概述"></a>3.2.2.1. 方法概述</h5><p><code>default boolean removeIf(Predicate＜? super E＞ filter)</code> 是一个接口方法的默认实现，用于根据条件删除当前 Collection 中一个或多个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>Objects.requireNonNull(filter);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();<br><span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br><span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>each.remove();<br>removed = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Predicate＜T＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9APredicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Predicate＜T＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h4 id="3-2-3-default-Stream＜E＞-stream"><a href="#3-2-3-default-Stream＜E＞-stream" class="headerlink" title="3.2.3. default Stream＜E＞ stream()"></a>3.2.3. default Stream＜E＞ stream()</h4><h5 id="3-2-3-1-方法概述"><a href="#3-2-3-1-方法概述" class="headerlink" title="3.2.3.1. 方法概述"></a>3.2.3.1. 方法概述</h5><p><code>default Stream＜E＞ stream()</code> 是一个接口方法的默认实现，用于 获取串行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>笔记：Java Stream<ol><li>obsidian 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJavaStream.md">笔记：JavaStream</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>StreamSupport 源码解析<ol><li>obsidian 内部链接：<br> 1. </li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h4 id="3-2-4-default-Stream＜E＞-parallelStream"><a href="#3-2-4-default-Stream＜E＞-parallelStream" class="headerlink" title="3.2.4. default Stream＜E＞ parallelStream()"></a>3.2.4. default Stream＜E＞ parallelStream()</h4><h5 id="3-2-4-1-方法概述"><a href="#3-2-4-1-方法概述" class="headerlink" title="3.2.4.1. 方法概述"></a>3.2.4.1. 方法概述</h5><p><code>default Stream＜E＞ parallelStream()</code> 是一个接口方法的默认实现，用于 获取并行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-3-接口方法（default-重写）"><a href="#3-3-接口方法（default-重写）" class="headerlink" title="3.3. 接口方法（default 重写）"></a>3.3. 接口方法（default 重写）</h3><h4 id="3-3-1-default-Spliterator＜E＞-spliterator"><a href="#3-3-1-default-Spliterator＜E＞-spliterator" class="headerlink" title="3.3.1. default Spliterator＜E＞ spliterator()"></a>3.3.1. default Spliterator＜E＞ spliterator()</h4><h5 id="3-3-1-1-方法概述"><a href="#3-3-1-1-方法概述" class="headerlink" title="3.3.1.1. 方法概述"></a>3.3.1.1. 方法概述</h5><p><code>default Spliterator＜E＞ spliterator()</code> 是一个接口方法的默认实现，重写了 <code>Iterable&lt;T&gt;</code> 的 <code>default Spliterator&lt;T&gt; spliterator()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Iterable＜T＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AIterable%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Iterable＜E＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-接口实现"><a href="#4-接口实现" class="headerlink" title="4. 接口实现"></a>4. 接口实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Collection</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; internalList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoCollection</span><span class="hljs-params">(Collection&lt;? extends java.lang.String&gt; c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.isEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.contains(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.iterator();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> internalList.toArray();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">return</span> internalList.toArray(a);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.add(string);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.remove(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.containsAll(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends String&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.addAll(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.removeAll(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        <span class="hljs-keyword">return</span> internalList.retainAll(c);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        internalList.clear();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Consumer＜T＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9AConsumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9AConsumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Consumer＜T＞-概述"><a href="#1-Consumer＜T＞-概述" class="headerlink" title="1. Consumer＜T＞ 概述"></a>1. Consumer＜T＞ 概述</h2><p><code>Consumer＜T＞</code> 是一个接口，定义了 “如何对一个参数执行某种操作，但不返回结果” 的规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 对传入参数执行一个操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br><br><span class="hljs-comment">// 将两个 Consumer 前后合并，顺序执行</span><br>    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-void-accept-T-t"><a href="#3-1-1-void-accept-T-t" class="headerlink" title="3.1.1. void accept(T t)"></a>3.1.1. void accept(T t)</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>void accept(T t)</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于对传入类型执行一个操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-1-2-方法实现"><a href="#3-1-1-2-方法实现" class="headerlink" title="3.1.1.2. 方法实现"></a>3.1.1.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pirnter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt; &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;  <br>        System.out.println(s + <span class="hljs-string">&quot;Tom&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>推荐使用 lambda 表达式：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; printer = s -&gt; System.out.println(s + <span class="hljs-string">&quot;Tom&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-接口方法（default）"><a href="#3-2-接口方法（default）" class="headerlink" title="3.2. 接口方法（default）"></a>3.2. 接口方法（default）</h3><h4 id="3-2-1-default-Consumer＜T＞-andThen-Consumer＜-super-T＞-after"><a href="#3-2-1-default-Consumer＜T＞-andThen-Consumer＜-super-T＞-after" class="headerlink" title="3.2.1. default Consumer＜T＞ andThen(Consumer＜? super T＞ after)"></a>3.2.1. default Consumer＜T＞ andThen(Consumer＜? super T＞ after)</h4><h5 id="3-2-1-1-方法概述"><a href="#3-2-1-1-方法概述" class="headerlink" title="3.2.1.1. 方法概述"></a>3.2.1.1. 方法概述</h5><p><code>default Consumer＜T＞ andThen(Consumer＜? super T＞ after)</code> 是一个接口方法的默认实现，用于将两个 Consumer 前后合并，顺序执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;<br>Objects.requireNonNull(after);<br><span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="3-2-1-2-方法实现"><a href="#3-2-1-2-方法实现" class="headerlink" title="3.2.1.2. 方法实现"></a>3.2.1.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 代码示例</span><br>Consumer&lt;String&gt; c1 = s -&gt; System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + s); <span class="hljs-comment">// Consumer 对象 1</span><br><br>Consumer&lt;String&gt; c2 = s -&gt; System.out.println(<span class="hljs-string">&quot;Bye &quot;</span> + s); <span class="hljs-comment">// Consumer 对象 2</span><br><br>Consumer&lt;String&gt; combined = c1.andThen(c2); <span class="hljs-comment">// 先执行 c1，再执行 c2</span><br><br>combined.accept(<span class="hljs-string">&quot;Tom&quot;</span>);<br><br><br><span class="hljs-comment">// 2. 输出结果</span><br>Hello Tom<br>Bye Tom<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Iterable＜E＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9AIterable%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9AIterable%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Iterable＜E＞概述"><a href="#1-Iterable＜E＞概述" class="headerlink" title="1. Iterable＜E＞概述"></a>1. Iterable＜E＞概述</h2><p><code>Iterable&lt;E&gt;</code> 是一个接口，定义了一个 “对象如何支持被迭代（遍历）” 的规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 1. 获取迭代器，它是一个实现了 Iterator&lt;T&gt; 接口的对象，内部维护着一个元素集合</span><br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 2. 遍历当前 Iterable 实例中的所有元素（其实是迭代器中维护的元素集合），并对每个元素执行传入的操作逻辑</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 3. 获取可拆分迭代器</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-Iterator＜T＞-iterator"><a href="#3-1-1-Iterator＜T＞-iterator" class="headerlink" title="3.1.1. Iterator＜T＞ iterator()"></a>3.1.1. Iterator＜T＞ iterator()</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>Iterator&lt;T&gt; iterator()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于获取迭代器</p><p>这个方法看起来有些特别，我们以前常见的方法返回 <code>void</code> 或某个类的实例，但很少见返回一个接口类型（因为 <code>Iterator&lt;T&gt;</code> 是一个接口）。其实，这里返回的本质是一个实现了 <code>Iterator&lt;T&gt;</code> 接口的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Iterator＜E＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AIterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Iterator＜E＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h5 id="3-1-1-2-方法实现"><a href="#3-1-1-2-方法实现" class="headerlink" title="3.1.1.2. 方法实现"></a>3.1.1.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoIterable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> T[] data;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoIterable</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        data = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addData</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &gt;= data.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数组已满&quot;</span>);<br>        &#125;<br>        data[size++] = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回一个内部迭代器对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoIterator</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 内部类：迭代器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 游标</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> current &lt; size;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> data[current++];<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里要求我们返回一个实现了某接口的对象，而不是让当前类直接去实现该接口。这种设计很有意思，通常的做法是通过定义一个内部类来实现该接口（备忘录模式就是使用了这种方法）</li><li>当然，我们完全没必要从零造轮子，直接使用 Java 已经封装好的数据结构就行，比如 <strong>List、Set、Map</strong><ol><li>但其实我们只是写了个 “套壳产品”，内部完全依赖 List、Set、Map 做事，没有提供新的数据结构，也没有对 Collection 的行为增加额外的逻辑，外部却自称是一个新的 Collection 实现</li><li>这就是重复劳动，既没有复用现有实现，也没有增加实际价值，在学习阶段可以做一做</li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoIterable</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;T&gt; data;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// 容量上限</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoIterable</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(capacity);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addData</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data.size() &gt;= capacity) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;容量已满&quot;</span>);<br>        &#125;<br>        data.add(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data.size();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 直接用 List 自带的迭代器</span><br>        <span class="hljs-keyword">return</span> data.iterator();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-接口方法（default）"><a href="#3-2-接口方法（default）" class="headerlink" title="3.2. 接口方法（default）"></a>3.2. 接口方法（default）</h3><h4 id="3-2-1-default-void-forEach-Consumer＜-super-T＞-action"><a href="#3-2-1-default-void-forEach-Consumer＜-super-T＞-action" class="headerlink" title="3.2.1. default void forEach(Consumer＜? super T＞ action)"></a>3.2.1. default void forEach(Consumer＜? super T＞ action)</h4><h5 id="3-2-1-1-方法概述"><a href="#3-2-1-1-方法概述" class="headerlink" title="3.2.1.1. 方法概述"></a>3.2.1.1. 方法概述</h5><p><code>default void forEach(Consumer＜? super T＞ action)</code> 是一个接口方法的默认实现，用于遍历当前 Iterable 实例中的所有元素（其实是迭代器中维护的元素集合），并对每个元素执行传入的操作逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>Objects.requireNonNull(action);<br><span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>action.accept(t);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>增强 for 循环（for-each 循环）是 Java 提供的一种语法糖，在编译阶段会被编译器自动转换为等价的迭代器遍历代码</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 编译前</span><br><span class="hljs-keyword">for</span> (T t : iterable) &#123;<br>xxxxxx<br>&#125;<br><br><br><span class="hljs-comment">// 2. 编译后</span><br><span class="hljs-keyword">for</span> (Iterator&lt;T&gt; it = iterable.iterator(); it.hasNext(); ) &#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> it.next();<br>xxxxxx<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. Consumer＜T＞ 源码解析<br>    1. obsidian 内部链接：<br>        1. <a href="%E6%BA%90%E7%A0%81%EF%BC%9AConsumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Consumer＜T＞源码解析</a><br>    2. Hexo 链接：<br>        1. </p></blockquote><hr><h4 id="3-2-2-default-Spliterator＜T＞-spliterator"><a href="#3-2-2-default-Spliterator＜T＞-spliterator" class="headerlink" title="3.2.2. default Spliterator＜T＞ spliterator()"></a>3.2.2. default Spliterator＜T＞ spliterator()</h4><h5 id="3-2-2-1-方法概述"><a href="#3-2-2-1-方法概述" class="headerlink" title="3.2.2.1. 方法概述"></a>3.2.2.1. 方法概述</h5><p><code>default Spliterator＜T＞ spliterator()</code> 是一个接口方法的默认实现，用于获取可拆分迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Spliterator</code> 是 Java 8 引入的一种特殊迭代器，可以把数据源拆分成多个部分，方便并行处理</li><li>XXXX 源码解析<ol><li>obsidian 内部链接：<br> 1. </li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-实现示例"><a href="#4-实现示例" class="headerlink" title="4. 实现示例"></a>4. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoIterable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> T[] data;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        data = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addData</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &gt;= data.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数组已满&quot;</span>);<br>        &#125;<br>        data[size++] = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回一个内部迭代器对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoIterator</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 内部类：迭代器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 游标</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> current &lt; size;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> data[current++];<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Iterator＜E＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9AIterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9AIterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Iterator-＜E＞-概述"><a href="#1-Iterator-＜E＞-概述" class="headerlink" title="1. Iterator ＜E＞ 概述"></a>1. Iterator ＜E＞ 概述</h2><p><code>Iterator&lt;E&gt;</code> 是一个接口，定义了 “一个集合如何支持按顺序取出元素” 的规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br><br><span class="hljs-comment">// 1. 判断集合中是否还有下一个元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 2. 返回集合中的下一个元素</span><br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 3. 删除迭代器返回的最后一个元素（上一次 next() 返回的元素）</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;remove&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">// 4. 迭代器剩余的所有元素依次执行传入的操作</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">while</span> (hasNext())<br>            action.accept(next());<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-接口方法"><a href="#3-接口方法" class="headerlink" title="3. 接口方法"></a>3. 接口方法</h2><h3 id="3-1-接口方法（无）"><a href="#3-1-接口方法（无）" class="headerlink" title="3.1. 接口方法（无）"></a>3.1. 接口方法（无）</h3><h4 id="3-1-1-boolean-hasNext"><a href="#3-1-1-boolean-hasNext" class="headerlink" title="3.1.1. boolean hasNext()"></a>3.1.1. boolean hasNext()</h4><h5 id="3-1-1-1-方法概述"><a href="#3-1-1-1-方法概述" class="headerlink" title="3.1.1.1. 方法概述"></a>3.1.1.1. 方法概述</h5><p><code>boolean hasNext()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于判断集合中是否还有下一个元素</p><hr><h5 id="3-1-1-2-方法实现"><a href="#3-1-1-2-方法实现" class="headerlink" title="3.1.1.2. 方法实现"></a>3.1.1.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Integer[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 维护一个数据结构</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前集合中元素个数</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 迭代器的游标</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> current &lt; size;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-1-2-E-next"><a href="#3-1-2-E-next" class="headerlink" title="3.1.2. E next()"></a>3.1.2. E next()</h4><h5 id="3-1-2-1-方法概述"><a href="#3-1-2-1-方法概述" class="headerlink" title="3.1.2.1. 方法概述"></a>3.1.2.1. 方法概述</h5><p><code>E next()</code> 是一个接口方法，需要由我们的实现类进行具体实现，用于返回集合中的下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-2-2-方法实现"><a href="#3-1-2-2-方法实现" class="headerlink" title="3.1.2.2. 方法实现"></a>3.1.2.2. 方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Integer[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 维护一个数据结构</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前集合中元素个数</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 迭代器的游标</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[current++];<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-接口方法（default）"><a href="#3-2-接口方法（default）" class="headerlink" title="3.2. 接口方法（default）"></a>3.2. 接口方法（default）</h3><h4 id="3-2-1-default-void-remove"><a href="#3-2-1-default-void-remove" class="headerlink" title="3.2.1. default void remove()"></a>3.2.1. default void remove()</h4><h5 id="3-2-1-1-方法概述"><a href="#3-2-1-1-方法概述" class="headerlink" title="3.2.1.1. 方法概述"></a>3.2.1.1. 方法概述</h5><p><code>default void remove()</code> 是一个接口方法的默认实现，用于删除迭代器返回的最后一个元素（上一次 next() 返回的元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;remove&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>该方法的默认实现是直接抛出 <code>UnsupportedOperationException</code> 异常。</li><li>这意味着如果我们想要调用它，就必须重写该方法，而且在大多数情况下，我们可能并不需要实现这个操作。</li></ol></blockquote><hr><h4 id="3-2-2-default-void-forEachRemaining-Consumer＜-super-E＞action"><a href="#3-2-2-default-void-forEachRemaining-Consumer＜-super-E＞action" class="headerlink" title="3.2.2. default void forEachRemaining(Consumer＜? super E＞action)"></a>3.2.2. default void forEachRemaining(Consumer＜? super E＞action)</h4><h5 id="3-2-2-1-方法概述"><a href="#3-2-2-1-方法概述" class="headerlink" title="3.2.2.1. 方法概述"></a>3.2.2.1. 方法概述</h5><p><code>default void forEachRemaining(Consumer＜? super E＞ action)</code> 是一个接口方法的默认实现，用于将迭代器剩余的所有元素依次执行传入的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>Objects.requireNonNull(action);<br><span class="hljs-keyword">while</span> (hasNext())<br>action.accept(next());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>Consumer＜T＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AConsumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Consumer＜T＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>如果一个方法传入对象类型的方法参数，并且可以对象可以用 lambda 表达式，那我们可以这样做：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">demo.forEach(item -&gt; System.out.println(item));<br></code></pre></td></tr></table></figure><hr><h2 id="4-实现示例"><a href="#4-实现示例" class="headerlink" title="4. 实现示例"></a>4. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Integer[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 维护一个数据结构</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前集合中元素个数</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 迭代器的游标</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addData</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &gt;= data.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数组已满&quot;</span>);<br>        &#125;<br>        data[size++] = value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetData</span><span class="hljs-params">()</span> &#123;<br>        current = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> current &lt; size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[current++];<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们去实现这个接口时，通常会在内部维护一个数据结构（数组、链表，甚至可以是文件、网络数据、懒加载或者计算生成的内容等），只要你能控制遍历的过程，就能写出自己的迭代器</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Predicate＜T＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9APredicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9APredicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>XXXX 是一个接口，定义了 “XXXX” 的规范</p><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">negate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">isEqual</span><span class="hljs-params">(Object targetRef)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span> == targetRef)<br>                ? Objects::isNull<br>                : object -&gt; targetRef.equals(object);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">not</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; target)</span> &#123;<br>        Objects.requireNonNull(target);<br>        <span class="hljs-keyword">return</span> (Predicate&lt;T&gt;)target.negate();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h2><hr><h2 id="4-抽象方法"><a href="#4-抽象方法" class="headerlink" title="4. 抽象方法"></a>4. 抽象方法</h2><hr><h2 id="5-接口方法"><a href="#5-接口方法" class="headerlink" title="5. 接口方法"></a>5. 接口方法</h2><h3 id="5-1-接口方法（无）"><a href="#5-1-接口方法（无）" class="headerlink" title="5.1. 接口方法（无）"></a>5.1. 接口方法（无）</h3><hr><h3 id="5-2-接口方法（default）"><a href="#5-2-接口方法（default）" class="headerlink" title="5.2. 接口方法（default）"></a>5.2. 接口方法（default）</h3><hr><h3 id="5-3-接口方法（default-重写）"><a href="#5-3-接口方法（default-重写）" class="headerlink" title="5.3. 接口方法（default 重写）"></a>5.3. 接口方法（default 重写）</h3><hr><h2 id="6-具体方法"><a href="#6-具体方法" class="headerlink" title="6. 具体方法"></a>6. 具体方法</h2><h3 id="6-1-具体方法（无）"><a href="#6-1-具体方法（无）" class="headerlink" title="6.1. 具体方法（无）"></a>6.1. 具体方法（无）</h3><hr><h3 id="6-2-具体方法（重写）"><a href="#6-2-具体方法（重写）" class="headerlink" title="6.2. 具体方法（重写）"></a>6.2. 具体方法（重写）</h3><hr><h3 id="6-3-具体方法（实现）"><a href="#6-3-具体方法（实现）" class="headerlink" title="6.3. 具体方法（实现）"></a>6.3. 具体方法（实现）</h3><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java Stream</title>
    <link href="/2025/08/25/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaStream/"/>
    <url>/2025/08/25/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaStream/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java-Stream-概述"><a href="#1-Java-Stream-概述" class="headerlink" title="1. Java Stream 概述"></a>1. Java Stream 概述</h2><p>在 Java 8 之前，我们操作集合的操作显得太 “啰嗦”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br><br>        <span class="hljs-comment">// 1. 创建集合</span><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 把所有以 “张” 开头的元素存储到新集合中</span><br>        ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : list1) &#123;<br>            <span class="hljs-keyword">if</span>(name.startsWith(<span class="hljs-string">&quot;张&quot;</span>))&#123;<br>                list2.add(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 3. 把 “张” 开头的，长度为 3 的元素再存储到新集合中</span><br>        ArrayList&lt;String&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : list2) &#123;<br>            <span class="hljs-keyword">if</span>(name.length() == <span class="hljs-number">3</span>)&#123;<br>                list3.add(name);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4. 遍历打印最终结果</span><br>        <span class="hljs-keyword">for</span> (String s : list3) &#123;<br>            System.out.println(s);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而 Java Stream 以一种声明式、函数式的风格，优雅的解决了这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        list1.stream().filter(name -&gt; name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter(name -&gt; name.length() == <span class="hljs-number">3</span>).forEach(name -&gt; System.out.println(name));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>增强 for 循环（for-each 循环）是 Java 提供的一种语法糖，在编译阶段会被编译器自动转换为等价的迭代器遍历代码</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 编译前</span><br><span class="hljs-keyword">for</span> (T t : iterable) &#123;<br>xxxxxx<br>&#125;<br><br><br><span class="hljs-comment">// 2. 编译后</span><br><span class="hljs-keyword">for</span> (Iterator&lt;T&gt; it = iterable.iterator(); it.hasNext(); ) &#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> it.next();<br>xxxxxx<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2-Java-Stream-常用方法"><a href="#2-Java-Stream-常用方法" class="headerlink" title="2. Java Stream 常用方法"></a>2. Java Stream 常用方法</h2><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AJavaStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：JavaStream常用方法</a></li></ol></li><li>Hexo 链接：<ol><li><a href="http://localhost:4000/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AJavaStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">http://localhost:4000/2025/08/25/%E6%96%B9%E6%B3%95%EF%BC%9AJavaStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</a></li></ol></li></ol><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：FileOutputStream 常用方法</title>
    <link href="/2025/08/24/%E6%96%B9%E6%B3%95%EF%BC%9AFileOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/24/%E6%96%B9%E6%B3%95%EF%BC%9AFileOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="FileOutputStream-String-name"><a href="#FileOutputStream-String-name" class="headerlink" title="FileOutputStream(String name)"></a>FileOutputStream(String name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * ============================================ </span><br><span class="hljs-comment"> * FileOutputStream(String name) </span><br><span class="hljs-comment"> * -------------------------------------------- </span><br><span class="hljs-comment"> * 1. 访问修饰符  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2. 非访问修饰符  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 3. 参数  </span><br><span class="hljs-comment"> *      1. String  </span><br><span class="hljs-comment"> *          1. 字符串路径  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 4. 返回值  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 5. 使用示例  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 6. 作用  </span><br><span class="hljs-comment"> *      1. 根据字符串路径创建出一个文件输出流  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 7. 注意事项  </span><br><span class="hljs-comment"> *      1. 如果 test.txt 不存在，系统会自动创建一个新文件  </span><br><span class="hljs-comment"> *      2. 如果 test.txt 已存在，文件内容会被清空，写入的数据会从头开始写  </span><br><span class="hljs-comment"> * ============================================  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="FileOutputStream-String-name-boolean-append"><a href="#FileOutputStream-String-name-boolean-append" class="headerlink" title="FileOutputStream(String name, boolean append)"></a>FileOutputStream(String name, boolean append)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * FileOutputStream(String name, boolean append)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. String name</span><br><span class="hljs-comment"> *          1. 字符串路径</span><br><span class="hljs-comment"> *      2. boolean append</span><br><span class="hljs-comment"> *          1. 是否为追加内容</span><br><span class="hljs-comment"> *          2. true</span><br><span class="hljs-comment"> *              1. 追加内容</span><br><span class="hljs-comment"> *          3. false</span><br><span class="hljs-comment"> *              1. 文件会被覆盖</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 根据字符串路径创建出一个文件输出流，并指定是否追加内容</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="FileOutputStream-File-file"><a href="#FileOutputStream-File-file" class="headerlink" title="FileOutputStream(File file)"></a>FileOutputStream(File file)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * FileOutputStream(File file)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. File file</span><br><span class="hljs-comment"> *          1. 文件对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 根据 File 对象创建文件输出流</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 本构造方法与 FileOutputStream(String name) 类似，只不过参数是 File 对象而不是字符串路径</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h3 id="FileOutputStream-File-file-boolean-append"><a href="#FileOutputStream-File-file-boolean-append" class="headerlink" title="FileOutputStream(File file, boolean append)"></a>FileOutputStream(File file, boolean append)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * FileOutputStream(File file, boolean append)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. File file</span><br><span class="hljs-comment"> *          1. 文件对象</span><br><span class="hljs-comment"> *      2. boolean oppend</span><br><span class="hljs-comment"> *          1. 是否为追加内容</span><br><span class="hljs-comment"> *          2. true</span><br><span class="hljs-comment"> *              1. 追加内容</span><br><span class="hljs-comment"> *          3. false</span><br><span class="hljs-comment"> *              1. 文件会被覆盖</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 根据 File 对象创建文件输出流，并指定是否追加内容</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="写方法"><a href="#写方法" class="headerlink" title="写方法"></a>写方法</h3><h4 id="void-write-int-b"><a href="#void-write-int-b" class="headerlink" title="void write(int b)"></a>void write(int b)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void write(int b)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. int b</span><br><span class="hljs-comment"> *          1. 要写入的 int 类型</span><br><span class="hljs-comment"> *          2. 虽然是 int 类型，但只取低 8 位（也就是 1 个字节）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. void</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 向输出流写入一个字节</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileOutputStream.write(<span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="void-write-byte-b"><a href="#void-write-byte-b" class="headerlink" title="void write(byte b[])"></a>void write(byte b[])</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void write(byte b[])</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. byte b[]</span><br><span class="hljs-comment"> *          1. 要写入的 byte 数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. void</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 向输出流写入一个字节数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>    writeBytes(b, <span class="hljs-number">0</span>, b.length, fdAccess.getAppend(fd));  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>关于 <code>byte b[]</code> ，如果我们要把字符串转成 <code>byte b[]</code>，有一种很方便的方式：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;haoshuaihaoshuia&quot;</span>;  <br><br>fileOutputStream.write(s.getBytes());<br></code></pre></td></tr></table></figure><hr><h4 id="void-write-byte-b-int-off-int-len"><a href="#void-write-byte-b-int-off-int-len" class="headerlink" title="void write(byte b[], int off, int len)"></a>void write(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void write(byte b[], int off, int len)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. byte b[]</span><br><span class="hljs-comment"> *          1. 要写入的 byte 数组</span><br><span class="hljs-comment"> *      2. int off</span><br><span class="hljs-comment"> *          1. byte 数组的 off 下标</span><br><span class="hljs-comment"> *      3. int len</span><br><span class="hljs-comment"> *          1. 选取的长度</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. void</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 向输出流写入一个字节数组的部分数据，从 off 到 off + len</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 数组的下标是以 0 开始的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileOutputStream.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="刷新方法"><a href="#刷新方法" class="headerlink" title="刷新方法"></a>刷新方法</h3><h4 id="void-flush"><a href="#void-flush" class="headerlink" title="void flush()"></a>void flush()</h4><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void close()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 关闭流</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 当我们 new FileOutputStream(&quot;test.txt&quot;) 的时候，JVM 会通过系统调用去打开一个文件，操作系统会返回文件描述符</span><br><span class="hljs-comment"> *      2. 这个文件描述符是操作系统级别的资源，数量有限，发得太多总会用完，close() 会把这个文件描述符还给操作系统</span><br><span class="hljs-comment"> *      3. 此外，底层操作系统的 IO 几乎都会有 Page Cache，当你写数据时，往往不是直接落盘，而是写到内存的缓冲区</span><br><span class="hljs-comment"> *      4. close() 会触发 flush，确保数据真正写进文件</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileOutputStream.close();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们创建的流，一定不要忘记 <code>close</code></li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：FileInputStream 常用方法</title>
    <link href="/2025/08/24/%E6%96%B9%E6%B3%95%EF%BC%9AFileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/24/%E6%96%B9%E6%B3%95%EF%BC%9AFileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="FileInputStream-String-name"><a href="#FileInputStream-String-name" class="headerlink" title="FileInputStream(String name)"></a>FileInputStream(String name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * ============================================ </span><br><span class="hljs-comment"> * FileInputStream(String name)</span><br><span class="hljs-comment"> * -------------------------------------------- </span><br><span class="hljs-comment"> * 1. 访问修饰符  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2. 非访问修饰符  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 3. 参数  </span><br><span class="hljs-comment"> *      1. String  </span><br><span class="hljs-comment"> *          1. 字符串路径  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 4. 返回值  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 5. 使用示例  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 6. 作用  </span><br><span class="hljs-comment"> *      1. 根据字符串路径创建出一个文件输入流  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * 7. 注意事项  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>与文件输出流不同，文件输出流是如果目标文件不存在，会<strong>自动创建</strong>新文件，因为它的主要目的就是向文件中写入内容</li><li>而文件输入流是如果目标文件不存在，则会<strong>直接抛出异常</strong>，因为读取操作必须依赖一个已经存在的文件</li></ol></blockquote><hr><h3 id="FileInputStream-File-file"><a href="#FileInputStream-File-file" class="headerlink" title="FileInputStream(File file)"></a>FileInputStream(File file)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * FileInputStream(File file)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. File file</span><br><span class="hljs-comment"> *          1. 文件对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 根据 File 对象创建文件输入流</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 本构造方法与 FileInputStream(String name) 类似，只不过参数是 File 对象而不是字符串路径</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="读方法"><a href="#读方法" class="headerlink" title="读方法"></a>读方法</h3><h4 id="int-read"><a href="#int-read" class="headerlink" title="int read()"></a>int read()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int read()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 读取字节的原始字节值（0 - 255）</span><br><span class="hljs-comment"> *          1. 不用任何字符集进行解释，单纯就是 8 位字节的无符号整数</span><br><span class="hljs-comment"> *      2. -1</span><br><span class="hljs-comment"> *          1. 流到达文件末尾时，返回 -1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 读一个字节数据</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> fileInputStream.read();<br></code></pre></td></tr></table></figure><hr><h4 id="int-read-byte-b"><a href="#int-read-byte-b" class="headerlink" title="int read(byte b[])"></a>int read(byte b[])</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int read(byte b[])</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. byte b[]</span><br><span class="hljs-comment"> *          1. 当缓冲容器的字符数组，数据先读到字符数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 本次读取的字节数量</span><br><span class="hljs-comment"> *      2. -1</span><br><span class="hljs-comment"> *          1. 流到达文件末尾时，返回 -1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 读一个字节数组的数据</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> fileInputStream.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void close()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 关闭流</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 当我们 new FileOutputStream(&quot;test.txt&quot;) 的时候，JVM 会通过系统调用去打开一个文件，操作系统会返回文件描述符</span><br><span class="hljs-comment"> *      2. 这个文件描述符是操作系统级别的资源，数量有限，发得太多总会用完，close() 会把这个文件描述符还给操作系统</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileInputStream.close();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：加密解密、编码解码</title>
    <link href="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/"/>
    <url>/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编码解码"><a href="#一、编码解码" class="headerlink" title="一、编码解码"></a>一、编码解码</h1><h2 id="1-编码解码基础"><a href="#1-编码解码基础" class="headerlink" title="1. 编码解码基础"></a>1. 编码解码基础</h2><h3 id="1-1-计算机存储规则"><a href="#1-1-计算机存储规则" class="headerlink" title="1.1. 计算机存储规则"></a>1.1. 计算机存储规则</h3><p>在计算机中，所有数据都以二进制形式存储。二进制中的一个位称为 <strong>bit</strong>，而由 8 个 bit 组成的字节（byte）则是计算机的基本存储和处理单元。</p><p><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-1.png"></p><hr><h3 id="1-2-ASCII-字符集"><a href="#1-2-ASCII-字符集" class="headerlink" title="1.2. ASCII 字符集"></a>1.2. ASCII 字符集</h3><p>ASCII（<code>American Standard Code for Information Interchange</code>，美国信息交换标准代码），其实就是一套 “翻译规则”，把字符（字母、数字、符号）映射成计算机可以理解和存储的数字</p><p>访问： <a href="https://c.biancheng.net/c/ascii/">https://c.biancheng.net/c/ascii/</a> ，可以查看完整的 ASCII 字符集<br><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81.png"></p><p>在底层，字符就是按 <strong>ASCII 编码规则</strong> 存储的：<br><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-2.png"></p><hr><h3 id="1-3-GBK-字符集"><a href="#1-3-GBK-字符集" class="headerlink" title="1.3. GBK 字符集"></a>1.3. GBK 字符集</h3><p>ASCII 的 128 个符号对美国人完全够用，但对汉字世界来说远远不能满足。于是我们有了自己的 “国标” 编码</p><ol><li>GB2312<ol><li>国标2312</li><li>1981 年推出，收录 6763 个简体汉字，总共 7445 个图形字符</li></ol></li><li>BIG5<ol><li>1984 年台湾推出，收录 13053 个繁体汉字</li></ol></li><li>GBK<ol><li>国标扩展</li><li>2000 年推出，收录 21003 个汉字，兼容 GB2312 与 BIG5，并覆盖常用中日韩字符</li></ol></li></ol><p>在底层，字符就是按照 GBK 编码规则 存储的，我们只需要着重关注 ASCII 字符和 简体中文：</p><p><font color="#92d050">1. ASCII 字符</font><br>GBK 编码规则完全兼容 ASCII 编码规则<br><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-3.png"></p><p><font color="#92d050">2. 简体中文</font><br><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-4.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>Windows 系统显示是 ANSI，但是默认使用的就是 GBK</li></ol></blockquote><hr><h3 id="1-4-Unicode-字符集"><a href="#1-4-Unicode-字符集" class="headerlink" title="1.4. Unicode 字符集"></a>1.4. Unicode 字符集</h3><p>随着全球信息化，需要一种覆盖所有语言文字的统一系统。于是 <strong>Unicode（万国码）</strong> 登场，它不断扩充，几乎涵盖了世上所有文字。</p><p>在底层，字符有多种编码规则进行存储：</p><ol><li>UTF-8<ol><li>最常用，采用 1 - 4 个字节</li><li>ASCII 字符采用 1 个字节</li><li>简体中文采用 3 个字节</li></ol></li><li>UTF-16<ol><li>采用 2 - 4 个字节保存</li></ol></li><li>UTF-32<ol><li>固定 4 个字节保存</li></ol></li></ol><p><font color="#92d050">1. UTF-8 编码规则</font><br><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-6.png"></p><p><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-7.png"></p><p><font color="#92d050">2. UTF-16、UTF-32 编码规则</font><br><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-5.png"></p><hr><h3 id="1-5-乱码出现的原因"><a href="#1-5-乱码出现的原因" class="headerlink" title="1.5. 乱码出现的原因"></a>1.5. 乱码出现的原因</h3><p>出现乱码，大部分原因就是：<strong>编码和解码规则不一致</strong>。写入时用的是一套编码，读取时用的却是另一套，于是 “翻译 ”错乱，字符自然就乱了。</p><p><img src="/2025/08/24/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81-8.png"></p><hr><h2 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h2><p>在 Java 中，字符串在内存里以 UTF-16 形式存储。当需要写入文件或通过网络传输时，必须显式指定所使用的外部编码（如 UTF-8），否则会出现不一致或乱码问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ai你哟&quot;</span>;<br><br>        <span class="hljs-comment">// 使用默认方式进行编码，即 IDEA 右下角的 UTF-8</span><br>        <span class="hljs-type">byte</span>[] bytes1 = str.getBytes();<br><br>        <span class="hljs-comment">// 使用指定方式进行编码</span><br>        <span class="hljs-type">byte</span>[] bytes2 = str.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>);<br><br>        <span class="hljs-comment">// 使用默认方式解码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes1, StandardCharsets.UTF_8);<br><br>        <span class="hljs-comment">// 使用指定方式进行解码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes2, <span class="hljs-string">&quot;GBK&quot;</span>);<br><br>        System.out.println(str1);<br>        <br>        System.out.println(str2);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>加密解密、编码解码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：分布式基础知识</title>
    <link href="/2025/08/21/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/08/21/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>下面简单介绍一下分布式系统、集群、高可用集群以及联邦的基本概念：</p><ol><li>分布式系统（Distributed System）<ol><li><ol><li>这是最<strong>基础、最泛化</strong>的概念，简单来说，就是将一件庞大复杂的事情拆分给<strong>多台机器</strong>分别处理，并通过协作完成整体任务。</li></ol></li><li>例如整个微服务架构，或者像淘宝这样的大型网站，背后可能有成千上万的服务器在同时支撑。</li></ol></li><li>集群（Cluster）<ol><li>是分布式系统的一种典型实现，简单来说，就是将多台功能相同的机器组织成一个“团队”，对外统一表现为“单个服务提供者”。</li><li>例如 3 台配置一致的 RabbitMQ 服务器组成一个集群，共同处理消息请求。</li><li><ol><li>从更大层面看，分布式系统往往是由多个这样的集群组合而成。</li></ol></li></ol></li><li>高可用集群（High-Availability Cluster）<ol><li>属于集群的“强化版”，目标是提供更高层级的服务稳定性，确保系统能实现 7×24 小时不间断运行。</li></ol></li><li>联邦<ol><li>用来作为<strong>连接多个独立集群的桥梁</strong>，简单来说，就是在集群之间建立消息自动转发规则，实现跨集群协作。</li><li>联邦通常用于功能相同的集群之间，例如 RabbitMQ ↔ RabbitMQ，但在更复杂场景下，也可能连接多个不同的分布式系统。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>分布式基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：MQ 概述</title>
    <link href="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9AMQ%E6%A6%82%E8%BF%B0/"/>
    <url>/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9AMQ%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>特性</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th><th>ActiveMQ</th></tr></thead><tbody><tr><td>类型</td><td>消息队列（AMQP）</td><td>分布式日志系统</td><td>分布式消息中间件</td><td>传统 JMS 消息队列</td></tr><tr><td>语言</td><td>Erlang</td><td>Scala&#x2F;Java</td><td>Java</td><td>Java</td></tr><tr><td>吞吐</td><td>中等</td><td>极高</td><td>高</td><td>中等偏低</td></tr><tr><td>延迟</td><td>低</td><td>中</td><td>低</td><td>中等</td></tr><tr><td>消息顺序</td><td>支持（某种程度）</td><td>分区内有序</td><td>原生强顺序（可配置）</td><td>有序（但不稳定）</td></tr><tr><td>消息追踪</td><td>无原生支持</td><td>有 offset 可控</td><td>✅ 原生消息轨迹追踪</td><td>❌ 不完善</td></tr><tr><td>消息回溯</td><td>复杂</td><td>✅ 易（offset 回溯）</td><td>✅ 类似 Kafka 的 offset 模型</td><td>❌ 基本不支持</td></tr><tr><td>分布式支持</td><td>集群可配但不天然</td><td>✅ 天然分布式</td><td>✅ 天然支持</td><td>❌ 集群弱，主备为主</td></tr><tr><td>死信队列</td><td>✅ 支持</td><td>需自建逻辑</td><td>✅ 原生支持</td><td>✅ 支持</td></tr><tr><td>社区活跃度</td><td>🔥🔥🔥</td><td>🔥🔥🔥🔥🔥</td><td>🔥🔥</td><td>❄️（Apache 里冷门）</td></tr></tbody></table><h2 id="1-MQ-概述"><a href="#1-MQ-概述" class="headerlink" title="1. MQ 概述"></a>1. MQ 概述</h2><p>MQ（Message Queue，消息队列）从字面上理解就是一个 FIFO（先进先出）的队列，只不过存放的对象是 Message。作为一种中间件服务，它不仅能够接收消息，还能进行存储和转发，为系统间的数据通信提供可靠的异步处理能力。<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9AMQ%E6%A6%82%E8%BF%B0/%E7%AC%94%E8%AE%B0%EF%BC%9AMQ%E6%A6%82%E8%BF%B0.png"></p><hr><h2 id="2️⃣-为什么用-MQ-而不是-TCC-Saga？"><a href="#2️⃣-为什么用-MQ-而不是-TCC-Saga？" class="headerlink" title="2️⃣ 为什么用 MQ 而不是 TCC&#x2F;Saga？"></a>2️⃣ 为什么用 MQ 而不是 TCC&#x2F;Saga？</h2><h3 id="✅-a-成熟度-落地难度"><a href="#✅-a-成熟度-落地难度" class="headerlink" title="✅ a) 成熟度 &amp; 落地难度"></a>✅ a) 成熟度 &amp; 落地难度</h3><ul><li>TCC &#x2F; Saga 都要求你重新设计业务接口：Try&#x2F;Confirm&#x2F;Cancel 或 正向&#x2F;补偿操作。</li><li>MQ 模式几乎不需要对业务大动刀子，只需要加一张消息表 + 投递程序。</li><li>MQ 已经是分布式架构里的标配设施，团队容易上手。</li></ul><h3 id="✅-b-系统解耦"><a href="#✅-b-系统解耦" class="headerlink" title="✅ b) 系统解耦"></a>✅ b) 系统解耦</h3><ul><li>MQ 的核心能力是<strong>异步解耦</strong>。</li><li>&lt;订单 → 库存 → 支付 → 物流&gt; 不需要彼此直接耦合，只要监听 MQ 事件。</li><li>否则用 Saga 编排，每次变动都要去改协调逻辑或补偿链，复杂度上天。</li></ul><h3 id="✅-c-吞吐-性能"><a href="#✅-c-吞吐-性能" class="headerlink" title="✅ c) 吞吐 &amp; 性能"></a>✅ c) 吞吐 &amp; 性能</h3><ul><li>MQ 模型强调 <strong>最终一致性</strong>，业务提交后很快就返回，异步去通知别人。</li><li>TCC 需要等所有 Try 成功才能确认，链路长、并发高时性能会明显下降。</li><li>Saga 的编排&#x2F;补偿也会拖长事务生命周期。</li></ul><h3 id="✅-d-灵活兜底"><a href="#✅-d-灵活兜底" class="headerlink" title="✅ d) 灵活兜底"></a>✅ d) 灵活兜底</h3><ul><li>MQ 天生有 <strong>存储 + 重试机制</strong>（比如 Kafka 消息落盘，失败可回溯），相比业务方自己写补偿逻辑，省心。</li><li>对于“能迟点同步”的业务（发积分、异步更新报表、通知下游系统），用 MQ 再合适不过。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理</category>
      
      <category>消息队列</category>
      
      <category>消息队列对比</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：RabbitMQ</title>
    <link href="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/"/>
    <url>/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="一、导图"><a href="#一、导图" class="headerlink" title="一、导图"></a>一、导图</h1><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-1.xmind"></p><hr><h1 id="二、RabbitMQ-基础"><a href="#二、RabbitMQ-基础" class="headerlink" title="二、RabbitMQ 基础"></a>二、RabbitMQ 基础</h1><h2 id="1-RabbitMQ-架构"><a href="#1-RabbitMQ-架构" class="headerlink" title="1. RabbitMQ 架构"></a>1. RabbitMQ 架构</h2><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-15.png"></p><p><font color="#92d050">1. Channel</font><br>Channel（信道）是建立在 Connection（连接）之上的虚拟通道，一个 Connection 可以有多个 Channel</p><p><font color="#92d050">2. Broker</font><br>一个 Broker 就是一个 RabbitMQ 实例</p><hr><h2 id="2-RabbitMQ-组件"><a href="#2-RabbitMQ-组件" class="headerlink" title="2. RabbitMQ 组件"></a>2. RabbitMQ 组件</h2><h3 id="2-1-Exchange"><a href="#2-1-Exchange" class="headerlink" title="2.1. Exchange"></a>2.1. Exchange</h3><p>·<img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-26.png"><br><font color="#92d050">1. All exchanges</font></p><ol><li>Features<ol><li>Echange 的特性</li><li>D（Durable）<ol><li>交换机是持久化的</li></ol></li><li>AD（Auto delete）<ol><li>如果没有消费者，自动删除该交换机</li></ol></li><li>I（Internal）<ol><li>交换机只能被其他交换机路由消息，而不能被客户端直接发布消息</li><li>一般用来做 Exchange 之间的二级路由</li></ol></li><li>AE（Alternate exchange）<ol><li>是某个交换机的备用交换机</li></ol></li></ol></li></ol><p><font color="#92d050">2. Add a new exchange</font></p><ol><li>Type<ol><li>交换机的类型</li><li>direct<ol><li>路由交换机，根据消息的路由键发送到相应队列</li></ol></li><li>topic<ol><li>通配符交换机，在路由交换机的基础上，支持 * 和 # 的路由键（注意是路由键）</li><li><ul><li><ol><li>一个单词，例如 <code>*.error</code></li></ol></li></ul></li><li><h1 id=""><a href="#" class="headerlink" title=""></a></h1><ol><li>零或多个单词，例如 <code>user.#</code></li></ol></li></ol></li><li>fanout<ol><li>广播交换机，将消息广播到所有绑定该交换机的队列</li></ol></li><li>headers<ol><li>根据消息携带的头部（headers 字典）将消息发送到相应队列</li></ol></li></ol></li><li>Durablity<ol><li>交换机是否持久化</li><li>durable<ol><li>交换机持久化</li></ol></li><li>Transient<ol><li>交换机临时的，重启就没了</li></ol></li></ol></li><li>Auto delete<ol><li>如果没有消费者，是否要自动删除该交换机</li></ol></li><li>Internal<ol><li>交换机是否只能被其他交换机路由消息，而不能被客户端直接发布消息</li></ol></li><li>Arguments<ol><li>交换机特定行为参数</li><li>Alternate exchange<ol><li>是那个交换机的备用交换机</li></ol></li></ol></li></ol><hr><h3 id="2-2-Message"><a href="#2-2-Message" class="headerlink" title="2.2. Message"></a>2.2. Message</h3><p>什么头阿，属性阿，还有 Message 到底能是什么？</p><hr><h2 id="3-RabbitMQ-核心流程"><a href="#3-RabbitMQ-核心流程" class="headerlink" title="3. RabbitMQ 核心流程"></a>3. RabbitMQ 核心流程</h2><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-18.png"></p><hr><h2 id="4-RabbitMQ-角色"><a href="#4-RabbitMQ-角色" class="headerlink" title="4. RabbitMQ 角色"></a>4. RabbitMQ 角色</h2><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-19.png"></p><hr><h2 id="5-RabbitMQ-消息模式"><a href="#5-RabbitMQ-消息模式" class="headerlink" title="5. RabbitMQ 消息模式"></a>5. RabbitMQ 消息模式</h2><h3 id="5-1-简单模式"><a href="#5-1-简单模式" class="headerlink" title="5.1. 简单模式"></a>5.1. 简单模式</h3><p>最基础的 “一对一” 消息投递，一个生产者一个队列一个消费者</p><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-20.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然没表现出交换机，但是确实会先把消息发送到一个默认交换机</li></ol></blockquote><hr><h3 id="5-2-工作模式"><a href="#5-2-工作模式" class="headerlink" title="5.2. 工作模式"></a>5.2. 工作模式</h3><p>一对多场景，一个生产者，一个队列多个消费者<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-21.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然没表现出交换机，但是确实会先把消息发送到一个默认交换机</li></ol></blockquote><hr><h3 id="5-3-发布订阅模式"><a href="#5-3-发布订阅模式" class="headerlink" title="5.3. 发布订阅模式"></a>5.3. 发布订阅模式</h3><p>把同一条消息广播给所有订阅者，一个消息能被交换机广播到很多队列<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-22.png"></p><hr><h3 id="5-4-路由模式"><a href="#5-4-路由模式" class="headerlink" title="5.4. 路由模式"></a>5.4. 路由模式</h3><p>生产者发送消息带 routing key，消费者队列只收到匹配的消息</p><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-23.png"></p><hr><h3 id="5-5-主题模式"><a href="#5-5-主题模式" class="headerlink" title="5.5. 主题模式"></a>5.5. 主题模式</h3><p>在路由模式的基础上，支持 * 和 #<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-24.png"></p><hr><h3 id="5-6-RPC-模式"><a href="#5-6-RPC-模式" class="headerlink" title="5.6. RPC 模式"></a>5.6. RPC 模式</h3><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-27.png"></p><blockquote><p>[!NOTE] Title</p><ol><li>大多数 RPC 功能，我们可以直接使用 RPC 框架，但是需要消息队列特性的异步 RPC，RabbitMQ RPC 可能会合适</li></ol></blockquote><hr><h2 id="RabbitMQ-命名规范"><a href="#RabbitMQ-命名规范" class="headerlink" title="RabbitMQ 命名规范"></a>RabbitMQ 命名规范</h2><ol><li>命名规范<ol><li><code>[项目名].[业务名].[功能名].[类型]</code></li></ol></li><li>类型<ol><li>交换机<ol><li>普通交换机<ol><li>exchange</li></ol></li><li>死信交换机<ol><li>dlx.exchange</li></ol></li><li>备份交换机<ol><li>backup.exchange</li></ol></li></ol></li><li>队列<ol><li>普通队列<ol><li>queue</li></ol></li><li>死信队列<ol><li>dlx.queue</li></ol></li><li>备份交换机<ol><li>backup.queue</li></ol></li></ol></li></ol></li><li>示例<ol><li>支付创建<ol><li>payment.create.exchange</li></ol></li><li>支付超时取消<ol><li>payment.timeout.exchange</li></ol></li></ol></li></ol><hr><h1 id="三、搭建-RabbitMQ-环境"><a href="#三、搭建-RabbitMQ-环境" class="headerlink" title="三、搭建 RabbitMQ 环境"></a>三、搭建 RabbitMQ 环境</h1><h2 id="1-单机测试环境"><a href="#1-单机测试环境" class="headerlink" title="1. 单机测试环境"></a>1. 单机测试环境</h2><h3 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1. 环境搭建"></a>1.1. 环境搭建</h3><h4 id="1-1-1-创建宿主机数据挂载目录"><a href="#1-1-1-创建宿主机数据挂载目录" class="headerlink" title="1.1.1. 创建宿主机数据挂载目录"></a>1.1.1. 创建宿主机数据挂载目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mystudy/data/rabbitmq<br></code></pre></td></tr></table></figure><hr><h4 id="1-1-2-启动-RabbitMQ-容器"><a href="#1-1-2-启动-RabbitMQ-容器" class="headerlink" title="1.1.2. 启动 RabbitMQ 容器"></a>1.1.2. 启动 RabbitMQ 容器</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --name rabbitmq <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e RABBITMQ_DEFAULT_USER=guest <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e RABBITMQ_DEFAULT_PASS=<span class="hljs-number">123456</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v rabbitmq-data:/var/lib/rabbitmq <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  rabbitmq:<span class="hljs-number">3</span>.<span class="hljs-number">13</span>-management<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>设置代理</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 命令行临时代理<br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$http_proxy</span> &amp;&amp;<span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> NO_PROXY=<span class="hljs-variable">$no_proxy</span><br><br><br>// docker 代理<br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.96.0.1,192.168.136.0/24,10.244.0.0/16,.svc,.cluster.local&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><hr><h4 id="1-1-3-访问-RabbitMQ-控制台"><a href="#1-1-3-访问-RabbitMQ-控制台" class="headerlink" title="1.1.3. 访问 RabbitMQ 控制台"></a>1.1.3. 访问 RabbitMQ 控制台</h4><p>访问： <a href="http://192.168.136.8:15672/">http://192.168.136.8:15672</a><br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ.png"></p><hr><h2 id="2-RabbitMQ-普通集群环境"><a href="#2-RabbitMQ-普通集群环境" class="headerlink" title="2. RabbitMQ 普通集群环境"></a>2. RabbitMQ 普通集群环境</h2><h3 id="2-1-环境概述"><a href="#2-1-环境概述" class="headerlink" title="2.1. 环境概述"></a>2.1. 环境概述</h3><p>我们经常会听到 “普通集群”、“镜像队列集群”、“Quorum 队列集群” 这样的说法。实际上，它们的<strong>集群架构本质上是相同的</strong>，搭建方法也完全一样。真正的区别在于：集群搭建完成后，运行在其上的队列所采用的高可用策略不同。</p><p>那为什么 RabbitMQ 不像 MySQL、Redis 那样，“建什么集群就是什么集群” 呢？问题的根源在于 RabbitMQ 集群的一个核心设计理念：<strong>集群只负责同步元数据（Metadata），而不负责同步消息数据（Message Data）。</strong></p><p>换句话说，像队列的名称、配置信息等元数据，可以在所有节点之间几乎实时传播；但队列内部的实际消息内容，默认只存放在创建该队列的节点上。正因为如此，为了实现消息级别的高可用，RabbitMQ 才在这个统一的集群架构之上，提供了多种不同的 <strong>队列高可用策略（HA 策略）</strong> 来弥补这一点。</p><hr><h3 id="2-2-环境特性"><a href="#2-2-环境特性" class="headerlink" title="2.2. 环境特性"></a>2.2. 环境特性</h3><h4 id="2-2-1-集群总体架构"><a href="#2-2-1-集群总体架构" class="headerlink" title="2.2.1. 集群总体架构"></a>2.2.1. 集群总体架构</h4><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-16.png"></p><hr><h4 id="2-2-2-集群线程特点"><a href="#2-2-2-集群线程特点" class="headerlink" title="2.2.2. 集群线程特点"></a>2.2.2. 集群线程特点</h4><p>并非所有分布式系统的线程都能总结出鲜明特征，没有独到之处的，也不必刻意总结</p><hr><h4 id="2-2-3-节点角色与关系"><a href="#2-2-3-节点角色与关系" class="headerlink" title="2.2.3. 节点角色与关系"></a>2.2.3. 节点角色与关系</h4><p>集群各节点之间是对等关系：</p><ol><li>无中心节点<ol><li>集群中没有所谓的 “主” 节点来统一调度，所有节点彼此平等，地位对等、功能对等。</li></ol></li><li>元数据全量同步<ol><li>任何一个节点上的元数据操作，都会被实时同步到整个集群，确保所有节点信息一致</li></ol></li><li>平等的客户端接入点<ol><li>客户端可以直接连接集群中的<strong>任意节点</strong>来执行操作，每个节点都是一个功能完备的入口。</li></ol></li></ol><hr><h4 id="2-2-4-节点部署与启动"><a href="#2-2-4-节点部署与启动" class="headerlink" title="2.2.4. 节点部署与启动"></a>2.2.4. 节点部署与启动</h4><h5 id="2-2-4-1-核心前提"><a href="#2-2-4-1-核心前提" class="headerlink" title="2.2.4.1. 核心前提"></a>2.2.4.1. 核心前提</h5><p>在开始之前，所有希望加入集群的节点必须满足两个基本条件：</p><ol><li>各节点必须相互解析<ol><li>因为每个 RabbitMQ 节点都有一个唯一名称，格式为 <code>rabbit@hostname</code>，其中 hostname 就是所在主机的主机名，例如：<code>rabbit@rbmq-node1</code></li><li>在搭建集群时，RabbitMQ 会取出主机名（如 <code>rbmq-node1</code>），通过网络解析成对应的 IP 地址，然后发起连接</li></ol></li><li>一致的 Erlang Cookie<ol><li>Erlang Cookie 是一个隐藏文件，通常位于 <code>/var/lib/rabbitmq/.erlang.cookie</code> 或用户主目录 <code>~/.erlang.cookie</code></li><li>它相当于一个 “共享密钥”，只有拥有相同 Cookie 的 Erlang 节点才能互相通信和认证。</li><li>在搭建集群前，你必须将第一个节点的 Cookie 文件内容复制到所有其他节点，这是集群通信的绝对前提，也是最常见的配置错误来源</li></ol></li></ol><hr><h5 id="2-2-4-2-首个节点启动的流程"><a href="#2-2-4-2-首个节点启动的流程" class="headerlink" title="2.2.4.2. 首个节点启动的流程"></a>2.2.4.2. 首个节点启动的流程</h5><p>当你在一个全新的环境中启动第一个 RabbitMQ 节点时，它并不会立即意识到自己未来要加入一个集群，此时，它只是一个普通的独立节点。随着 RabbitMQ 服务启动，Erlang 虚拟机（BEAM）先行加载，然后启动 RabbitMQ 应用程序。</p><p>启动过程的第一步，是节点检查自身的数据目录（例如 <code>/var/lib/rabbitmq/mnesia/</code>）。由于这是初次运行，Mnesia 数据库仍然是空的，于是节点会自动创建一份全新的本地 Mnesia 数据库模式（Schema），用于存放各种元数据信息。</p><p>完成初始化之后，该节点就已经具备完整功能，可以作为一个单节点的 RabbitMQ 服务器独立运行。</p><hr><h5 id="2-2-4-3-后续节点加入的流程"><a href="#2-2-4-3-后续节点加入的流程" class="headerlink" title="2.2.4.3. 后续节点加入的流程"></a>2.2.4.3. 后续节点加入的流程</h5><p>当你要将第二个或更多节点加入现有集群时，流程看似“简单粗暴”，但其实设计得非常精细。而且对加入节点来说，这一步操作是破坏性的，即它必须完全放弃自我，才能融入集体。</p><p>一开始，新节点的启动过程与第一个节点一样：启动 RabbitMQ 服务，初始化出一份空白的本地 Mnesia 数据库。此时，它还是一个 “孤胆英雄” ，和其他节点没有任何关系。</p><p>当我们执行 <code>rabbitmqctl stop_app</code> 时，RabbitMQ 应用会停止，但底层 Erlang 虚拟机仍在运行。</p><p>接着再用 <code>rabbitmqctl reset</code>，新节点会把自己刚创建的本地元数据彻底清空。</p><p>然后到了关键动作，我们运行 <code>rabbitmqctl join_cluster rabbit@node1</code>，此命令会触发以下过程：</p><ol><li>认证<ol><li>新节点（例如 <code>node2</code>）首先联系集群成员之一（如 <code>node1</code>）</li><li>双方交换并验证 Erlang Cookie。如果 Cookie 不匹配，加入立刻失败</li></ol></li><li>权威宣告<ol><li>验证通过后，<code>node1</code> 向 <code>node2</code> 下达指令：“想进来可以，但你必须丢掉自己的一切，从我这里重新开始。”</li></ol></li><li>本地状态清零<ol><li><code>node2</code> 会清空自己残留的 Mnesia 数据库，这个操作是不可逆的</li><li>因为 RabbitMQ 不能 “假设” 调用者一定先 reset 了，所以自带一次强制清零</li></ol></li><li>元数据同步<ol><li><code>node2</code> 从 <code>node1</code> 拉取整个集群的 Mnesia 数据库副本，此后它的元数据与集群保持完全一致</li></ol></li><li>成员注册<ol><li><code>node1</code> 将 <code>node2</code> 正式添加到集群成员列表，并将此更新通知集群中的其他节点</li></ol></li></ol><p>最后，当你再次执行 <code>rabbitmqctl start_app</code>，新节点会启动，并加载刚同步过来的集群元数据。此时它已不再是孤胆英雄，而是一个拥有和所有成员完全一致“世界观”的 RabbitMQ 节点：相同的 vhosts、用户、交换器和队列定义，一个都不少</p><hr><h4 id="2-2-5-数据写入机制"><a href="#2-2-5-数据写入机制" class="headerlink" title="2.2.5. 数据写入机制"></a>2.2.5. 数据写入机制</h4><h5 id="2-2-5-1-元数据写入"><a href="#2-2-5-1-元数据写入" class="headerlink" title="2.2.5.1. 元数据写入"></a>2.2.5.1. 元数据写入</h5><p>RabbitMQ 的元数据存储在 Mnesia 数据库中。Mnesia 是 Erlang 内置的分布式数据库，专为 Erlang 应用设计。每个 RabbitMQ 节点都会运行一个独立的 Mnesia 实例，这些实例共同组成一个集群。因此，这里描述的主要是 Mnesia 的写入流程。</p><p>元数据写入在四个维度上的选择如下：</p><ol><li>维度一：同步复制（全同）</li><li>维度二：多主复制（同步多主）</li><li>维度三<ol><li>底层技术：快照 + 增量同步（基于日志）</li><li>实现方式：类 2PC 的事务机制</li><li>详细流程：<ol><li>客户端会将元数据变更请求发送到集群中的任一节点，我们把它称为 <strong>协调节点</strong>。</li><li>协调节点在收到请求后，会首先启动一个 <strong>Mnesia 事务</strong>，为了保证隔离性和一致性，协调节点会主动向所有持有该表副本的节点发送<strong>锁请求</strong>。<ol><li>并不是像标准 2PC 那样先进入 “准备阶段”，而是先尝试把相关资源的锁都拿到手</li><li>一般数据库都是边执行边逐步申请锁，而 Mnesia 是以访问模式尝试获取相应的锁</li></ol></li><li>等所有相关节点都成功加锁后，协议才会继续进入接近传统 <strong>2PC</strong> 流程的后续阶段</li></ol></li></ol></li><li>维度四：整体保存<ol><li>元数据会被完整的复制到每一个节点上</li></ol></li></ol><hr><h5 id="2-2-5-2-数据写入"><a href="#2-2-5-2-数据写入" class="headerlink" title="2.2.5.2. 数据写入"></a>2.2.5.2. 数据写入</h5><p>在 RabbitMQ 中，数据就是队列中的消息</p><p>在普通集群模式下，消息队列中的数据仅存储于本地副本，没有什么好讲的</p><hr><h4 id="2-2-6-数据读取机制"><a href="#2-2-6-数据读取机制" class="headerlink" title="2.2.6. 数据读取机制"></a>2.2.6. 数据读取机制</h4><h5 id="2-2-6-1-元数据读取"><a href="#2-2-6-1-元数据读取" class="headerlink" title="2.2.6.1. 元数据读取"></a>2.2.6.1. 元数据读取</h5><p>所有元数据读取请求，都在客户端所连接的节点上本地完成，它会直接查询自己本地的 Mnesia 数据库，不涉及任何跨节点网络通信</p><hr><h5 id="2-2-6-2-数据读取"><a href="#2-2-6-2-数据读取" class="headerlink" title="2.2.6.2. 数据读取"></a>2.2.6.2. 数据读取</h5><p>如果请求的数据正好存储在当前节点，那么该节点会直接返回结果</p><p>如果数据不在本节点上，比如客户端访问了 <strong>Broker2</strong>，那么 <strong>Broker2</strong> 会先根据元数据定位到实际存储数据的 <strong>Broker1</strong>，从 <strong>Broker1</strong> 获取数据后，再由 <strong>Broker2</strong> 将结果返回给客户端。</p><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-17.png"></p><hr><h4 id="2-2-7-数据冗余机制"><a href="#2-2-7-数据冗余机制" class="headerlink" title="2.2.7. 数据冗余机制"></a>2.2.7. 数据冗余机制</h4><h5 id="2-2-7-1-元数据冗余"><a href="#2-2-7-1-元数据冗余" class="headerlink" title="2.2.7.1. 元数据冗余"></a>2.2.7.1. 元数据冗余</h5><p>RabbitMQ 会对元数据进行复制，确保其在每个节点上都有保存。</p><hr><h5 id="2-2-7-2-数据冗余"><a href="#2-2-7-2-数据冗余" class="headerlink" title="2.2.7.2. 数据冗余"></a>2.2.7.2. 数据冗余</h5><p>消息本身仅存储于本地节点，RabbitMQ 并未将同样的冗余机制扩展至消息数据</p><hr><h4 id="2-2-8-数据事务支持"><a href="#2-2-8-数据事务支持" class="headerlink" title="2.2.8. 数据事务支持"></a>2.2.8. 数据事务支持</h4><h5 id="2-2-8-1-元数据事务支持"><a href="#2-2-8-1-元数据事务支持" class="headerlink" title="2.2.8.1. 元数据事务支持"></a>2.2.8.1. 元数据事务支持</h5><p>元数据由 <strong>Mnesia</strong>（Erlang 内置的分布式数据库）负责存储和复制。Mnesia 自身具备事务特性，但这些事务能力并不会对外直接暴露给 RabbitMQ 的使用者。</p><hr><h5 id="2-2-8-2-数据事务支持"><a href="#2-2-8-2-数据事务支持" class="headerlink" title="2.2.8.2. 数据事务支持"></a>2.2.8.2. 数据事务支持</h5><p>RabbitMQ 的事务支持几乎一直被视为 “痛点”，它虽然遵循 AMQP 规范，提供了事务 API：生产者可以开启一个事务，在其中发送一批消息，然后选择 <strong>commit</strong> 提交。如果中途失败，可以 <strong>rollback</strong> 回滚</p><p>但问题在于，它的限制非常大：</p><ol><li>作用范围有限<ol><li>事务仅限于单个 Channel（即一次客户端连接），无法跨连接、跨队列，更不具备跨节点的分布式事务能力。</li></ol></li><li>性能表现极差<ol><li>虽然发送了一批数据，但每一个数据的提交都需要等待 Broker 的完整确认，吞吐量会骤降到正常情况下的几十分之一甚至更低。</li></ol></li></ol><p>正因如此，RabbitMQ 的事务功能几乎无人问津。批量消息写入效率过于低下，与高吞吐的消息队列定位背道而驰。取而代之，大家普遍采用 发布确认机制（Publisher Confirms） 来保证消息可靠性，它在性能和可用性上远远优于事务。</p><hr><h4 id="2-2-9-负载均衡策略"><a href="#2-2-9-负载均衡策略" class="headerlink" title="2.2.9. 负载均衡策略"></a>2.2.9. 负载均衡策略</h4><p>不存在内置负载均衡策略，依靠外部负载均衡组件</p><hr><h4 id="2-2-10-故障转移机制"><a href="#2-2-10-故障转移机制" class="headerlink" title="2.2.10. 故障转移机制"></a>2.2.10. 故障转移机制</h4><p>不存在故障转移机制</p><hr><h3 id="2-3-环境限制"><a href="#2-3-环境限制" class="headerlink" title="2.3. 环境限制"></a>2.3. 环境限制</h3><hr><h3 id="2-4-环境要求"><a href="#2-4-环境要求" class="headerlink" title="2.4. 环境要求"></a>2.4. 环境要求</h3><h4 id="2-4-1-操作系统要求"><a href="#2-4-1-操作系统要求" class="headerlink" title="2.4.1. 操作系统要求"></a>2.4.1. 操作系统要求</h4><p>不依赖特定操作系统，支持在 Linux、macOS 和 Windows 环境下运行</p><hr><h4 id="2-4-2-节点要求"><a href="#2-4-2-节点要求" class="headerlink" title="2.4.2. 节点要求"></a>2.4.2. 节点要求</h4><ol><li>最小节点数量</li><li>最大节点数量<ol><li>没有硬性限制，但有软性上限</li></ol></li><li>推荐节点数量<ol><li>轻量级场景</li><li>微生产级场景</li><li>中生产级场景</li><li>高并发、高吞吐、高容量生产级场景</li></ol></li><li>节点数量奇偶<ol><li>奇数节点</li></ol></li><li>最小存活节点数量</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>为什么最大节点数量没有硬性限制，但有软性上限？<ol><li>元数据同步开销大<ol><li>当节点数量过度，每一次修改元数据的延迟都会变得非常明显</li></ol></li><li>运维成本上升<ol><li>节点越多，需要监控的就越多，运维复杂度上升，运维成本上升</li></ol></li></ol></li></ol></blockquote><hr><h4 id="2-4-3-磁盘要求"><a href="#2-4-3-磁盘要求" class="headerlink" title="2.4.3. 磁盘要求"></a>2.4.3. 磁盘要求</h4><ol><li>最小磁盘容量</li><li>推荐磁盘容量</li></ol><hr><h4 id="2-4-4-CPU-要求"><a href="#2-4-4-CPU-要求" class="headerlink" title="2.4.4. CPU 要求"></a>2.4.4. CPU 要求</h4><ol><li>最小 CPU 核心数</li><li>推荐 CPU 核心数</li></ol><hr><h4 id="2-4-5-内存要求"><a href="#2-4-5-内存要求" class="headerlink" title="2.4.5. 内存要求"></a>2.4.5. 内存要求</h4><ol><li>最小内存大小</li><li>推荐内存大小<ol><li>轻量级场景</li><li>微生产级场景</li><li>中生产级场景</li><li>高并发、高吞吐、高容量生产级场景</li></ol></li></ol><hr><h4 id="2-4-6-时间要求"><a href="#2-4-6-时间要求" class="headerlink" title="2.4.6. 时间要求"></a>2.4.6. 时间要求</h4><p>RabbitMQ 集群中的各节点之间必须保持时间同步。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在跨多集群时，时间同步更加敏感，必须进行时间同步。</li></ol></blockquote><hr><h4 id="2-4-7-用户要求"><a href="#2-4-7-用户要求" class="headerlink" title="2.4.7. 用户要求"></a>2.4.7. 用户要求</h4><p>安全起见，在生产环境中，建议新建一个专门的系统用户（例如命名为 <code>minio</code>）来运行 MinIO 服务，不建议赋予其过高权限（如 root 权限），以降低安全风险。通过限制权限，可以有效防止因服务漏洞导致整个系统被攻破。</p><hr><h4 id="2-4-8-端口要求"><a href="#2-4-8-端口要求" class="headerlink" title="2.4.8. 端口要求"></a>2.4.8. 端口要求</h4><table><thead><tr><th>端口</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1883</td><td>TCP</td><td>MQTT 插件</td></tr><tr><td><strong>4369</strong></td><td>TCP</td><td>Erlang epmd 服务（Erlang 节点间依赖该服务进行发现）</td></tr><tr><td><strong>5672</strong></td><td>TCP</td><td>AMQP 协议主通道</td></tr><tr><td><strong>15672</strong></td><td>TCP</td><td>Web 控制台</td></tr><tr><td>15674</td><td>TCP</td><td>WebSocket 插件</td></tr><tr><td><strong>25672</strong></td><td>TCP</td><td>RabbitMQ 节点间内部通信</td></tr></tbody></table><hr><h4 id="2-4-9-扩容要求"><a href="#2-4-9-扩容要求" class="headerlink" title="2.4.9. 扩容要求"></a>2.4.9. 扩容要求</h4><hr><h4 id="2-4-10-Swap-分区要求"><a href="#2-4-10-Swap-分区要求" class="headerlink" title="2.4.10. Swap 分区要求"></a>2.4.10. Swap 分区要求</h4><p>swap 分区，简单来说，是操作系统在系统内存不足时，将某些程序不活跃或暂时不需要的数据移动到 swap 分区（位于硬盘），以释放内存资源供当前活跃程序使用。</p><p>由于 swap 分区依赖硬盘，其读写速度远低于内存。如果系统频繁使用 swap，会造成大量磁盘 I&#x2F;O，严重影响系统性能，甚至导致系统响应迟缓或无响应。因此，在性能敏感的场景（如数据库、实时计算、大内存服务器）中，通常建议禁用 swap，确保数据始终在高速内存中运行。</p><p>我们推荐 RabbitMQ 服务器关闭 Swap 分区</p><hr><h4 id="2-4-11-节点相互解析要求"><a href="#2-4-11-节点相互解析要求" class="headerlink" title="2.4.11. 节点相互解析要求"></a>2.4.11. 节点相互解析要求</h4><p>各节点必须相互解析，因为：</p><ol><li>每个 RabbitMQ 节点都有一个唯一名称，格式为 <code>rabbit@hostname</code>，其中 hostname 就是所在主机的主机名，例如：<code>rabbit@rbmq-node1</code></li><li>在搭建集群时，RabbitMQ 会取出主机名（如 <code>rbmq-node1</code>），通过网络解析成对应的 IP 地址，然后发起连接</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>小规模：主机名解析</li><li>中等规模：DNS 解析</li><li>大规模：服务发现组件</li></ol></blockquote><hr><h3 id="2-5-环境准备"><a href="#2-5-环境准备" class="headerlink" title="2.5. 环境准备"></a>2.5. 环境准备</h3><h4 id="2-5-1-查看-Ubuntu-版本"><a href="#2-5-1-查看-Ubuntu-版本" class="headerlink" title="2.5.1. 查看 Ubuntu 版本"></a>2.5.1. 查看 Ubuntu 版本</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">lsb_release -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><hr><h4 id="2-5-2-节点列表"><a href="#2-5-2-节点列表" class="headerlink" title="2.5.2. 节点列表"></a>2.5.2. 节点列表</h4><table><thead><tr><th align="center">IP</th><th align="center">磁盘</th><th align="center">CPU</th><th align="center">内存</th><th align="center">带宽</th><th align="center">主机名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">192.168.136.8</td><td align="center">Root 盘</td><td align="center">2 核</td><td align="center">4GB</td><td align="center"></td><td align="center">rbmq-node1</td><td align="center"></td></tr><tr><td align="center">192.168.136.9</td><td align="center">Root 盘</td><td align="center">2 核</td><td align="center">4GB</td><td align="center"></td><td align="center">rbmq-node2</td><td align="center"></td></tr><tr><td align="center">192.168.136.10</td><td align="center">Root 盘</td><td align="center">2 核</td><td align="center">4GB</td><td align="center"></td><td align="center">rbmq-node3</td><td align="center"></td></tr></tbody></table><hr><h4 id="2-5-3-时间同步"><a href="#2-5-3-时间同步" class="headerlink" title="2.5.3. 时间同步"></a>2.5.3. 时间同步</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> -v chrony &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-built_in">sudo</span> apt-get install -y chrony<br><br><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> chrony &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl start chrony<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>设置代理</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 命令行临时代理<br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$http_proxy</span> &amp;&amp;<span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> NO_PROXY=<span class="hljs-variable">$no_proxy</span><br><br><br>// docker 代理<br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.96.0.1,192.168.136.0/24,10.244.0.0/16,.svc,.cluster.local&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><hr><h4 id="2-5-4-开放端口"><a href="#2-5-4-开放端口" class="headerlink" title="2.5.4. 开放端口"></a>2.5.4. 开放端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 1833<br><span class="hljs-built_in">sudo</span> ufw allow 1833/tcp<br><br>// 4369<br><span class="hljs-built_in">sudo</span> ufw allow 4369/tcp<br><br>// 5672<br><span class="hljs-built_in">sudo</span> ufw allow 5672/tcp<br><br>// 15672<br><span class="hljs-built_in">sudo</span> ufw allow 15672/tcp<br><br>// 15674<br><span class="hljs-built_in">sudo</span> ufw allow 15674/tcp<br><br>// 25672<br><span class="hljs-built_in">sudo</span> ufw allow 25672/tcp<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果使用云服务器，同样需要开放安全组</li></ol></blockquote><hr><h4 id="2-5-5-关闭-Swap-分区"><a href="#2-5-5-关闭-Swap-分区" class="headerlink" title="2.5.5. 关闭 Swap 分区"></a>2.5.5. 关闭 Swap 分区</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1. 编辑 /etc/fstab</span><br>vim <span class="hljs-regexp">/etc/</span>fstab<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># 将此内容进行注释（/swap 开头的）</span><br><span class="hljs-string"># /swap.img       none    swap    sw      0       0</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-comment"># 2. 立即关闭 Swap 分区</span><br>swapoff -a<br></code></pre></td></tr></table></figure><hr><h4 id="2-5-6-设置节点相互解析"><a href="#2-5-6-设置节点相互解析" class="headerlink" title="2.5.6. 设置节点相互解析"></a>2.5.6. 设置节点相互解析</h4><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 1. 设置主机名</span><br><span class="hljs-comment"># 1.1. 192.168.136.8</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">rbmq-node1</span><br><br><span class="hljs-comment"># 1.2. 192.168.136.9</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">rbmq-node2</span><br><br><span class="hljs-comment"># 1.3. 192.168.136.10</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">rbmq-node3</span><br><br><br><span class="hljs-comment"># 2. 设置主机名互相解析</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">vim</span> /<span class="hljs-string">etc</span>/<span class="hljs-string">hosts</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">192.168.136.8 rbmq-node1</span><br><span class="hljs-string">192.168.136.9 rbmq-node2</span><br><span class="hljs-string">192.168.136.10 rbmq-node3</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><hr><h4 id="2-5-7-安装需要的工具"><a href="#2-5-7-安装需要的工具" class="headerlink" title="2.5.7. 安装需要的工具"></a>2.5.7. 安装需要的工具</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">// 1. dos2unix，用于将文件转为 Unix 格式</span><br>command -v dos2unix &gt;/<span class="hljs-built_in">dev</span>/<span class="hljs-built_in">null</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> || sudo apt-<span class="hljs-built_in">get</span> install -y dos2unix<br><br><br><span class="hljs-comment">// 2. xfsprogs，用于将磁盘块设备格式化为 xfs 文件系统</span><br>command -v xfsprogs &gt;/<span class="hljs-built_in">dev</span>/<span class="hljs-built_in">null</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> || sudo apt install -y xfsprogs<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>设置代理</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 命令行临时代理<br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$http_proxy</span> &amp;&amp;<span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> NO_PROXY=<span class="hljs-variable">$no_proxy</span><br><br><br>// docker 代理<br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.96.0.1,192.168.136.0/24,10.244.0.0/16,.svc,.cluster.local&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><hr><h3 id="2-6-环境搭建"><a href="#2-6-环境搭建" class="headerlink" title="2.6. 环境搭建"></a>2.6. 环境搭建</h3><h4 id="2-6-1-安装-RabbitMQ"><a href="#2-6-1-安装-RabbitMQ" class="headerlink" title="2.6.1. 安装 RabbitMQ"></a>2.6.1. 安装 RabbitMQ</h4><p>删除之前的 <code>packagecloud.io</code> 和 <code>erlang-solutions.com</code> 的源：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1. 查找所有涉及 packagecloud.io 和 erlang-solutions.com 的源</span><br>grep -R <span class="hljs-string">&quot;packagecloud\.io\|erlang-solutions\.com&quot;</span> <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list /</span>etc<span class="hljs-regexp">/apt/</span>sources.list.d/*.list<br><br><br><span class="hljs-comment"># 2. 删除这些源</span><br>sudo rm <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>erlang.list \<br>        <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>rabbitmq_erlang.list \<br>        <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>rabbitmq_server.list<br></code></pre></td></tr></table></figure><p>然后根据 <a href="https://www.rabbitmq.com/docs/install-debian">RabbitMQ 安装文档</a>，选择合适的版本（4.1），并在每个节点上进行安装：<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-12.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>设置代理</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 命令行临时代理<br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://192.168.8.5:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$http_proxy</span> &amp;&amp;<span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> NO_PROXY=<span class="hljs-variable">$no_proxy</span><br><br><br>// docker 代理<br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">Environment=&quot;HTTP_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;HTTPS_PROXY=http://192.168.8.5:7890&quot;</span><br><span class="hljs-string">Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.96.0.1,192.168.136.0/24,10.244.0.0/16,.svc,.cluster.local&quot;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. 出现以下情况，无需在意，实际上它已经创建了主目录</p></blockquote><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-14.png"></p><hr><h4 id="2-6-2-启用-Web-控制台"><a href="#2-6-2-启用-Web-控制台" class="headerlink" title="2.6.2. 启用 Web 控制台"></a>2.6.2. 启用 Web 控制台</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><hr><h4 id="2-6-3-首个节点启动"><a href="#2-6-3-首个节点启动" class="headerlink" title="2.6.3. 首个节点启动"></a>2.6.3. 首个节点启动</h4><h5 id="2-6-3-1-节点启动"><a href="#2-6-3-1-节点启动" class="headerlink" title="2.6.3.1. 节点启动"></a>2.6.3.1. 节点启动</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 1. 启动 RabbitMQ 服务</span><br>systemctl start  rabbitmq-<span class="hljs-keyword">server</span><br><br><br><span class="hljs-meta"># 2. 开机自启动 RabbitMQ 服务</span><br>systemctl enable rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><hr><h5 id="2-6-3-2-集群基础配置"><a href="#2-6-3-2-集群基础配置" class="headerlink" title="2.6.3.2. 集群基础配置"></a>2.6.3.2. 集群基础配置</h5><h6 id="2-6-3-2-1-添加用户"><a href="#2-6-3-2-1-添加用户" class="headerlink" title="2.6.3.2.1. 添加用户"></a>2.6.3.2.1. 添加用户</h6><p>默认的超级管理员账号是 <code>guest/guest</code>。但出于安全考虑，RabbitMQ 限制该账号只能在本机（<code>127.0.0.1</code> 或 <code>::1</code>）登录，远程连接会被拒绝。因此，如果需要从其他机器访问，就必须添加用户</p><p><font color="#92d050">1. 添加用户</font></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">rabbitmqctl <span class="hljs-keyword">add_user </span><span class="hljs-keyword">batian </span>wq666666<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 设置用户标签</font><br>用户可以被分配一个或多个标签，常见标签包括：</p><ol><li>administrator<ol><li>拥有完整的管理权限</li><li>可在 Web 控制台和 HTTP API 中执行所有管理操作</li></ol></li><li>monitoring<ol><li>拥有监控权限</li><li>仅能查看系统运行状态（如队列长度、连接数、通道、消息速率等），无法进行写入或配置操作</li></ol></li><li>policymaker<ol><li>拥有策略管理权限</li><li>可创建、修改与删除策略（policies），不具备完整的管理或监控能力<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rabbitmqctl set_user_tags batian administrator</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><p><font color="#92d050">3. 设置用户虚拟机权限</font><br>为用户在指定的虚拟主机（vhost）上分配权限</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">rabbitmqctl set_permissions -<span class="hljs-keyword">p</span> <span class="hljs-symbol">&lt;vhost&gt;</span> <span class="hljs-symbol">&lt;username&gt;</span> <span class="hljs-symbol">&lt;configure-regex&gt;</span> <span class="hljs-symbol">&lt;write-regex&gt;</span> <span class="hljs-symbol">&lt;read-regex&gt;</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>rabbitmqctl set_permissions -<span class="hljs-keyword">p</span> / batian <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">1. configure-regex</font><br>控制声明与删除操作，影响对象包括队列、交换机、绑定、甚至 quorum queue，使用正则表达式书写</p><p><font color="#92d050">2. write-regex</font><br>控制消息写入行为，包括向交换机或默认交换机发送消息，使用正则表达式书写</p><p><font color="#92d050">3. read-regex</font><br>控制消息读取与队列消费行为，也涵盖 HTTP API 的读取访问，使用正则表达式书写</p><hr><h6 id="2-6-3-2-2-启用所有稳定功能-flag-启用"><a href="#2-6-3-2-2-启用所有稳定功能-flag-启用" class="headerlink" title="2.6.3.2.2. 启用所有稳定功能 flag 启用"></a>2.6.3.2.2. 启用所有稳定功能 flag 启用</h6><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">rabbitmqctl enable_feature_flag <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><hr><h6 id="2-6-3-2-3-重启-RabbitMQ-服务"><a href="#2-6-3-2-3-重启-RabbitMQ-服务" class="headerlink" title="2.6.3.2.3. 重启 RabbitMQ 服务"></a>2.6.3.2.3. 重启 RabbitMQ 服务</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">systemctl <span class="hljs-keyword">restart</span> rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><hr><h4 id="2-6-4-后续节点加入"><a href="#2-6-4-后续节点加入" class="headerlink" title="2.6.4. 后续节点加入"></a>2.6.4. 后续节点加入</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 关闭 RabbitMQ 服务<br>sudo systemctl stop rabbitmq-server<br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 同步 Erlang Cookie<br>echo -n <span class="hljs-string">&quot;KBPLAAQIFRMRMIMPVSVI&quot;</span> | sudo tee <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/rabbitmq/</span>.erlang.cookie &gt; <span class="hljs-regexp">/dev/</span>null<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1. 首先需要查看第一个节点的 Erlang Cookie：cat /var/lib/rabbitmq/.erlang.cookie</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 启动 RabbitMQ 服务<br>sudo systemctl start rabbitmq-server<br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. 停止 RabbitMQ（Erlang 虚拟机仍然运行）<br>rabbitmqctl stop_app<br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">5</span>. 清空本地元数据<br>rabbitmqctl reset<br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">6</span>. 加入集群<br>rabbitmqctl join_cluster rabbit@rbmq-node1<br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">7</span>. 启动 RabbitMQ<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><hr><h4 id="2-6-5-检查集群状态"><a href="#2-6-5-检查集群状态" class="headerlink" title="2.6.5. 检查集群状态"></a>2.6.5. 检查集群状态</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rabbitmqctl cluster_status</span><br></code></pre></td></tr></table></figure><hr><h1 id="四、Spring-for-RabbitMQ"><a href="#四、Spring-for-RabbitMQ" class="headerlink" title="四、Spring for RabbitMQ"></a>四、Spring for RabbitMQ</h1><h2 id="1-Spring-for-RabbitMQ-组件"><a href="#1-Spring-for-RabbitMQ-组件" class="headerlink" title="1. Spring for RabbitMQ 组件"></a>1. Spring for RabbitMQ 组件</h2><h2 id="2-Spring-for-RabbitMQ-配置"><a href="#2-Spring-for-RabbitMQ-配置" class="headerlink" title="2. Spring for RabbitMQ 配置"></a>2. Spring for RabbitMQ 配置</h2><h3 id="2-1-配置模板"><a href="#2-1-配置模板" class="headerlink" title="2.1. 配置模板"></a>2.1. 配置模板</h3><h4 id="2-1-1-yml-配置"><a href="#2-1-1-yml-配置" class="headerlink" title="2.1.1. yml 配置"></a>2.1.1. yml 配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.8</span>  <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>                                      <span class="hljs-comment"># 注意不要写 15672，其是 Web 控制台</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>  <br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>  <br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span>                                 <span class="hljs-comment"># RabbitMQ 的虚拟空间</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span>              <span class="hljs-comment"># 开启交换机确认</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span>                         <span class="hljs-comment"># 开启队列确认</span><br>    <span class="hljs-attr">listener:</span>  <br>      <span class="hljs-attr">simple:</span>  <br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span>                    <span class="hljs-comment"># 开启主动应答</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1000</span>                              <span class="hljs-comment"># 每次最多从消息队列取回 1000 条数据（预取数量）</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 精简版</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.8</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-快速上手"><a href="#3-快速上手" class="headerlink" title="3. 快速上手"></a>3. 快速上手</h2><h3 id="3-1-添加相关依赖"><a href="#3-1-添加相关依赖" class="headerlink" title="3.1. 添加相关依赖"></a>3.1. 添加相关依赖</h3><ol><li>Web<ol><li>Spring Web</li></ol></li><li>Messaging<ol><li>Spring for RabbitMQ</li></ol></li></ol><hr><h3 id="3-2-进行相关配置"><a href="#3-2-进行相关配置" class="headerlink" title="3.2. 进行相关配置"></a>3.2. 进行相关配置</h3><p>详见上文：Spring for RabbitMQ 配置</p><hr><h3 id="3-3-创建交换机"><a href="#3-3-创建交换机" class="headerlink" title="3.3. 创建交换机"></a>3.3. 创建交换机</h3><p>这里创建的交换机名称为：<code>test.exchange</code>：<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-2.png"></p><hr><h3 id="3-4-创建队列"><a href="#3-4-创建队列" class="headerlink" title="3.4. 创建队列"></a>3.4. 创建队列</h3><p>这里创建的队列名称为：<code>test.queue</code>：<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-3.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虚拟空间默认使用的队列类型，一定是 classic</li></ol></blockquote><hr><h3 id="3-5-将队列与交换机绑定"><a href="#3-5-将队列与交换机绑定" class="headerlink" title="3.5. 将队列与交换机绑定"></a>3.5. 将队列与交换机绑定</h3><p>将 <code>test.queue</code> 队列与 <code>test.exchange</code> 交换机绑定，使用路由键 <code>test</code>。这样，发送到 <code>test.exchange</code> 且路由键为 <code>test</code> 的消息会被转发到 <code>test.queue</code>。</p><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-4.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>一个交换机可以绑定多个队列，一个队列也可以绑定多个交换机</li></ol></blockquote><hr><h3 id="3-6-创建生产者"><a href="#3-6-创建生产者" class="headerlink" title="3.6. 创建生产者"></a>3.6. 创建生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQProduce</span> &#123;  <br><br>    <span class="hljs-comment">// 交换机  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.direct.test&quot;</span>;  <br>    <br>    <span class="hljs-comment">// 路由键  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;  <br>  <br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;  <br>  <br>    <span class="hljs-meta">@GetMapping(&quot;/sendMessage&quot;)</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;  <br>        rabbitTemplate.convertAndSend(<br>        EXCHANGE_DIRECT,  <br>                ROUTING_KEY,  <br>                <span class="hljs-string">&quot;first sent message!&quot;</span>,  <br>                message -&gt; &#123;  <br>                <span class="hljs-comment">// 设置消息属性</span><br>                .......<br>                    <span class="hljs-keyword">return</span> message;  <br>                &#125;,  <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;123456&quot;</span>));  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-业务处理"><a href="#4-业务处理" class="headerlink" title="4. 业务处理"></a>4. 业务处理</h2><h3 id="4-1-发布确认"><a href="#4-1-发布确认" class="headerlink" title="4.1. 发布确认"></a>4.1. 发布确认</h3><h4 id="4-1-1-发布确认概述"><a href="#4-1-1-发布确认概述" class="headerlink" title="4.1.1. 发布确认概述"></a>4.1.1. 发布确认概述</h4><p>发布确认 的出现主要是为了解决以下问题：生产者将消息发送到 RabbitMQ 服务器后，是直接返回的，生产者不知道消息是否真正到达了 RabbitMQ</p><p>而 发布确认 通过为 Channel 上发布的消息都会被分配一个唯一的ID（从1开始的递增整数，称为 <code>deliveryTag</code>）</p><ol><li>当 RabbitMQ 服务器成功处理这些消息后，会向生产者发送一个<strong>确认（acknowledgement，简称 ack）</strong>，其中包含了对应消息的 <code>deliveryTag</code></li><li>如果 RabbitMQ 因为内部错误等原因无法处理某条消息，它会发送一个<strong>否定确认（negative-acknowledgement，简称 nack）</strong></li><li>生产者可以通过监听这些 <code>ack</code> 和 <code>nack</code> 来判断消息是否发送成功，并决定是否需要重发。</li></ol><hr><h4 id="4-1-2-发布确认实现方式"><a href="#4-1-2-发布确认实现方式" class="headerlink" title="4.1.2. 发布确认实现方式"></a>4.1.2. 发布确认实现方式</h4><h5 id="4-1-2-1-同步单条确认"><a href="#4-1-2-1-同步单条确认" class="headerlink" title="4.1.2.1. 同步单条确认"></a>4.1.2.1. 同步单条确认</h5><p>每次消息发布后，生产者都必须等待确认完成才能继续发送后续消息（同步阻塞）</p><p>其优点是：</p><ol><li>简单、直观</li><li>数据零丢失</li></ol><p>其缺点是：</p><ol><li>性能最差<ol><li>生产者必须等待确认完成才能继续发送后续消息，这种同步阻塞的机制严重限制了吞吐量</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>生产环境中几乎不推荐使用，除非系统对性能要求极低。</li></ol></blockquote><hr><h5 id="4-1-2-2-同步批量确认"><a href="#4-1-2-2-同步批量确认" class="headerlink" title="4.1.2.2. 同步批量确认"></a>4.1.2.2. 同步批量确认</h5><p>批量确认是在单条确认的基础上的一种优化。生产者可以一次性发布多条消息（例如 100 条），然后等待这一批消息的统一确认（同步阻塞）</p><p>其优点是：</p><ol><li>性能提升<ol><li>虽然依旧是同步阻塞方式，但吞吐量相较于逐条确认明显提升</li></ol></li></ol><p>其缺点是：</p><ol><li>无法定位失败消息<ol><li>一旦发布失败，你只能得知这一批消息中至少有一条出错，却无法定位具体是哪一条。于是只能整批重发，这就可能导致部分消息重复。</li></ol></li></ol><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-28.png"></p><hr><h5 id="4-1-2-3-异步确认（推荐）"><a href="#4-1-2-3-异步确认（推荐）" class="headerlink" title="4.1.2.3. 异步确认（推荐）"></a>4.1.2.3. 异步确认（推荐）</h5><p>这是最复杂，但同时<strong>性能最高、也是官方最推荐</strong>的方式。生产者只需专注于不断发送消息（异步非阻塞），并借助独立的 I&#x2F;O 线程异步来处理 RabbitMQ 的回馈</p><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-29.png"></p><p><font color="#92d050">1. 进行相关配置</font></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span>         <span class="hljs-comment"># 开启交换机确认</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 精简版</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建 RabbitMQ 回调配置类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQCallBackConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">// 使用 @PostConstruct 注解，在所有 Bean 初始化完成后执行这个方法</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRabbitTemplate</span><span class="hljs-params">()</span> &#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * void confirm(CorrelationData correlationData, boolean ack, String cause)</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. public</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. 参数</span><br><span class="hljs-comment">     *      1. CorrelationData correlationData</span><br><span class="hljs-comment">     *          1. 消息的元数据对象</span><br><span class="hljs-comment">     *          2. 需要注意的是，该对象不是 RabbitMQ 为我们生产的，而是我们发消息时自己传入，并在回调中传回来的</span><br><span class="hljs-comment">     *      2. boolean ack</span><br><span class="hljs-comment">     *          1. RabbitMQ 回馈消息是否到达交换机</span><br><span class="hljs-comment">     *          2. true</span><br><span class="hljs-comment">     *              1. 消息到达交换机</span><br><span class="hljs-comment">     *          3. false</span><br><span class="hljs-comment">     *              1. 消息未到达交换机</span><br><span class="hljs-comment">     *      3. String cause</span><br><span class="hljs-comment">     *          1. 如果消息未到达交换机，RabbitMQ 回馈失败原因</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. 返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 5. 使用示例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 6. 作用</span><br><span class="hljs-comment">     *      1. 当消息发送到交换机成功或失败时，会调用这个回调方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 7. 注意事项</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-comment">// 当消息发送到交换机 成功或失败 时，会调用这个方法</span><br>        System.out.println(<span class="hljs-string">&quot;confirm（）回调函数打印 CorrelationData：&quot;</span>+ correlationData);<br>        System.out.println(<span class="hljs-string">&quot;confirm（）回调函数打印 ack：&quot;</span>+ack);<br>        System.out.println(<span class="hljs-string">&quot;confirm（）回调函数打印 cause：&quot;</span>+cause);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-路由失败"><a href="#4-2-路由失败" class="headerlink" title="4.2. 路由失败"></a>4.2. 路由失败</h3><h4 id="4-2-1-路由失败概述"><a href="#4-2-1-路由失败概述" class="headerlink" title="4.2.1. 路由失败概述"></a>4.2.1. 路由失败概述</h4><p>路由失败是指：交换机接收到了消息，但在其绑定关系中找不到任何一个匹配的队列来投递这条消息</p><ol><li>Direct Exchange<ol><li>发送消息时指定的 <code>routing_key</code> 没有与任何队列的 <code>binding_key</code> 完全匹配</li></ol></li><li>Topic Exchange<ol><li>发送消息时指定的 <code>routing_key</code> 不符合任何队列绑定的模式（Pattern）</li></ol></li><li>Fanout Exchange<ol><li>该交换机上没有绑定任何队列</li></ol></li><li>Headers Exchange<ol><li>消息的 <code>headers</code> 属性与任何队列的绑定参数都不匹配</li></ol></li></ol><p>如果不对路由失败做任何处理，RabbitMQ 的默认行为是默默地将这条消息丢弃（Discard）</p><hr><h4 id="路由失败解决方案"><a href="#路由失败解决方案" class="headerlink" title="路由失败解决方案"></a>路由失败解决方案</h4><h5 id="4-2-2-备用交换机解决方案（推荐）"><a href="#4-2-2-备用交换机解决方案（推荐）" class="headerlink" title="4.2.2. 备用交换机解决方案（推荐）"></a>4.2.2. 备用交换机解决方案（推荐）</h5><p>当原始交换机收到一条无法路由任何队列的消息时，会自动把这条消息转发到事先指定好的 备份交换机（AE）<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-31.png"></p><p><font color="#92d050">1. 创建备份交换机、备份队列，将备份交换机和备份队列绑定</font></p><ol><li>交换机<ol><li>名称<ol><li>test.backup.exchange</li></ol></li><li>类型<ol><li>fanout</li><li>当消息从主交换机转发到备份交换机时，并不会携带路由键，所以一般使用 fanout 进行广播</li></ol></li></ol></li><li>队列<ol><li>名称<ol><li>test.backup.queue</li></ol></li></ol></li></ol><p><font color="#92d050">2. 创建交换机、队列，将交换机和队列绑定</font></p><ol><li>交换机<ol><li>Name<ol><li>test.exchange</li></ol></li><li>Type<ol><li>direct</li></ol></li><li>Arguments<ol><li>alternate-exchange &#x3D; test.backup.exchange<ol><li>指定本交换机的备份交换机</li></ol></li></ol></li></ol></li><li>队列<ol><li>Name<ol><li>test.queue</li></ol></li></ol></li><li>路由键<ol><li>test</li></ol></li></ol><hr><h5 id="4-2-3-消息回退解决方案"><a href="#4-2-3-消息回退解决方案" class="headerlink" title="4.2.3. 消息回退解决方案"></a>4.2.3. 消息回退解决方案</h5><p>当原始交换机收到一条无法路由任何队列的消息时，会自动把这条消息退回给生产者，生产者可以使用回调方法进行处理</p><p><font color="#92d050">1.进行相关配置</font></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span>                                 <span class="hljs-comment"># 开启路由失败消息回退</span><br><span class="hljs-attr">template:</span><br>  <span class="hljs-attr">mandatory:</span> <span class="hljs-literal">true</span>                                           <span class="hljs-comment"># 把消息回退给生产者</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 精简版</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">template:</span><br>  <span class="hljs-attr">mandatory:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建 RabbitMQ 回调配置类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQCallBackConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ReturnsCallback &#123;  <br><br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;  <br>  <br><span class="hljs-comment">// 使用 @PostConstruct 注解，在所有 Bean 初始化完成后执行这个方法</span><br>    <span class="hljs-meta">@PostConstruct</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRabbitTemplate</span><span class="hljs-params">()</span> &#123;  <br>        rabbitTemplate.setReturnsCallback(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>    <br>    <span class="hljs-comment">// 当消息发送到队列失败时，才会调用这个方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returnedMessage)</span> &#123;  <br>        <br>        System.out.println(<span class="hljs-string">&quot;消息主体: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(returnedMessage.getMessage().getBody()));  <br>        System.out.println(<span class="hljs-string">&quot;应答码: &quot;</span> + returnedMessage.getReplyCode());  <br>        System.out.println(<span class="hljs-string">&quot;描述: &quot;</span> + returnedMessage.getReplyText());  <br>        System.out.println(<span class="hljs-string">&quot;消息使用的交换器 exchange : &quot;</span> + returnedMessage.getExchange());  <br>        System.out.println(<span class="hljs-string">&quot;消息使用的路由键 routing : &quot;</span> + returnedMessage.getRoutingKey());  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-消息应答"><a href="#4-3-消息应答" class="headerlink" title="4.3. 消息应答"></a>4.3. 消息应答</h3><p>默认情况下，RabbitMQ 一旦向消费者发送了一条消息后，便立即将该消息标记为删除。由于消费者处理一个消息可能需要一段时间，假如在处理消息中途消费者挂掉了，我们会丢失其正在处理的消息以及后续发送给该消费这的消息，这就叫 “消息黑洞”，为了避免这个情况，RabbitMQ 提供了消息应答机制</p><ol><li>自动应答（默认，auto）<ol><li>只要消息被消费者方法接收到，不管是否成功处理，RabbitMQ 都会认为消息已消费成功，立刻从队列删除</li><li>其优点是：<ol><li>性能高<ol><li>不需要等待消费者回应，丢出去就完了</li></ol></li></ol></li><li>其缺点是：<ol><li>消息丢失风险<ol><li>万一你的消费端发生异常，如宕机、代码跑错等，消息就丢了</li></ol></li><li>消息无限推送<ol><li>RabbitMQ 不追踪“消费者未确认的消息”，于是 Broker 想都不想，看到有消费者就一股脑下发消息。</li><li>消息堆积在消费者进程里（尚未处理完），随着时间推移可能撑爆内存。</li><li>操作系统看你进程内存爆炸 → OOM Killer 出动 → 消费者线程&#x2F;进程被强行终止</li></ol></li></ol></li><li>适用场景：<ol><li>消费者可以高效并以某种速率能够处理这些消息的场景</li><li>对可靠性要求不高的场景</li></ol></li></ol></li><li>手动应答（manual）<ol><li>消费者收到消息后，需要在自己在代码里调用 <code>channel.basicAck()</code>、<code>channel.basicNack()</code> 或 <code>channel.basicReject()</code> 来告诉 RabbitMQ：这条消息我处理好了（或处理失败）。<ol><li>basicAck<ol><li>确认消息已成功处理，RabbitMQ 删除这条消息</li></ol></li><li>basicNack<ol><li>拒绝消息，可以选择是否重新入队</li></ol></li><li>basicReject<ol><li>等同于 <code>basicNack</code>，但一次只能拒绝单条消息，一般不用这个</li></ol></li></ol></li><li>如果消息没有应答，消息会重新回到队列</li></ol></li></ol><p>这里主要讲一讲手动应答</p><p><font color="#92d050">1. 开启手动应答</font></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.8</span>  <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>  <br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>  <br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">listener:</span>  <br>      <span class="hljs-attr">simple:</span>  <br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span>                    <span class="hljs-comment"># 开启主动应答</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1000</span>                              <span class="hljs-comment"># 每次最多从消息队列取回 1000 条数据（预取数量）</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建消费者</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.order&quot;</span>;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;QUEUE_NAME&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(String dataString, Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 获取当前消息的 deliveryTag        </span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">deliveryTag</span> <span class="hljs-operator">=</span> message.getMessageProperties().getDeliveryTag();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 核心操作  </span><br>            System.out.println(<span class="hljs-string">&quot;消费端 消息内容: &quot;</span> + dataString);<br><br>            <span class="hljs-comment">// 核心操作成功: 返回 ACK 信息  </span><br>            channel.basicAck(deliveryTag, <span class="hljs-literal">false</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>            <span class="hljs-comment">// 判断该消息是否为重复投递。如果不是重复的，可以选择重新投递；如果是重复的，则可以考虑不再投递，避免死循环或资源浪费</span><br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">redelivered</span> <span class="hljs-operator">=</span> message.getMessageProperties().getRedelivered();<br><br>            <span class="hljs-keyword">if</span> (redelivered)&#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * ============================================</span><br><span class="hljs-comment">                 * void basicNack(long var1, boolean var3, boolean var4)</span><br><span class="hljs-comment">                 * --------------------------------------------</span><br><span class="hljs-comment">                 * 1. 访问修饰符</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * 2. 非访问修饰符</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * 3. 参数</span><br><span class="hljs-comment">                 *      1. long var1</span><br><span class="hljs-comment">                 *          1. 要处理的消息的 deliveryTag</span><br><span class="hljs-comment">                 *      2. boolean var3</span><br><span class="hljs-comment">                 *          1. 是否进行批量处理</span><br><span class="hljs-comment">                 *          2. true</span><br><span class="hljs-comment">                 *              1. 最早的消息到当前的消息都会一起处理</span><br><span class="hljs-comment">                 *          3. false</span><br><span class="hljs-comment">                 *              1. 仅处理当前消息</span><br><span class="hljs-comment">                 *      3. boolean var4</span><br><span class="hljs-comment">                 *          1. 是否将消息重新投递</span><br><span class="hljs-comment">                 *          2. true</span><br><span class="hljs-comment">                 *              1. 将消息重新放回队列，由 broker 再次投递</span><br><span class="hljs-comment">                 *          3. false</span><br><span class="hljs-comment">                 *              1. 不再投递，broker 会删除该消息</span><br><span class="hljs-comment">                 * </span><br><span class="hljs-comment">                 * 4. 返回值</span><br><span class="hljs-comment">                 *      1. void</span><br><span class="hljs-comment">                 * </span><br><span class="hljs-comment">                 * 5. 使用示例</span><br><span class="hljs-comment">                 * </span><br><span class="hljs-comment">                 * 6. 作用</span><br><span class="hljs-comment">                 * </span><br><span class="hljs-comment">                 * 7. 注意事项</span><br><span class="hljs-comment">                 * ============================================</span><br><span class="hljs-comment">                 */</span><br>                channel.basicNack(deliveryTag, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                channel.basicNack(deliveryTag,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-消息持久化"><a href="#4-4-消息持久化" class="headerlink" title="4.4. 消息持久化"></a>4.4. 消息持久化</h3><p>在 RabbitMQ 中，所有消息，无论是否持久化，都会首先存入内存。对于持久化消息，生产者发送后，RabbitMQ 会立即将消息追加到相应的存储文件，并随后向生产者确认 ACK，确保即使发生宕机也不会丢失数据。而对于非持久化消息，RabbitMQ 只有在内存压力较小的情况下才会将其写入存储文件。</p><p>虽然消息分为持久化和非持久化两类，最终所有消息都会持久化到某种存储介质中，只是持久化的时机不同。如果需要强一致性，可以选择使用持久化消息；若对一致性要求不那么严格，则可以使用非持久化消息。需要注意的是，即便消息本身是持久化的，交换机和队列也必须设置为持久化，只有这样才能确保数据不会丢失。</p><p>如果需要确保一致性，可以将数据设置为持久化，因为默认情况下，发送的消息是非持久化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/sendMessage&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate.convertAndSend(<br>        EXCHANGE_DIRECT,<br>        ROUTING_KEY,<br>        <span class="hljs-string">&quot;first sent message!&quot;</span>,<br>        message -&gt; &#123;<br>            <span class="hljs-comment">// 设置消息持久化</span><br>            message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;123456&quot;</span>)<br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-5-消息超时"><a href="#4-5-消息超时" class="headerlink" title="4.5. 消息超时"></a>4.5. 消息超时</h3><p>消息一直没被取走也不能一直留在消息队列中，我们给消息设定一个过期时间，超过这个时间没有被取走的消息就会被删除，我们可以从两个层面来给消息设定过期时间：</p><ol><li>队列层面<ol><li>在队列级别设置统一的过期时间，该队列中所有消息都会使用相同的过期时间。</li></ol></li><li>生产者层面<ol><li>生产者在发送消息时，可以为某一条消息单独指定过期时间</li></ol></li></ol><p><font color="#92d050">1. 队列层面设置</font><br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-9.png"></p><p><font color="#92d050">2. 生产者层面设置</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQProduce</span> &#123;  <br><br>    <span class="hljs-comment">// 交换机  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test.exchange&quot;</span>;  <br>    <br>    <span class="hljs-comment">// 路由键  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;  <br>  <br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;  <br>  <br>    <span class="hljs-meta">@GetMapping(&quot;/sendMessage&quot;)</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;  <br>        rabbitTemplate.convertAndSend(  <br>                EXCHANGE_DIRECT,  <br>                ROUTING_KEY,  <br>                <span class="hljs-string">&quot;first sent message!&quot;</span>,  <br>                message -&gt; &#123;  <br>                    <span class="hljs-comment">// 消息层面设置超时时间，以毫秒为单位  </span><br>                    message.getMessageProperties().setExpiration(<span class="hljs-string">&quot;7000&quot;</span>);  <br>                    message.getMessageProperties().setPriority(<span class="hljs-number">4</span>);  <br>                    message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);  <br>                    <span class="hljs-keyword">return</span> message;  <br>                &#125;,  <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;123456&quot;</span>)  <br>        );  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果两个层面都设置了过期时间，以较短的那个时间为准（而不是以生产者层面为准）</li></ol></blockquote><hr><h3 id="4-6-消峰限流"><a href="#4-6-消峰限流" class="headerlink" title="4.6. 消峰限流"></a>4.6. 消峰限流</h3><p>假设队列中有一万条数据，我们可以设置消费端每次最多从队列中取回 1000 条数据。设置起来也很简单，只需在配置中调整一个参数：<code>prefetch</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.7</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">listener:</span>  <br>      <span class="hljs-attr">simple:</span>  <br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1000</span>                   <span class="hljs-comment"># 每次最多从消息队列取回 1000 条数据</span><br></code></pre></td></tr></table></figure><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-10.png"></p><hr><h3 id="4-7-延迟队列"><a href="#4-7-延迟队列" class="headerlink" title="4.7. 延迟队列"></a>4.7. 延迟队列</h3><h4 id="延迟队列概述"><a href="#延迟队列概述" class="headerlink" title="延迟队列概述"></a>延迟队列概述</h4><p>延迟队列 是指：类似于电商网站中的提示 “订单已提交，请在 23 时 59 分 47 秒内完成支付”，我们希望在订单创建后<strong>延迟 24 小时</strong>再进行未支付订单的关闭处理。</p><hr><h4 id="延迟队列实现方式"><a href="#延迟队列实现方式" class="headerlink" title="延迟队列实现方式"></a>延迟队列实现方式</h4><h5 id="消息超时-死信队列"><a href="#消息超时-死信队列" class="headerlink" title="消息超时 + 死信队列"></a>消息超时 + 死信队列</h5><p>将消息发送到一个设置了 TTL（过期时间）的普通队列，但是不对该队列进行消费。然后当消息在队列中存满 24 小时后未被消费，它会自动过期并被转发到 死信队列（DLQ），我们只需要对死信队列进行消费即可。</p><hr><h5 id="rabbitmq-delayed-message-exchange-插件（推荐）"><a href="#rabbitmq-delayed-message-exchange-插件（推荐）" class="headerlink" title="rabbitmq_delayed_message_exchange 插件（推荐）"></a>rabbitmq_delayed_message_exchange 插件（推荐）</h5><p><font color="#92d050">1. 下载插件</font><br>访问： <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange?tab=readme-ov-file">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange?tab=readme-ov-file</a> ，下载与 RabbitMQ 版本相同的插件<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-32.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>要下载 <code>.ez</code> 文件，这是 Erlang 使用的归档文件，就像 Java 的 <code>.jar</code> 能被 RabbitMQ 直接加载</li></ol></blockquote><p><font color="#92d050">2. 插件上传到 RabbitMQ 插件目录</font><br>RabbitMQ 插件目录一般在：<code>/usr/lib/rabbitmq/lib/rabbitmq_server-x.x.x/plugins/</code></p><p><font color="#92d050">3. 启用插件</font></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 重启 RabbitMQ 服务</font><br>重启 RabbitMQ 服务，让插件生效</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">systemctl <span class="hljs-keyword">restart</span> rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建交换机、队列，将交换机和队列绑定</font></p><ol><li>交换机<ol><li>Name<ol><li>test.exchange</li></ol></li><li>Type<ol><li>x-delayed-message<ol><li>这是 rabbitmq_delayed_message_exchange 插件提供的一种 Exchange 类型</li></ol></li></ol></li><li>Arguments<ol><li>x-delayed-type &#x3D; direct<ol><li>指定 Exchange 类型</li></ol></li></ol></li></ol></li><li>队列<ol><li>Name<ol><li>test.queue</li></ol></li></ol></li><li>路由键<ol><li>test</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>该插件最多支持 48 小时</li></ol></blockquote><hr><h3 id="4-8-死信处理"><a href="#4-8-死信处理" class="headerlink" title="4.8. 死信处理"></a>4.8. 死信处理</h3><p>上文说 “我们给消息设定一个过期时间，超过这个时间没有被取走的消息就会被删除” 其实不太准确，应该是 “超过这个时间没有被取走的消息就会成为死信，默认被抛弃”</p><p>死信产生的原因通常包括：</p><ol><li>拒绝投递<ol><li>消费者显式拒绝消息（调用 <code>basicReject()</code> 或 <code>basicNack()</code>），并且设置 <code>requeue=false</code>，表示不重新投回原队列，消息因此被丢弃为死信。</li></ol></li><li>队列溢出<ol><li>队列达到最大容量限制。</li><li>例如一个队列最多只能容纳 10 条消息，当已有 10 条消息时再投递新消息，会导致最早的一条消息被挤出，成为死信（遵循先进先出原则）</li></ol></li><li>超时未消费<ol><li>消息设置了过期时间，如果在指定时间内没有被消费，就会过期，变为死信。</li></ol></li></ol><p>死信常用的处理方式包括：</p><ol><li>直接丢弃（默认）<ol><li>适用于业务上不重要的消息，无需额外处理。</li></ol></li><li>入库保存<ol><li>将死信记录入数据库，便于后续人工或定时任务处理。</li></ol></li><li>进入死信队列（推荐）<ol><li>配置死信队列（DLX）并由消费者监听，专门对死信消息进行分析和补偿处理，是较常用的做法。</li></ol></li></ol><p>这里主要讲解死信进入死信队列的步骤：</p><p><font color="#92d050">1. 创建死信交换机、死信队列，将死信交换机与死信队列绑定</font><br>死信交换机名称为：test.dlx.exchange<br>死信队列名称为：test.dlx.queue<br>路由键名称为：test</p><p><font color="#92d050">2. 创建交换机、队列，将交换机和队列绑定</font><br>交换机名称为：test.exchange<br>队列名称为：test.queue，并且需要指定一些 Arguments<br>路由键名称为：test<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-8.png"></p><blockquote><p>[!NOTE] 注意事项<br>1.这样，数据在特定条件下会进入死信队列。<br>不过，进入死信队列并不意味着就不再处理它们，因此，通常还需要编写死信队列的消费者代码，对这些消息进行进一步处理。</p></blockquote><hr><h3 id="4-9-事务消息"><a href="#4-9-事务消息" class="headerlink" title="4.9. 事务消息"></a>4.9. 事务消息</h3><p>所谓的事务消息，其实并不是多牛的分布式事务，而是 Java 自己在本地搞的小动作：先把消息留在内存里，等你整个流程都 OK 了才发出去；要是中间出事了，干脆就不发了直接回滚。</p><p>需要注意的是，哪怕发出去了，也不一定真到交换机或者队列里。所以说到底，这套事务控制是 “应用层面自娱自乐”，别指望它替你搞定消息可靠投递那一套。<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-6.png"></p><p><font color="#92d050">1. 创建 RabbitMQ 事务配置类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitTransactionConfig</span> &#123;<br><br><span class="hljs-comment">// 创建 RabbitMQ 事务管理器，使 Spring 可以通过 @Transactional 管理 RabbitMQ 的事务</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RabbitTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(CachingConnectionFactory connectionFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTransactionManager</span>(connectionFactory);<br>    &#125;<br><br><span class="hljs-comment">// 创建 RabbitTemplate，并开启事务模式</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RabbitTemplate <span class="hljs-title function_">rabbitTemplate</span><span class="hljs-params">(CachingConnectionFactory connectionFactory)</span> &#123;<br>        <span class="hljs-type">RabbitTemplate</span> <span class="hljs-variable">rabbitTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>(connectionFactory);<br>        rabbitTemplate.setChannelTransacted(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> rabbitTemplate;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 标注 @Transactional 注解</font> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">// 使用 Spring 提供的事务管理，开启事务消息（MyBatis 中涉及）  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQProduce</span> &#123;  <br><br>    <span class="hljs-comment">// 交换机  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.direct.test&quot;</span>;  <br>    <br>    <span class="hljs-comment">// 路由键  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;  <br>  <br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;  <br>  <br>    <span class="hljs-meta">@GetMapping(&quot;sendMessage&quot;)</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;  <br>        rabbitTemplate.convertAndSend(EXCHANGE_DIRECT, ROUTING_KEY, <span class="hljs-string">&quot;first sent message!&quot;</span>);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-10-优先消息"><a href="#4-10-优先消息" class="headerlink" title="4.10. 优先消息"></a>4.10. 优先消息</h3><p>默认情况下，队列遵循先进先出（FIFO）原则，先入队的消息优先被投递。但是当我们为消息设置了优先级后，优先级较高的消息将优先于低优先级消息进行投递。</p><p><font color="#92d050">1. 创建交换机</font><br>交换机名称为：test.exchange</p><p><font color="#92d050">2. 创建队列</font><br>队列名称为：test.queue，并且使用 <code>x-max-priority</code> Arguments 指定队列中消息最高的优先级<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ/%E7%AC%94%E8%AE%B0%EF%BC%9ARabbitMQ-7.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>消息优先级取值范围为：1 ~ 255</li><li>RabbitMQ 官方建议在 1 ~ 5 之间取值，因为优先级越高，占用 CPU、内存等资源越多</li></ol></blockquote><p><font color="#92d050">3. 将死信交换机与死信队列绑定</font><br>路由键名称为：test</p><p><font color="#92d050">4. 生产者处指定消息优先级</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQProduce</span> &#123;  <br><br>    <span class="hljs-comment">// 交换机  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test.exchange&quot;</span>;  <br>    <span class="hljs-comment">// 路由键  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;  <br>  <br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;  <br>  <br>    <span class="hljs-meta">@GetMapping(&quot;/sendMessage&quot;)</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;  <br>        rabbitTemplate.convertAndSend(  <br>                EXCHANGE_DIRECT,  <br>                ROUTING_KEY,  <br>                <span class="hljs-string">&quot;first sent message!&quot;</span>,  <br>                message -&gt; &#123;  <br>                    <span class="hljs-comment">// 指定消息优先级，不得超过 x-max-priority</span><br>                    message.getMessageProperties().setPriority(<span class="hljs-number">4</span>);  <br>                    message.getMessageProperties().setExpiration(<span class="hljs-string">&quot;7000&quot;</span>);  <br>                    message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);  <br>                    <span class="hljs-keyword">return</span> message;  <br>                &#125;,  <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;123456&quot;</span>)  <br>        );  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>数据管理</category>
      
      <category>消息队列</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：分布式一致性</title>
    <link href="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h2><p>分布式一致性是用来描述多个副本之间数据是否一致、何时一致，以及对用户来说是否可见一致，一致性的模型有很多：</p><ol><li>强一致性</li><li>线性一致性</li><li>顺序一致性</li><li>因果一致性</li><li>会话一致性</li><li>最终一致性</li></ol><p>但是我们仅需要将其简单地划分为两大阵营：</p><ol><li>强一致性<ol><li>任何时刻，所有客户端看到的都是相同且最新的数据</li></ol></li><li>最终一致性<ol><li>数据可能暂时不一致，但在没有新的写入操作后，所有副本最终会达到一个相同的值</li><li>最终一致性通常可以在我们人为干涉的情况下，达到一种看似强一致性的效果，这也被称为“伪强一致性”。</li></ol></li></ol><hr><h2 id="复制协议"><a href="#复制协议" class="headerlink" title="复制协议"></a>复制协议</h2><p>我们可以把<strong>一致性</strong>看作系统的目标，而<strong>复制协议</strong>则是实现这一目标的手段，不同的复制协议会直接影响系统的一致性。</p><p>需要注意的是，<strong>复制协议不仅仅是用来解决 “复制” 问题的，它既用于 “复制”，也用于 “写入”</strong>。这听起来像个悖论，但实际上，在分布式系统中，写入和复制本质上是同一操作的两个方面。因为一次成功的写入操作，其定义就是：数据在所有（或多数）副本上成功完成复制。</p><p>下面内容，是复制协议的六脉神剑：</p><ol><li>少商剑：节点的拓扑结构<ol><li>这个维度决定了数据流动的方向，也就是谁负责写入，谁负责同步</li><li>主从复制（单主复制）<ol><li>系统中只有一个主节点，具有多个从节点</li><li>客户端所有写请求都必须发到主节点，多个从节点负责同步数据</li><li>客户端所有读请求既可以发到主节点也可以发到从节点</li><li>在复杂系统中，可以对集群进行分区，使得不同分区拥有各自的主节点以及对应的从节点（例如 ES），这也被称之为分区主从</li></ol></li><li>多主复制<ol><li>在主从复制模式下，所有写入操作必须经由主库完成。一旦主库因故障或网络原因不可访问，写入就会受阻。为了解决这一瓶颈，人们提出了多主复制的方案，即允许多个主节点同时承担写入任务。</li><li>根据节点间数据 “复制模式”（维度一）的不同，多主复制又可分为异步多主和同步多主。<ol><li>异步多主<ol><li>异步多主通常应用于多个数据中心场景。每个数据中心内部依旧采用常规的主从复制，但在不同数据中心的主节点上，可以同时写入同一份数据。随后，各个数据中心之间再进行异步的数据同步</li><li>之所以称为 “异步多主”，是因为跨数据中心的数据传播大多依赖异步复制（例如 MySQL 环状复制）</li></ol></li><li>同步多主<ol><li>常用于单数据中心内的集群，每个节点彼此平等，都可以同时执行读写请求，不再需要永远固定的 “老大哥主节点”，这样能减少单点故障风险，实现较高的可用性或更严格的分布式事务</li><li>之所以称为 “同步多主”，是因为一般通过同步复制来保证节点间的数据一致性</li><li>例如 RabbitMQ 的所有节点在架构上是对等的，在元数据写入时，执行写入的那个节点会临时充当 “主节点”（事务协调者，进行事务协调），启动一个分布式事务来确保所有节点一致。因此，RabbitMQ 在元数据写入方面，实际上符合同步多主的模式</li><li>之所以不将这种方式归类为主从复制，是因为：<ol><li>它不符合典型的 “主—从” 角色划分，不存在一个始终固定的主节点</li><li>它不依赖单一主节点作为统一访问入口，而是允许任何节点在需要时接收请求</li><li>每个节点都有可能在特定时刻临时充当主节点，本质上更接近“多个主节点”的模式</li></ol></li><li>之所以不讲这种方式归类未无主复制，是因为：<ol><li>无主复制的核心是 Quorum NWR 模型</li></ol></li></ol></li></ol></li><li>多主复制面临的核心挑战在于写入冲突<ol><li>由于系统中存在多个写入入口，就可能同时产生彼此矛盾的更新。</li><li>例如，你在在线文档中输入 “项目将在本周五发布”，而同事几乎同时写下 “项目将在下周一发布”。</li><li>这类冲突必须通过机制来检测、处理或避免，才能保证数据一致性。</li></ol></li></ol></li><li>无主复制<ol><li>集群中不存在 “主从” 之分，所有节点地位对等、功能相同，每个节点都可直接执行写入操作，其他节点负责同步数据</li><li>无主复制本质上不强制依赖 Quorum NWR 模型，但在工程实践中，为了保证读写结果的正确性和可预期性，几乎都会配合 Quorum NWR 来控制一致性<ol><li>若满足 <code>R + W &gt; N</code>，则读操作必然会命中至少一个包含最新写入的副本</li><li>N &#x3D; 副本总数</li><li>W &#x3D; 写请求需要确认的副本数</li><li>R &#x3D; 读请求需要确认的副本数</li></ol></li><li>无主复制面临的核心挑战同样在于写入冲突</li></ol></li></ol></li><li>商阳剑：数据的分布策略<ol><li>这个维度决定了数据是作为整体存放在某一位置内，还是被拆分后分布在多个位置</li><li>整体存储<ol><li>数据完整地存储在某一位置</li></ol></li><li>数据拆分<ol><li>分库</li><li>分表</li><li>分片<ol><li>例如 Minio 在存储对象时，会将其切割成若干块，并在多个驱动上进行分布</li></ol></li></ol></li></ol></li><li>中冲剑：数据的同步时机<ol><li>这个维度直接决定了我们的分布式系统提供强一致性还是最终一致性</li><li>同步复制：提供强一致性<ol><li>当主节点收到一个写入请求后，它必须等待<strong>所有&#x2F;大多数</strong>从节点都成功复制了数据，才能向客户端返回成功响应</li></ol></li><li>异步复制：提供最终一致性<ol><li>当主节点收到一个写入请求后，它立即向客户端返回成功响应，然后在后台异步地将数据同步给从节点</li></ol></li><li>半同步复制：折中方案<ol><li>强一致性和最终一致性的折中方案，主节点在提交事务后，只等待<strong>至少一个从节点</strong>确认收到数据，就向客户端返回成功</li></ol></li></ol></li><li>关冲剑：同步的传输内容<ol><li>日志拉取<ol><li>不直接同步数据本身，而是同步引起数据变化的、确定性的<strong>操作指令 (Command&#x2F;Operation)</strong></li><li>所有副本都以完全相同的顺序执行这些指令，从而达到一致的状态。基于日志是状态机复制理论的直接体现</li><li>主节点在执行写入操作时，会将变更顺序地记录到日志中</li><li>从节点通过拉取这些日志条目并按顺序回放，来重建数据状态（从哪里开始缺失就从哪里开始拉取）</li></ol></li><li>状态同步<ol><li>状态转移<ol><li>主节点直接把 “最终状态” 发送给从节点，用新的状态整体覆盖旧内容（可能是全部状态，也可能仅是需要被覆盖的部分状态）</li><li>例如字符串从 Hello ➔ Hello World，主节点不会发 “请追加 World”，而是直接把完整的 Hello World 状态传输过去。</li><li>再例如 MySQL 中，修改后的数据页会替换掉硬盘上的旧数据页，这就是最纯粹的状态转移。</li><li>与快照不同的是，状态转移是每一轮同步的基本方式，而快照更像是一种辅助优化（例如每隔 5 秒才做一次），并非每次都用。</li></ol></li><li>状态合并<ol><li>例如在 A 节点上点了 5 次赞（结果 105），在 B 节点上又点了 8 次赞（结果 108）。</li><li>如果用状态转移方式，A 把 105 发给 B，B 把 108 发给 A，会造成冲突，导致增量信息丢失</li><li>改为传递 “状态合并”，即 A 记录并发送“我增加了 5 个赞”，B 记录并发送“我增加了 8 个赞”。这样合并后，大家都得到正确的 113</li><li>状态合并的优势在于与同步顺序无关，只要变更被正确传播，最终状态就是一致的</li></ol></li></ol></li><li>请求转发<ol><li>这是最简单也最危险的方式，直接将客户端发来的**原始请求 (Raw Request)**，原封不动地转发给所有副本，期望大家独立执行后能得到相同的结果</li><li>然而，如果请求中包含诸如 <code>timestamp()</code> 或 <code>random()</code> 这样的非确定性操作，各节点独立执行时就可能得到不同结果，从而产生状态分歧，直接破坏强一致性。</li><li>此外，如果请求的执行逻辑依赖于节点当前已有的状态，而这些状态在不同节点上并不完全相同，那么即使是同一个请求，也可能得出不同结果，依旧存在一致性风险</li></ol></li><li>快照 + 增量<ol><li>快照，简单来说，就是把某个时间点之前<strong>所有历史操作执行后的最终状态</strong>记录下来</li><li>增量同步则相对简单，可以基于前面提到的日志复制、状态同步、请求转发等方式来实现</li><li>因此，“快照 + 增量同步” 可以看作其他方式的<strong>增强机制</strong>：快照负责 “快速赶上旧账”，增量负责 “实时保持跟进”，两者结合既提高了效率，又兼顾了可靠性</li><li>使用快照的典型场景：<ol><li>新节点首次加入时，直接加载快照，再拉取最新增量；</li><li>节点宕机过久，错过了太多日志，且这些日志已被清理，只能重新加载快照恢复</li></ol></li></ol></li></ol></li><li>少泽剑：状态的协调机制<ol><li>CRDT</li><li>共识协议</li><li>分布式事务</li><li>Quorum NWR 模型</li></ol></li><li>少冲剑：数据的持久化保障<ol><li>持久化逻辑<ol><li>状态持久化（基于快照的持久化）<ol><li>在某个特定时间点，将完整数据状态一次性地写入磁盘</li></ol></li><li>操作持久化（基于日志的持久化）<ol><li>不直接记录数据本身，而是将所有导致数据变化的写操作指令按照顺序追加到日志文件中</li><li>恢复时，可以通过重放所有操作来重建最终的数据状态</li></ol></li><li>混合持久化（基于 快照 + 日志 的持久化）<ol><li>结合快照和日志的优点，取长补短，系统定期生成快照，并在两次快照之间，以日志形式记录增量操作</li></ol></li></ol></li><li>存储引擎实现<ol><li>原地更新模型<ol><li>数据以高度结构化的形式（如 B+ 树）存储在磁盘页（Page）中</li><li>当数据更新时，系统直接定位到磁盘对应页，将其读入内存修改，再写回原来的位置</li><li>这种模型高度依赖 预写日志（WAL，Write-Ahead Log），任何磁盘页的修改必须先记录到 WAL 并持久化，以保证崩溃恢复</li><li>如果系统发生故障，可以通过重放 WAL 来恢复未完成的操作</li></ol></li><li>写时复制模型<ol><li>不直接修改已写入的数据，而是将修改写入 新的数据块或新文件</li><li>在写入新数据时，同时记录 WAL（操作日志），保证崩溃恢复的完整性</li><li>数据写入完成后，再通过 替换&#x2F;合并 的方式更新原来的文件或数据结构</li></ol></li><li>需要注意的是，并非所有系统都必须使用 WAL，例如 <strong>Redis</strong>，其 RDB 快照机制允许在快照间隔内丢失部分数据，因此在写入快照时 不依赖 WAL。</li></ol></li><li>操作系统交互<ol><li>无论采用哪种持久化逻辑思想和存储引擎层模型，最终都必须通过操作系统将数据写入物理磁盘。</li><li>然而为了提高性能，操作系统引入了页缓存（Page Cache），这意味着应用程序的 <code>write</code> 调用默认并不保证数据立即落盘。</li><li>因此，必须采用特定机制来确保数据真正写入磁盘，从而保证持久化的可靠性。<ol><li>强制刷盘（fsync 系统调用）<ol><li>当需要确保关键数据绝对可靠时（例如 WAL），就要在 <code>write</code> 之后调用 <code>fsync</code>，将内存中的数据强制写入磁盘。</li><li>根据调用 <code>fsync</code> 的时机，强制刷盘可分为三类：<ol><li>同步刷盘<ol><li>每次写入操作完成后立即调用 <code>fsync</code>，确保数据即时落盘</li></ol></li><li>间隔刷盘<ol><li>定期调用 <code>fsync</code>，在一定时间间隔内批量刷盘，以兼顾性能和可靠性</li></ol></li><li>操作系统自由安排<ol><li>完全依赖操作系统决定何时刷盘，应用程序不显式调用 <code>fsync</code></li></ol></li></ol></li></ol></li><li>绕过缓存（直接 IO）<ol><li>这是一种更底层的优化手段，允许应用程序绕过操作系统的页缓存，直接在自身的内存缓冲区和磁盘之间传输数据</li></ol></li></ol></li></ol></li></ol></li></ol><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-12.png"></p><hr><h2 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h2><h3 id="Paxos-协议"><a href="#Paxos-协议" class="headerlink" title="Paxos 协议"></a>Paxos 协议</h3><hr><h3 id="Raft-协议"><a href="#Raft-协议" class="headerlink" title="Raft 协议"></a>Raft 协议</h3><h4 id="Raft-协议概述"><a href="#Raft-协议概述" class="headerlink" title="Raft 协议概述"></a>Raft 协议概述</h4><p>Raft 协议是一个强一致性协议，在三个维度上的选择如下：</p><ol><li>维度一：同步复制</li><li>维度二：主从复制</li><li>维度三：基于日志的复制<ol><li>从 Raft 协议的设计来看，本质是基于日志的复制。只要日志可以无限增长，并且新加入的节点能够完整同步所有历史日志，Raft 就能正常工作。</li><li>但在真实实现中，几乎不会只依赖日志复制，而是采用 <strong>快照 + 增量同步</strong> 的方式。这么做是因为：<ol><li>存储空间有限：<ol><li>志会随着集群的持续运行不断追加，如果不做处理，最终会耗尽存储</li></ol></li><li>同步耗时过长：<ol><li>新加入的节点，如果从零开始，需要从第一个日志条目起依次同步。</li><li>长时间宕机的节点，也必须从其停机点之后的日志开始追赶。</li><li>你想一想，如果系统写入量很大，比如数据库每秒产生 1,000 条写入，每条日志 1KB，那么每秒就是 1MB，一天就是 <strong>86.4GB</strong>，仅仅传输日志就会成为严重瓶颈。</li></ol></li></ol></li></ol></li></ol><hr><h4 id="Raft-协议核心角色"><a href="#Raft-协议核心角色" class="headerlink" title="Raft 协议核心角色"></a>Raft 协议核心角色</h4><p><font color="#92d050">1. Follower（跟随者，默认）</font><br>Follower 是集群中的默认角色，主要职责包括：</p><ol><li>不直接处理客户端的写请求</li><li>等待并执行 Leader 的指令</li><li>接收并持久化 Leader 的日志复制</li><li>响应 Leader 的心跳，如在超时未收到心跳，则转换为 Candidate 发起选举</li></ol><p><font color="#92d050">2. Candidate（候选者）</font><br>Candidate 是竞选 Leader 的临时角色，主要职责包括：</p><ol><li>当 Follower 长时间未收到 Leader 心跳时，会转为 Candidate，并向其他节点发起 <code>RequestVote</code> 请求以争取选票<ol><li>若赢得多数选票，则晋升为 Leader</li><li>若选举失败，则可能再次进入 Candidate 状态，或回退为 Follower</li></ol></li></ol><p><font color="#92d050">3. Leader（领导者）</font><br>Leader 是集群中<strong>唯一负责处理写请求</strong>并向 Follower 复制日志的角色，整个集群在任意时刻最多只有一个 Leader。主要职责包括：</p><ol><li>接收并处理客户端的写入请求</li><li>定期向 Follower 发送心跳以维持领导地位</li><li>将日志复制到各 Follower 节点并确保数据一致性</li></ol><hr><h4 id="Raft-协议核心流程"><a href="#Raft-协议核心流程" class="headerlink" title="Raft 协议核心流程"></a>Raft 协议核心流程</h4><p><font color="#92d050">1. Raft 启动与第一次选举 Leader</font><br>启动时，所有节点默认处于 Follower 状态，term 初始为 0，并各自设置一个 150–300ms 之间的随机选举超时时间。如果在超时时间内未收到来自 Leader 的心跳信号，该节点将从 Follower 状态切换为 Candidate，将 term 加 1，发起第一轮选举</p><p>一旦某个 Candidate 获得的票数超过半数（即 &gt; N&#x2F;2，这里的 N 指的是集群中的所有节点数，而非存活节点数，因此无需担心宕机会影响选票），就会当选为 Leader。这里有两个关键点需要注意：</p><ol><li>选举必须赢得多数票<ol><li>这一机制有效防止了脑裂问题，因为在网络分区时，只有一方能获得多数，从而成为唯一的 Leader</li></ol></li><li>建议集群节点数为奇数<ol><li>这样可以避免选举时多个 Follower 平票的情况，提高选举成功率</li><li>若没有任何一个 Candidate 获得多数票，则本轮选举失败。各节点会等待各自的选举超时器再次超时，随后将 term 再增加 1，并发起新一轮选举</li></ol></li></ol><p>若某个 Candidate 当选为 Leader，会立即向其他节点发送心跳信号。其他节点一旦收到来自新 Leader 的心跳，便会自动 “认输”，切换回 Follower 状态</p><p>这个全局递增的 <code>term</code>，可以理解为 “当前是第几届村长执政”。每个节点都会保存一个本地的 <code>term</code>，谁的 <code>term</code> 高，谁就拥有更高的优先级，从而避免 “过时的村长” 重新掌权</p><p><font color="#92d050">2. 数据写入与复制</font><br>Leader 负责整个系统的读写操作（由 Leader 负责读取，是为了避免脏读），这种设计虽然保证了强一致性，但也将压力集中在了 Leader 节点。</p><p>当 Leader 接受到一个写入请求后，会创建一个新的日志条目，Raft 要求包含当前的日志条目的索引号、当前任期号、客户端具体操作命令，例如：</p><table><thead><tr><th>索引 (Index)</th><th>任期 (Term)</th><th>命令 (Command)</th></tr></thead><tbody><tr><td>1</td><td>1</td><td><code>set(&quot;name&quot;, &quot;Alice&quot;)</code></td></tr><tr><td>2</td><td>1</td><td><code>set(&quot;age&quot;, &quot;30&quot;)</code></td></tr><tr><td>3</td><td>2</td><td><code>increment(&quot;counter&quot;)</code></td></tr><tr><td>4</td><td>2</td><td><code>set(&quot;city&quot;, &quot;New York&quot;)</code></td></tr></tbody></table><p>Leader 首先会将该日志条目追加到本地日志中，常见的实现方式包括：</p><ol><li>文件追加模式<ol><li>这是最常见、最直观的方式，每个节点维护一个专用日志文件，新生成的日志条目会简单地追加到文件末尾</li><li>通常采用分段存储，当日志文件过大时，会开启新的文件，有助于后续的日志压缩与清理</li><li>多数实现会使用 WAL（Write-Ahead Log）机制，先将日志写入磁盘，再应用到内存中的状态机，以确保系统崩溃后日志仍然可恢复</li></ol></li><li>基于键值对存储<ol><li>某些实现会选择使用键值存储保存日志条目，其中索引号作为键，日志内容作为值</li><li>这种方式支持快速随机访问，且管理相对灵活</li></ol></li></ol><p>然后，Leader 并行地向所有 Follower 发送 <code>AppendEntries</code> RPC，请求它们复制这个新的日志条目，然后我们就进入 Raft 设计最精妙的地方：一致性检查：</p><ol><li>在 <code>AppendEntries</code> RPC 中，Leader 不仅会带上新的日志条目，还会附带新日志条目前一个日志的索引 (prevLogIndex) 和任期 (prevLogTerm)</li><li>Follower 收到请求后，会检查自己本地日志在 <code>prevLogIndex</code> 位置的条目，看其任期是否与 <code>prevLogTerm</code> 匹配<ol><li>如果匹配<ol><li>说明日志到此为止都是一致的，Follower 会安全地将新的日志条目追加到自己的日志中，并向 Leader 回复成功</li></ol></li><li>如果不匹配<ol><li>说明 Follower 的日志在此处与 Leader 有分歧，Follower 会拒绝该请求</li><li>当 Leader 收到 Follower 拒绝的响应后，它会向前回溯，找到与该 Follower 的日志共同的、一致的那个点，然后从该点开始，将后续的所有日志条目重新发送给 Follower，强制覆盖掉不一致的部分。</li><li>Raft 协议是让我们使用日志进行记录，即便是刚上任的 Leader，也能够向前回溯，因为在投票前，节点会先检查候选人的日志是否至少和自己一样新，才会投票</li><li>但是在大多数情况下，我们其实还是会使用快照，如果我们使用了快照，我们最多也只能回溯到快照处，如果发现需要回溯到比这个快照更造，那就会判断 Follower 的日志是严重落后（Follower 长期下线、新节点加入）</li><li>在这种情况下，Leader 不会再尝试逐条回溯并同步日志，而是直接向这个 Follower 发送一个快照（这比回溯和同步大量的旧日志要高效得多）</li></ol></li></ol></li><li>所以一个典型的 <code>AppendEntries</code> RPC 包含以下关键字段：<ol><li>leaderId<ol><li>Leader 的节点 ID</li><li>用于 Follower 响应客户端请求时的重定向，它可以告诉客户端 “去找这个 Leader”</li></ol></li><li>term<ol><li>Leader 的当前任期号</li><li>Follower 收到 <code>AppendEntries</code> RPC 后，会首先检查这个 <code>term</code><ol><li>如果 <code>term</code> 小于自己的任期号，说明这个 Leader 是一个 “过时” 的 Leader，Follower 会拒绝这个 RPC，并告知它当前的正确任期，促使它下台</li><li>如果 <code>term</code> 大于或等于自己的任期号，Follower 会接受这个 RPC，并更新自己的任期号。这是 Raft 确保集群中所有节点都在同一个 “时代” 工作的基本机制</li></ol></li></ol></li><li>prevLogIndex<ol><li>新日志条目前一个条目的索引号</li><li>Follower 收到后，会检查自己的日志中是否存在索引号为 <code>prevLogIndex</code> 的日志条目</li></ol></li><li>prevLogTerm<ol><li>新日志条目前一个条目的任期号</li><li>与 <code>prevLogIndex</code> 配合使用，提供一个双重校验，Follower 不仅要检查自己的日志中是否存在 <code>prevLogIndex</code> 处的条目，还要确保这个条目的任期号与 <code>prevLogTerm</code> 完全一致</li><li>如果两者都匹配，那么 Leader 和 Follower 的日志在这一点上就是一致的，可以安全地进行追加。如果不匹配，则说明日志存在分歧，需要进行修复。</li></ol></li><li>entries<code>[]</code><ol><li>要复制的日志条目数组</li><li>Leader 要同步给 Follower 的新日志条目，通常只包含一个新条目，但在日志修复或优化时，也可能包含多个</li></ol></li><li>leaderCommit<ol><li>Leader 节点已提交的最高日志条目的索引号</li><li>当 Leader 收到大多数 Follower 对某个日志条目（比如索引号为 10）的成功复制响应时，它会立即更新自己的 <code>commitIndex</code> 为 10，并将该条目应用到自己的状态机中。</li><li>Leader 会在下一次发送的 <code>AppendEntries</code> RPC（无论是新的日志条目还是心跳）中，携带这个更新后的 <code>leaderCommit = 10</code>。</li><li>Follower 收到这个 RPC 后，才会将自己的 <code>commitIndex</code> 更新为 10，并且如果发现自己的日志中，索引小于或等于 <code>leaderCommit</code> 的条目还没被提交，它就会将这些条目标记为已提交</li><li>一旦日志条目被标记为已提交，Follower 就可以将其安全地应用到自己的状态机（state machine）中，从而更新自己的状态</li><li>所以我们知道了，Follower 收到日志后，只是将其<strong>持久化</strong>到本地，但不会立即执行，而是等 Leader 的下一次指令，这是为什么呢？这是因为只有 Leader 才有权决定一个日志条目是否已提交，Follower 必须被动地等待 Leader 的提交指令。</li></ol></li></ol></li></ol><p>当 Leader 发现<strong>超过半数</strong>的 Follower 都已成功复制了某条日志后，该日志条目就被认为是 “已提交” (Committed) 的，它会立即更新自己的 <code>commitIndex</code> ，然后将该日志中的命令应用到自己的状态机，并向客户端返回成功</p><p>Leader 在后续的心跳中会通知所有 Follower 哪些日志已经被提交（心跳会发送不包含任何日志条目的 <code>AppendEntries</code> RPC），Follower 收到通知后也将相应的命令应用到自己的状态机</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>你可能会疑惑，当 Leader 发现 <strong>超过半数</strong> 的 Follower 已成功复制某条日志时，该日志就被视为 <strong>已提交（Committed）</strong>。此时，Leader 会立即更新自己的 <code>commitIndex</code>，并将该日志中的命令应用到状态机。但是在极端情况下，若 Leader 尚未来得及发送下一次心跳，Follower 还未更新自己的 <code>commitIndex</code>、也未执行该日志时，Leader 突然宕机。此时会触发新一轮选举，新的 Leader 当选后，会不会因为部分 Follower 尚未执行这条日志而产生影响呢？</li><li>新 Leader 上任后，其 <code>commitIndex</code> 可能暂时停留在日志条目 A 之前的某个索引，此时它不会立即将日志条目 A 标记为已提交。</li><li>因为根据 Raft 的提交规则：<ol><li>本任期的日志<ol><li>Leader 必须将日志复制到多数节点后才能提交</li></ol></li><li>前任期的日志<ol><li>Leader 需要先在本任期提交一个后续日志条目，才能一次性将之前的日志条目标记为已提交</li></ol></li></ol></li><li>如果系统在此时没有新的写操作，那么自然不会产生新的日志条目。为了解决这个问题，Raft 规定：新 Leader 选举成功后，会立即在自己的日志中追加一个 no-op 日志条目，这个条目是本任期的第一个操作。</li><li>在提交这个 no-op 条目之前，Leader 会先执行该条目之前未提交的所有日志，确保它们被正确应用；然后再提交并执行这个 no-op 条目，从而完成本任期的初始化。</li></ol></blockquote><p><font color="#92d050">3. Leader A 宕机</font><br>假设集群中已经经过几次选举了，此时 A 是当前的 Leader（term&#x3D;10），定期向 B、C、D、E 发送心跳信号。而如果 A 宕机后，B、C、D、E 都不再收到心跳信号，触发各自的选举超时定时器（150–300 ms 随机）</p><ol><li>假如 B 最先超时未收到心跳<ol><li>B 超时在先（如 180 ms），检测到未收到心跳，便将 <code>term</code> 从 10 增加到 11，变为 Candidate。B 立即给自己投票（票数&#x3D;1），并向 C、D、E 以及已掉线的 A 广播 <code>RequestVote(term=11, candidateId=B, lastLog…)</code>。</li><li>C、D、E 收到 B 的请求后，发现请求中的 term&#x3D;11 比自己当前的 term&#x3D;10 更新，便更新 term → 11，切回 Follower 身份，<strong>检查 B 的日志无落后后</strong>，投票给 B。</li><li>B 收到来自 C 和 D 的投票（B 自己 + C + D &#x3D; 3 票），满足多数要求，成功当选为新 Leader（term&#x3D;11）。</li><li>B 立即向其他活跃节点（C、D、E）以及离线的 A 发送心跳 <code>AppendEntries(term=11)</code>。C、D、E 收到后重置选举定时器，保持 Follower 状态；</li><li>如果 A 之后恢复上线，它将收到 B 的心跳 RPC，并发现 term&#x3D;11 比自己的 term&#x3D;10 更新，于是更新自己的 term → 11，退回 Follower 状态，放弃原先的 Leader 身份。这样保证：一个处于旧 term 的节点无法参与当前任期的投票或发起选举，只有“意识到要进入新一届”的节点才能重新参选。</li></ol></li><li>假如 B、C 几乎同时超时未收到心跳<ol><li>若 B 和 C 的选举超时非常接近（如均为 180 ms 左右），两者几乎同时将 term 从 10 升为 11，变为 Candidate，并向其余节点广播 <code>RequestVote(term=11)</code>（B 向 A、C、D、E 发，C 向 A、B、D、E 发）。</li><li>假设 D 先收到 B 的请求，检查通过后将票投给 B，并更新 term → 11。</li><li>同时，E 先收到 C 的请求，也检查通过并投票给 C，更新 term → 11。</li><li>当 B 收到来自 C 的 <code>RequestVote(term=11)</code> 请求时，B 发现自己在当前 term（11）中已将票投给自己，因此拒绝给 C 投票。C 也是同理（只能投一次，投给自己就没办法投给别人了）</li><li>B 最终得票为自己 + D &#x3D; 2，C 得票为自己 + E &#x3D; 2，均未获得多数 → <strong>选票分裂（split vote）</strong>，本轮选举失败。</li><li>B、C、D、E 的选举超时器重新启动，等待下一轮触发。再次进入超时的节点将把 term 增加到 12 并发起新一轮选举，如此循环，直到有人获得多数票成功当选。term 会随着失败轮次不断累加。</li></ol></li></ol><p>由于会检查日志是否落后之后再去投票，而且 Raft 协议还是多数成功，就直接杜绝了日志落后的节点“混进多数”并被选为 Leader 的可能性。</p><p><font color="#92d050">4. A 节点恢复</font><br>A 节点重启后，term 仍是 10。当它收到新 Leader（如 D）发来的心跳 <code>AppendEntries</code> RPC 中 term&#x3D;11 后，立刻发现对方的 term 更新，于是更新自己的 term → 11，退回 Follower 身份，并且进行日志同步，重新与集群保持一致。<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-1.png"></p><hr><h3 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h3><hr><h3 id="Multi-Paxos-协议"><a href="#Multi-Paxos-协议" class="headerlink" title="Multi-Paxos 协议"></a>Multi-Paxos 协议</h3><hr><h3 id="EPaxos-协议"><a href="#EPaxos-协议" class="headerlink" title="EPaxos 协议"></a>EPaxos 协议</h3><hr><h3 id="Atlas-协议"><a href="#Atlas-协议" class="headerlink" title="Atlas 协议"></a>Atlas 协议</h3><hr><h3 id="RIFL-协议"><a href="#RIFL-协议" class="headerlink" title="RIFL 协议"></a>RIFL 协议</h3><hr><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h3><p>在数据库里，事务具有四个关键特性（ACID）</p><ol><li>原子性（A）<ol><li>事务中的所有操作要么全部执行成功，要么全部执行失败回滚。</li><li>对于数据库来说，事务是一个不可分割的最小操作单元。</li></ol></li><li>一致性（C）<ol><li>事务执行前后，数据库都处于一致的状态。</li><li>也就是说，事务执行前后，数据库的状态应该满足所有的定义约束、触发器、级联操作等。</li></ol></li><li>隔离性（I）<ol><li>事务的执行不会受到其他事务的干扰。</li><li>多个事务并发执行时，一个事务的中间状态对其他事务是不可见的。</li></ol></li><li>持久性（D）<ol><li>事务一旦提交，其结果就永久保存到数据库中。</li><li>即使系统发生故障，事务的结果也不会丢失。</li></ol></li></ol><hr><h3 id="分布式事务概述"><a href="#分布式事务概述" class="headerlink" title="分布式事务概述"></a>分布式事务概述</h3><p>分布式事务是指：把事务的概念，从单机数据库扩展到了<strong>跨多个微服务、多个数据库</strong>的场景。</p><p>过去，在单体应用的电商系统里，订单、支付、库存都塞在一个大项目，数据也都放在同一个数据库里。这样一来，所有操作都在单机环境的同一个数据库里完成，事务自然很简单。例如在 MySQL 里只要 <code>BEGIN … COMMIT</code>，数据库就能帮你搞定一致性。</p><p>后来大家觉得“大一统”的架构太笨重，就拆成了微服务：有 订单服务、库存服务、支付服务。每个服务不仅代码独立，还各自拿着自己的数据库，技术选型五花八门（这边用 MySQL，那边用 MongoDB，甚至还有 Redis 出来凑热闹）</p><p>可是问题也随之出现，在电商下单场景里：</p><ol><li>订单服务要插入一条订单记录（向数据库 A）</li><li>库存服务要扣减一条库存（向数据库 B）</li><li>付服务要完成扣款（向数据库 C）</li></ol><p>这三件事必须保证 要么全部成功，要么全部失败，否则就会出现 “订单生成了但没扣钱”、“扣了钱却没库存” 的大灾难。</p><p>但是数据库 A 有自己的本地事务，数据库 B 有自己的本地事务，数据库 C 也有自己的本地事务，他们各自为政，互不干涉，却没有一个 “老大哥” 能帮你全局管控。</p><p>于是，这正是 分布式事务 要解决的问题：在分布式场景下，每个服务都能开启自己的 本地事务，只保证自己的一亩三分地。而分布式事务的任务，就是把这些零散的本地事务“绑在一起”，形成一个 逻辑上的整体事务，让它们的命运合二为一。</p><hr><h3 id="强一致性分布式事务"><a href="#强一致性分布式事务" class="headerlink" title="强一致性分布式事务"></a>强一致性分布式事务</h3><h4 id="2PC-提交协议"><a href="#2PC-提交协议" class="headerlink" title="2PC 提交协议"></a>2PC 提交协议</h4><h5 id="2PC-核心角色"><a href="#2PC-核心角色" class="headerlink" title="2PC 核心角色"></a>2PC 核心角色</h5><p><font color="#92d050">1. 协调者（Coordinator）</font><br>负责事务的发起、管理和最终决定（提交 &#x2F; 回滚）。</p><p><font color="#92d050">2. 参与者（Participant）</font><br>一般是数据库、消息队列节点，实际执行事务操作。</p><hr><h5 id="2PC-核心流程"><a href="#2PC-核心流程" class="headerlink" title="2PC 核心流程"></a>2PC 核心流程</h5><h6 id="阶段一：准备阶段"><a href="#阶段一：准备阶段" class="headerlink" title="阶段一：准备阶段"></a>阶段一：准备阶段</h6><p>在这个阶段，协调者需要确认所有参与者都 “有能力” 提交事务。于是，它会向所有参与者发送 Prepare 请求，就好比在问：“你们是否能提交事务？”</p><p>参与者收到 <code>Prepare</code> 请求后，开始执行事务操作并锁定相关资源，但不会提交事务：</p><ol><li>执行事务操作，在这个过程要将相关资源加锁（行锁、表锁），确保这批数据在最终提交前不会被其他事务破坏</li><li>并且将事务的 Redo Log 和 Undo Log 写入本地的持久化日志文件</li></ol><p>如果一切顺利，参与者就向协调者返回 YES，表示自己已经做好提交的准备。若中途遇到异常（如约束条件失败、磁盘空间不足等），则返回 NO。</p><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在这里，Prepare 阶段通常依赖我们 “四维度理论” 所强调的底层技术来实现</li><li>其他地方中的多次 “交互” 本质上只是一条网络信号的传递</li></ol></blockquote><hr><h6 id="阶段二：提交阶段"><a href="#阶段二：提交阶段" class="headerlink" title="阶段二：提交阶段"></a>阶段二：提交阶段</h6><p>协调者在收到所有参与者的响应消息后，会根据反馈结果通知各参与者：执行 commit 提交 或 rollback 回滚 操作。</p><p><font color="#92d050">1. 事务提交</font><br>当所有参与者均返回 <strong>YES</strong> 时，协调者发起正式的提交流程：</p><ol><li>协调者向所有参与者发送 <code>commit</code> 请求。<ol><li>参与者接到请求后，正式提交事务，并释放事务执行期间锁定的资源（行锁、表锁）和占用的数据库连接</li></ol></li><li>提交完成后，参与者向协调者返回 <code>ACK</code></li><li>协调者收到所有参与者的 <code>ACK</code> 后，确认整个事务提交完成<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-2.png"></li></ol><p><font color="#92d050">2. 事务回滚</font><br>若任意一个参与者返回 <strong>NO</strong>，或在超时时间内未返回响应，则协调者触发回滚流程：</p><ol><li>协调者向所有参与者发送 <code>rollback</code> 请求</li><li>参与者根据第一阶段保存的 <strong>undo 信息</strong> 执行回滚，并释放事务执行期间锁定的资源（行锁、表锁）和占用的数据库连接</li><li>回滚完成后，参与者向协调者发送 <code>ACK</code> 确认消息</li><li>协调者收到所有参与者的 <code>ACK</code> 后，确认事务已取消<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-3.png"></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 阶段二 中，如果协调者迟迟没有收到某个参与者返回的 <code>ACK</code>，根据严格的 2PC 协议规范，协调者会进入阻塞等待状态，等待该参与者恢复正常，或由管理员人工干预</li><li>在工程实践中，很多实现会加入重试机制，但依旧无法改变阻塞的事实</li></ol></blockquote><hr><h6 id="2PC-优缺点"><a href="#2PC-优缺点" class="headerlink" title="2PC 优缺点"></a>2PC 优缺点</h6><p>协调着也有可能卡死，参与者也有可能卡死</p><ol><li>缺点<ol><li>性能问题<ol><li>在分布式场景下，2PC 严重依赖多次网络通信</li><li>而且在第二阶段，资源会被锁定，其他节点想要访问这部分资源，只能阻塞等待<ol><li>这也是 2PC 不适合长事务的原因：事务持续越久，锁定的资源越多，等待的请求越多，系统吞吐量就会迅速下降</li></ol></li><li>此外还会长期占用数据库连接</li><li>在高并发场景（成千上万事务同时执行）下，使用 2PC 很容易导致系统 “卡爆”</li><li>因此，在对响应速度要求极高的场景（如电商秒杀、社交消息流），几乎不会采用 2PC</li></ol></li><li>可靠性问题<ol><li>协调者（TM）是整个流程的核心，存在单点故障问题</li><li>尤其是在提交阶段，一旦 TM 宕机，资源会被一直锁定，数据库连接也会被持续占用</li><li>尽管可以通过重新选举产生一个新的协调者，但这并不能解除因原协调者宕机而导致的参与者长期处于阻塞状态的问题</li></ol></li><li>数据一致性问题<ol><li>在提交阶段中，如果协调者已经向部分参与者下发了 <code>commit</code>，但由于网络中断，另外一些参与者没有收到指令，就会导致一部分节点提交成功、另一部分节点停留在未提交状态，最终造成数据不一致。</li><li>2PC和3PC都无法保证数据绝对的一致性，一般为了预防这种问题，可以添加一个报警，比如监控到事务异常的时候，通过脚本自动补偿差异的信息。</li></ol></li></ol></li></ol><hr><h4 id="3PC-提交协议"><a href="#3PC-提交协议" class="headerlink" title="3PC 提交协议"></a>3PC 提交协议</h4><blockquote><p>[!NOTE] 注意事项</p><ol><li>YES&#x2F;NO 与 ACK 的区别<ol><li>YES&#x2F;NO<ol><li>用于协调者的询问阶段，仅表示参与者的意向或能力，不会实际修改资源</li></ol></li><li>ACK<ol><li>用于指令执行阶段，当协调者下达操作命令后，参与者完成执行并以 <code>ACK</code> 确认结果。</li></ol></li><li>nack</li><li>error</li></ol></li></ol></blockquote><h5 id="3PC-概述"><a href="#3PC-概述" class="headerlink" title="3PC 概述"></a>3PC 概述</h5><p>三阶段提交（3PC）被设计出来的唯一目的，就是为了解决两阶段提交（2PC）的一个致命缺陷：<strong>协调者单点故障导致的参与者永久阻塞问题</strong>。</p><p>3PC 的出现主要是为了解决以下问题：</p><ol><li>2PC 阻塞问题<ol><li>在 2PC 中，一旦参与者在准备阶段返回了 <code>YES</code>，它就不得不锁定公共资源并占用数据库连接，直到协调者发来最终指令。</li><li>如果此时协调者宕机，参与者将一直无法释放资源，陷入阻塞状态。</li></ol></li><li>2PC 数据不一致问题<ol><li>在提交阶段中，如果协调者已经向部分参与者下发了 <code>commit</code>，但由于网络中断，另外一些参与者没有收到指令，就会导致一部分节点提交成功、另一部分节点停留在未提交状态，最终造成数据不一致。</li></ol></li></ol><p>而 3PC 通过引入一个额外的 <strong><code>PreCommit</code>（预提交）</strong> 阶段，并加入 <strong>超时机制</strong>，来<strong>缓解</strong>这些问题</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然 3PC 缓解了 2PC 的部分问题，但它也带来了更高的通信成本和实现复杂性，且依旧具有性能问题和数据一致性问题</li><li>因此，在现代分布式系统中，人们更倾向于使用 2PC 而非 3PC，甚至更倾向于采用共识协议来解决这部分问题</li></ol></blockquote><hr><h5 id="3PC-核心流程"><a href="#3PC-核心流程" class="headerlink" title="3PC 核心流程"></a>3PC 核心流程</h5><h6 id="阶段一：CanCommit（准备阶段）"><a href="#阶段一：CanCommit（准备阶段）" class="headerlink" title="阶段一：CanCommit（准备阶段）"></a>阶段一：CanCommit（准备阶段）</h6><p>协调者向所有参与者发送 <code>CanCommit</code> 请求，询问它们是否都 “有能力” 提交事务</p><p>参与者在收到 <code>CanCommit</code> 请求后，会先对自身环境进行检查（例如：本地数据是否满足约束、资源是否充足等），此时<strong>不会真正执行事务操作或锁定资源</strong></p><p>检查无误后，它会向协调者返回 YSE。若检查失败，则返回 NO</p><hr><h6 id="阶段二：PreCommit-预提交阶段"><a href="#阶段二：PreCommit-预提交阶段" class="headerlink" title="阶段二：PreCommit (预提交阶段)"></a>阶段二：PreCommit (预提交阶段)</h6><p>协调者根据参与者在阶段一的反应情况，来决定如何进行 PreCommit 操作，有以下两种可能：</p><p><font color="#92d050">1. 事务预提交</font><br>当所有参与者均返回 YES 时，协调者向所有参与者发送 <code>PreCommit</code> 请求。</p><p>参与者收到 <code>PreCommit</code> 请求后，开始执行事务操作并锁定相关资源，但不会提交事务（这步才真正等同于 2PC 的第一阶段）</p><p>执行成功后，参与者向协调者返回 <code>ACK</code>。若执行失败，则返回 NO<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-4.png"></p><p><font color="#92d050">2. 事务中断</font><br>若任意一个参与者返回 NO，或在超时时间内未返回响应，协调者向所有参与者发送 <code>Abort</code> 请求</p><p>参与者收到 <code>Abort</code> 请求后，直接中断事务<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-5.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 3PC 中引入 “超时机制”，主要体现在第二和第三阶段。如果参与者在规定时间内没有收到协调者的指令，就可以自主作出决策，默认将事务中止，从而避免因协调者故障而无限期阻塞。</li></ol></blockquote><hr><h5 id="阶段三：DoCommit（提交阶段）"><a href="#阶段三：DoCommit（提交阶段）" class="headerlink" title="阶段三：DoCommit（提交阶段）"></a>阶段三：DoCommit（提交阶段）</h5><p>协调者根据参与者在阶段二的反应情况，来决定如何进行 DoCommit 操作，有以下两种可能：</p><p><font color="#92d050">1. 事务提交</font><br>当所有参与者均返回 ACK 时，协调者向所有参与者发送 <code>DoCommit</code> 请求。</p><p>参与者收到 <code>DoCommit</code> 请求后，正式提交事务，并释放事务执行期间锁定的资源（行锁、表锁）和占用的数据库连接</p><p>提交完成后，参与者向协调者返回 <code>ACK</code></p><p> 协调者收到所有参与者的 <code>ACK</code> 后，确认整个事务提交完成<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-6.png"></p><p><font color="#92d050">2. 事务中断</font><br>若任意一个参与者返回 NO，或在超时时间内未返回响应，协调者向所有参与者发送 <code>Abort</code> 请求</p><p>参与者收到 <code>Abort</code> 请求后，根据阶段二记录的 Undo 日志执行回滚，并释放事务执行期间锁定的资源（行锁、表锁）和占用的数据库连接</p><p>中断完成后，参与者向协调者返回 <code>ACK</code></p><p> 协调者收到所有参与者的 <code>ACK</code> 后，确认整个事务中断完成</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 3PC 中引入 “超时机制”，主要体现在第二和第三阶段。如果参与者在规定时间内没有收到协调者的指令，就可以自主作出决策，默认将事务中止，从而避免因协调者故障而无限期阻塞。</li></ol></blockquote><hr><h3 id="最终一致性分布式事务"><a href="#最终一致性分布式事务" class="headerlink" title="最终一致性分布式事务"></a>最终一致性分布式事务</h3><h4 id="TCC-模式"><a href="#TCC-模式" class="headerlink" title="TCC 模式"></a>TCC 模式</h4><h5 id="TCC-概述"><a href="#TCC-概述" class="headerlink" title="TCC 概述"></a>TCC 概述</h5><p>TCC 的出现主要是为了解决以下问题：传统强一致分布式事务协议（如 2PC、3PC）实现复杂、性能低下，而且常常导致资源长时间锁定</p><p>而 TCC 通过在业务层进行灵活的编排，将锁粒度和持锁时间最小化，从而以更高效的方式实现最终一致性</p><hr><h5 id="TCC-核心流程"><a href="#TCC-核心流程" class="headerlink" title="TCC 核心流程"></a>TCC 核心流程</h5><h6 id="阶段一：Try-阶段（资源预留）"><a href="#阶段一：Try-阶段（资源预留）" class="headerlink" title="阶段一：Try 阶段（资源预留）"></a>阶段一：Try 阶段（资源预留）</h6><p>假设你在 Mall 商城里买了一台手机，这个操作涉及到三个服务：</p><ol><li>订单服务<ol><li>创建订单</li></ol></li><li>库存服务<ol><li>扣减库存</li></ol></li><li>支付服务<ol><li>扣除余额</li></ol></li></ol><p>在 Try 阶段，事务协调者会调用各服务的 Try 接口，各服务先执行资源预留，但尚未进行最终确认：</p><ol><li>订单服务<ol><li>在数据库插入一条订单记录</li><li>状态设为 <code>Pending</code>（待确认）</li></ol></li><li>库存服务<ol><li>从 <code>available_quantity</code>（可用库存）中扣减对应数量</li><li>在 <code>reserved_quantity</code>（冻结库存）中增加相应数量</li></ol></li><li>支付服务<ol><li>从 <code>available_balance</code>（可用余额）中扣减相应金额</li><li>在 <code>reserved_balance</code>（冻结金额）中增加对应金额</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>常见的资源预留实现方式可以分为两类：<ol><li>库存预留<ol><li>数据库设计：<ol><li> 建立两类字段或表，<code>available_quantity</code>（可用库存） 和 <code>reserved_quantity</code>（冻结库存）</li></ol></li><li>Try<ol><li>扣减 <code>available_quantity</code>，并相应增加 <code>reserved_quantity</code></li></ol></li><li>Confirm<ol><li>直接从 <code>reserved_quantity</code> 扣除，完成真正消耗</li></ol></li><li>Cancel<ol><li>回滚操作，即增加 <code>available_quantity</code>，并减少 <code>reserved_quantity</code></li></ol></li></ol></li><li>优惠卷预留<ol><li>Try<ol><li>给记录加上 “冻结” 标志（如 <code>Locked=Y</code>），并通常设置过期时间（例如 10 分钟）</li><li>在冻结期间，该优惠券对其他用户不可见</li></ol></li><li>Confirm<ol><li>将标志更新为 “已领取”</li></ol></li><li>Cancel<ol><li>将标志恢复成原始状态（解除冻结）</li></ol></li></ol></li></ol></li><li>状态预留不会像 2PC、3PC 那样锁住数据库资源，而是通过业务字段来标记和控制资源的占用状态</li></ol></blockquote><hr><h6 id="阶段二：Confirm-Cancel-阶段"><a href="#阶段二：Confirm-Cancel-阶段" class="headerlink" title="阶段二：Confirm&#x2F;Cancel 阶段"></a>阶段二：Confirm&#x2F;Cancel 阶段</h6><p>事务协调者根据各服务在阶段一的反应情况，来决定如何进行阶段二的操作，有以下两种可能：</p><p><font color="#92d050">1. Confirm 阶段</font><br>当所有服务都 Try 成功，事务协调者会调用各服务的 Confirm 接口：</p><ol><li>订单服务<ol><li>把 <code>Pending</code> 修改为 <code>Confirmed</code></li></ol></li><li>库存服务<ol><li>直接从 <code>reserved_quantity</code>（冻结库存）扣除，完成真正消耗</li></ol></li><li>支付服务<ol><li>直接从 <code>reserved_balance</code>（冻结金额）扣除，完成真正支付</li></ol></li></ol><p><font color="#92d050">2. Cancel 阶段</font><br>当任一服务在 Try 阶段有任何失败，事务协调者会调用各服务的 Cancel 接口：</p><ol><li>订单服务<ol><li>把订单取消甚至直接删除</li></ol></li><li>库存服务<ol><li>解锁刚才冻结的库存</li></ol></li><li>支付服务<ol><li>解锁刚才冻结的金额<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-7.png"></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>幂等保护<ol><li>Confirm 和 Cancel 必须设计成安全的重复调用</li><li>我们可以通过事务 ID（分布式 ID）来记录，确保不会重复结算</li></ol></li><li>允许空回滚<ol><li>空回滚是指：一个服务根本没成功执行过 Try，就被要求执行 Cancel</li><li>造成空回滚的原因包括：<ol><li>网络抖动<ol><li>事务协调器的 Try 请求因为网络抖动超时未到达服务，但协调者认为失败了，就会触发 Cancel</li></ol></li><li>服务宕机<ol><li>事务协调器的 Try 请求因为服务宕机无法未到达服务，但协调者认为失败了，就会触发 Cancel</li></ol></li></ol></li><li>我们可以在各服务维护一个事务日志表，对每个事务 ID 记录 Try&#x2F;Confirm&#x2F;Cancel 状态<ol><li>在 Cancel 的时候，如果查不到事务日志记录，说明 Try 根本没执行过，就直接返回（即空回滚），不能真的去执行操作</li></ol></li></ol></li><li>防悬挂控制<ol><li>悬挂是指：Cancel 比 Try 先到达，然后 Try 又 “姗姗来迟”</li><li>我们可以在处理 Try 时，先检查事务日志表 ，查看这个事务 ID 是否已经是 Cancel 状态</li><li>如果已经是 Cancel 状态，说明 Cancel 已经到达过，就拒绝执行 Try</li></ol></li></ol></blockquote><hr><h4 id="Saga-模式"><a href="#Saga-模式" class="headerlink" title="Saga 模式"></a>Saga 模式</h4><h5 id="Saga-概述"><a href="#Saga-概述" class="headerlink" title="Saga 概述"></a>Saga 概述</h5><p>Saga 是指：将一个大事务拆分为一系列可以独立提交的<strong>局部事务</strong>，每个局部事务<strong>成功后立即提交</strong>，避免长时间持有锁与资源，如果中途出现失败，则按既定顺序依次执行对应的<strong>补偿操作</strong>，将已完成的动作回滚，从而保证整体达到<strong>最终一致性</strong></p><p>只要每个小事务都是自洽的（要么提交，要么补偿），那么整个业务过程在逻辑上就是完整、可恢复的。</p><hr><h5 id="Saga-恢复策略"><a href="#Saga-恢复策略" class="headerlink" title="Saga 恢复策略"></a>Saga 恢复策略</h5><ol><li>向前恢复（补偿事务）<ol><li>一旦执行过程中出错，就回滚之前已经成功的局部事务</li><li>这个恢复策略需要每个局部事务必须有一个对应的补偿，来导致状态回退</li><li>但有些操作可能不好补偿，比如发短信都已经发出去了，很难 “收回”</li></ol></li><li>向后恢复（端点续跑）<ol><li>出错后不撤销之前成功的事务，而是不断重试失败的那一步，直到成功为止</li><li>这个恢复策略假设所有局部事务最终一定能成功，不需要补偿</li></ol></li></ol><hr><h5 id="Saga-核心流程"><a href="#Saga-核心流程" class="headerlink" title="Saga 核心流程"></a>Saga 核心流程</h5><h6 id="编排模式（Orchestration）"><a href="#编排模式（Orchestration）" class="headerlink" title="编排模式（Orchestration）"></a>编排模式（Orchestration）</h6><p>在 编排式 Saga（Orchestration Saga） 中，会有一个中心控制器 （Saga Orchestrator），它负责统一调度所有子事务及其补偿事务：</p><ol><li>正常执行<ol><li>Orchestrator 按顺序依次调用各个局部事务：Txn1 → Txn2 → Txn3 → …</li><li>每个事务执行成功后立即提交，不阻塞后续流程</li></ol></li><li>异常回滚<ol><li>一旦有事务失败，Orchestrator 会主动触发补偿逻辑：Cn(n-1) → Cn(n-2) → …<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-8.png"></li></ol></li></ol><hr><h6 id="舞会模式（Choreography）"><a href="#舞会模式（Choreography）" class="headerlink" title="舞会模式（Choreography）"></a>舞会模式（Choreography）</h6><p>在 <strong>协作式 Saga</strong> 中，不再有中心控制器，而是每个服务通过<strong>事件驱动</strong>自发参与事务流程：</p><ol><li>正常执行<ol><li>当某个服务完成自己的局部事务后，会发布一个事件（如 OrderCreate）</li><li>下一个相关服务订阅并监听该事件，执行自己的局部事务并继续发布事件（如 InventoryReserved）</li><li>整个 Saga 事务就这样靠事件链条一步步推进</li></ol></li><li>异常回滚<ol><li>如果某个服务在执行时发生错误，它会发布一个补偿事件（如 PaymentFaile）</li><li>订阅该补偿事件的服务按照约定，自行触发补偿逻辑</li><li>由此实现链式的按需回滚<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-9.png"></li></ol></li></ol><hr><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><h5 id="本地消息表概述"><a href="#本地消息表概述" class="headerlink" title="本地消息表概述"></a>本地消息表概述</h5><p>本地消息表 的出现主要是为了解决以下问题：<br>在分布式系统中，我们常通过消息队列来传递事件（因为消息队列优势很多，详见笔记：MQ 概述）。</p><p>但如果采用 “先写数据库，再发消息” 这种常见流程，就会产生一致性问题：</p><ol><li>如果 “写库成功，但发消息失败”，队列中就没有事件，消费者无法感知</li><li>如果 “发消息成功，但写库失败”，消费者就会处理到一条不存在的业务（脏数据）</li><li>这些问题都会导致数据不一致</li></ol><p>而 本地消息表 通过先将消息写入本地消息表，随后由后台定时任务扫描该表，并将消息推送到消息队列。这样，即使因宕机等原因导致消息一时未能发送，消息记录仍然安全地保存在本地，后续任务会对其进行扫描和补发，从而保证最终一致性。</p><hr><h5 id="本地消息表核心流程"><a href="#本地消息表核心流程" class="headerlink" title="本地消息表核心流程"></a>本地消息表核心流程</h5><p><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-10.png"></p><h4 id="MQ-事务消息"><a href="#MQ-事务消息" class="headerlink" title="MQ 事务消息"></a>MQ 事务消息</h4><p><a href="https://blog.csdn.net/a745233700/article/details/122402303">https://blog.csdn.net/a745233700/article/details/122402303</a></p><p><a href="https://zhuanlan.zhihu.com/p/1936417534988489826">https://zhuanlan.zhihu.com/p/1936417534988489826</a></p><hr><h4 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h4><p>重复通知，消息校对<br><img src="/2025/08/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7-11.png"></p><p>Seata 不只是单一的 2PC，而是封装了多种模式，适合不同业务需求：</p><ol><li><p><strong>AT 模式（Automatic Transaction）</strong></p><ul><li><p>最常用，适合关系型数据库。</p></li><li><p>原理：Seata 拦截 SQL，自动生成 <strong>Undo Log</strong>，失败时自动回滚。</p></li><li><p>对应用开发者几乎无感知。</p></li></ul></li><li><p><strong>TCC 模式（Try-Confirm-Cancel）</strong></p><ul><li><p>业务层自己定义三步操作：Try 预留资源、Confirm 确认提交、Cancel 回滚。</p></li><li><p>灵活，但业务代码要额外编写。</p></li></ul></li><li><p><strong>Saga 模式</strong></p><ul><li><p>把长事务拆成一系列本地事务，如果中间失败，就用补偿操作撤销。</p></li><li><p>适合跨服务、长流程场景。</p></li></ul></li><li><p><strong>XA 模式</strong>（标准两阶段协议）</p></li></ol><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><h4 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h4><p><a href="https://blog.csdn.net/a745233700/article/details/122402795">https://blog.csdn.net/a745233700/article/details/122402795</a></p><p><a href="https://zhuanlan.zhihu.com/p/315164700">https://zhuanlan.zhihu.com/p/315164700</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>分布式一致性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法：FileChannel 常用方法</title>
    <link href="/2025/08/19/%E6%96%B9%E6%B3%95%EF%BC%9AFileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/19/%E6%96%B9%E6%B3%95%EF%BC%9AFileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><strong>FileChannel</strong> 可以通过 <code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code> 的 <code>getChannel()</code> 方法获取：</p><ol><li>使用 <code>FileInputStream</code> 获取的是读通道</li><li>使用 <code>FileOutputStream</code> 获取的是写通道</li><li>使用 <code>RandomAccessFile</code> 获取的是读写通道</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 FileInputStream</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><br><span class="hljs-comment">// 获取 FileChannel（本质上是新建 FileChannel）</span><br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>他们的 API 方法列表是完全一致的，区别在于他们只能调用符合权限的方法，否则会抛异常。<ol><li>例如通过 <code>FileInputStream</code> 获取的读通道如果调用 <code>write()</code>，会抛出异常</li><li>例如通过 <code>FileOutputStream</code> 获取的写通道如果调用 <code>read()</code>，同样会抛异常</li><li>而使用 <code>RandomAccessFile</code> 获取的读写通道则没有这些限制，读写操作都支持</li></ol></li></ol></blockquote><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="读方法"><a href="#读方法" class="headerlink" title="读方法"></a>读方法</h3><h4 id="int-read-ByteBuffer"><a href="#int-read-ByteBuffer" class="headerlink" title="int read(ByteBuffer)"></a>int read(ByteBuffer)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int read(ByteBuffer)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. ByteBuffer</span><br><span class="hljs-comment"> *          1. 数据应该从文件读取到那个 Buffer（因为 Channel 只做传输，不留数据）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 本次读取的字节数量</span><br><span class="hljs-comment"> *          1. 假如文件还剩 100 字节，Buffer 可用空间只有 32，那么本次最多只能读 32，返回 32</span><br><span class="hljs-comment"> *          2. 这里有一个特殊情况，如果 Buffer 已经没有剩余空间，会因为无法写入而返回 0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *      2. -1</span><br><span class="hljs-comment"> *          1. 表示文件已到末尾，没有更多数据可读</span><br><span class="hljs-comment"> *          2. 例如文件只有 32 字节，Buffer 可用空间也为 32，那么第一次读，返回 32</span><br><span class="hljs-comment"> *          3. 再次调用 read() 时，由于文件已经读完，无法再搬任何字节，返回 -1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 把数据从文件读取到某 Buffer（从 Buffer 当前的 position 开始写入）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 方法本身只执行一次读操作，通常会尽力把 Buffer 填满，但这并不保证一定成功，具体情况取决于运行时环境，无法提前预测。</span><br><span class="hljs-comment"> *      2. 并且由于通常无法预知文件大小，不知道一次读操作是否能把文件内容全部读取。</span><br><span class="hljs-comment"> *      3. 所以我们常根据方法返回值循环调用该方法，当 Buffer 填满时进行处理，当方法返回 -1 时截止</span><br><span class="hljs-comment"> *      4. 不必担心每次读都会从文件开头开始，因为系统级打开文件表会维护当前读写的偏移量</span><br><span class="hljs-comment"> *      5. 虽然这些方法定义在 Channel 上，但实际上 Channel 更像是一个中间桥梁。读取时，数据是通过 Channel 从文件读入到 Buffer；写入时，数据则是通过 Channel 从 Buffer 写入到文件。  </span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileChannel.read(byteBuffer);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>一定要牢记这两个流程：<ol><li>程序读数据：硬件（磁盘&#x2F;网卡） ➔ 内核空间 ➔ Channel ➔ Buffer</li><li>程序写数据：Buffer ➔ Channel ➔ 内核空间 ➔ 硬件（磁盘&#x2F;网卡）</li></ol></li><li>如果你发现文件内容莫名消失，原因可能是你创建的 FileOutputStream 没有开启追加模式，只需在创建时设置为追加模式即可：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="int-read-ByteBuffer-long"><a href="#int-read-ByteBuffer-long" class="headerlink" title="int read(ByteBuffer, long)"></a>int read(ByteBuffer, long)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int read(ByteBuffer, long)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. ByteBuffer</span><br><span class="hljs-comment"> *          1. 数据应该从文件读取到那个 Buffer</span><br><span class="hljs-comment"> *      2. long</span><br><span class="hljs-comment"> *          1. 从文件的那个偏移量开始读</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 本次读取的字节数量</span><br><span class="hljs-comment"> *      2. -1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 把数据从文件指定偏移量开始，读取到某 ByteBuffer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 不会改变系统级打开文件表维护的当前读写偏移量</span><br><span class="hljs-comment"> *      2. 例如之前使用 int read(ByteBuffer) 读取到某个位置，调用此方法后</span><br><span class="hljs-comment"> *      3. 如果再次使用 int read(ByteBuffer)，依然会从之前的位置继续读取</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileChannel.read(byteBuffer, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="写方法"><a href="#写方法" class="headerlink" title="写方法"></a>写方法</h3><h4 id="int-write-ByteBuffer"><a href="#int-write-ByteBuffer" class="headerlink" title="int write(ByteBuffer)"></a>int write(ByteBuffer)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int write(ByteBuffer)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. ByteBuffer</span><br><span class="hljs-comment"> *          1. 数据应该从那个 Buffer 写入到文件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 本次写入的字节数量</span><br><span class="hljs-comment"> *          1. 这里有一个特殊情况，如果 Buffer 已经没有剩余数据，会因为无法写出而返回 0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 把数据从某 Buffer 写入到文件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 方法本身同样只执行一次写操作，通常会尽力把 Buffer 全部写出，但这并不保证一定成功，具体情况取决于运行时环境，无法提前预测。</span><br><span class="hljs-comment"> *      2. 所以我们常根据 byteBuffer.hasRemaining() 循环调用该方法，当 byteBuffer.hasRemaining() 返回 0 时截止</span><br><span class="hljs-comment"> *      2. 同样不必担心每次写都会从文件开头开始</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileChannel.write(byteBuffer);  <br></code></pre></td></tr></table></figure><hr><h4 id="int-write-ByteBuffer-long"><a href="#int-write-ByteBuffer-long" class="headerlink" title="int write(ByteBuffer, long)"></a>int write(ByteBuffer, long)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * int write(ByteBuffer, long)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 本次写入的字节数量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 把数据从某 Buffer 从文件指定偏移量开始写入</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 同样不会改变系统级打开文件表维护的当前读写偏移量</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileChannel.write(byteBuffer, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="落盘方法"><a href="#落盘方法" class="headerlink" title="落盘方法"></a>落盘方法</h3><h4 id="void-force-boolean"><a href="#void-force-boolean" class="headerlink" title="void force(boolean)"></a>void force(boolean)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void force(boolean)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. boolean</span><br><span class="hljs-comment"> *          1. true</span><br><span class="hljs-comment"> *              1. 连文件的元数据（例如文件大小、修改时间、权限等）也一并强制 flush</span><br><span class="hljs-comment"> *          2. false</span><br><span class="hljs-comment"> *              1. 只保证文件内容 flush 到磁盘，元数据是否刷新由操作系统自己决定</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 默认情况下，当你调用 channel.write() 时，数据未必马上 flush 到磁盘</span><br><span class="hljs-comment"> *      2. 通常是先写到操作系统的缓存（page cache），并标记为 dirty page。虽然速度快，但如果此时停电 / 系统奔溃，缓存里的数据可能丢失</span><br><span class="hljs-comment"> *      3. 而本方法是强制把 FileChannel 对应的文件修改，真正写入磁盘。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br>fileChannel.force(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h3><h4 id="long-size"><a href="#long-size" class="headerlink" title="long size()"></a>long size()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回与 FileChannel 关联的文件一共有多少字节</span><br><span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> fileChannel.size();<br></code></pre></td></tr></table></figure><hr><h3 id="position-管理方法"><a href="#position-管理方法" class="headerlink" title="position 管理方法"></a>position 管理方法</h3><h4 id="long-position"><a href="#long-position" class="headerlink" title="long position()"></a>long position()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回系统级打开文件表维护的当前读写偏移量</span><br><span class="hljs-type">long</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> fileChannel.position();<br></code></pre></td></tr></table></figure><hr><h4 id="FileChannel-position-long"><a href="#FileChannel-position-long" class="headerlink" title="FileChannel position(long)"></a>FileChannel position(long)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改系统级打开文件表维护的当前读写偏移量</span><br>fileChannel.position(<span class="hljs-number">32</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="内存映射方法"><a href="#内存映射方法" class="headerlink" title="内存映射方法"></a>内存映射方法</h3><h4 id="MappedByteBuffer-map-MapMode-long-long"><a href="#MappedByteBuffer-map-MapMode-long-long" class="headerlink" title="MappedByteBuffer map(MapMode, long, long)"></a>MappedByteBuffer map(MapMode, long, long)</h4><hr><h3 id="零拷贝文件传输方法"><a href="#零拷贝文件传输方法" class="headerlink" title="零拷贝文件传输方法"></a>零拷贝文件传输方法</h3><h4 id="transferTo-long-position-long-count-WritableByteChannel-target"><a href="#transferTo-long-position-long-count-WritableByteChannel-target" class="headerlink" title="transferTo(long position, long count, WritableByteChannel target)"></a>transferTo(long position, long count, WritableByteChannel target)</h4><h4 id="transferFrom-ReadableByteChannel-src-long-position-long-count"><a href="#transferFrom-ReadableByteChannel-src-long-position-long-count" class="headerlink" title="transferFrom(ReadableByteChannel src, long position, long count)"></a>transferFrom(ReadableByteChannel src, long position, long count)</h4><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">fileChannel.close();<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：FileOutputStream 源码解析</title>
    <link href="/2025/08/18/%E6%BA%90%E7%A0%81%EF%BC%9AFileOutputStream%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/18/%E6%BA%90%E7%A0%81%EF%BC%9AFileOutputStream%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="源码（成员方法-实例方法-静态方法）"><a href="#源码（成员方法-实例方法-静态方法）" class="headerlink" title="源码（成员方法 &#x3D; 实例方法 + 静态方法）"></a>源码（成员方法 &#x3D; 实例方法 + 静态方法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OutputStream</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">JavaIOFileDescriptorAccess</span> <span class="hljs-variable">fdAccess</span> <span class="hljs-operator">=</span> SharedSecrets.getJavaIOFileDescriptorAccess();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FileDescriptor fd;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> FileChannel channel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String path;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">closeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> closed;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileOutputStream</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-built_in">this</span>(name != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(name) : <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileOutputStream</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> append)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-built_in">this</span>(name != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(name) : <span class="hljs-literal">null</span>, append);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileOutputStream</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-built_in">this</span>(file, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileOutputStream</span><span class="hljs-params">(File file, <span class="hljs-type">boolean</span> append)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (file != <span class="hljs-literal">null</span> ? file.getPath() : <span class="hljs-literal">null</span>);<br>        <br>        <span class="hljs-meta">@SuppressWarnings(&quot;removal&quot;)</span><br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        <br>        <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;<br>            security.checkWrite(name);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (file.isInvalid()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">&quot;Invalid file path&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-built_in">this</span>.fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileDescriptor</span>();<br>        <br>        fd.attach(<span class="hljs-built_in">this</span>);<br>        <br>        <span class="hljs-built_in">this</span>.path = name;<br><br>        open(name, append);<br>        <br>        FileCleanable.register(fd);<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileOutputStream</span><span class="hljs-params">(FileDescriptor fdObj)</span> &#123;<br>    <br>        <span class="hljs-meta">@SuppressWarnings(&quot;removal&quot;)</span><br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        <br>        <span class="hljs-keyword">if</span> (fdObj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;<br>            security.checkWrite(fdObj);<br>        &#125;<br>        <br>        <span class="hljs-built_in">this</span>.fd = fdObj;<br>        <br>        <span class="hljs-built_in">this</span>.path = <span class="hljs-literal">null</span>;<br><br>        fd.attach(<span class="hljs-built_in">this</span>);<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open0</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> append)</span> <span class="hljs-keyword">throws</span> FileNotFoundException;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> append)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        open0(name, append);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">boolean</span> append)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        write(b, fdAccess.getAppend(fd));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeBytes</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len, <span class="hljs-type">boolean</span> append)</span><br>        <span class="hljs-keyword">throws</span> IOException;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        writeBytes(b, <span class="hljs-number">0</span>, b.length, fdAccess.getAppend(fd));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        writeBytes(b, off, len, fdAccess.getAppend(fd));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <br>        <span class="hljs-keyword">if</span> (closed) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">synchronized</span> (closeLock) &#123;<br>            <span class="hljs-keyword">if</span> (closed) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            closed = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> channel;<br>        <span class="hljs-keyword">if</span> (fc != <span class="hljs-literal">null</span>) &#123;<br>            fc.close();<br>        &#125;<br><br>        fd.closeAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Closeable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               fd.close();<br>           &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> FileDescriptor <span class="hljs-title function_">getFD</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (fd != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> fd;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>     &#125;<br><br>    <span class="hljs-keyword">public</span> FileChannel <span class="hljs-title function_">getChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.channel;<br>        <span class="hljs-keyword">if</span> (fc == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                fc = <span class="hljs-built_in">this</span>.channel;<br>                <span class="hljs-keyword">if</span> (fc == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.channel = fc = FileChannelImpl.open(fd, path, <span class="hljs-literal">false</span>,<br>                        <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-built_in">this</span>);<br>                    <span class="hljs-keyword">if</span> (closed) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            fc.close();<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(ioe);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fc;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initIDs</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        initIDs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="写方法"><a href="#写方法" class="headerlink" title="写方法"></a>写方法</h3><h4 id="void-write-int-b"><a href="#void-write-int-b" class="headerlink" title="void write(int b)"></a>void write(int b)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void write(int b)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. int b</span><br><span class="hljs-comment"> *          1. 要写入的 int 类型</span><br><span class="hljs-comment"> *          2. 虽然是 int 类型，但只取低 8 位（也就是 1 个字节）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. void</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *      1. fileOutputStream.write(97);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 向输出流写入一个字节</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>write(b, fdAccess.getAppend(fd));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="void-write-byte-b"><a href="#void-write-byte-b" class="headerlink" title="void write(byte b[])"></a>void write(byte b[])</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void write(byte b[])</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. byte b[]</span><br><span class="hljs-comment"> *          1. 要写入的 byte 数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. void</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *      1. fileOutputStream.write(new byte[]&#123;97, 98, 99, 100, 101&#125;);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 向输出流写入一个字节数组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>    writeBytes(b, <span class="hljs-number">0</span>, b.length, fdAccess.getAppend(fd));  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>关于 <code>byte b[]</code> ，如果我们要把字符串转成 <code>byte b[]</code>，有一种很方便的方式：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;haoshuaihaoshuia&quot;</span>;  <br>  <br>fileOutputStream.write(s.getBytes());<br></code></pre></td></tr></table></figure><hr><h4 id="void-write-byte-b-int-off-int-len"><a href="#void-write-byte-b-int-off-int-len" class="headerlink" title="void write(byte b[], int off, int len)"></a>void write(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * void write(byte b[], int off, int len)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 3. 参数</span><br><span class="hljs-comment"> *      1. byte b[]</span><br><span class="hljs-comment"> *          1. 要写入的 byte 数组</span><br><span class="hljs-comment"> *      2. int off</span><br><span class="hljs-comment"> *          1. byte 数组的 off 下标</span><br><span class="hljs-comment"> *      3. int len</span><br><span class="hljs-comment"> *          1. 选取的长度</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. void</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 使用示例</span><br><span class="hljs-comment"> *      1. fileOutputStream.write(new byte[]&#123;97, 98, 99, 100, 101&#125;, 2, 3);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 向输出流写入一个字节数组的部分数据，从 off 到 off + len</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 数组的下标是以 0 开始的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>    writeBytes(b, off, len, fdAccess.getAppend(fd));  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><h4 id="void-close"><a href="#void-close" class="headerlink" title="void close()"></a>void close()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>    <span class="hljs-keyword">if</span> (closed) &#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">synchronized</span> (closeLock) &#123;  <br>        <span class="hljs-keyword">if</span> (closed) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        closed = <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> channel;  <br>    <span class="hljs-keyword">if</span> (fc != <span class="hljs-literal">null</span>) &#123;  <br>        fc.close();  <br>    &#125;  <br>  <br>    fd.closeAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Closeable</span>() &#123;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>           fd.close();  <br>       &#125;  <br>    &#125;);  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们创建的流，一定不要忘记 <code>close</code></li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java IO 模式</title>
    <link href="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/unique_perfect/article/details/115108640">https://blog.csdn.net/unique_perfect/article/details/115108640</a></p><h2 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a>同步阻塞（BIO）</h2><h3 id="BIO-概述"><a href="#BIO-概述" class="headerlink" title="BIO 概述"></a>BIO 概述</h3><p>BIO（Blocking IO）是最传统的 I&#x2F;O 模型，采用传统的 “一连接一线程” 的方式，并且在进行 IO 操作时，如果数据还没准备好，那么发起 IO 调用的线程就会一直阻塞等待，直到数据可用。</p><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F.png"></p><hr><h3 id="伪异步-IO"><a href="#伪异步-IO" class="headerlink" title="伪异步 IO"></a>伪异步 IO</h3><p>在最传统的 <strong>BIO 模式</strong> 下，服务端的处理方式是 <strong>一连接一线程</strong>，每当有一个客户端接入，就创建一个线程专门处理这个连接，如果同时有 1000 个客户端，那么服务端就要开 1000 个线程去等待</p><p>然而，<strong>线程资源并不是无限的</strong>，Java 中每个线程都会占用一定的内存（线程栈空间），而且操作系统能同时调度的线程数也有限。当线程数急剧膨胀，就会导致：内存消耗过大 → 堆栈溢出、线程创建失败，最终可能导致进程宕机或僵死</p><p>我们可以采用 <strong>线程池 + 任务队列</strong> 的方式进行优化：</p><ol><li>服务端接收到新的客户端连接后，不再立即创建独立线程，而是将客户端的 <code>Socket</code> 封装成一个 <strong>任务（Runnable&#x2F;Callable）</strong></li><li>这个任务会被放入 <strong>线程池的任务队列</strong>，后台仅维护固定数量的工作线程（例如 10 或 20 个）</li><li>工作线程会不断从队列中取出任务并执行，从而保证线程数量可控</li></ol><p>这样一来，即使有大量客户端并发接入，也不会出现无节制的新建线程，系统能保持稳定运行。</p><p>需要注意的是，这种方式只是解决了 <strong>“线程爆炸”</strong> 的资源问题，本质上仍然是 <strong>阻塞 I&#x2F;O</strong>，因为每个工作线程在执行具体的 IO 操作时依然会阻塞等待数据，所以这被称为 伪异步 IO</p><hr><h2 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a>同步非阻塞（NIO）</h2><h3 id="NIO-概述"><a href="#NIO-概述" class="headerlink" title="NIO 概述"></a>NIO 概述</h3><p>NIO（New IO）通过 “一个线程处理多个连接” 的方式，所有客户端的连接都会注册到多路复用器（Selector）上，服务器线程通过轮询 Selector，发现有 IO 事件时才进行处理，从而大大提升了资源利用率和并发能力。<br><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F-3.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>NIO 的读写流程<ol><li>程序读数据：硬件（磁盘&#x2F;网卡） ➔ 内核空间 ➔ Channel ➔ Buffer</li><li>程序写数据：Buffer ➔ Channel ➔ 内核空间 ➔ 硬件（磁盘&#x2F;网卡）</li></ol></li></ol></blockquote><hr><h3 id="NIO-组件"><a href="#NIO-组件" class="headerlink" title="NIO 组件"></a>NIO 组件</h3><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><h5 id="Buffer-概述"><a href="#Buffer-概述" class="headerlink" title="Buffer 概述"></a>Buffer 概述</h5><p>Buffer 就是一个数组，可以存放多个相同类型的数据。想要掌握 Buffer，必须了解其几个重要概念：</p><ol><li>容量 (capacity) <ol><li>作为内存块，Buffer 具有固定大小，也称为 “容量”</li><li>缓冲区容量不能为负，并且创建后不可更改</li></ol></li><li>限制 (limit)：<ol><li>表示缓冲区中可操作的数据范围（超过 limit 的数据无法读写）</li><li>限制不能为负，也不能超过容量</li><li>写入模式下，limit 等于 Buffer 的容量</li><li>读取模式下，limit 等于已写入的数据量</li></ol></li><li>位置 (position)：<ol><li>指向下一个要读取或写入的数据索引</li><li>位置不能为负，也不能超过 limit</li></ol></li><li>标记 (mark) 与重置 (reset)：<ol><li>标记是通过 <code>mark()</code> 方法在 Buffer 中设置的一个特定 position</li><li>之后可以通过 <code>reset()</code> 方法将 position 恢复到标记的位置</li></ol></li></ol><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%A8%A1%E5%BC%8F-4.png"></p><hr><h5 id="Buffer-分类"><a href="#Buffer-分类" class="headerlink" title="Buffer 分类"></a>Buffer 分类</h5><p>Buffer 根据存储类型，可分为：</p><ol><li>ByteBuffer</li><li>ShortBuffer</li><li>CharBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ol><hr><h5 id="Buffer-常用方法"><a href="#Buffer-常用方法" class="headerlink" title="Buffer 常用方法"></a>Buffer 常用方法</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ABuffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：Buffer常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><h5 id="Channel-概述"><a href="#Channel-概述" class="headerlink" title="Channel 概述"></a>Channel 概述</h5><hr><h5 id="Channel-分类"><a href="#Channel-分类" class="headerlink" title="Channel 分类"></a>Channel 分类</h5><p>在 Java IO 流中，如果以来源&#x2F;目的地进行分类，有：</p><ol><li>文件流</li><li>内存流</li><li>管道流</li><li>网络流</li></ol><p>这里除了内存流没有对应的 Channel，其他三种流都有对应的 Channel</p><ol><li>文件流对应 Channel<ol><li>FileChannel</li></ol></li><li>管道流对应 Channel<ol><li>写入端 Channel<ol><li>Pipe.SinkChannel</li></ol></li><li>读取端 Channel<ol><li>Pipe.SourceChannel</li></ol></li></ol></li><li>网络流对应 Channel<ol><li>TCP Channel<ol><li>SocketChannel<ol><li>与远程主机进行 TCP 通信的通道</li></ol></li><li>ServerSocketChannel<ol><li>监听客户端 TCP 连接请求的通道</li></ol></li></ol></li><li>UDP Channel<ol><li>DatagramChannel<ol><li>UDP 读写网络中的通道</li></ol></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然一般管道都是可读可写的双向管道但是 NIO Pipe 的设计模型就是一个负责都一个负责写的单向管道</li><li><code>FileChannel</code> 实际上是阻塞的，而且不像网络通道那样可以通过 <code>configureBlocking(false)</code> 设置为非阻塞，因此不属于多路复用的一类，不能注册到 Selector</li><li>虽然 Pipe 也支持非阻塞，也能注册到 Selector，但主要是在单机程序内部做信号桥，用于线程间通信，不是网络通信。</li><li>上述 Channel 分类只是 NIO 模式下 可用的通道类型。还有很多其他类型的 Channel，例如 AIO 使用的通道，并未在这里描述</li></ol></blockquote><hr><h5 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h5><h6 id="FileChannel-概述"><a href="#FileChannel-概述" class="headerlink" title="FileChannel 概述"></a>FileChannel 概述</h6><p><code>FileChannel</code> 来自 Java NIO 包，表面上看似属于“新 I&#x2F;O”，因此很多人会以为它支持非阻塞操作。但实际上，当你调用 <code>fileChannel.read(ByteBuffer)</code> 或 <code>fileChannel.write(ByteBuffer)</code> 时，当前线程还是会一直等待，直到数据传输完成才返回。</p><p>你可能会问：既然 <code>FileChannel</code> 也是阻塞的，为什么不直接使用 BIO 的输入流和输出流，而要用它并配合 Buffer？这是不是显得有些麻烦？</p><p>其实，<code>FileChannel</code> 的优势并不在于非阻塞，而体现在以下几个方面：</p><ol><li>随机访问<ol><li><code>FileChannel</code> 可以直接跳转到文件的任意位置去读写（通过 <code>position(long)</code> 方法）</li></ol></li><li>内存映射<ol><li><code>map()</code> 方法可以把文件直接映射到内存中。这样你像操作内存数组一样去读写文件（它底层利用操作系统的虚拟内存机制）</li><li>在处理超大文件时，这种方式比传统 BIO 效率高得多</li></ol></li><li>零拷贝文件传输<ol><li><code>transferTo()</code> &#x2F; <code>transferFrom()</code> 可以把数据直接在内核层搬运，避免用户态&#x2F;内核态来回倒腾</li><li>在复制大文件（或者文件通过 socket 发送出去）时，性能优势非常明显</li></ol></li><li>适合与 NIO 生态统一<ol><li>如果你项目里既需要网络非阻塞 NIO，也需要文件操作，<code>FileChannel</code> 让接口和类型更统一</li></ol></li></ol><hr><h6 id="FileChannel-常用方法"><a href="#FileChannel-常用方法" class="headerlink" title="FileChannel 常用方法"></a>FileChannel 常用方法</h6><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AFileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：FileChannel常用方法</a></li></ol></li><li>Hexo 链接：<ol><li><a href="http://localhost:4000/2025/08/19/%E6%96%B9%E6%B3%95%EF%BC%9AFileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">http://localhost:4000/2025/08/19/%E6%96%B9%E6%B3%95%EF%BC%9AFileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</a></li></ol></li></ol><hr><h5 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h5><h6 id="SocketChannel-概述"><a href="#SocketChannel-概述" class="headerlink" title="SocketChannel 概述"></a>SocketChannel 概述</h6><p><code>SocketChannel</code> 是客户端连接远程服务器时使用的通道，既支持阻塞模式，也支持非阻塞模式。在非阻塞模式下，可以将多个通道注册到同一个 <code>Selector</code>，再通过轮询机制高效地管理和处理大量连接。</p><hr><h6 id="SocketChannel-常用方法"><a href="#SocketChannel-常用方法" class="headerlink" title="SocketChannel 常用方法"></a>SocketChannel 常用方法</h6><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ASocketChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：SocketChannel常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><h5 id="Selector-概述"><a href="#Selector-概述" class="headerlink" title="Selector 概述"></a>Selector 概述</h5><p>Selector 是 <code>SelectableChannel</code> 对象的多路复用器，能够检测多个已注册通道上是否有事件发生，如果有事件发生，就会获取相应的事件，并对每个事件进行处理，从而实现一个线程同时监控多个 <code>SelectableChannel</code> 的 IO 状态</p><hr><h5 id="Selector-常用方法"><a href="#Selector-常用方法" class="headerlink" title="Selector 常用方法"></a>Selector 常用方法</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ASelector%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：Selector常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><h2 id="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"><a href="#aaaaaaaaaaaaaaaaaaaaaaaaaaaaa" class="headerlink" title="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"></a>aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</h2><h2 id="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-1"><a href="#aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-1" class="headerlink" title="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"></a>aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</h2><h2 id="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-2"><a href="#aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-2" class="headerlink" title="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"></a>aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</h2><h2 id="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-3"><a href="#aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-3" class="headerlink" title="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"></a>aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</h2><h2 id="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-4"><a href="#aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-4" class="headerlink" title="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"></a>aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</h2><h2 id="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-5"><a href="#aaaaaaaaaaaaaaaaaaaaaaaaaaaaa-5" class="headerlink" title="aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"></a>aaaaaaaaaaaaaaaaaaaaaaaaaaaaa</h2><h3 id="异步非阻塞操作（AIO）"><a href="#异步非阻塞操作（AIO）" class="headerlink" title="异步非阻塞操作（AIO）"></a>异步非阻塞操作（AIO）</h3><p>Java AIO（异步非阻塞式）采用 “一个有效请求对应一个线程” 的模式，客户端的 I&#x2F;O 请求由操作系统先完成，然后再通知服务器应用启动线程进行处理。通常适用于连接数较多、且连接时间较长的场景。</p><p>因此 Java AIO 适用于连接数多且连接时间较长（重操作）的架构，例如相册服务器。它能够充分利用操作系统参与并发处理。从 JDK 7 开始提供支持，但编程相对复杂。</p><hr><h6 id="SocketChannel、ServerSocketChannel"><a href="#SocketChannel、ServerSocketChannel" class="headerlink" title="SocketChannel、ServerSocketChannel"></a>SocketChannel、ServerSocketChannel</h6><p><font color="#92d050">1. 客户端</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 SocketChannel</span><br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br><br><span class="hljs-comment">// 让 SocketChannel 连接到指定 IP 地址和端口</span><br>socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 服务端</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 ServerSocketChannel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br><span class="hljs-comment">// 让 ServerSocketChannel 监听指定 IP 地址和端口</span><br>serverChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;192.168.1.100&quot;</span>, <span class="hljs-number">8080</span>););<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在有多个网卡的情况下，通常可以指定某个 IP 地址进行监听</li><li>如果不指定 IP，程序会监听所有网卡地址，即 <code>0.0.0.0</code></li></ol></blockquote><hr><h6 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h6><p><font color="#92d050">1. 发送方</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 DatagramChannel</span><br><span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">datagramChannel</span> <span class="hljs-operator">=</span> DatagramChannel.open();<br><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;Hello&quot;</span>.getBytes());<br>datagramChannel.send(buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java IO 模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java IO 流</title>
    <link href="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81/"/>
    <url>/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-IO-流基础"><a href="#1-IO-流基础" class="headerlink" title="1. IO 流基础"></a>1. IO 流基础</h2><h3 id="1-1-用户态与内核态"><a href="#1-1-用户态与内核态" class="headerlink" title="1.1. 用户态与内核态"></a>1.1. 用户态与内核态</h3><p>计算机 IO（输入、输出）本质上都是：<strong>用户空间 ↔ 内核空间 ↔ 硬件（磁盘&#x2F;网卡）</strong></p><p>在理解 IO 之前，一个关键的基础概念就是 <strong>用户态（User Mode）和内核态（Kernel Mode）</strong>，这<strong>决定了你的程序到底能不能直接操作硬件和系统资源</strong>。</p><ol><li>用户态（User Mode）<ol><li>这是应用程序（比如你的 Java 代码）运行的地方。</li><li>在这个级别下，程序既不能直接访问硬件设备（如硬盘、网卡），也无法随意操作操作系统的关键内存区域，以及干预进程的调度机制。</li><li>有这种限制的目的，就是保护系统稳定性。想象如果一个小程序能随便写进硬盘文件系统的元数据，整个系统就可能立刻崩溃</li></ol></li><li>内核态（Kernel Mode）<ol><li>这是操作系统内核运行的地方</li><li>在这个特权级别下，代码可以执行任何敏感指令：访问硬件、操作内存、调度进程等</li></ol></li></ol><p>当程序在用户态里想做 “越权操作” 时，必须通过 <strong>系统调用（System Call）</strong> 请求操作系统内核帮忙</p><hr><h3 id="1-2-文件流读写流程"><a href="#1-2-文件流读写流程" class="headerlink" title="1.2. 文件流读写流程"></a>1.2. 文件流读写流程</h3><h4 id="1-2-1-读流程"><a href="#1-2-1-读流程" class="headerlink" title="1.2.1. 读流程"></a>1.2.1. 读流程</h4><p>假设我们有这样一段 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> fis.read();<br></code></pre></td></tr></table></figure><p><font color="#92d050">1. 获取文件描述符</font><br>当我们执行 <code>new FileInputStream(&quot;a.txt&quot;)</code> 的时候，在 Java 层我们创建了一个 <code>FileInputStream</code> 对象，在系统层，这个构造函数内部会触发一个 open 系统调用，请求操作系统内核打开名为 “a.txt” 的文件</p><p>操作系统内核接收到请求后，会在文件系统中查找 “a.txt”，并会在其内部创建一个代表这个打开文件的结构体（包含了文件信息、当前读取位置等），然后返回一个唯一的数字ID给你的程序，这个ID就是**文件描述符 (File Descriptor)**。</p><p><code>FileInputStream</code> 对象会保存这个文件描述符，现在，这个 Java 对象就和底层的内核文件结构体关联起来了。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>操作系统内部管理文件，大概有这样一层层的表结构：<ol><li>进程级文件描述符表（per‑process fd table）<ol><li>每个进程在内核态都有一张 “文件描述符表”，你调用 <code>open()</code> 得到的 <strong>整数 fd</strong>，其实就是这张表的 “下标”</li><li><ol><li>该表项本身并不存放文件数据，而是一个 <strong>引用</strong>，指向 <strong>系统级打开文件表</strong> 的某个条目。</li></ol></li></ol></li><li>系统级打开文件表（system‑wide open file table）<ol><li>内核维护这张全局表，用于记录所有被打开的文件实例</li><li>每个条目保存了与这次“打开行为”相关的状态，包括：<ol><li>当前读写偏移量</li><li>打开模式（只读&#x2F;可写&#x2F;追加）</li></ol></li><li>此外，每个条目还含有一个 <strong>引用</strong>，指向对应的 <strong>inode</strong>，这样可以找到文件的元信息和数据位置</li></ol></li><li>文件系统 inode 表（inode table）<ol><li><strong>inode</strong> 是文件系统维护的文件元信息结构，与某个用户进程无关。</li><li>一个 inode 描述了：文件大小、所有者、权限、时间戳，以及磁盘数据块的物理位置等</li><li>所有指向该文件的 “打开实例条目”，最终都会通过 inode 找到该文件的真实内容</li></ol></li></ol></li><li>每个新进程创建时，内核会默认为它打开三个文件描述符：<ol><li>0<ol><li>标准输入（stdin），默认连接到键盘输入</li></ol></li><li>1<ol><li>标准输出（stdout），默认连接到终端屏幕</li></ol></li><li>2<ol><li>标准错误输出（stderr），默认连接到终端屏幕，独立于标准输出</li></ol></li><li>这就是为什么在 C 程序里常见的 <code>printf</code> 或者在 Java 里 <code>System.out.println</code>，最终都能直接在屏幕上看到结果。</li></ol></li><li>我们可以通过 <code>FileInputStream.getFD()</code> 等方式拿到一个 <strong><code>FileDescriptor</code> 对象</strong>。在这个对象内部，确实有一个记录底层文件描述符整数的字段（<code>fd</code>）。<ol><li>不过，这个字段在 JDK 中被标记为 <strong>包级可见（package‑private）</strong>，也就是说外部代码无法直接访问。Java 之所以这样设计，是有意避免开发者绕过抽象层，直接依赖平台相关的文件描述符数字。</li><li>如果真的需要查看这个数字，通常只能借助 <strong>反射</strong> 这个黑科技来访问该字段。</li></ol></li></ol></blockquote><p><font color="#92d050">2. Java 层发起读请求</font><br><code>fis.read()</code> 在 JVM 里其实会调用一个 native 方法（JNI），本质就是触发 <code>read()</code> 的系统调用。</p><p>它向内核传递了三个关键信息：</p><ol><li>文件描述符<ol><li>指明要从哪个文件读取数据</li></ol></li><li>目标缓冲区<ol><li>告诉内核数据应写入到 JVM 的哪块内存区域</li></ol></li><li>读取长度</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>当调用 <code>int len = fis.read(byte[] buffer)</code> 时，传递给内核的其实是 <strong>这个字节数组在 JVM 堆中的起始地址</strong>，内核据此将数据直接写入相应的内存区域。</li><li>如果调用的是 <code>int b = fis.read()</code>，情况就不同了。因为 <code>b</code> 只是一个基本类型变量，存放在局部变量槽中，并没有内存地址可以直接交给内核</li><li>为解决这个问题，Java I&#x2F;O 库通常在 JNI 层准备一个 <strong>内部缓冲区（通常只有 1 个字节大小）</strong>。内核会先把数据写入这个缓冲区，再由底层代码取出并赋值给 <code>b</code></li></ol></blockquote><p><font color="#92d050">3. 内核接管 CPU，检查 “高速缓存”</font><br>从这一刻开始，CPU 的执行状态会从 <strong>用户态</strong> 切换为 <strong>内核态</strong>。控制权交由操作系统内核，Java 线程在逻辑上则进入“挂起等待” 状态。</p><p>内核接手后，会先通过传入的文件描述符定位到对应的文件结构体，接着读取其中的当前读写偏移量，并据此计算出本次需要访问的具体数据范围。</p><p>然后，操作系统内核会检查内存中的 <strong>文件缓存区（page cache）</strong>。这是内核预留的一块专门缓存，以「页（page）」为单位管理（通常 4KB）。内核会先计算出目标数据所在的页面，再判断缓存情况：</p><ol><li>缓存命中<ol><li>这是最高效的路径，可能因为你或别的程序刚刚读过这个文件，相关内容已经被预加载到内存里。</li><li>内核在 Page Cache 中找到了所需的页面，从中精确拷贝出请求的那几个字节，并拷贝到你的用户空间</li></ol></li><li>缓存未命中<ol><li>这是第一次读文件，或者数据太久没被用过，缓存里没有现成的页。</li><li>内核会向硬盘驱动发出请求，要求读取包含目标字节的<strong>一个完整数据块</strong>（往往是 4KB 或更大，这是典型的预读优化策略）</li><li>因为磁盘 I&#x2F;O 较慢，内核会把发起系统调用的 Java 线程标记为「阻塞」，先从 CPU 上撤下来，让处理器去忙别的任务</li><li>这时，硬盘控制器开始用 <strong>DMA（直接内存访问）</strong> 把数据搬到内存。完成后，它会给 CPU 发一个“中断”信号，报告：“货已送达！”</li><li>内核收到中断后启动对应的处理程序，把刚才的 Java 线程唤醒，将状态改为「就绪」，排队等待调度</li><li>当调度器再次分配 CPU 时间时，这个线程会 “从刚才阻塞的地方继续执行”，完成最后的 <code>copy_to_user(user_buf, page_cache_data, len)</code>。</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>所谓 “逻辑暂停”，只是从 Java 程序员的视角看，线程像被卡住了一样。实际上 CPU 并没闲着，而是在执行内核态的代码</li><li>即便你只用 <code>read()</code> 读取 <strong>1 个字节</strong>，内核访问磁盘时仍然是按 <strong>页（page）</strong> 为单位的（通常 4KB）</li><li>Page Cache 没有固定大小，而是动态伸缩的。<ol><li>如果机器有 32GB 内存，Page Cache 占个二十几 GB 都很正常，这是内核的 “贪吃” 本性</li><li>当应用程序突然需要大量内存（比如一口气要 28GB），内核会逐步回收一部分 Page Cache，把空间还给应用程序。</li><li>操作系统提供了一系列可调参数，用来影响 Page Cache 的回收与写回策略</li></ol></li></ol></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// Linux 查看内存状态</span><br>cat <span class="hljs-regexp">/proc/m</span>eminfo | <span class="hljs-keyword">grep</span> -E <span class="hljs-string">&quot;Cached|Buffers&quot;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 唤醒线程</font><br>CPU 从<strong>内核态</strong>切换回<strong>用户态</strong>，把控制权交还给 Java 线程</p><hr><h4 id="1-2-2-写流程"><a href="#1-2-2-写流程" class="headerlink" title="1.2.2. 写流程"></a>1.2.2. 写流程</h4><p>假设我们有这样一段 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);  <br>  <br>fos.write(<span class="hljs-string">&quot;Hello&quot;</span>.getBytes());  <br></code></pre></td></tr></table></figure><p><font color="#92d050">1. 获取文件描述符</font></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>与读取流程略有不同，如果目标文件不存在，写操作会先创建一个新文件，再返回对应的文件描述符</li></ol></blockquote><p><font color="#92d050">2. Java 层发起写请求</font><br><code>fos.write(&quot;Hello&quot;.getBytes())</code> 在 JVM 里其实会调用一个 native 方法（JNI），本质就是触发 <code>write(data)</code> 的系统调用。</p><p>它向内核传递了三个关键信息：</p><ol><li>文件描述符<ol><li>指明要往哪个文件写入数据</li></ol></li><li>数据源</li><li>数据长度</li></ol><p><font color="#92d050">3. 内核接管 CPU，写入到 ”高速缓存“</font><br>从这一刻开始，CPU 的执行状态会从 <strong>用户态</strong> 切换为 <strong>内核态</strong>。控制权交由操作系统内核，Java 线程在逻辑上则进入“挂起等待” 状态。</p><p>内核接手后，会先通过传入的文件描述符定位到对应的文件结构体，接着读取其中的当前读写偏移量，确定要写入的位置</p><p>然后，操作系统内核会定位或分配一块属于该文件的 <strong>Page Cache 内存页</strong>，并将你的 <code>data</code> 从 <strong>用户空间</strong> 拷贝到 <strong>内核空间的 Page Cache</strong> 中。</p><p>此时数据已经落到了内存缓存里（Page Cache），<strong>还没有真正写入硬盘</strong>！</p><p>当数据被写入 Page Cache 后，内核会在对应的内存页上打一个 “脏页” 标记，意思是，该页内存中的内容比硬盘上的副本更新，未来需要在合适的时机回写到磁盘。</p><p><font color="#92d050">4. 返回成功状态</font><br><code>write(data)</code> 系统调用在数据被写入 Page Cache 并打上“脏页”标记后，就算大功告成了。此时它会立即返回一个 “写入成功” 的状态给你的程序，CPU 也随之从 内核态 切回 用户态。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里的 “写入成功”，仅仅意味着数据已经可靠地进入了 内存缓存（Page Cache），但这并不等同于硬盘上的内容已经更新。如果在此之后系统突然崩溃，那么这些尚未来得及写入磁盘的数据依然可能丢失。</li><li>数据真正落盘的时机有：<ol><li>内核定时任务<ol><li>操作系统有一个后台进程（如 Linux 的 <code>pdflush</code> 或 <code>kworker</code>），会周期性地检查 “脏” 页。</li><li>如果一个页面“脏”了太久，就会被安排写入磁盘。</li></ol></li><li>内存压力<ol><li>当系统内存不足，需要回收一些 Page Cache 页面给其他程序使用时，如果这些页面是 “脏” 的，内核会先将它们写入磁盘，然后再回收。</li></ol></li><li>用户主动要求<ol><li>fos.flush()<ol><li>这个方法会触发一个 <code>fsync(fd)</code> 的系统调用，会将这个文件的所有 Page Cache 落盘，并等到底层存储设备报告 “写成功” 才返回</li><li>这个过程是阻塞的，确保数据持久化</li></ol></li><li>fos.close()<ol><li>关闭文件流时，它会在内部自动调用一次 <code>fos.flush()</code>，然后再释放文件描述符等资源。</li></ol></li></ol></li><li>sync 命令<ol><li>在 Linux 系统中，执行 <code>sync</code> 命令会要求内核将所有内存中的 “脏” 数据（不仅仅是你的文件）全部写入磁盘。</li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-IO-流分类"><a href="#2-IO-流分类" class="headerlink" title="2. IO 流分类"></a>2. IO 流分类</h2><p>Java IO 流分类的核心是：</p><ol><li>以数据流向分类<ol><li>输入流<ol><li>从数据源读取数据到程序中</li></ol></li><li>输出流<ol><li>将数据从程序写出到目标位置</li></ol></li></ol></li><li>以数据单位分类<ol><li>字节流<ol><li>以字节（8 bit）为基本单位进行读写</li><li>适合处理所有类型的文件，尤其是二进制文件（如图片、音频、视频等）</li></ol></li><li>字符流<ol><li>以字符为基本单位进行读写</li><li>专门为文本数据设计，仅适用于纯文本文件</li></ol></li></ol></li><li>以来源&#x2F;目的地分类（节点流）<ol><li>文件流</li><li>内存流</li><li>管道流</li><li>网络流</li></ol></li><li>在基础的节点流之上，Java 提供了一类处理流。<ol><li>处理流不能单独存在，而是通过 “包裹其他流” 来对已有流进行功能增强。</li><li>缓冲流</li><li>数据流</li><li>对象流</li><li>转换流</li><li>打印流</li><li>压缩流</li></ol></li></ol><p>IO 流侧重于前两种分类方式，又形成 IO 世界的 “四大天王”：</p><ol><li>InputStream<ol><li>字节输入流，抽象基类</li></ol></li><li>OutputStream<ol><li>字节输出流，抽象基类</li></ol></li><li>Reader<ol><li>字符输入流，抽象基类</li></ol></li><li>Writer<ol><li>字符输出流，抽象基类</li></ol></li></ol><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81-1.png"></p><p>在这四个抽象类的基础上，根据功能又可分为：</p><ol><li>文件流<ol><li>文件字节流<ol><li>FileInputStream</li><li>FileOutputStream</li></ol></li><li>文件字符流<ol><li>FileReader</li><li>FileWriter</li></ol></li></ol></li><li>缓冲流<ol><li>缓冲字节流<ol><li>BufferedInputStream</li><li>BufferedOutputStream</li></ol></li><li>缓冲字符流<ol><li>BufferedReader</li><li>BufferedWriter</li></ol></li></ol></li><li>数据流<ol><li>数据字节流<ol><li>DataInputStream</li><li>DataOutputStream</li></ol></li></ol></li><li>对象流<ol><li>对象字节流<ol><li>ObjectInputStream</li><li>ObjectOutputStream</li></ol></li></ol></li><li>转换流</li><li>序列化流</li><li>打印流</li><li>压缩流</li><li>Commons-io</li></ol><ul><li><strong>文件流</strong>：<code>FileInputStream</code>, <code>FileOutputStream</code>, <code>FileReader</code>, <code>FileWriter</code></li><li><strong>缓冲流</strong>（带缓存，加速读写）：<code>BufferedReader</code>, <code>BufferedWriter</code>, <code>BufferedInputStream</code>, <code>BufferedOutputStream</code></li><li><strong>数据流</strong>（直接读写基本数据类型）：<code>DataInputStream</code>, <code>DataOutputStream</code></li><li><strong>对象流</strong>（读写对象）：<code>ObjectInputStream</code>, <code>ObjectOutputStream</code></li><li>随机访问流（在文件任意位置读写）RandomAccessFile</li><li>转换流</li><li>序列化流</li><li>打印流</li><li>压缩流</li><li>Commons-io</li></ul><hr><h2 id="3-节点流"><a href="#3-节点流" class="headerlink" title="3. 节点流"></a>3. 节点流</h2><h3 id="3-1-文件流"><a href="#3-1-文件流" class="headerlink" title="3.1. 文件流"></a>3.1. 文件流</h3><h4 id="3-1-1-文件字节流"><a href="#3-1-1-文件字节流" class="headerlink" title="3.1.1. 文件字节流"></a>3.1.1. 文件字节流</h4><h5 id="3-1-1-1-FileInputStream"><a href="#3-1-1-1-FileInputStream" class="headerlink" title="3.1.1.1. FileInputStream"></a>3.1.1.1. FileInputStream</h5><h6 id="3-1-1-1-1-FileInputStream-概述"><a href="#3-1-1-1-1-FileInputStream-概述" class="headerlink" title="3.1.1.1.1. FileInputStream 概述"></a>3.1.1.1.1. FileInputStream 概述</h6><p><code>FileInputStream</code> 是字节输入流，用于从文件中读取原始字节数据</p><hr><h6 id="3-1-1-1-2-FileInputStream-常用方法"><a href="#3-1-1-1-2-FileInputStream-常用方法" class="headerlink" title="3.1.1.1.2. FileInputStream 常用方法"></a>3.1.1.1.2. FileInputStream 常用方法</h6><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AFileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：FileInputStream常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h5 id="3-1-1-2-FileOutputStream"><a href="#3-1-1-2-FileOutputStream" class="headerlink" title="3.1.1.2. FileOutputStream"></a>3.1.1.2. FileOutputStream</h5><h6 id="3-1-1-2-1-FileOutputStream-概述"><a href="#3-1-1-2-1-FileOutputStream-概述" class="headerlink" title="3.1.1.2.1. FileOutputStream 概述"></a>3.1.1.2.1. FileOutputStream 概述</h6><p><code>FileOutputStream</code> 是字节输出流，用于向文件写入原始字节数据</p><hr><h6 id="3-1-1-2-2-FileOutputStream-常用方法"><a href="#3-1-1-2-2-FileOutputStream-常用方法" class="headerlink" title="3.1.1.2.2. FileOutputStream 常用方法"></a>3.1.1.2.2. FileOutputStream 常用方法</h6><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AFileOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：FileOutputStream常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h4 id="3-1-2-文件字符流"><a href="#3-1-2-文件字符流" class="headerlink" title="3.1.2. 文件字符流"></a>3.1.2. 文件字符流</h4><h5 id="3-1-2-1-FileReader"><a href="#3-1-2-1-FileReader" class="headerlink" title="3.1.2.1. FileReader"></a>3.1.2.1. FileReader</h5><h6 id="3-1-2-1-1-FileReader-概述"><a href="#3-1-2-1-1-FileReader-概述" class="headerlink" title="3.1.2.1.1. FileReader 概述"></a>3.1.2.1.1. FileReader 概述</h6><p><code>FileReader</code> 是字符输入流，它用于从文件中读取文件内容，并将底层的字节自动解码为字符（根据解码方式，自动取出合适数量的字节来解码成一个完整字符）</p><p>虽然理论上字节流可以用于处理所有文件类型，但它是以 <strong>“一个字节一个字节”</strong> 的方式读数据。如果只是复制文件，这完全没问题。但如果直接拿来显示文本，就容易出现乱码，因为常见的编码方式（如 UTF-8）并不是 “一个字符 &#x3D; 一个字节”，而是<strong>可变长度编码</strong>（1～4 个字节一个字符）。这就导致逐字节解析时可能把字符拆断，显示结果自然就乱了。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>JDK 11 之前，<code>FileReader</code> 只能使用系统默认解码规则<ol><li>Mac<ol><li>UTF-8</li></ol></li><li>Linux<ol><li>UTF-8</li></ol></li><li>Windows<ol><li>GBK</li></ol></li></ol></li></ol></blockquote><hr><h6 id="3-1-2-1-2-FileReader-常用方法"><a href="#3-1-2-1-2-FileReader-常用方法" class="headerlink" title="3.1.2.1.2. FileReader 常用方法"></a>3.1.2.1.2. FileReader 常用方法</h6><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AFileReader%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：FileReader常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h5 id="3-1-2-2-FileWriter"><a href="#3-1-2-2-FileWriter" class="headerlink" title="3.1.2.2. FileWriter"></a>3.1.2.2. FileWriter</h5><h6 id="3-1-2-2-1-FileWriter-概述"><a href="#3-1-2-2-1-FileWriter-概述" class="headerlink" title="3.1.2.2.1. FileWriter 概述"></a>3.1.2.2.1. FileWriter 概述</h6><p><code>FileWriter</code> 是字符输出流，用于向文件写入字符数据</p><hr><h6 id="3-1-2-2-2-FileWriter-常用方法"><a href="#3-1-2-2-2-FileWriter-常用方法" class="headerlink" title="3.1.2.2.2. FileWriter 常用方法"></a>3.1.2.2.2. FileWriter 常用方法</h6><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AFileWriter%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：FileWriter常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h2 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4. 缓冲流"></a>4. 缓冲流</h2><h3 id="4-1-缓冲字节流"><a href="#4-1-缓冲字节流" class="headerlink" title="4.1. 缓冲字节流"></a>4.1. 缓冲字节流</h3><h4 id="4-1-1-BufferedInputStream"><a href="#4-1-1-BufferedInputStream" class="headerlink" title="4.1.1. BufferedInputStream"></a>4.1.1. BufferedInputStream</h4><h5 id="4-1-1-1-BufferedInputStream-概述"><a href="#4-1-1-1-BufferedInputStream-概述" class="headerlink" title="4.1.1.1. BufferedInputStream 概述"></a>4.1.1.1. BufferedInputStream 概述</h5><p><code>BufferedInputStream</code> 在字节节点流（任意字节节点流）之上，增加了一个默认大小为 8192 字节的内部缓冲区，从而减少底层 I&#x2F;O 调用，提高性能，同时免去了我们手动维护字节数组的麻烦。</p><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81-2.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>对于普通的字节输入流（如 <code>FileInputStream</code>），如果逐字节读取，会导致底层频繁触发 I&#x2F;O 调用，效率很低。虽然它也支持 <code>read(byte[])</code> 批量读取，但这种方式需要我们自己准备和管理字节数组。而 <code>BufferedInputStream</code> 内部自带一个缓冲区（默认 8192 字节）。当缓存耗尽时，它会一次性尽量把缓冲区填满，这样接下来无论你是逐字节读取，还是用自己的外部数组接收数据，都优先从内存缓冲区取，避免频繁访问底层流</li><li>实际代码中，我们仍常常会声明一个外部的 <code>byte[] b</code> 来装数据。这看似是 “缓存套缓存”，但别担心，内部缓冲负责减少系统 I&#x2F;O 调用，外部数组只是从内部缓存搬数据到用户逻辑做处理。内存中的拷贝开销极小，几乎可以忽略，而且速度极快，两者结合大大提高了整体性能</li></ol></blockquote><hr><h5 id="4-1-1-2-BufferedInputStream-常用方法"><a href="#4-1-1-2-BufferedInputStream-常用方法" class="headerlink" title="4.1.1.2. BufferedInputStream 常用方法"></a>4.1.1.2. BufferedInputStream 常用方法</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ABufferedInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：BufferedInputStream常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h4 id="4-1-2-BufferedOutputStream"><a href="#4-1-2-BufferedOutputStream" class="headerlink" title="4.1.2. BufferedOutputStream"></a>4.1.2. BufferedOutputStream</h4><h5 id="4-1-2-1-BufferedOutputStream-概述"><a href="#4-1-2-1-BufferedOutputStream-概述" class="headerlink" title="4.1.2.1. BufferedOutputStream 概述"></a>4.1.2.1. BufferedOutputStream 概述</h5><p><code>BufferedOutputStream</code> 同样在字节节点流（任意字节节点流）之上，增加了一个默认大小为 8192 字节的内部缓冲区，从而减少底层 I&#x2F;O 调用，提高性能，同时免去了我们手动维护字节数组的麻烦。</p><hr><h5 id="4-1-2-2-BufferedOutputStream-常用方法"><a href="#4-1-2-2-BufferedOutputStream-常用方法" class="headerlink" title="4.1.2.2. BufferedOutputStream 常用方法"></a>4.1.2.2. BufferedOutputStream 常用方法</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ABufferedOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：BufferedOutputStream常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h3 id="4-2-缓冲字符流"><a href="#4-2-缓冲字符流" class="headerlink" title="4.2. 缓冲字符流"></a>4.2. 缓冲字符流</h3><h4 id="4-2-1-BufferedReader"><a href="#4-2-1-BufferedReader" class="headerlink" title="4.2.1. BufferedReader"></a>4.2.1. BufferedReader</h4><h5 id="4-2-1-1-BufferedReader-概述"><a href="#4-2-1-1-BufferedReader-概述" class="headerlink" title="4.2.1.1. BufferedReader 概述"></a>4.2.1.1. BufferedReader 概述</h5><p><code>BufferedReader</code> 同样在字符节点流（任意字符节点流）之上，增加了一个默认大小为 8192 字节的内部缓冲区，从而减少底层 I&#x2F;O 调用，提高性能，同时免去了我们手动维护字节数组的麻烦。</p><hr><h5 id="4-2-1-2-BufferedReader-常用方法"><a href="#4-2-1-2-BufferedReader-常用方法" class="headerlink" title="4.2.1.2. BufferedReader 常用方法"></a>4.2.1.2. BufferedReader 常用方法</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ABufferedReader%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：BufferedReader常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h4 id="4-2-2-BufferedWriter"><a href="#4-2-2-BufferedWriter" class="headerlink" title="4.2.2. BufferedWriter"></a>4.2.2. BufferedWriter</h4><h5 id="4-2-2-1-BufferedWriter-概述"><a href="#4-2-2-1-BufferedWriter-概述" class="headerlink" title="4.2.2.1. BufferedWriter 概述"></a>4.2.2.1. BufferedWriter 概述</h5><p><code>BufferedWriter</code> 同样在字符节点流（任意字符节点流）之上，增加了一个默认大小为 8192 字节的内部缓冲区，从而减少底层 I&#x2F;O 调用，提高性能，同时免去了我们手动维护字节数组的麻烦。</p><hr><h5 id="4-2-2-2-BufferedWriter-常用方法"><a href="#4-2-2-2-BufferedWriter-常用方法" class="headerlink" title="4.2.2.2. BufferedWriter 常用方法"></a>4.2.2.2. BufferedWriter 常用方法</h5><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9ABufferedWriter%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：BufferedWriter常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h2 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5. 转换流"></a>5. 转换流</h2><h2 id="6-对象流"><a href="#6-对象流" class="headerlink" title="6. 对象流"></a>6. 对象流</h2><h3 id="6-1-对象流概述"><a href="#6-1-对象流概述" class="headerlink" title="6.1. 对象流概述"></a>6.1. 对象流概述</h3><p>对象流也常被称为 序列化流 &#x2F; 反序列化流，能够把 Java 内存中的对象序列化为 字节流，并且可以再从字节流中反序列化恢复成原始对象，这使得对象可以方便地 持久化到文件 或 通过网络传输。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>序列化的结果是 <strong>字节流</strong>，而不是字符流。字符流只适合处理文本数据；对象序列化必须通过字节流来表达。</li><li>被序列化的类，必须实现 <code>Serializable</code> 接口。这个接口是一个标记接口，是通过 “接口” 的形式，给 JVM 或相关的类库打个标记，说：“这个类支持某种特性”，而只要我们 Implements Serializable，他就告诉 JVM 这个类的对象可以被序列化和反序列化</li></ol></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Serializable</span> &#123; <br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>3. 序列化&#x2F;反序列化，一定要注意固定 serialVersionUID<br>    1. 我们之前定义了一个可序列化的类，如果对象已经序列化写入文件，当我们修改了类的结构（比如新增字段、修改字段类型等），在反序列化时就会报错<br>    2. 这是因为 Java 在序列化时会自动为类生成一个 serialVersionUID（版本号），并将其写入序列化文件。<br>    3. 反序列化时，JVM 会检查本地类的 serialVersionUID 是否与文件中存储的一致，如果不一致，就会抛出 <code>InvalidClassException</code>。<br>    4. 因此，我们通常会手动指定一个固定的 <strong>serialVersionUID</strong>，以避免因类结构的轻微调整导致反序列化失败：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;  <br><br>    <span class="hljs-comment">// 固定写法，建议不要修改</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;  <br><br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>4. 在 IDEA 中，可以开启这两个选项，这样当我们实现类 <code>Serializable</code> 接口但未定义 <code>serialVersionUID</code> 时会提醒你，并可以自动计算出一个 UID</p></blockquote><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81/%E7%AC%94%E8%AE%B0%EF%BC%9AJavaIO%E6%B5%81-3.png"></p><hr><h3 id="6-2-ObjectInputStream"><a href="#6-2-ObjectInputStream" class="headerlink" title="6.2. ObjectInputStream"></a>6.2. ObjectInputStream</h3><h4 id="6-2-1-ObjectInputStream-概述"><a href="#6-2-1-ObjectInputStream-概述" class="headerlink" title="6.2.1. ObjectInputStream 概述"></a>6.2.1. ObjectInputStream 概述</h4><p><code>ObjectInputStream</code> 用于从底层的字节输入流中 <strong>反序列化</strong>（deserialize）对象，也就是说，把字节流还原成 Java 对象</p><hr><h4 id="6-2-2-ObjectInputStream-常用方法"><a href="#6-2-2-ObjectInputStream-常用方法" class="headerlink" title="6.2.2. ObjectInputStream 常用方法"></a>6.2.2. ObjectInputStream 常用方法</h4><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AObjectInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：ObjectInputStream常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h3 id="6-3-ObjectOutputStream"><a href="#6-3-ObjectOutputStream" class="headerlink" title="6.3. ObjectOutputStream"></a>6.3. ObjectOutputStream</h3><h4 id="6-3-1-ObjectOutputStream-概述"><a href="#6-3-1-ObjectOutputStream-概述" class="headerlink" title="6.3.1. ObjectOutputStream 概述"></a>6.3.1. ObjectOutputStream 概述</h4><p><code>ObjectOutputStream</code> 用于把 Java 内存中的对象序列化为字节流</p><hr><h4 id="6-3-2-ObjectOutputStream-常用方法"><a href="#6-3-2-ObjectOutputStream-常用方法" class="headerlink" title="6.3.2. ObjectOutputStream 常用方法"></a>6.3.2. ObjectOutputStream 常用方法</h4><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AObjectOutputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：ObjectOutputStream常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol><hr><h2 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7. 打印流"></a>7. 打印流</h2><h3 id="7-1-字节打印流"><a href="#7-1-字节打印流" class="headerlink" title="7.1. 字节打印流"></a>7.1. 字节打印流</h3><h4 id="7-1-1-PrintStream"><a href="#7-1-1-PrintStream" class="headerlink" title="7.1.1. PrintStream"></a>7.1.1. PrintStream</h4><h3 id="7-2-字符打印流"><a href="#7-2-字符打印流" class="headerlink" title="7.2. 字符打印流"></a>7.2. 字符打印流</h3><h4 id="7-2-1-PrintWriter"><a href="#7-2-1-PrintWriter" class="headerlink" title="7.2.1. PrintWriter"></a>7.2.1. PrintWriter</h4><hr><h2 id="8-压缩流"><a href="#8-压缩流" class="headerlink" title="8. 压缩流"></a>8. 压缩流</h2><h3 id="8-1-压缩流"><a href="#8-1-压缩流" class="headerlink" title="8.1. 压缩流"></a>8.1. 压缩流</h3><h3 id="8-2-解压缩流"><a href="#8-2-解压缩流" class="headerlink" title="8.2. 解压缩流"></a>8.2. 解压缩流</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java IO 流</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 数据类型</title>
    <link href="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、脑图"><a href="#一、脑图" class="headerlink" title="一、脑图"></a>一、脑图</h1><ol><li><p>Xmind<br><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1.xmind"></p></li><li><p>Edraw<br><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.eddx"></p></li></ol><hr><h1 id="三、基本数据类型"><a href="#三、基本数据类型" class="headerlink" title="三、基本数据类型"></a>三、基本数据类型</h1><table><thead><tr><th>名称</th><th>范围</th><th>描述</th><th>默认值</th><th>赋值示例</th></tr></thead><tbody><tr><td><strong>数值类型</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><code>byte</code></td><td>1 字节（8 bit），-128 ~ 127</td><td>小范围整数</td><td><code>0</code></td><td><code>byte b = 100;</code></td></tr><tr><td><code>short</code></td><td>2 字节（16 bit），-32,768 ~ 32,767</td><td>稍大范围整数</td><td><code>0</code></td><td><code>short s = 3000;</code></td></tr><tr><td><code>int</code></td><td>4 字节（32 bit），-2³¹ ~ 2³¹-1</td><td>常规整数</td><td><code>0</code></td><td><code>int i = 1000000;</code></td></tr><tr><td><code>long</code></td><td>8 字节（64 bit），2⁶³ ~ 2⁶³-1</td><td>非常大的整数</td><td><code>0L</code></td><td><code>long l = 9876543210L;</code></td></tr><tr><td><code>float</code></td><td>4 字节（32 bit），7 位十进制精度</td><td>常规浮点数，单精度，精度较低</td><td><code>0.0F</code></td><td><code>float f = 3.14F;</code></td></tr><tr><td><code>double</code></td><td>8 字节（64 bit），15 ~ 16 位十进制精度</td><td>双精度浮点数，精度高，适合科学计算</td><td><code>0.0</code></td><td><code>double d = 0.00004567;</code></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>字符类型</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><code>char</code></td><td>2 字节（16 bit）</td><td>单个字符</td><td><code>\u0000</code></td><td><code>char c = &#39;A&#39;;</code></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>布尔类型</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><code>boolean</code></td><td>1 字节（8 bit）</td><td></td><td><code>false</code></td><td><code>boolean flag = true;</code></td></tr></tbody></table><blockquote><p>[!NOTE] 注意事项</p><ol><li>数据类型转换<ol><li>赋值时<ol><li>小数据类型的值赋值给大数据类型的变量时，Java 会自动进行类型转换<ol><li><code>byte</code> → <code>short</code> → <code>int</code> → <code>long</code> → <code>float</code> → <code>double</code></li><li><code>char</code> → <code>int</code> → <code>long</code> → <code>float</code> → <code>double</code></li><li>由于 <code>long</code> 为 8 字节，<code>float</code> 为 4 字节，将 <code>long</code> → <code>float</code> 时，超出 <code>float</code> 精度范围的部分就会被舍弃，导致精度丢失</li></ol></li><li>大数据类型的值赋值给小数据类型的变量时，必须进行强制类型转换<ol><li>大的整数类型转换为小的整数类型时，会发生截断，只保留低位字节，数值可能发生较大变化</li><li>浮点数转换为整数时，小数部分会被直接截掉（不是四舍五入）</li></ol></li></ol></li><li>算术时<ol><li>算术运算中，如果操作数类型不同，Java 会将它们自动提升到最高精度的类型再计算</li><li>需要注意的是，在算术前，<code>byte</code>、<code>short</code>、<code>char</code> 会先提升为 <code>int</code>。因此，只要涉及到这三种类型，结果至少是 <code>int</code>。例如：<code>short + float</code> → <code>int + float</code> → 结果为 <code>float</code></li></ol></li></ol></li><li>建议在书写 <code>long</code> 和 <code>float</code> 的值时养成习惯加上后缀 <code>L</code> 和 <code>F</code>，这样能避免歧义，提高代码可读性</li><li>为 <code>char</code> 类型赋值时，例如 <code>char c = &#39;A&#39;;</code>，实际存储的是字符对应的 Unicode 编码。<ol><li>输出时，如果类型是 <code>char</code>，Java 会自动将该编码转换回对应字符，因此输出仍然是 <code>&#39;A&#39;</code></li><li>如果将 <code>char</code> 类型转换为 <code>int</code> 并输出，结果就是对应的 Unicode 编码值，输出的就是 65</li></ol></li></ol></blockquote><hr><h1 id="四、引用数据类型"><a href="#四、引用数据类型" class="headerlink" title="四、引用数据类型"></a>四、引用数据类型</h1><h2 id="1-类（class）"><a href="#1-类（class）" class="headerlink" title="1. 类（class）"></a>1. 类（class）</h2><h3 id="1-1-具体类"><a href="#1-1-具体类" class="headerlink" title="1.1. 具体类"></a>1.1. 具体类</h3><h4 id="1-1-1-简单类（POJO-类）"><a href="#1-1-1-简单类（POJO-类）" class="headerlink" title="1.1.1. 简单类（POJO 类）"></a>1.1.1. 简单类（POJO 类）</h4><h5 id="1-1-1-1-POJO-类概述"><a href="#1-1-1-1-POJO-类概述" class="headerlink" title="1.1.1.1. POJO 类概述"></a>1.1.1.1. POJO 类概述</h5><p><strong>POJO 类（Plain Old Java Object）</strong> 全称为 “普通的老式 Java 对象”，这个术语最早是为对抗 EJB（臃肿的企业 Java Bean）而提出的，旨在回归简单、纯粹的 Java 编程风格</p><p>其特点如下：</p><ol><li>不实现特定的接口</li><li>不继承任何特定的父类</li><li>不包含业务逻辑或复杂方法</li><li>仅包含属性、构造方法（无参构造、有参构造）、Getter、Setter、equals、hashCode、toString 等基本方法</li></ol><p>这种类通常用于数据封装与传递，可以简单理解为：“它啥也不干，只负责<strong>装数据</strong>、<strong>传递数据</strong>”。</p><hr><h5 id="1-1-1-2-Entity-类（DO、PO）"><a href="#1-1-1-2-Entity-类（DO、PO）" class="headerlink" title="1.1.1.2. Entity 类（DO、PO）"></a>1.1.1.2. Entity 类（DO、PO）</h5><p><code>Entity</code> 类通常用于映射数据库表，一个 <code>Entity</code> 对象对应表中的一条记录，常见于 ORM 框架，如 Hibernate、JPA、MyBatis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-comment">// 属性（private，建议使用包装类支持 null）</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String firstName;<br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-keyword">private</span> String email;<br><br><span class="hljs-comment">// 其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="1-1-1-3-DTO-类"><a href="#1-1-1-3-DTO-类" class="headerlink" title="1.1.1.3. DTO 类"></a>1.1.1.3. DTO 类</h5><p><code>DTO</code> 类专门用来 在不同系统或不同层之间传递数据。例如，在微服务架构中用于跨系统调用，或者前端向后端发送请求时，后端接收并返回 <code>DTO</code> 对象给前端。</p><hr><h5 id="1-1-1-4-VO-类"><a href="#1-1-1-4-VO-类" class="headerlink" title="1.1.1.4. VO 类"></a>1.1.1.4. VO 类</h5><p><code>VO</code> 类专门用来 展示给前端或视图层的数据对象。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>VO</code> 更倾向于前端展示，<code>DTO</code> 更倾向于传输</li></ol></blockquote><hr><h5 id="1-1-1-5-BO-类"><a href="#1-1-1-5-BO-类" class="headerlink" title="1.1.1.5. BO 类"></a>1.1.1.5. BO 类</h5><p><code>BO</code> 类用于封装业务逻辑和业务数据，通常在业务层（Service 层）使用。如果业务层逻辑简单，可以直接用 <code>Entity</code> 代替 <code>BO</code>；当业务复杂时，<code>BO</code> 则发挥重要作用。</p><hr><h4 id="1-1-2-复杂类"><a href="#1-1-2-复杂类" class="headerlink" title="1.1.2. 复杂类"></a>1.1.2. 复杂类</h4><p>复杂类是我们平时编写的类，它们不像 POJO 类那样有严格限制，通常包含更多业务逻辑或功能。</p><hr><h4 id="1-1-3-包装类"><a href="#1-1-3-包装类" class="headerlink" title="1.1.3. 包装类"></a>1.1.3. 包装类</h4><p>Java 是一门面向对象的语言，但它的基本数据类型（如 <code>int</code>、<code>char</code> 等）并不是对象，所以 Java 提供了包装类让这些基本类型也能在需要 “对象” 的场景中被使用：</p><ol><li>包装类可以为 <code>null</code><ol><li>这在 ORM 框架中非常有用，因为你也不确定数据库里到底有没有这个值，会不会是 <code>null</code></li></ol></li><li>包装类可以存入集合<ol><li>集合中只能存入对象，不能存入基本数据类型</li><li>而我们使用包装类，就可以直接存入集合中</li></ol></li><li>包装类可以使用更多的方法</li></ol><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>byte</td><td>Byte</td></tr></tbody></table><blockquote><p>[!NOTE] 注意事项</p><ol><li>包装类提供了自动装箱 &#x2F; 拆箱的机制：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;           <span class="hljs-comment">// 自动装箱 int -&gt; Integer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">5</span>;            <span class="hljs-comment">// 自动拆箱 Integer -&gt; int</span><br></code></pre></td></tr></table></figure><hr><h3 id="1-2-类的特性"><a href="#1-2-类的特性" class="headerlink" title="1.2. 类的特性"></a>1.2. 类的特性</h3><h4 id="1-2-1-类的继承"><a href="#1-2-1-类的继承" class="headerlink" title="1.2.1. 类的继承"></a>1.2.1. 类的继承</h4><h5 id="1-2-1-1-匿名内部类继承"><a href="#1-2-1-1-匿名内部类继承" class="headerlink" title="1.2.1.1. 匿名内部类继承"></a>1.2.1.1. 匿名内部类继承</h5><p>匿名内部类是四种内部类之一，主要用于继承某个类或实现某个接口。它的特点是不需要单独定义类名（因为是匿名的），因此能让代码更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <br><span class="hljs-comment">// 创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;myThread&quot;</span>) &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-comment">// 本线程要执行的任务  </span><br>            &#125;  <br>        &#125;;  <br>          <br>        <span class="hljs-comment">// 启动线程  </span><br>        myThread.start();  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>判断是否是匿名内部类，可以看 <code>new</code> 的写法：</p><ol><li>new Thread()<ol><li>只是创建一个 普通的 Thread 对象</li></ol></li><li>new Thread() { … }<ol><li>创建的是 匿名内部类对象</li></ol></li></ol><p>在编译时，编译器会自动生成两个字节码文件，一个是 <code>Demo.class</code>，另一个是 <code>Demo$1.class</code>。这个自动生成的类继承了 Thread 类，并重写了 <code>run</code> 方法。</p><p>当执行到 <code>Thread myThread = new Thread(&quot;myThread&quot;) &#123; ... &#125;;</code> 时，JVM 会像处理普通类一样，将 <code>Demo$1.class</code> 加载到方法区，并在堆区创建这个对象实例，赋值给变量 <code>myThread</code>。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>使用匿名类创建了临时的类对象，方法执行完后如果栈帧中没有对该对象的引用，它可能会在下一次 GC 时就被回收</li><li>但它对应的类信息仍然会加载到方法区，而且我们知道方法区中的类卸载条件非常严格，所以必须明确匿名类的适用范围：<ol><li>如果只是临时封装逻辑，使用匿名类是合适的<ol><li>但如果需要在两处及以上复用同一段逻辑，匿名类就不太合适</li></ol></li><li>匿名类不支持灵活传参，若需要传参灵活，建议避免使用匿名类</li><li>在事件驱动或回调场景中，匿名类则非常适用</li></ol></li></ol></blockquote><hr><h5 id="1-2-1-2-显示声明类继承"><a href="#1-2-1-2-显示声明类继承" class="headerlink" title="1.2.1.2. 显示声明类继承"></a>1.2.1.2. 显示声明类继承</h5><p>显式声明类，是指无论你是直接定义一个类对象，还是在某个类中编写成员内部类、静态内部类、局部内部类等嵌套类，总之你都是明确地定义了一个具名类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 本线程要执行的任务  </span><br>  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>类只能继承一个父类，但是能实现多个接口</li><li>在 Java 中，所有类最终都继承自 <code>java.lang.Object</code>。即使在定义类时没有显式写出 <code>extends</code>。Object 类作为祖宗类，提供了一些常用的方法：<ol><li>toString()</li><li>equals(Object)</li><li>hashCode()</li><li>getClass()</li><li>clone()</li><li>wait()&#x2F;notify()&#x2F;notifyAll()</li><li>finalize()</li><li>这些方法，有一些你看不到它的代码块，这是因为他是 native 方法，是使用 C &#x2F; C++ 等底层语言在 JVM 内部实现的</li></ol></li><li>父类的属性和方法在访问修饰符选择上需要仔细斟酌：<ol><li>public<ol><li>天下皆友</li></ol></li><li>protected<ol><li>同包 + 子女特权</li></ol></li><li>package-private<ol><li>同包是朋友，子类靠边站</li></ol></li><li>pivate<ol><li>独守秘密</li></ol></li></ol></li><li>当我们去 new 一个子类对象的时候，它会先去调用父类的构造方法<ol><li>父类有无参构造<ol><li>如果子类构造器中没有显示调用 super()，Java 编译器会在子类构造方法中的第一行自动插入一个 super 调用</li></ol></li><li>父类无无参构造<ol><li>子类必须在其构造方法中使用 super(…) ，向父类构造方法传入参数来显示调用父类的带参构造器</li></ol></li></ol></li><li>字段方面的继承<ol><li>对于静态变量和静态常量，看似我们的子类继承了，但是其实我们访问的还是父类中定义的，修改的还是父类中定义的，内存地址都不变的</li><li>对于实例变量和实例常量，我们的子类是真实继承了的</li><li>我们可以在子类中自己声明一些父类没有的字段</li></ol></li><li>方法方面的继承<ol><li>子类可以通过 super.method() 的方法去调用父类的方法。但是如果父类方法没有被子类重写，那么子类中直接调用 method() 也是一样的效果</li><li>子类也可以去根据需要去重写父类的方法，这样再去调用这个方法，就不是默认的调用父类的方法了，而是调用我们重写的方法，想要调用父类的方法还是需要调用 super.method()</li><li>如果父类是抽象类，那么具体子类必须实现父类中所有的抽象方法<ol><li>如果子类本身还是抽象类，则可以不去实现这些方法，把责任继续 “往下传”</li><li>如果父类继承了其他抽象类或实现了接口，但还没重写&#x2F;实现的方法，所有未重写&#x2F;实现的方法，都需要在最终的具体子类中重写&#x2F;实现</li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-数组（Array）"><a href="#2-数组（Array）" class="headerlink" title="2. 数组（Array）"></a>2. 数组（Array）</h2><h3 id="2-1-Array"><a href="#2-1-Array" class="headerlink" title="2.1. Array"></a>2.1. Array</h3><p>数组是 Java 内置的数据结构，用于存储<strong>固定大小</strong>且<strong>类型相同</strong>的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建方式 1</span><br>T[] arrayName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[n];<br><br><br><span class="hljs-comment">// 创建方式 2</span><br>String[] names = &#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Spike&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>数组本身没有方法，只有 <code>length</code> 属性用于获取长度。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br><br>System.out.println(nums.length); <br></code></pre></td></tr></table></figure><hr><h3 id="2-2-Arrays"><a href="#2-2-Arrays" class="headerlink" title="2.2. Arrays"></a>2.2. Arrays</h3><p><code>Arrays</code> 是 Java 为了弥补数组功能的限制，专门提供用于操作数组的工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br><br>Arrays.sort(nums);<br></code></pre></td></tr></table></figure><hr><h2 id="3-集合"><a href="#3-集合" class="headerlink" title="3. 集合"></a>3. 集合</h2><h3 id="3-1-Set"><a href="#3-1-Set" class="headerlink" title="3.1. Set"></a>3.1. Set</h3><h4 id="3-1-1-Set-概述"><a href="#3-1-1-Set-概述" class="headerlink" title="3.1.1. Set 概述"></a>3.1.1. Set 概述</h4><p><code>Set</code> 是一种集合类型，元素唯一，重复元素会自动去除，适合用于去重或集合运算（如交集、并集、差集）</p><hr><h4 id="3-1-2-Set-基础体系"><a href="#3-1-2-Set-基础体系" class="headerlink" title="3.1.2. Set 基础体系"></a>3.1.2. Set 基础体系</h4><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4.png"></p><hr><h4 id="3-1-3-HashSet"><a href="#3-1-3-HashSet" class="headerlink" title="3.1.3. HashSet"></a>3.1.3. HashSet</h4><h5 id="3-1-3-1-HashSet-体系位置"><a href="#3-1-3-1-HashSet-体系位置" class="headerlink" title="3.1.3.1. HashSet 体系位置"></a>3.1.3.1. HashSet 体系位置</h5><hr><h3 id="3-2-Map"><a href="#3-2-Map" class="headerlink" title="3.2. Map"></a>3.2. Map</h3><h4 id="3-2-1-Map-概述"><a href="#3-2-1-Map-概述" class="headerlink" title="3.2.1. Map 概述"></a>3.2.1. Map 概述</h4><p><code>Map</code> 是一种存储键值对（key-value）的集合，每个元素包含 <strong>key</strong> 和 <strong>value</strong>，可以通过 key 快速获取对应的 value。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>key</code> 是唯一的，<code>value</code> 可以重复</li></ol></blockquote><hr><h4 id="3-2-2-Map-基础体系"><a href="#3-2-2-Map-基础体系" class="headerlink" title="3.2.2. Map 基础体系"></a>3.2.2. Map 基础体系</h4><hr><h4 id="3-2-3-ConcurrentHashMap"><a href="#3-2-3-ConcurrentHashMap" class="headerlink" title="3.2.3. ConcurrentHashMap"></a>3.2.3. ConcurrentHashMap</h4><h5 id="3-2-3-1-ConcurrentHashMap-体系位置"><a href="#3-2-3-1-ConcurrentHashMap-体系位置" class="headerlink" title="3.2.3.1. ConcurrentHashMap 体系位置"></a>3.2.3.1. ConcurrentHashMap 体系位置</h5><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5.png"></p><hr><h3 id="3-3-Queue"><a href="#3-3-Queue" class="headerlink" title="3.3. Queue"></a>3.3. Queue</h3><h4 id="3-3-1-Queue-概述"><a href="#3-3-1-Queue-概述" class="headerlink" title="3.3.1. Queue 概述"></a>3.3.1. Queue 概述</h4><hr><h4 id="3-3-2-Queue-基础体系"><a href="#3-3-2-Queue-基础体系" class="headerlink" title="3.3.2. Queue 基础体系"></a>3.3.2. Queue 基础体系</h4><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3.png"></p><ol><li>Iterable＜E＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AIterable%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Iterable＜E＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>Collection＜E＞ 源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9ACollection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Collection＜E＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li><li>Queue＜E＞源码解析<ol><li>obsidian 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AQueue%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：Queue＜E＞源码解析</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 Java 社区的惯例中，集合类的泛型参数通常使用 <code>E</code> 来表示元素类型</li></ol></blockquote><hr><h4 id="3-3-3-Queue-分类"><a href="#3-3-3-Queue-分类" class="headerlink" title="3.3.3. Queue 分类"></a>3.3.3. Queue 分类</h4><ol><li>阻塞队列<ol><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>LinkedBlockingDeque</li><li>PriorityBlockingQueue</li><li>DelayQueue</li><li>SynchronousQueue</li><li>LinkedTransferQueue</li></ol></li><li>非阻塞队列<ol><li>PriorityQueue</li><li>ConcurrentLinkedQueue</li><li>ConcurrentLinkedDeque</li></ol></li></ol><table><thead><tr><th align="center">类名</th><th align="center">是否阻塞</th><th align="center">是否有界</th><th align="center">是否支持双端</th><th align="center">是否线程安全</th><th align="center">是否支持延迟</th><th align="center">是否支持优先级</th></tr></thead><tbody><tr><td align="center"><strong>阻塞队列</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ArrayBlockingQueue</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">LinkedBlockingQueue</td><td align="center">✅</td><td align="center">✅（可设）</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">LinkedBlockingDeque</td><td align="center">✅</td><td align="center">✅（可设）</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">PriorityBlockingQueue</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td align="center">DelayQueue</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">SynchronousQueue</td><td align="center">✅</td><td align="center">✅（0）</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">LinkedTransferQueue</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center"><strong>非阻塞队列</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">PriorityQueue</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td align="center">ConcurrentLinkedQueue</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">ConcurrentLinkedDeque</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr></tbody></table><hr><h4 id="3-3-4-阻塞队列"><a href="#3-3-4-阻塞队列" class="headerlink" title="3.3.4. 阻塞队列"></a>3.3.4. 阻塞队列</h4><h5 id="3-3-4-1-ArrayBlockingQueue"><a href="#3-3-4-1-ArrayBlockingQueue" class="headerlink" title="3.3.4.1. ArrayBlockingQueue"></a>3.3.4.1. ArrayBlockingQueue</h5><h6 id="3-3-4-1-1-ArrayBlockingQueue-概述"><a href="#3-3-4-1-1-ArrayBlockingQueue-概述" class="headerlink" title="3.3.4.1.1. ArrayBlockingQueue 概述"></a>3.3.4.1.1. ArrayBlockingQueue 概述</h6><p><code>ArrayBlockingQueue</code> 是一种基于数组实现的有界阻塞队列，容量在创建时指定且固定不变。</p><hr><h6 id="3-3-4-1-2-ArrayBlockingQueue-体系结构"><a href="#3-3-4-1-2-ArrayBlockingQueue-体系结构" class="headerlink" title="3.3.4.1.2. ArrayBlockingQueue 体系结构"></a>3.3.4.1.2. ArrayBlockingQueue 体系结构</h6><p><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2.png"></p><hr><h6 id="3-3-4-1-3-ArrayBlockingQueue-常用方法"><a href="#3-3-4-1-3-ArrayBlockingQueue-常用方法" class="headerlink" title="3.3.4.1.3. ArrayBlockingQueue 常用方法"></a>3.3.4.1.3. ArrayBlockingQueue 常用方法</h6><ol><li>obsidian 内部链接：<ol><li><a href="%E6%96%B9%E6%B3%95%EF%BC%9AArrayBlockingQueue%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.md">方法：ArrayBlockingQueue常用方法</a></li></ol></li><li>Hexo 链接：<ol><li></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 数据类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Spring Task</title>
    <link href="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpringTask/"/>
    <url>/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpringTask/</url>
    
    <content type="html"><![CDATA[<h1 id="一、理论"><a href="#一、理论" class="headerlink" title="一、理论"></a>一、理论</h1><h2 id="Spring-Task-概述"><a href="#Spring-Task-概述" class="headerlink" title="Spring Task 概述"></a>Spring Task 概述</h2><p>Spring Task 是 Spring 框架提供的任务调度和异步执行工具，它的核心作用是让你不用手动管理线程或定时器，也能轻松完成定时任务和异步任务的执行。</p><hr><h2 id="Spring-Task-相关注解"><a href="#Spring-Task-相关注解" class="headerlink" title="Spring Task 相关注解"></a>Spring Task 相关注解</h2><h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Repeatable(Schedules.class)</span><br><span class="hljs-meta">@Reflective</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Scheduled &#123;<br><br><span class="hljs-comment">// Spring 的特殊标记，表示 CRON 任务被禁用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">CRON_DISABLED</span> <span class="hljs-operator">=</span> ScheduledTaskRegistrar.CRON_DISABLED;<br><br><span class="hljs-comment">// 设置 CRON 表达式，例如：@Scheduled(cron = &quot;0 0 12 * * ?&quot;)</span><br>String <span class="hljs-title function_">cron</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 设置时区，如果不设置，默认使用 JVM 系统时区，例如：@Scheduled(cron = &quot;0 0 12 * * ?&quot;, zone = &quot;Asia/Shanghai&quot;)</span><br>String <span class="hljs-title function_">zone</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 设置执行固定频率，上次任务未完成也会再次执行，例如：@Scheduled(fixedRate = 5000)</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">fixedRate</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 与 fixedRate 类似，但可以用字符串指定值，方便由配置文件中读取，例如：@Scheduled(fixedRateString = &quot;$&#123;my.task.rate&#125;&quot;) </span><br>String <span class="hljs-title function_">fixedRateString</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 设置执行固定延迟，上次任务完成后，等待固定时间再次执行，例如：@Scheduled(fixedDelay = 5000)</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">fixedDelay</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 与 fiexdDelay 类似，但可以用字符串指定值，方便由配置文件中读取</span><br>String <span class="hljs-title function_">fixedDelayString</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 设置项目启动后，延迟多久进行第一次执行，例如：@Scheduled(fixedRate = 5000, initialDelay = 10000) </span><br><span class="hljs-type">long</span> <span class="hljs-title function_">initialDelay</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 与 initialDelayString 类似，但可以用字符串指定值，方便由配置文件中读取</span><br>String <span class="hljs-title function_">initialDelayString</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 上面 fixedRate、fiexdDelay、initialDelay 的单位</span><br>TimeUnit <span class="hljs-title function_">timeUnit</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> TimeUnit.MILLISECONDS;<br><br><span class="hljs-comment">// 指定使用那个 TaskScheduler 来调度任务，默认使用 Spring 提供的线程池</span><br>String <span class="hljs-title function_">scheduler</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="CRON-表达式"><a href="#CRON-表达式" class="headerlink" title="CRON 表达式"></a>CRON 表达式</h2><p>CRON 表达式是一种用来 定义时间调度规则的字符串，通常用于定时任务，用来告诉系统 何时执行某个任务，在 Spring Task、Quartz 等 Java 定时任务框架中非常常用。</p><p>其基本写法为：<br><img src="/2025/08/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpringTask/%E7%AC%94%E8%AE%B0%EF%BC%9ASpringTask.png"><br>例如下面的代码，表示任务每天中午 12 点，第 0 分，第 0 秒，执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">12</span> * * ?<br></code></pre></td></tr></table></figure><p>另外，CRON 表达式还可以包含一些特殊符号来定义更加灵活的定时规则</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>每一个值</td><td><code>0 * * * * ?</code> 表示 每分钟执行一次</td></tr><tr><td><code>,</code></td><td>枚举值</td><td><code>0 0,15,30,45 * * * ?</code> 表示 每小时，第 0、15、30、45 分，第 0 秒 执行一次</td></tr><tr><td><code>-</code></td><td>区间</td><td><code>0 0 10-12 * * ?</code> 表示 每天 10 点到 12 点，第 0 分，第 0 秒执行一次</td></tr><tr><td><code>/</code></td><td>步长</td><td><code>0 0/5 * * * ?</code> 表示 每小时，从 0 分开始，每 5 分钟执行一次</td></tr><tr><td><code>?</code></td><td>不指定</td><td></td></tr><tr><td><code>L</code></td><td>最后</td><td><code>0 59 23 L * ?</code> 表示 每个月，最后一天第 23 个小时，第 59 分，第 0 秒，执行一次</td></tr><tr><td><code>W</code></td><td>日字段专用，表示离该日最近的工作日</td><td><code>0 0 10 15W * ?</code> 表示 每个月，离15号最近的工作日，第 10 小时，第 0 分，第 0 秒，执行一次</td></tr><tr><td><code>#</code></td><td>星期字段专用，表示第几个星期几</td><td><code>0 0 9 ? * 2#1</code> 表示 每个月，第 1 个星期的星期 1，第 9 小时，第 0 分，第 0 秒，执行一次</td></tr></tbody></table><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 CRON 表达式中，日和星期可能会产生冲突，因此至少其中一个需要使用 <code>?</code> 表示 “不指定”</li></ol></blockquote><hr><h1 id="二、实操"><a href="#二、实操" class="headerlink" title="二、实操"></a>二、实操</h1><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h4><ol><li>Web<ol><li>Spring Web</li></ol></li></ol><hr><h4 id="开启支持任务调度"><a href="#开启支持任务调度" class="headerlink" title="开启支持任务调度"></a>开启支持任务调度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableScheduling</span>  <span class="hljs-comment">// 开启支持任务调度</span><br><span class="hljs-meta">@SpringBootApplication</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringTaskApplication</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        SpringApplication.run(SpringTaskApplication.class, args);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="标注-Scheduled-注解"><a href="#标注-Scheduled-注解" class="headerlink" title="标注 @Scheduled 注解"></a>标注 @Scheduled 注解</h4><p><code>@Scheduled</code> 一般标注在 <code>Service</code> 层。需要注意的是，<code>@Scheduled</code> 要生效，类必须是由 IOC 容器管理的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TaskService</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">firstTask</span><span class="hljs-params">()</span>;  <br>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">secondTask</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br><br><br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TaskService</span> &#123;  <br>  <br>    <span class="hljs-meta">@Scheduled(fixedDelay = 5000)</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">firstTask</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;第一个任务...&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Scheduled(fixedDelay = 10000)</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">secondTask</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;第二个任务...&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>定时任务默认使用的线程池是 <code>ThreadPoolTaskScheduler</code></li></ol></blockquote><hr><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><h4 id="添加相关依赖-1"><a href="#添加相关依赖-1" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h4><ol><li>Web<ol><li>Spring Web</li></ol></li></ol><hr><h4 id="开启支持异步任务"><a href="#开启支持异步任务" class="headerlink" title="开启支持异步任务"></a>开启支持异步任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span> <span class="hljs-comment">// 开启支持异步任务  </span><br><span class="hljs-meta">@SpringBootApplication</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringTaskApplication</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        SpringApplication.run(SpringTaskApplication.class, args);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="标注-Async-注解"><a href="#标注-Async-注解" class="headerlink" title="标注 @Async 注解"></a>标注 @Async 注解</h4><p><code>@Async</code> 一般标注在 <code>Service</code> 层。需要注意的是，<code>@Async</code> 要生效，类必须是由 IOC 容器管理的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TaskService</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">firstTask</span><span class="hljs-params">()</span>;  <br>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">secondTask</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br><br><br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TaskService</span> &#123;  <br>  <br>    <span class="hljs-meta">@Async</span>  <br>    <span class="hljs-meta">@Scheduled(fixedDelay = 5000)</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">firstTask</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;第一个任务的线程是：&quot;</span> + Thread.currentThread().getName());  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Scheduled(fixedDelay = 10000)</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">secondTask</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;第二个任务的线程是：&quot;</span> + Thread.currentThread().getName());  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>异步任务默认使用的线程池是 <code>SimpleAsyncTaskExecutor</code></li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 生态</category>
      
      <category>Spring Task</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 环境标识</title>
    <link href="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E7%8E%AF%E5%A2%83%E6%A0%87%E8%AF%86/"/>
    <url>/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E7%8E%AF%E5%A2%83%E6%A0%87%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>环境</th><th>环境标识</th><th>使用者</th><th>说明</th></tr></thead><tbody><tr><td>本地环境</td><td><code>local</code></td><td>开发者</td><td>个人开发者在本机或本地容器中用于快速验证和调试。资源有限，随时可启动，数据和配置随实例销毁而丢失，不做持久化。</td></tr><tr><td>开发环境</td><td><code>dev</code></td><td>开发团队</td><td>团队协作开发新功能或联调接口时使用，环境配置可频繁调整，数据可随意增删改，用于功能验证与开发调试，不保证数据完整性和稳定性。</td></tr><tr><td>测试环境</td><td><code>test</code></td><td>QA 测试人员</td><td>QA 在此环境中执行功能测试和回归测试，验证功能正确性和业务流程完整性。环境配置相对稳定，数据可定期重置，用于准确复现测试用例场景。</td></tr><tr><td>压测环境</td><td><code>perf</code></td><td>性能测试工程师</td><td>用于进行大规模并发、压力和性能基准测试，集群配置接近或优于生产环境，支持导入海量脏数据，重点关注系统吞吐量、响应时间和资源占用。测试结束后可整体销毁并重建。</td></tr><tr><td>生产环境</td><td><code>prod</code></td><td>真实用户</td><td>面向外部或内部正式业务的运行环境，配置固定且受严格变更管理，具备高可用部署、监控告警、日志审计及定期备份机制，数据持久化存储，并制定完善的故障恢复和安全策略。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 环境标识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 文档</title>
    <link href="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/"/>
    <url>/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-文档基础"><a href="#Java-文档基础" class="headerlink" title="Java 文档基础"></a>Java 文档基础</h1><h2 id="1-Swagger-和-OpenAPI-概述"><a href="#1-Swagger-和-OpenAPI-概述" class="headerlink" title="1. Swagger 和 OpenAPI 概述"></a>1. Swagger 和 OpenAPI 概述</h2><p>Swagger 是一种 RESTful API 规范（用于定义 API 的格式）以及一套工具链（称为 Swagger 工具链，用于辅助开发和文档生成）</p><p>所谓 RESTful API 规范，是指开发者通过 JSON 或 YAML 文件，<strong>描述</strong> API 的接口路径、请求方式、参数格式、响应结构、认证机制等关键信息。</p><p>Swagger 规范正是这样一种定义 API 的规范标准。目前 Swagger 有两个主要版本：Swagger 2.0 和 Swagger 3.0。通常我们将 Swagger 2.0 称为 “Swagger 规范”，而 Swagger 3.0 则被正式命名为 “OpenAPI 规范”。</p><p>无论采用的是 Swagger 规范描述 API，还是采用 OpenAPI 规范描述 API，都可以借助 Swagger 工具链（如 Swagger UI、Swagger Codegen、Swagger Editor 等）来进行辅助开发和文档生成</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">Sample</span> <span class="hljs-string">API</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">paths:</span><br>  <span class="hljs-string">/users:</span><br>    <span class="hljs-attr">get:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">Get</span> <span class="hljs-string">a</span> <span class="hljs-string">list</span> <span class="hljs-string">of</span> <span class="hljs-string">users</span><br>      <span class="hljs-attr">responses:</span><br>        <span class="hljs-attr">&#x27;200&#x27;:</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">A</span> <span class="hljs-string">list</span> <span class="hljs-string">of</span> <span class="hljs-string">users</span><br>          <span class="hljs-attr">content:</span><br>            <span class="hljs-attr">application/json:</span><br>              <span class="hljs-attr">schema:</span><br>                <span class="hljs-attr">type:</span> <span class="hljs-string">array</span><br>                <span class="hljs-attr">items:</span><br>                  <span class="hljs-attr">type:</span> <span class="hljs-string">object</span><br>                  <span class="hljs-attr">properties:</span><br>                    <span class="hljs-attr">id:</span><br>                      <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span><br>                    <span class="hljs-attr">name:</span><br>                      <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-Swagger-工具链"><a href="#2-Swagger-工具链" class="headerlink" title="2. Swagger 工具链"></a>2. Swagger 工具链</h2><h3 id="2-1-Swagger-UI"><a href="#2-1-Swagger-UI" class="headerlink" title="2.1. Swagger UI"></a>2.1. Swagger UI</h3><p>Swagger UI 能根据 API 文档提供一个交互式的 API 文档界面，用户可以直接通过浏览器进行 API 的测试和查看，其使用方法是：</p><p><font color="#92d050">1. 添加相关依赖</font></p><ol><li>springfox-swagger-ui<ol><li>Maven<ol><li><a href="https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui">https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui</a></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 输入访问 Swagger UI 的 URL</font><br>访问： <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>Swagger UI 的 URL 要根据我们的配置的地址进行访问</li></ol></blockquote><hr><h3 id="2-2-Swagger-Editor"><a href="#2-2-Swagger-Editor" class="headerlink" title="2.2. Swagger Editor"></a>2.2. Swagger Editor</h3><p>Swagger Editor 是一个<a href="https://editor.swagger.io/">在线编译器</a>，用于编写和查看 Swagger 规范文件（Swagger 2.0 或 OpenAPI 3.0 格式）。</p><hr><h1 id="Java-文档工具"><a href="#Java-文档工具" class="headerlink" title="Java 文档工具"></a>Java 文档工具</h1><h2 id="1-Swagger-Editor"><a href="#1-Swagger-Editor" class="headerlink" title="1. Swagger Editor"></a>1. Swagger Editor</h2><p>Swagger Editor 是一个<a href="https://editor.swagger.io/">在线编译器</a>，用于编写和查看 Swagger 规范文件（Swagger 2.0 或 OpenAPI 3.0 格式）。</p><hr><h2 id="2-Apifox"><a href="#2-Apifox" class="headerlink" title="2. Apifox"></a>2. Apifox</h2><h3 id="2-1-在-IDEA-中创建-Java-项目"><a href="#2-1-在-IDEA-中创建-Java-项目" class="headerlink" title="2.1. 在 IDEA 中创建 Java 项目"></a>2.1. 在 IDEA 中创建 Java 项目</h3><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-10.png"></p><hr><h3 id="2-2-在-IDEA-中安装-Apifox-插件"><a href="#2-2-在-IDEA-中安装-Apifox-插件" class="headerlink" title="2.2. 在 IDEA 中安装 Apifox 插件"></a>2.2. 在 IDEA 中安装 Apifox 插件</h3><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-13.png"></p><hr><h3 id="2-3-在-Apifox-中创建团队和项目"><a href="#2-3-在-Apifox-中创建团队和项目" class="headerlink" title="2.3. 在 Apifox 中创建团队和项目"></a>2.3. 在 Apifox 中创建团队和项目</h3><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-14.png"></p><hr><h3 id="2-4-在-IDEA-中配置密钥、Java-项目与-Apifox-项目对应关系"><a href="#2-4-在-IDEA-中配置密钥、Java-项目与-Apifox-项目对应关系" class="headerlink" title="2.4. 在 IDEA 中配置密钥、Java 项目与 Apifox 项目对应关系"></a>2.4. 在 IDEA 中配置密钥、Java 项目与 Apifox 项目对应关系</h3><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-11.png"></p><hr><h3 id="2-5-在-IDEA-中上传-Java-项目"><a href="#2-5-在-IDEA-中上传-Java-项目" class="headerlink" title="2.5. 在 IDEA 中上传 Java 项目"></a>2.5. 在 IDEA 中上传 Java 项目</h3><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-12.png"></p><hr><h3 id="2-6-在-Apifox-中配置环境路径"><a href="#2-6-在-Apifox-中配置环境路径" class="headerlink" title="2.6. 在 Apifox 中配置环境路径"></a>2.6. 在 Apifox 中配置环境路径</h3><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-15.png"></p><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-16.png"></p><hr><h1 id="Spring-Doc"><a href="#Spring-Doc" class="headerlink" title="Spring Doc"></a>Spring Doc</h1><h2 id="1-SpringDoc-配置"><a href="#1-SpringDoc-配置" class="headerlink" title="1. SpringDoc 配置"></a>1. SpringDoc 配置</h2><h3 id="1-1-配置模板"><a href="#1-1-配置模板" class="headerlink" title="1.1. 配置模板"></a>1.1. 配置模板</h3><h4 id="1-1-1-配置类配置"><a href="#1-1-1-配置类配置" class="headerlink" title="1.1.1. 配置类配置"></a>1.1.1. 配置类配置</h4><p>在配置类中用于配置 API 文档的基本信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@OpenAPIDefinition(                                   // 文档基本信息</span><br><span class="hljs-meta">    info = @Info(</span><br><span class="hljs-meta">        title = &quot;My API&quot;,</span><br><span class="hljs-meta">        version = &quot;v1&quot;,</span><br><span class="hljs-meta">        description = &quot;This is the API documentation for my application&quot;,</span><br><span class="hljs-meta">        contact = @Contact(name = &quot;John Doe&quot;, email = &quot;john.doe@example.com&quot;)</span><br><span class="hljs-meta">    )</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenApiConfiguration</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="1-1-2-application-yaml-配置"><a href="#1-1-2-application-yaml-配置" class="headerlink" title="1.1.2. application.yaml 配置"></a>1.1.2. application.yaml 配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">springdoc:</span><br>  <span class="hljs-attr">api-docs:</span>                               <span class="hljs-comment"># API 文档相关配置</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/v3/api-docs</span>                    <span class="hljs-comment"># 设置 OpenAPI 文档的访问路径</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>                         <span class="hljs-comment"># 是否开启文档接口，即是否能访问 /v3/api-docs</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">openapi_3_0</span>                  <span class="hljs-comment"># 指定 OpenAPI 版本，可选 openapi_3_0, openapi_3_1，默认是 openapi_3_0</span><br>    <span class="hljs-attr">groups:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>                       <span class="hljs-comment"># 是否启用分组功能，需结合下面的 group-configs 使用</span><br><br>  <span class="hljs-attr">group-configs:</span>                          <span class="hljs-comment"># 分组相关配置（需启用分组功能）</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;controller1&quot;</span>                <span class="hljs-comment"># 分组的名称</span><br>      <span class="hljs-attr">packages-to-scan:</span>                   <span class="hljs-comment"># 分组扫描（仅支持包名、不支持类名）</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller1</span><br>      <span class="hljs-attr">packages-to-exclude:</span>                <span class="hljs-comment"># 分组排除（仅支持包名、不支持类名）</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller1.xxxxx</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;controller2&quot;</span><br>      <span class="hljs-attr">packages-to-scan:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller2</span><br>      <span class="hljs-attr">packages-to-exclude:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller2.xxxxx</span><br><br>  <span class="hljs-attr">swagger-ui:</span>                             <span class="hljs-comment"># Swagger UI 页面相关配置</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/swagger-ui.html</span>                <span class="hljs-comment"># 设置 Swagger UI 的访问路径</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>                         <span class="hljs-comment"># 是否开启 Swagger UI 界面，即是否能访问 /swagger-ui.html</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/v3/api-docs</span>                     <span class="hljs-comment"># 告诉 Swagger UI 去加载哪个 OpenAPI 文档</span><br>    <span class="hljs-attr">display-request-duration:</span> <span class="hljs-literal">true</span>        <span class="hljs-comment"># 在 Swagger UI 页面中，每个接口请求下方显示耗时（ms）</span><br>    <span class="hljs-attr">tags-sorter:</span> <span class="hljs-string">alpha</span>                    <span class="hljs-comment"># 控制标签（tags）排序方式，alpha 是按字母顺序排序</span><br>    <span class="hljs-attr">operations-sorter:</span> <span class="hljs-string">alpha</span>              <span class="hljs-comment"># 控制接口方法（operations）的排序方式，alpha 是按字母顺序排序</span><br>    <span class="hljs-attr">max-displayed-tags:</span> <span class="hljs-number">20</span>                <span class="hljs-comment"># Swagger UI 中最多显示多少个 tags（控制器分组），-1 表示不限制</span><br>    <span class="hljs-attr">try-it-out-enabled:</span> <span class="hljs-literal">true</span>              <span class="hljs-comment"># 开启后可直接在页面上发起接口请求，若设为 false，则只能查看接口描述，不能发请求</span><br><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项：</p><ol><li>精简版本如下：</li></ol></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">springdoc:</span><br>  <span class="hljs-attr">api-docs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/v3/api-docs</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">openapi_3_0</span><br>    <span class="hljs-attr">groups:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">group-configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;controller1&quot;</span><br>      <span class="hljs-attr">packages-to-scan:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller1</span><br>      <span class="hljs-attr">packages-to-exclude:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller1.AdminController</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;controller2&quot;</span><br>      <span class="hljs-attr">packages-to-scan:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller2</span><br>      <span class="hljs-attr">packages-to-exclude:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">com.example.springdoctoopenapi.controller2.SupportController</span><br><br>  <span class="hljs-attr">swagger-ui:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/swagger-ui.html</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">/v3/api-docs</span><br>    <span class="hljs-attr">display-request-duration:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tags-sorter:</span> <span class="hljs-string">alpha</span><br>    <span class="hljs-attr">operations-sorter:</span> <span class="hljs-string">alpha</span><br>    <span class="hljs-attr">max-displayed-tags:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">try-it-out-enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h3 id="1-2-配置详解"><a href="#1-2-配置详解" class="headerlink" title="1.2. 配置详解"></a>1.2. 配置详解</h3><h4 id="1-2-1-API-文档相关配置"><a href="#1-2-1-API-文档相关配置" class="headerlink" title="1.2.1. API 文档相关配置"></a>1.2.1. API 文档相关配置</h4><h5 id="1-2-1-1-设置-OpenAPI-文档的访问路径"><a href="#1-2-1-1-设置-OpenAPI-文档的访问路径" class="headerlink" title="1.2.1.1. 设置 OpenAPI 文档的访问路径"></a>1.2.1.1. 设置 OpenAPI 文档的访问路径</h5><p>如果我们配置如下访问路径，就可以通过这个路径获取 JSON 或 YAML 格式的 API 文档：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">springdoc:</span><br>  <span class="hljs-attr">api-docs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/v3/api-docs</span> <br></code></pre></td></tr></table></figure><p><font color="#92d050">1. 获取 JSON 格式的文档</font><br>访问： <a href="http://localhost:8080/v3/api-docs.json">http://localhost:8080/v3/api-docs.json</a><br><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果想下载 JSON 格式的文档，可以在 IDEA 中下载插件 <code>OpenAPI Specifications</code>，点击模块的右键 <code>Export OpenAPI</code> 导出 JSON 类型的 API 文档</li></ol></blockquote><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-1.png"></p><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-2.png"></p><p><font color="#92d050">2. 获取 YAML 格式的文档</font><br>访问： <a href="http://localhost:8080/v3/api-docs.yaml">http://localhost:8080/v3/api-docs.yaml</a> ，浏览器会自动下载 YAML 格式的文档，打开后的内容格式如下：<br><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-3.png"></p><hr><h4 id="1-2-2-分组相关配置"><a href="#1-2-2-分组相关配置" class="headerlink" title="1.2.2. 分组相关配置"></a>1.2.2. 分组相关配置</h4><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-4.png"></p><hr><h2 id="2-快速上手"><a href="#2-快速上手" class="headerlink" title="2. 快速上手"></a>2. 快速上手</h2><h3 id="2-1-添加相关依赖"><a href="#2-1-添加相关依赖" class="headerlink" title="2.1. 添加相关依赖"></a>2.1. 添加相关依赖</h3><ol><li>创建时<ol><li>Web<ol><li>Spring Web</li></ol></li></ol></li><li>创建后<ol><li>springdoc-openapi-starter-webmvc-ui&lt;<ol><li>Maven<ol><li><a href="https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui">https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui</a></li></ol></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>spring-openapi-stater-webmvc-ui 依赖，会自动添加 Swagger UI 依赖</li></ol></blockquote><hr><h3 id="2-2-编写测试代码"><a href="#2-2-编写测试代码" class="headerlink" title="2.2. 编写测试代码"></a>2.2. 编写测试代码</h3><h4 id="2-2-1-在-Controller1-包下"><a href="#2-2-1-在-Controller1-包下" class="headerlink" title="2.2.1. 在 Controller1 包下"></a>2.2.1. 在 Controller1 包下</h4><p><font color="#92d050">1. AdminController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/admin/dashboard&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAdminDashboard</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome to the Admin Dashboard!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/admin/settings&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAdminSettings</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Admin settings page.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. UserController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/profile&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserProfile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is the user&#x27;s profile page.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/settings&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserSettings</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User settings page.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. OrderController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/order/history&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOrderHistory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Here are your past orders.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/order/status&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOrderStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Order is currently being processed.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. ProductController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/product/list&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProductList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;List of available products.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/product/details&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProductDetails</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Details of the selected product.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="2-2-2-在-Controller2-包下"><a href="#2-2-2-在-Controller2-包下" class="headerlink" title="2.2.2. 在 Controller2 包下"></a>2.2.2. 在 Controller2 包下</h4><p><font color="#92d050">1. ReportController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/report/daily&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDailyReport</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Daily report data.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/report/monthly&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMonthlyReport</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Monthly report data.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><p><font color="#92d050">2. NotificationController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/notification/list&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNotificationList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;List of notifications.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/notification/settings&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNotificationSettings</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Notification settings page.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><p><font color="#92d050">3. FeedbackController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeedbackController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/feedback/submit&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitFeedback</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Submit your feedback here.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/feedback/status&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFeedbackStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Feedback processing status.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><p><font color="#92d050">4. SupportController.java</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SupportController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/support/contact&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContactInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Support contact information.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/support/faq&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFaq</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Frequently asked questions.&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-3-进行-SpringDoc-配置"><a href="#2-3-进行-SpringDoc-配置" class="headerlink" title="2.3. 进行 SpringDoc 配置"></a>2.3. 进行 SpringDoc 配置</h3><p>详见上文：SpringDoc 配置</p><hr><h3 id="2-4-标注-SpringDoc-相关注解"><a href="#2-4-标注-SpringDoc-相关注解" class="headerlink" title="2.4. 标注 SpringDoc 相关注解"></a>2.4. 标注 SpringDoc 相关注解</h3><h4 id="2-4-1-Controller上的注解"><a href="#2-4-1-Controller上的注解" class="headerlink" title="2.4.1. Controller上的注解"></a>2.4.1. Controller上的注解</h4><h5 id="2-4-1-1-Tag"><a href="#2-4-1-1-Tag" class="headerlink" title="2.4.1.1. @Tag"></a>2.4.1.1. @Tag</h5><p><code>@Tag</code> 用于<strong>为 Controller 类中所有方法添加标签</strong>，可以用来组织 API 文档中的接口分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Tag(name = &quot;Admin API&quot;,description = &quot;Operation related to admins&quot;)</span><br><span class="hljs-meta">@Tag(name = &quot;User API&quot;, description = &quot;Operations related to users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    .......<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项：对此处 <code>@Tag</code> 的理解</p><ol><li>可以将 <code>@Tag</code> 理解为在 <code>group-configs</code> 所定义的大分组内部，用于进一步细分接口的子标签</li><li>使用 <code>@Tag</code> 时可以手动指定标签名；如果未显式设置，系统会为每个类生成一个默认标签，例如 <code>UserController</code> 会对应默认标签 <code>user-controller</code></li><li>每个 <code>@Tag</code> 只能指定一个 <code>name</code>，但一个类可以标注多个 <code>@Tag</code>，用于归类到多个标签下</li></ol></blockquote><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-5.png"></p><hr><h5 id="2-4-1-2-Operation"><a href="#2-4-1-2-Operation" class="headerlink" title="2.4.1.2. @Operation"></a>2.4.1.2. @Operation</h5><p><code>@Operation</code> 用于<strong>为一个方法添加标签</strong>，并对该方法进行详细说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Operation(  </span><br><span class="hljs-meta">summary = &quot;Get user by ID&quot;,  </span><br><span class="hljs-meta">description = &quot;Fetch a user by their unique ID from the database.&quot;,  </span><br><span class="hljs-meta">tags = &#123;&quot;User&quot;,&quot;Admin&quot;&#125;,  </span><br><span class="hljs-meta">parameters = &#123;  </span><br><span class="hljs-meta">@Parameter(xxxxxx),  </span><br><span class="hljs-meta">@Parameter(xxxxxx)  </span><br><span class="hljs-meta">&#125;,  </span><br><span class="hljs-meta">requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(xxxxxxx),  </span><br><span class="hljs-meta">responses = &#123;  </span><br><span class="hljs-meta">@ApiResponse(xxxxxx),  </span><br><span class="hljs-meta">@ApiResponse(xxxxxx)  </span><br><span class="hljs-meta">&#125;,  </span><br><span class="hljs-meta">deprecated = false  </span><br><span class="hljs-meta">  </span><br><span class="hljs-meta">)</span>  <br><span class="hljs-meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span>  <br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(  </span><br><span class="hljs-params">        <span class="hljs-meta">@PathVariable</span> Long id,  </span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam</span> String fields  </span><br><span class="hljs-params">)</span> &#123;  <br>    <span class="hljs-comment">// 查询用户并返回  </span><br>    <span class="hljs-keyword">return</span> userService.getUserById(id, fields);  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">1. summary</font><br>对 API 方法的简短描述</p><p><font color="#92d050">2. description</font><br>对 API 方法的详细描述</p><p><font color="#92d050">3. tags</font><br>用于指定 API 方法的标签</p><p><font color="#92d050">4. perameters</font><br>包含由 <code>@Parameter</code> 注解组成的数组，用于<strong>描述接口的传入参数</strong>，而 <code>@Parameter</code> 注解的具体属性，可以通过 <code>Ctrl + 鼠标点击</code> 查看其来源，或详见下文：<code>@Parameter</code> ，其中列出了常用属性</p><p><font color="#92d050">5. requestBody</font><br><code>@RequestBody</code> 注解的实例，用于<strong>描述请求体的内容</strong>，通常用于 <code>POST</code>、<code>PUT</code>、<code>PATCH</code> 等请求方法</p><p><code>@RequestBody</code> 注解的具体属性，可以通过 <code>Ctrl + 鼠标点击</code> 查看其来源，或详见下文：<code>@RequestBody</code> ，其中列出了常用属性</p><p><font color="#92d050">6. responses</font><br>包含由 <code>@ApiResponse</code> 注解构成的数组，用于描述接口可能<strong>返回的 HTTP 响应</strong>，而 <code>@ApiResponse</code> 注解的具体属性，可以通过 <code>Ctrl + 鼠标点击</code> 查看其来源，或详见下文： <code>@ApiResponse</code> ，其中列出了常用属性</p><p><font color="#92d050">7. deprecated</font><br>用于标记接口是否已弃用。如果设置为 <code>true</code>，表示该接口已不推荐使用，通常会在文档中注明，默认为 <code>false</code></p><blockquote><p>[!NOTE] 注意事项：对此处 <code>tags</code> 的理解</p><ol><li>默认情况下，一个 Controller 类中的所有方法，都会在类标注的 <code>@Tag</code> 中，即类级别的标签。而在此处使用 <code>tags</code>，单独指定方法自己的标签，那么该方法既会出现在 <code>@Tag</code> 标注的标签，又会出现在<code>tags</code> 标注的标签</li></ol></blockquote><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-6.png"></p><hr><h5 id="2-4-1-3-Parameter"><a href="#2-4-1-3-Parameter" class="headerlink" title="2.4.1.3. @Parameter"></a>2.4.1.3. @Parameter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Parameter(</span><br><span class="hljs-meta">    name = &quot;id&quot;, </span><br><span class="hljs-meta">    description = &quot;User ID&quot;, </span><br><span class="hljs-meta">    example = &quot;123&quot;, </span><br><span class="hljs-meta">    schema = @Schema(implementation = User.class),</span><br><span class="hljs-meta">    in = ParameterIn.PATH,</span><br><span class="hljs-meta">    required = true, </span><br><span class="hljs-meta">    allowEmptyValue = true</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">1. name  </font><br>描述参数的名称，通常应与方法参数名保持一致。</p><p><font color="#92d050">2. description  </font><br>用于说明参数的含义或用途，便于使用者理解其业务意义。</p><p><font color="#92d050">3. example  </font><br>为参数提供一个示例值，帮助文档阅读者更直观地了解其典型输入。</p><p><font color="#92d050">4. schema  </font><br>指向参数所对应的类，大多数情况下，你不需要手动指定 <code>schema</code>，因为 SpringDoc 能自动根据参数类型推断出来。</p><p><font color="#92d050">5. in  </font><br>用于指定参数的来源位置。常见取值如下：  </p><ol><li>path：<ol><li>表示来自 URL 路径，常用于路径变量（如 <code>/users/&#123;id&#125;</code>）</li></ol></li><li>query：<ol><li>表示来自 URL 查询字符串，用于 GET 请求中的查询参数</li></ol></li><li>header：<ol><li>表示来自 HTTP 请求头部，例如 Authorization 令牌</li></ol></li><li>cookie：<ol><li>表示来自 HTTP 请求的 Cookie，例如 JSESSIONID</li></ol></li><li>需要注意的是，如果参数来自请求体，需要使用 <code>@RequestBody</code> 注解</li></ol><p><font color="#92d050">6. required  </font><br>用于指定该参数是否为必填项，默认值为 <code>false</code>。若设置为 <code>true</code>，则参数在请求中必须存在。</p><p><font color="#92d050">7. allowEmptyValue  </font><br>指示该参数是否允许为空值，默认值为 <code>false</code>。</p><hr><h5 id="2-4-1-4-RequestBody"><a href="#2-4-1-4-RequestBody" class="headerlink" title="2.4.1.4. @RequestBody"></a>2.4.1.4. @RequestBody</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestBody(  </span><br><span class="hljs-meta">        description = &quot;User data&quot;,  </span><br><span class="hljs-meta">        required = true,  </span><br><span class="hljs-meta">        content = @Content(xxxxx)  </span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">1. description  </font><br>描述请求体的内容。</p><p><font color="#92d050">2. required  </font><br>指定请求体是否为必填项，默认值为 <code>true</code>。</p><p><font color="#92d050">3. content  </font><br><code>@Content</code> 注解的实例，用于描述请求体或响应体的内容类型与结构。而<code>@Content</code> 注解的具体属性可以通过 <code>Ctrl + 鼠标点击</code> 查看其来源，或详见下文：<code>@Content</code> ，其中列出了常用属性。</p><hr><h5 id="2-4-1-5-ApiResponse"><a href="#2-4-1-5-ApiResponse" class="headerlink" title="2.4.1.5. @ApiResponse"></a>2.4.1.5. @ApiResponse</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiResponse(</span><br><span class="hljs-meta">responseCode = &quot;200&quot;,</span><br><span class="hljs-meta">description = &quot;Successfully retrieved the user&quot;,</span><br><span class="hljs-meta">content = @Content(xxxxxx)</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">1. responseCode  </font><br>用于指定响应的 HTTP 状态码，例如 <code>200</code>、<code>400</code>、<code>404</code>、<code>500</code> 等。</p><p><font color="#92d050">2. description  </font><br>为对应的响应状态码提供详细描述，说明响应的含义或返回条件。</p><p><font color="#92d050">3. content  </font><br><code>@Content</code> 注解的实例，用于描述请求体或响应体的内容类型与结构。而<code>@Content</code> 注解的具体属性可以通过 <code>Ctrl + 鼠标点击</code> 查看其来源，或详见下文：<code>@Content</code> 部分，其中列出了常用属性。</p><hr><h5 id="2-4-1-6-Content"><a href="#2-4-1-6-Content" class="headerlink" title="2.4.1.6. @Content"></a>2.4.1.6. @Content</h5><p><code>@Content</code> 注解用于描述请求体或响应体的内容类型和结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">content = <span class="hljs-meta">@Content(</span><br><span class="hljs-meta">mediaType = &quot;application/json&quot;,</span><br><span class="hljs-meta">schema = @Schema(implementation = User.class),</span><br><span class="hljs-meta">examples = @ExampleObject(value = &quot;&#123;\&quot;name\&quot;:\&quot;John Doe\&quot;,\&quot;age\&quot;:30&#125;&quot;),</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">1. mediaType  </font><br>用于指定响应体的 MIME 类型，例如 <code>application/json</code>、<code>text/plain</code> 等。</p><p><font color="#92d050">2. schema  </font><br>指向响应体对应的模型类（Model 类），用于定义返回数据的结构。</p><p><font color="#92d050">3. examples  </font><br>用于提供响应内容的示例数据，帮助使用者理解接口的典型返回结果</p><hr><h4 id="2-4-2-POJO-上的注解"><a href="#2-4-2-POJO-上的注解" class="headerlink" title="2.4.2. POJO 上的注解"></a>2.4.2. POJO 上的注解</h4><h5 id="2-4-2-1-Schema"><a href="#2-4-2-1-Schema" class="headerlink" title="2.4.2.1. @Schema"></a>2.4.2.1. @Schema</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Schema(name = &quot;User&quot;, description = &quot;User object representing a system user&quot;)</span> <span class="hljs-comment">// 类上建议写 name、属性上不建议</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br><br>    <span class="hljs-meta">@Schema(description = &quot;Unique identifier of the user&quot;, example = &quot;1&quot;, defaultValue = &quot;100&quot;)</span><br>    <span class="hljs-keyword">private</span> Long id;  <br><br>    <span class="hljs-meta">@Schema(description = &quot;Username of the user&quot;, required = true, example = &quot;john_doe&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;  <br><br>    <span class="hljs-meta">@Schema(description = &quot;Email address of the user&quot;, example = &quot;john@example.com&quot;)</span><br>    <span class="hljs-keyword">private</span> String email;  <br><br>    <span class="hljs-meta">@Schema(description = &quot;Age of the user&quot;, example = &quot;25&quot;, defaultValue = &quot;25&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;  <br><br>    <span class="hljs-meta">@Schema(description = &quot;Creation date of the user account&quot;, format = &quot;date-time&quot;, example = &quot;2024-01-01T00:00:00Z&quot;)</span><br>    <span class="hljs-keyword">private</span> LocalDateTime createdAt;  <br>    <br><span class="hljs-meta">@Schema(allowableValues = &#123;&quot;True&quot;, &quot;False&quot;&#125;)</span><br><span class="hljs-keyword">private</span> Boolean isTrue;<br><br>    <span class="hljs-comment">// Getters and Setters</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果你只是定义了一个 <code>User</code> 类，但没有在 Swagger 能扫描到的方法中使用它（作为参数或返回值），那么即便你写了 <code>@Schema</code> 注解，也不会在 Swagger UI 中显示</li><li>只要在被 Swagger 扫描的方法中引用了 <code>User</code>（比如作为请求参数或响应结果），它就会自动展示出你标注的字段说明，例如：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Operation(summary = &quot;创建用户&quot;)</span><br><span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br><span class="hljs-comment">// 业务逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-7.png"></p><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-8.png"></p><p><font color="#92d050">1. name  </font><br>指定模型属性的名称。</p><p><font color="#92d050">2. description  </font><br>为该属性提供简短描述，说明其用途或含义。</p><p><font color="#92d050">3. required  </font><br>表示该属性是否为必填项，默认值为 <code>false</code>。</p><p><font color="#92d050">4. example  </font><br>用于提供该字段的示例值，帮助理解其典型输入。</p><p><font color="#92d050">5. defaultValue  </font><br>指定该字段的默认值，当未显式赋值时将使用此值。</p><p><font color="#92d050">6. format  </font><br>用于指定字段的格式，特别适用于日期、时间等类型，便于文档工具正确渲染数据格式。  </p><ol><li>date-time：<ol><li>日期 + 时间，符合 ISO 8601 格式</li><li>如 <code>2024-01-01T12:00:00Z</code>，适用类型：<code>LocalDateTime</code>、<code>Date</code>、<code>ZonedDateTime</code> 等。</li></ol></li><li>date：<ol><li>仅日期，格式为 <code>yyyy-MM-dd</code></li><li>如 <code>2024-01-01</code>，适用类型：<code>LocalDate</code>。</li></ol></li><li>time：<ol><li>仅时间，格式为 <code>HH:mm:ss</code></li><li>如 <code>12:00:00</code>，适用类型：<code>LocalTime</code>。</li></ol></li></ol><hr><h3 id="2-5-访问-Swagger-UI-界面"><a href="#2-5-访问-Swagger-UI-界面" class="headerlink" title="2.5. 访问 Swagger UI 界面"></a>2.5. 访问 Swagger UI 界面</h3><p> Swagger UI 界面默认为： <a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></p><hr><h2 id="3-业务处理"><a href="#3-业务处理" class="headerlink" title="3. 业务处理"></a>3. 业务处理</h2><h3 id="3-1-Springdoc-集成-Spring-Security"><a href="#3-1-Springdoc-集成-Spring-Security" class="headerlink" title="3.1. Springdoc 集成 Spring Security"></a>3.1. Springdoc 集成 Spring Security</h3><p>在使用 Spring Security 时，访问 Swagger UI 界面或者访问 API 文档时，会出现空白或被拒绝，这通常是由于其需要获取的资源被 Spring Security 的资源访问控制机制拦截导致的。你可以按下 F12 打开浏览器开发者工具，查看哪些资源被拦截，然后将这些资源路径配置为 <code>permitAll</code>。常见被拦截的资源包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;/swagger-ui/**&quot;</span>, <span class="hljs-string">&quot;/swagger-resources/**&quot;</span>, <span class="hljs-string">&quot;webjars/**&quot;</span>, <span class="hljs-string">&quot;v3/**&quot;</span><br></code></pre></td></tr></table></figure><p>然后你就可以配置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">auth.requestMatchers(<span class="hljs-string">&quot;/swagger-ui/**&quot;</span>, <span class="hljs-string">&quot;/swagger-resources/**&quot;</span>, <span class="hljs-string">&quot;webjars/**&quot;</span>, <span class="hljs-string">&quot;v3/**&quot;</span>).permitAll()<br></code></pre></td></tr></table></figure><p><img src="/2025/08/17/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%87%E6%A1%A3-9.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 文档</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Http、Https通信</title>
    <link href="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AHttp%E3%80%81Https%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AHttp%E3%80%81Https%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<ol><li>HttpClient</li><li>Apache HttpClient</li><li>OkHttp</li><li>Retrofit（通常配合 OkHttp）</li><li><code>RestTemplate</code>（Spring 传统方式）</li><li><code>WebClient</code>（Spring WebFlux，响应式方式）</li></ol><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 网络通信</category>
      
      <category>Http、Https 通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：23 种设计模式</title>
    <link href="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-导图"><a href="#1-导图" class="headerlink" title="1. 导图"></a>1. 导图</h2><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1.xmind"></p><hr><h2 id="2-代码质量标准"><a href="#2-代码质量标准" class="headerlink" title="2. 代码质量标准"></a>2. 代码质量标准</h2><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p><hr><h2 id="3-六大设计原则"><a href="#3-六大设计原则" class="headerlink" title="3. 六大设计原则"></a>3. 六大设计原则</h2><h3 id="3-1-单一职责原则（SRP）"><a href="#3-1-单一职责原则（SRP）" class="headerlink" title="3.1. 单一职责原则（SRP）"></a>3.1. 单一职责原则（SRP）</h3><p>单一职责原则是指：<strong>一个类应该有且只有一个引起它变化的原因</strong>。简单来说，如果多个功能因为同一个 “原因” 而发生变化，它们可以放在同一个类中。如果是不同的 “原因”，则应将它们拆分到不同的类中，这里的 ”原因“ 通常是指：</p><ol><li>一个业务场景</li><li>一个具体角色</li></ol><p>我们来看一个反例，这个类就承担了太多职责：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-comment">// 职责 1：管理用户属性</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeUsername</span><span class="hljs-params">(String newUsername)</span> &#123;<br>        <span class="hljs-keyword">if</span> (newUsername != <span class="hljs-literal">null</span> &amp;&amp; newUsername.length() &gt; <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-built_in">this</span>.username = newUsername;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 职责 2：数据库持久化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUserToDatabase</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 连接数据库、构建SQL、保存用户的代码...</span><br>        System.out.println(<span class="hljs-string">&quot;用户 &quot;</span> + username + <span class="hljs-string">&quot; 已保存到数据库。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 职责 3：数据展示</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">generateHtmlReport</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 生成用于网页展示的HTML代码...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;div&gt;&lt;h1&gt;&quot;</span> + username + <span class="hljs-string">&quot;&lt;/h1&gt;&lt;p&gt;&quot;</span> + email + <span class="hljs-string">&quot;&lt;/p&gt;&lt;/div&gt;&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用一些常见的判断标准来判断它是否违背了单一职责原则：</p><p><font color="#92d050">1. 你能用一句话清晰地、无歧义地描述这个类的职责吗？（业务场景）</font><br>我们的这个类负责管理用户的属性，并且还负责数据库的持久化，同时还负责数据展示。</p><p>当我们的描述中，出现了类似于同时、并且等字眼的时候，就要知道可能会违背单一职责原则了，一个职责清晰的类，描述通常应该非常简洁，例如：</p><ol><li>这是一个负责管理用户属性的类</li><li>这是一个负责数据库持久化的类</li><li>这是一个负责数据展示的类</li></ol><p><font color="#92d050">2. 什么角色会要求我修改这个类？（具体角色）</font><br>这是一个非常有效的思维，想象一下你的类：</p><ol><li>如果管理用户属性发生变化：<ol><li>比如，修改用户名长度的验证规则（<code>changeUsername</code>）</li><li>这通常是由产品经理或业务分析师驱动的</li></ol></li><li>如果数据库持久化发生变化<ol><li>比如，从 MySQL 数据库迁移到 MongoDB</li><li>这通常是由数据库管理员或架构师驱动的</li></ol></li><li>如果数据展示发生变化<ol><li>比如，从生成 HTML 报告变为生成 JSON 数据</li><li>这通常是由前端开发或 API 设计者驱动的</li></ol></li></ol><p>所以我们发现了，产品经理、业务分析师、数据库管理员、架构师、前端开发这几个完全不同的角色，都有可能让我们去修改同一个 Employee 类，这就是典型的违反了单一职责原则</p><p><font color="#92d050">3. 这个类的 import 列表是不是看起来很 ”分裂“？</font><br>假如这个类的顶部 import 语句，同时出现了：</p><ol><li>处理数据库的包，如 <code>java.sql.*</code></li><li>处理网络请求的包，如 <code>org.apache.http.*</code></li><li>处理 UI 元素的包，如 <code>javax.swing.*</code></li><li>处理文件操作的包，如 <code>java.io.*</code></li></ol><p>那么它几乎 <strong>100%</strong> 违反了单一职责原则。这说明这个类横跨了应用的多个层次（持久化层、业务逻辑层、表现层），是一个典型的“上帝类”（God Class）</p><p>当我们出现上述问题的时候，就需要考虑重构这个类了。在项目初期或简单应用中，将几个关联紧密的职责放在一起可能是可以接受的，随着业务复杂度的增加，当一个类开始因为不同原因而频繁被修改时，就是重构和拆分它的最佳时机</p><hr><h3 id="3-2-开闭原则（OCP）"><a href="#3-2-开闭原则（OCP）" class="headerlink" title="3.2. 开闭原则（OCP）"></a>3.2. 开闭原则（OCP）</h3><h4 id="3-2-1-开闭原则概述"><a href="#3-2-1-开闭原则概述" class="headerlink" title="3.2.1. 开闭原则概述"></a>3.2.1. 开闭原则概述</h4><p>开闭原则是指：<strong>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭</strong>。这句话听起来很矛盾，我们把它拆开来理解：</p><ol><li>对扩展开放<ol><li>当系统需要增加新功能时，我们可以通过增加新代码（新的类、新的模块）来实现，而不是去动老代码</li></ol></li><li>对修改关闭<ol><li>一旦一个类或模块开发完成、测试通过，就应该尽可能地保持稳定，不应再去修改它的内部代码。</li><li>这是因为修改老代码很容易引入新的 Bug，影响已有的稳定功能。</li></ol></li></ol><p>我们先来看一个反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphicEditor</span> &#123;<br><br>    <span class="hljs-comment">// 每次增加新形状，都要修改这个方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShape</span><span class="hljs-params">(String shapeType)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;rectangle&quot;</span>.equals(shapeType)) &#123;<br>            drawRectangle();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;circle&quot;</span>.equals(shapeType)) &#123;<br>            drawCircle();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;triangle&quot;</span>.equals(shapeType)) &#123; <span class="hljs-comment">// 新增需求：画三角形</span><br>            drawTriangle(); <span class="hljs-comment">// 必须在这里加一个else if，修改了原有代码</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRectangle</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;绘制矩形&quot;</span>); &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;绘制圆形&quot;</span>); &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawTriangle</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;绘制三角形&quot;</span>); &#125; <span class="hljs-comment">// 新增方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类就是典型的对修改开放，每次产品经理说：嘿，我们再加一个五角星的形状吧。你就必须修改这个方法，再添加一个 <code>else if (&quot;star&quot;.equals(shapeType))</code> 和 <code>drawStar()</code> 方法</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里有一个常见的误区，就是说类写好之后，再去动他就是违反了开闭原则，这是不正确的</li><li>如果你在类里新增了一些方法，而且这些方法不会影响原有方法的逻辑，那么这依然符合开闭原则，不过有两点需要注意：<ol><li>即使没直接改原方法，如果新增方法需要访问或修改类的内部状态，还是有可能引入风险，导致原功能被间接影响</li><li>如果新增方法跟这个类的核心职责无关，那可能会违背单一职责原则，虽然没违反开闭原则</li></ol></li><li>虽然不违反开闭原则，但我们更希望能够在外部扩展，而不是直接在类里加内容，这样能减少类膨胀</li></ol></blockquote><hr><h4 id="3-2-2-开闭原则实现"><a href="#3-2-2-开闭原则实现" class="headerlink" title="3.2.2. 开闭原则实现"></a>3.2.2. 开闭原则实现</h4><h5 id="3-2-2-1-开闭原则实现核心"><a href="#3-2-2-1-开闭原则实现核心" class="headerlink" title="3.2.2.1. 开闭原则实现核心"></a>3.2.2.1. 开闭原则实现核心</h5><p>实现开闭原则的核心就是：<strong>抽象（接口、抽象类） + 多态（向上转型、向下转型），即面向抽象编程，而不是面向具体编程</strong></p><ol><li>接口<ol><li>接口是用来定义行为规范的</li><li>当实现类之间没有太多共同代码，只是需要遵守同一个行为规范时，推荐使用接口</li></ol></li><li>抽象类<ol><li>当子类之间有大量通用代码，且你想定义一个固定的算法骨架（模板）时，推荐使用抽象类</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>为什么在定义行为规范时，要使用接口而不是抽象类？<ol><li>如果使用抽象类定义行为规范，子类必须继承它，而类的继承是单一的，即子类只能有一个父类，这就限制了扩展性；</li><li>相比之下，接口支持多实现，更加灵活。</li></ol></li><li>为什么在实现通用代码时，要使用抽象类，而不是接口？<ol><li>接口中虽然提供了 <code>default</code> 方法，但它的诞生是为了解决历史遗留的兼容性问题，而不是为了取代抽象类的作用：<ol><li>Java 8 之前<ol><li>接口一旦发布，就不能随便加方法</li><li>因为如果加了新方法，所有已经实现该接口的类都要改代码，不然编译不过</li><li>对于已经在广泛使用的库和框架，如果接口贸然新增方法，后果会非常严重，几乎等同于 “天塌了”</li></ol></li><li>Java 8 之后<ol><li>允许在接口中新增方法的同时，给一个默认实现，这样老的实现类不用动，也不会编译报错</li><li>简单来说，其实 default 方法本质上是为了接口的“向后兼容”，让接口也能适度演化，而不破坏已有实现类，而不是说去取代抽象类</li></ol></li></ol></li><li>抽象类比接口提供了更强大的基础支持结构<ol><li>接口中不能持有实例变量、实例常量、静态变量，只能定义静态常量（static final）</li><li>接口中不能定义构造方法，因此无法控制子类的初始化过程</li></ol></li></ol></li></ol></blockquote><hr><h5 id="3-2-2-2-接口-多态实现开闭原则"><a href="#3-2-2-2-接口-多态实现开闭原则" class="headerlink" title="3.2.2.2. 接口 + 多态实现开闭原则"></a>3.2.2.2. 接口 + 多态实现开闭原则</h5><p>其实开闭原则的实现思路很清晰，可以归纳为三个步骤：<strong>底层抽象 → 中层扩展 → 上层使用</strong>。</p><p><font color="#92d050">1. 底层抽象</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>; <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 中层扩展</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;绘制矩形！&quot;</span>); &#125;<br>    <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;绘制圆形！&quot;</span>); &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 上层使用</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">shape</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();  <br>          <br>        shape.draw();  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="3-2-2-3-抽象类-多态实现开闭原则"><a href="#3-2-2-3-抽象类-多态实现开闭原则" class="headerlink" title="3.2.2.3. 抽象类 + 多态实现开闭原则"></a>3.2.2.3. 抽象类 + 多态实现开闭原则</h5><p><font color="#92d050">1. 底层抽象</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeverageMaker</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeBeverage</span><span class="hljs-params">()</span> &#123;<br>        boilWater();<br>        brew();<br>        pourInCup();<br>        addCondiments();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">boilWater</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;烧开水&quot;</span>); &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourInCup</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;倒入杯中&quot;</span>); &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 中层扩展</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeverageMaker</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;用沸水冲泡咖啡&quot;</span>); &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;加糖和牛奶&quot;</span>); &#125;<br>    <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeaMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeverageMaker</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;用沸水浸泡茶叶&quot;</span>); &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;加柠檬&quot;</span>); &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 上层使用</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">BeverageMaker</span> <span class="hljs-variable">beverageMaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoffeeMaker</span>();  <br>          <br>        beverageMaker.makeBeverage();  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然使用具体类加多态也能实现开闭原则，但不推荐。可以用普通类作为“策略基类”，让子类继承并重写方法，但这样抽象程度低，外部依赖的是具体类而非抽象类，容易违反依赖倒置原则。</li><li>接口与抽象类通常是配合使用的，而不是相互隔离。很多框架都采用这种组合：例如 <code>List</code>（接口）→ <code>AbstractList</code>（抽象类，实现大部分通用方法）→ <code>ArrayList</code>（具体类）。</li></ol></blockquote><hr><h3 id="3-3-里氏替换原则（LSP）"><a href="#3-3-里氏替换原则（LSP）" class="headerlink" title="3.3. 里氏替换原则（LSP）"></a>3.3. 里氏替换原则（LSP）</h3><p>里氏替换原则是指：<strong>如果对每一个类型为 T 的对象 x，都有一个属性 Φ(x) 成立，那么对于类型为 S 的对象 y，其中 S 是 T 的子类型，属性 Φ(y) 也应该成立</strong>。</p><p>我们来看一个反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 矩形</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> width;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123; width = w; &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123; height = h; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> width * height; &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 正方形</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<br>        width = w;<br>        height = w;  <span class="hljs-comment">// 高度也被改变</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>        width = h;   <span class="hljs-comment">// 宽度也被改变</span><br>        height = h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-4-接口隔离原则（ISP）"><a href="#3-4-接口隔离原则（ISP）" class="headerlink" title="3.4. 接口隔离原则（ISP）"></a>3.4. 接口隔离原则（ISP）</h3><p>接口隔离原则是指：<strong>不应该强迫一个类去实现它不需要的接口方法</strong>。</p><p>如果接口包含过多方法，而某些方法对部分实现类毫无意义，这些类就会被迫提供空实现或抛异常。为避免这种“万能接口”，应将大接口拆分成更小的接口，让类只依赖自己真正需要的功能。</p><p>我们来看一个反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个 “万能” 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MultiFunctionDevice</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fax</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br><br><br><span class="hljs-comment">// 老式打印机</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OldPrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MultiFunctionDevice</span> &#123;<br><br><span class="hljs-comment">// 只具有打印功能</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;Printing...&quot;</span>); &#125;<br><br><span class="hljs-comment">// 被迫实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); <br>    &#125;<br><br><span class="hljs-comment">// 被迫实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fax</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(); <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>把大接口拆分成小接口，让类只依赖自己需要的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Scanner</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fax</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fax</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 老式打印机</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OldPrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;Printing...&quot;</span>); &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 高级多功能设备</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiFunctionPrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Printer</span>, Scanner, Fax &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;Printing...&quot;</span>); &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;Scanning...&quot;</span>); &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fax</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;Faxing...&quot;</span>); &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="3-5-依赖倒置原则（DIP）"><a href="#3-5-依赖倒置原则（DIP）" class="headerlink" title="3.5. 依赖倒置原则（DIP）"></a>3.5. 依赖倒置原则（DIP）</h3><p>依赖倒置原则是指：<strong>高层模块不应该依赖低层模块，二者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象</strong>。</p><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7.png"></p><hr><h3 id="3-6-迪米特原则（LKP）"><a href="#3-6-迪米特原则（LKP）" class="headerlink" title="3.6. 迪米特原则（LKP）"></a>3.6. 迪米特原则（LKP）</h3><p>迪米特原则的定义是：<strong>一个对象应当对其他对象有尽可能少的了解，只与直接的朋友通信，不与陌生的对象发生耦合</strong>。简单来说，中调用方法时，应优先调用：</p><ol><li>本类自己的方法</li><li>本类中引用类型的常量、变量、方法参数或局部变量的方法</li></ol><p>不应调用链过长的对象，例如 <code>a.getB().getC().doSomething()</code>。这里的 <code>C</code> 对 <code>A</code> 来说是 “陌生人”，违反了迪米特法则。</p><hr><h2 id="4-创建型模式（5-种）"><a href="#4-创建型模式（5-种）" class="headerlink" title="4. 创建型模式（5 种）"></a>4. 创建型模式（5 种）</h2><h3 id="4-1-单例模式"><a href="#4-1-单例模式" class="headerlink" title="4.1. 单例模式"></a>4.1. 单例模式</h3><h4 id="4-1-1-单例模式概述"><a href="#4-1-1-单例模式概述" class="headerlink" title="4.1.1. 单例模式概述"></a>4.1.1. 单例模式概述</h4><p>单例模式是指：<strong>保证一个类在整个系统中只有一个实例，并提供一个全局访问点来获取该实例</strong></p><p>单例模式主要解决的问题是：在整个系统中，有些类只需要一个实例即可，例如系统配置类、日志管理器、线程池或数据库连接池等。如果不限制实例数量，可能会造成资源浪费或状态不一致。</p><hr><h4 id="4-1-2-单例模式实现"><a href="#4-1-2-单例模式实现" class="headerlink" title="4.1.2. 单例模式实现"></a>4.1.2. 单例模式实现</h4><h5 id="4-1-2-1-饿汉式"><a href="#4-1-2-1-饿汉式" class="headerlink" title="4.1.2.1. 饿汉式"></a>4.1.2.1. 饿汉式</h5><p>饿汉式是指：在类加载的时候就创建实例</p><p>其优点是：</p><ol><li>线程安全</li></ol><p>其缺点是：</p><ol><li>不支持懒加载</li><li>类加载速度变慢</li><li>如果实例一直未被使用，会造成内存浪费（尤其是实例占用资源很大时）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 饿汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 属性：对自身的引用</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. private</span><br><span class="hljs-comment">     *          1. 防止随意访问</span><br><span class="hljs-comment">     *          2. 保证了必须通过全局访问点来获取该实例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *      1. static</span><br><span class="hljs-comment">     *          1. 类被加载时初始化</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>    <span class="hljs-comment">// 构造方法（private，防止随意 new 对象）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 具体方法：全局访问点</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. public</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *      1. static</span><br><span class="hljs-comment">     *          1. 提供一个全局的访问点，而无需先创建对象再调用方法</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo <span class="hljs-title function_">getDemo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> demo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="4-1-2-2-懒汉式"><a href="#4-1-2-2-懒汉式" class="headerlink" title="4.1.2.2. 懒汉式"></a>4.1.2.2. 懒汉式</h5><p>懒汉式是指：只有当用户第一次通过全局访问点获取实例时，才会创建实例</p><p>其优点是：</p><ol><li>懒加载</li><li>线程安全</li></ol><p>其缺点是：</p><ol><li>第一次调用全局访问点时，有性能延迟</li><li>由于 synchronized 操作，全局访问点并发度很低，性能较差</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 属性：对自身的引用</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. private</span><br><span class="hljs-comment">     *          1. 防止随意访问</span><br><span class="hljs-comment">     *          2. 保证了必须通过全局访问点来获取该实例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *      1. static</span><br><span class="hljs-comment">     *          1. 类被加载时就为 demo 在方法区分配空间</span><br><span class="hljs-comment">     *          2. static 方法只能访问 static 变量，不能访问非 static 变量</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo demo;<br><br><br>    <span class="hljs-comment">// 构造方法（private，防止随意 new 对象）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 具体方法：全局访问点</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. public</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *      1. static</span><br><span class="hljs-comment">     *          1. 提供一个全局的访问点，而无需先创建对象再调用方法</span><br><span class="hljs-comment">     *      2. synchronized</span><br><span class="hljs-comment">     *          1. 保证线程安全</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Demo <span class="hljs-title function_">getDemo</span><span class="hljs-params">()</span> &#123;<br>    <br>        <span class="hljs-comment">// 第一次调用时才创建实例</span><br>        <span class="hljs-keyword">if</span> (demo == <span class="hljs-literal">null</span>)<br>            demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>        <span class="hljs-keyword">return</span> demo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="4-1-2-3-双重检验"><a href="#4-1-2-3-双重检验" class="headerlink" title="4.1.2.3. 双重检验"></a>4.1.2.3. 双重检验</h5><p>双重校验是指：第一次先判断实例是否为空，为空时再加锁（保证性能较为高效）。加锁后再进行第二次判断，确认实例尚未被其他线程创建后才创建新实例，从而避免重复创建。它是一种广泛使用且高效的实现方式</p><p>其优点是：</p><ol><li>懒加载</li><li>线程安全</li><li>性能较高</li></ol><p>其缺点是：</p><ol><li>写法复杂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 属性：对自身的引用</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. private</span><br><span class="hljs-comment">     *          1. 防止随意访问</span><br><span class="hljs-comment">     *          2. 保证了必须通过全局访问点来获取该实例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *      1. volatile</span><br><span class="hljs-comment">     *          1. 保证了变量的可见性</span><br><span class="hljs-comment">     *          2. 因为值被保存在线程虚拟机栈的栈帧的局部变量表中，如果不保证可见性，就有可能读到过期的值</span><br><span class="hljs-comment">     *          3. 从而在第二次校验的时候出现误校验</span><br><span class="hljs-comment">     *      2. static</span><br><span class="hljs-comment">     *          1. 类被加载时就为 demo 在方法区分配空间</span><br><span class="hljs-comment">     *          2. 并且在类加载时就完成实例的创建和复制</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Demo demo;<br><br>    <span class="hljs-comment">// 构造方法（private，防止随意 new 对象）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 具体方法：全局访问点</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. public</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *      1. static</span><br><span class="hljs-comment">     *          1. 提供一个全局的访问点，而无需先创建对象再调用方法</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo <span class="hljs-title function_">getDemo</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 第一次校验</span><br>        <span class="hljs-keyword">if</span> (demo == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Demo.class) &#123;<br>                <span class="hljs-comment">// 第二次校验，防止加锁后直接创建实例</span><br>                <span class="hljs-keyword">if</span> (demo == <span class="hljs-literal">null</span>) &#123;<br>                    demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> demo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="4-1-2-4-静态内部类"><a href="#4-1-2-4-静态内部类" class="headerlink" title="4.1.2.4. 静态内部类"></a>4.1.2.4. 静态内部类</h5><p>静态内部类是指：利用其不会随外部类加载而立即加载的特性，实例仅在首次使用时创建，同时天然保证线程安全，因此是一种强烈推荐的单例实现方式</p><p>其优点是：</p><ol><li>懒加载</li><li>线程安全</li><li>写法优雅</li><li>性能最好</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <br>    <span class="hljs-comment">// 静态内部类（private，防止随意访问）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoHandler</span> &#123;<br>        <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法（private，防止随意 new 对象）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 具体方法：全局访问点</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 访问修饰符</span><br><span class="hljs-comment">     *      1. public</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 非访问修饰符</span><br><span class="hljs-comment">     *      1. static</span><br><span class="hljs-comment">     *          1. 提供一个全局的访问点，而无需先创建对象再调用方法</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo <span class="hljs-title function_">getDemo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> DemoHandler.demo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-简单工厂模式"><a href="#4-2-简单工厂模式" class="headerlink" title="4.2. 简单工厂模式"></a>4.2. 简单工厂模式</h3><h4 id="4-2-1-简单工厂模式概述"><a href="#4-2-1-简单工厂模式概述" class="headerlink" title="4.2.1. 简单工厂模式概述"></a>4.2.1. 简单工厂模式概述</h4><p>简单工厂模式不属于 23 种设计模式，其核心思想是：<strong>由工厂类负责决定创建哪种具体产品，而客户端无需直接使用 new 去实例化</strong>。</p><p>简单工厂模式通常包含三个角色：</p><ol><li>抽象产品<ol><li>通常是接口，也可以是抽象类</li></ol></li><li>具体产品<ol><li>实现或继承了抽象产品的具体类</li><li>客户端不直接创建具体产品实例，而是通过工厂来创建</li></ol></li><li>工厂<ol><li>具体类</li><li>将创建具体产品实例的逻辑集中在此，负责创建具体产品实例</li></ol></li></ol><hr><h4 id="4-2-2-简单工厂模式实现"><a href="#4-2-2-简单工厂模式实现" class="headerlink" title="4.2.2. 简单工厂模式实现"></a>4.2.2. 简单工厂模式实现</h4><p>场景：假设有一个工厂专门用于生产各种几何图形</p><p><font color="#92d050">1. 创建抽象产品</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象产品：图形  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体产品</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体产品：圆形  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;生成一个圆形...&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br><br><br><span class="hljs-comment">// 具体产品：正方形  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;生产一个正方形...&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建工厂类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工厂：图形工厂  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeFactory</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title function_">createShape</span><span class="hljs-params">(String type)</span> &#123;  <br>        <span class="hljs-keyword">switch</span> (type) &#123;  <br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;circle&quot;</span>:  <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();  <br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;square&quot;</span>:  <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();  <br>            <span class="hljs-keyword">default</span>:  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;未知类型&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> ShapeFactory.createShape(<span class="hljs-string">&quot;circle&quot;</span>);  <br>  <br>        circle.draw();  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-工厂方法模式"><a href="#4-3-工厂方法模式" class="headerlink" title="4.3. 工厂方法模式"></a>4.3. 工厂方法模式</h3><h4 id="4-3-1-工厂方法模式概述"><a href="#4-3-1-工厂方法模式概述" class="headerlink" title="4.3.1. 工厂方法模式概述"></a>4.3.1. 工厂方法模式概述</h4><p>工厂方法模式是指：<strong>通过定义一个用于创建对象的接口，让子类决定实例化哪一个具体类，从而将对象的创建与使用分离</strong>。简单来说就是，把对象的创建交给子类去实现，而不是在父类或调用者中直接 new</p><p>工厂方法模式通常包含四个角色：</p><ol><li>抽象产品<ol><li>通常是接口，也可以是抽象类</li></ol></li><li>具体产品<ol><li>实现或继承了抽象产品的具体类</li><li>客户端不直接创建具体产品实例，而是通过具体工厂来创建</li></ol></li><li>抽象工厂<ol><li>通常是接口，也可以是抽象类</li></ol></li><li>具体工厂<ol><li>具体类</li><li><strong>一个具体产品</strong>对应一个具体工厂，该工厂专门用于生产这个产品</li></ol></li></ol><hr><h4 id="4-3-2-工厂方法模式实现"><a href="#4-3-2-工厂方法模式实现" class="headerlink" title="4.3.2. 工厂方法模式实现"></a>4.3.2. 工厂方法模式实现</h4><p>场景：假设有一个工厂专门用于生产各种几何图形，工厂老板觉得一个工厂负责生产多种图形会显得混乱，于是设计了多个工厂，每个工厂专门负责生产一种图形</p><p><font color="#92d050">1. 创建抽象产品</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象产品：图形  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体产品</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体产品：圆形  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;生成一个圆形...&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br><br><br><span class="hljs-comment">// 具体产品：正方形  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;生产一个正方形...&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建抽象工厂</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ShapeFactory</span> &#123;  <br>      <br>    Shape <span class="hljs-title function_">createShape</span><span class="hljs-params">()</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建具体工厂</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体工厂：圆形工厂  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeFactory</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> Shape <span class="hljs-title function_">createShape</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体工厂：正方形工厂  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeFactory</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Shape <span class="hljs-title function_">createShape</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>          <br>        <span class="hljs-type">CircleFactory</span> <span class="hljs-variable">circleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleFactory</span>();  <br>          <br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> circleFactory.createShape();  <br>          <br>        circle.draw();  <br>          <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-抽象工厂模式"><a href="#4-4-抽象工厂模式" class="headerlink" title="4.4. 抽象工厂模式"></a>4.4. 抽象工厂模式</h3><h4 id="4-4-1-抽象工厂模式概述"><a href="#4-4-1-抽象工厂模式概述" class="headerlink" title="4.4.1. 抽象工厂模式概述"></a>4.4.1. 抽象工厂模式概述</h4><p>抽象工厂模式是指：<strong>提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类</strong>。</p><p>抽象工厂模式通常包含四个角色：</p><ol><li>抽象产品（AbstractProduct）<ol><li>通常是接口，也可以是抽象类</li></ol></li><li>具体产品（ConcreteProduct）<ol><li>实现或继承了抽象产品的具体类</li><li>客户端不直接创建具体产品实例，而是通过具体工厂来创建</li></ol></li><li>抽象工厂（AbstractFactory）<ol><li>通常是接口，也可以是抽象类</li><li>命名以 <code>Factory</code> 结尾</li></ol></li><li>具体工厂（ConcreteFactory）<ol><li>具体类</li><li><strong>一系列的具体产品</strong>对应一个具体工厂，该工厂专门用于生产这个系列的产品</li><li>命名以 <code>Factory</code> 结尾</li></ol></li></ol><hr><h4 id="4-4-2-抽象工厂模式实现"><a href="#4-4-2-抽象工厂模式实现" class="headerlink" title="4.4.2. 抽象工厂模式实现"></a>4.4.2. 抽象工厂模式实现</h4><p>场景：有多家大厂分别专门生产 CPU 和 GPU</p><p><font color="#92d050">1. 创建抽象产品（AbstractProduct）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象产品：CPU  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cpu</span> &#123;  <br>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 抽象产品：GPU  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Gpu</span> &#123;  <br>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体产品（ConcreteProduct）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体产品：Intel CPU</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cpu</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Intel CPU&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体产品：Intel GPU</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterGpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Gpu</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Intel GPU&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br><br><br><span class="hljs-comment">// 具体产品：AMD CPU  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cpu</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;AMD CPU&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br><br><br><span class="hljs-comment">// 具体产品：AMD GPU  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AmdGpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Gpu</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;AMD GPU&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建抽象工厂（AbstractFactory）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂：电脑工厂  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComputerFactory</span> &#123;  <br>      <br>    <span class="hljs-keyword">public</span> Cpu <span class="hljs-title function_">createCpu</span><span class="hljs-params">()</span>;  <br>      <br>    <span class="hljs-keyword">public</span> Gpu <span class="hljs-title function_">createGpu</span><span class="hljs-params">()</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建具体工厂（ConcreteFactory）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体工厂：Intel Factory  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComputerFactory</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Cpu <span class="hljs-title function_">createCpu</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCpu</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Gpu <span class="hljs-title function_">createGpu</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterGpu</span>();  <br>    &#125;  <br>      <br>&#125;<br><br><br><span class="hljs-comment">// 具体工厂：AMD Factory  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComputerFactory</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Cpu <span class="hljs-title function_">createCpu</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmdCpu</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Gpu <span class="hljs-title function_">createGpu</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmdGpu</span>();  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>          <br>        <span class="hljs-type">ComputerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelFactory</span>();  <br>          <br>        <span class="hljs-type">Cpu</span> <span class="hljs-variable">cpu</span> <span class="hljs-operator">=</span> factory.createCpu();  <br>          <br>        <span class="hljs-type">Gpu</span> <span class="hljs-variable">gpu</span> <span class="hljs-operator">=</span> factory.createGpu();  <br>          <br>        cpu.print();  <br>          <br>        gpu.print();  <br>          <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-5-建造者模式"><a href="#4-5-建造者模式" class="headerlink" title="4.5. 建造者模式"></a>4.5. 建造者模式</h3><h4 id="4-5-1-建造者模式概述"><a href="#4-5-1-建造者模式概述" class="headerlink" title="4.5.1. 建造者模式概述"></a>4.5.1. 建造者模式概述</h4><p>建造者模式是指：<strong>将一个复杂对象的构建过程与其表示分离，使同样的构建过程可以创建不同的表示</strong>。</p><p>建造者模式通常包含四个角色：</p><ol><li>产品（Product）<ol><li>具体类</li><li>创建的实例就是这个复杂产品类的实例</li></ol></li><li>抽象建造者（Builder）<ol><li>通常是接口，可以是抽象类</li><li>定义了用于构建产品各个部分（即属性）的方法</li><li>命名以 <code>Builder</code> 结尾</li></ol></li><li>具体建造者（ConcreteBuilder）<ol><li>实现或继承了 <code>Builder</code> 的具体类</li><li>持有对 <code>Product</code> 的引用</li><li>实现各个构建方法，负责构建产品的各个部分（属性）</li><li>命名以 <code>Builder</code> 结尾</li></ol></li><li>指挥者（Director）<ol><li>具体类</li><li>持有对 <code>Builder</code> 的引用</li><li>按一定顺序调用具体建造者中各构建方法的实现</li><li>命名以 <code>Director</code> 结尾</li></ol></li></ol><hr><h4 id="4-5-2-建造模式实现"><a href="#4-5-2-建造模式实现" class="headerlink" title="4.5.2. 建造模式实现"></a>4.5.2. 建造模式实现</h4><h5 id="4-5-2-1-链式建造"><a href="#4-5-2-1-链式建造" class="headerlink" title="4.5.2.1. 链式建造"></a>4.5.2.1. 链式建造</h5><p><font color="#92d050">1. 创建产品（Product）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 产品：电脑  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：CPU（private）  </span><br>    <span class="hljs-keyword">private</span> String cpu;  <br>  <br>    <span class="hljs-comment">// 属性：内存（private）  </span><br>    <span class="hljs-keyword">private</span> String memory;  <br>  <br>    <span class="hljs-comment">// 属性：存储（private）  </span><br>    <span class="hljs-keyword">private</span> String storage;  <br>  <br>    <span class="hljs-comment">// 具体方法：设置 CPU    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(String cpu)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.cpu = cpu;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：设置内存  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(String memory)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.memory = memory;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：设置存储  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStorage</span><span class="hljs-params">(String storage)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.storage = storage;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Computer&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, storage=&#x27;&quot;</span> + storage + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体建造者（ConcreteBuilder）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体建造者：电脑建造者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputerBuilder</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 Computer 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();  <br>  <br>    <span class="hljs-comment">// 重写方法：构建 CPU    </span><br>    <span class="hljs-keyword">public</span> ComputerBuilder <span class="hljs-title function_">cpu</span><span class="hljs-params">(String cpu)</span> &#123;  <br>        computer.setCpu(cpu);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：构建内存  </span><br>    <span class="hljs-keyword">public</span> ComputerBuilder <span class="hljs-title function_">memory</span><span class="hljs-params">(String memory)</span> &#123;  <br>        computer.setMemory(memory);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：构建存储  </span><br>    <span class="hljs-keyword">public</span> ComputerBuilder <span class="hljs-title function_">storage</span><span class="hljs-params">(String storage)</span> &#123;  <br>        computer.setStorage(storage);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：建造最终产品  </span><br>    <span class="hljs-keyword">public</span> Computer <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> computer;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComputerBuilder</span>()  <br>.cpu(<span class="hljs-string">&quot;i9&quot;</span>)  <br>.memory(<span class="hljs-string">&quot;32GB&quot;</span>)  <br>.storage(<span class="hljs-string">&quot;1TB&quot;</span>)  <br>.build();  <br><br>        System.out.println(computer.toString());  <br>          <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="4-5-2-2-非链式建造"><a href="#4-5-2-2-非链式建造" class="headerlink" title="4.5.2.2. 非链式建造"></a>4.5.2.2. 非链式建造</h5><p><font color="#92d050">1. 创建产品（Product）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 产品：电脑  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：CPU（private）  </span><br>    <span class="hljs-keyword">private</span> String cpu;  <br>  <br>    <span class="hljs-comment">// 属性：内存（private）  </span><br>    <span class="hljs-keyword">private</span> String memory;  <br>  <br>    <span class="hljs-comment">// 属性：存储（private）  </span><br>    <span class="hljs-keyword">private</span> String storage;  <br>  <br>    <span class="hljs-comment">// 具体方法：设置 CPU    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(String cpu)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.cpu = cpu;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：设置内存  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(String memory)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.memory = memory;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：设置存储  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStorage</span><span class="hljs-params">(String storage)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.storage = storage;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Computer&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, storage=&#x27;&quot;</span> + storage + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建抽象建造者（Builder）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象构造者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComputerBuilder</span> &#123;  <br>  <br>    <span class="hljs-comment">// 接口方法：构建 CPU    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCpu</span><span class="hljs-params">(String cpu)</span>;  <br>  <br>    <span class="hljs-comment">// 接口方法：构建内存  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMemory</span><span class="hljs-params">(String memory)</span>;  <br>  <br>    <span class="hljs-comment">// 接口方法：构建存储  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildStorage</span><span class="hljs-params">(String storage)</span>;  <br>  <br>    <span class="hljs-comment">// 接口方法：建造最终产品  </span><br>    <span class="hljs-keyword">public</span> Computer <span class="hljs-title function_">build</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建具体建造者（ConcreteBuilder）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体建造者：游戏本建造者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GamingComputerBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComputerBuilder</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 Computer 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();  <br>  <br>    <span class="hljs-comment">// 重写方法：构建 CPU    </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCpu</span><span class="hljs-params">(String cpu)</span> &#123;  <br>        computer.setCpu(<span class="hljs-string">&quot;Intel i9&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：构建内存  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMemory</span><span class="hljs-params">(String memory)</span> &#123;  <br>        computer.setMemory(<span class="hljs-string">&quot;32GB DDR5&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：构建存储  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildStorage</span><span class="hljs-params">(String storage)</span> &#123;  <br>        computer.setStorage(<span class="hljs-string">&quot;1TB NVMe SSD&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：建造最终产品  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Computer <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> computer;  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体建造者：办公本建造者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OfficeComputerBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ComputerBuilder</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 Computer 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();  <br>  <br>    <span class="hljs-comment">// 重写方法：构建 CPU    </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCpu</span><span class="hljs-params">(String cpu)</span> &#123;  <br>        computer.setCpu(<span class="hljs-string">&quot;Intel i5&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：构建内存  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMemory</span><span class="hljs-params">(String memory)</span> &#123;  <br>        computer.setMemory(<span class="hljs-string">&quot;16GB DDR4&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：构建存储  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildStorage</span><span class="hljs-params">(String storage)</span> &#123;  <br>        computer.setStorage(<span class="hljs-string">&quot;512GB SSD&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：建造最终产品  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Computer <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> computer;  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建指挥者（Director）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指挥者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputerDirector</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 ComputerBuilder 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> ComputerBuilder computerBuilder;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ComputerDirector</span><span class="hljs-params">(ComputerBuilder computerBuilder)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.computerBuilder = computerBuilder;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：构建电脑  </span><br>    <span class="hljs-keyword">public</span> Computer <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;  <br>        computerBuilder.buildCpu();  <br>        computerBuilder.buildMemory();  <br>        computerBuilder.buildStorage();  <br>        <span class="hljs-keyword">return</span> computerBuilder.build();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">ComputerDirector</span> <span class="hljs-variable">gamingComputerDirector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComputerDirector</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GamingComputerBuilder</span>());  <br>  <br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">gamingComputer</span> <span class="hljs-operator">=</span> gamingComputerDirector.construct();  <br>  <br>        System.out.println(gamingComputer.toString());  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-6-原型模式"><a href="#4-6-原型模式" class="headerlink" title="4.6. 原型模式"></a>4.6. 原型模式</h3><h4 id="4-6-1-原型模式概述"><a href="#4-6-1-原型模式概述" class="headerlink" title="4.6.1. 原型模式概述"></a>4.6.1. 原型模式概述</h4><p>原型模式是指：<strong>使用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象</strong>。</p><p>原型模式主要解决的问题是：如果创建对象的成本较高，例如对象中的数据需要经过复杂计算才能获得，或者依赖于从 RPC 接口、数据库等较慢的 I&#x2F;O 操作中获取，那么此时可以使用原型模式，即通过从已有对象中拷贝来生成新对象，就无需每次都从零创建并执行耗时的初始化过程。<br><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12.png"></p><p>原型模式通常包含两个角色：</p><ol><li>抽象原型（Prototype）<ol><li>通常是接口，也可以是抽象类</li><li>定义了一个 <code>clone()</code> 方法，用于克隆</li><li>然而，在 Java 中通常不需要自己写抽象原型，因为在 Java 里 <code>Object.clone()</code> 已经天然提供了原型模式所需的克隆能力</li></ol></li><li>具体原型（ConcretePrototype）<ol><li>实现或继承 Prototype 的具体类</li><li>实现 <code>clone()</code> 方法，负责返回当前对象的副本</li></ol></li></ol><hr><h4 id="4-6-2-原型模式实现"><a href="#4-6-2-原型模式实现" class="headerlink" title="4.6.2. 原型模式实现"></a>4.6.2. 原型模式实现</h4><h5 id="4-6-2-1-浅克隆"><a href="#4-6-2-1-浅克隆" class="headerlink" title="4.6.2.1. 浅克隆"></a>4.6.2.1. 浅克隆</h5><h6 id="4-6-2-1-1-浅克隆概述"><a href="#4-6-2-1-1-浅克隆概述" class="headerlink" title="4.6.2.1.1. 浅克隆概述"></a>4.6.2.1.1. 浅克隆概述</h6><p>浅克隆是指：<strong>被复制对象中的所有变量都会拥有与原对象相同的值</strong>（引用类型的变量虽然也与原对象的值相同，但它们保存的是引用，指向同一块内存地址）</p><hr><h6 id="4-6-2-1-2-浅克隆实现"><a href="#4-6-2-1-2-浅克隆实现" class="headerlink" title="4.6.2.1.2. 浅克隆实现"></a>4.6.2.1.2. 浅克隆实现</h6><p>Java 中的 Object 类提供了 <code>clone()</code> 方法用于实现浅克隆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@IntrinsicCandidate</span>  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p>它是一个 native 方法，虽然无法直接看到实现，但底层是用 C&#x2F;C++ 编写的。该方法默认返回 <code>Object</code> 类型，而我们通常希望它返回具体的原型类型，例如希望 <code>user.clone()</code> 返回 <code>User</code> 类型，而不是 <code>Object</code>，因此需要对结果进行类型转换。除此之外，它的访问修饰符是 <code>protected</code>，这意味着在其他类中无法直接调用 <code>user.clone()</code>，所以我们通常会在子类中重写该方法，并顺便完成类型转换。</p><p>需要注意，实现克隆的类必须实现 标识接口 <code>Cloneable</code>，用于表明该类支持被复制。若未实现该接口，在调用 <code>clone()</code> 时会抛出 <code>CloneNotSupportedException</code></p><p>场景：现在我们有一个 User 对象，想在这个对象的基础上克隆一个 User 对象</p><p><font color="#92d050">1. 创建具体原型</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体原型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;  <br>  <br>    <span class="hljs-keyword">private</span> String name;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ConcretePrototype&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>    <br>    <span class="hljs-comment">// 重写方法：克隆</span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> User <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;  <br>        <span class="hljs-keyword">return</span> (User) <span class="hljs-built_in">super</span>.clone();  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;  <br>  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>);  <br>  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">cloneUser</span> <span class="hljs-operator">=</span> user.clone();  <br>  <br>        System.out.println(user.toString());  <br>  <br>        System.out.println(cloneUser.toString());  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="4-6-2-2-深克隆"><a href="#4-6-2-2-深克隆" class="headerlink" title="4.6.2.2. 深克隆"></a>4.6.2.2. 深克隆</h5><h6 id="4-6-2-2-1-深克隆概述"><a href="#4-6-2-2-1-深克隆概述" class="headerlink" title="4.6.2.2.1. 深克隆概述"></a>4.6.2.2.1. 深克隆概述</h6><p>深克隆是指：<strong>被复制对象中，所有基本数据类型变量都会拥有与原对象相同的值，引用类型的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象</strong>。</p><hr><h6 id="4-6-2-2-2-手动深拷贝"><a href="#4-6-2-2-2-手动深拷贝" class="headerlink" title="4.6.2.2.2. 手动深拷贝"></a>4.6.2.2.2. 手动深拷贝</h6><p>手动深拷贝是指：你自己在 <code>clone()</code> 方法里逐个处理引用类型的字段，给它们也创建一个新的对象副本，而不是直接复制引用地址</p><p><font color="#92d050">1. 创建具体原型</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体原型  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> String name;  <br>  <br>    <span class="hljs-keyword">private</span> Address address;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, Address address)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.address = address;  <br>    &#125;  <br>  <br><span class="hljs-comment">// 重写方法：克隆</span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>  <br>            <span class="hljs-comment">// 浅拷贝当前对象  </span><br>            <span class="hljs-type">User</span> <span class="hljs-variable">cloned</span> <span class="hljs-operator">=</span> (User) <span class="hljs-built_in">super</span>.clone();  <br>  <br>            <span class="hljs-comment">// 深拷贝引用字段  </span><br>            cloned.address = address.clone();  <br>  <br>            <span class="hljs-keyword">return</span> cloned;  <br>  <br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// Address</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;  <br>  <br>    <span class="hljs-keyword">private</span> String city;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.city = city;  <br>    &#125;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;city=&#x27;&quot;</span> + city + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>    <br>    <span class="hljs-comment">// 重写方法：克隆</span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();  <br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();  <br>        &#125;  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>);  <br>  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Bob&quot;</span>, address);  <br>  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">cloneUser</span> <span class="hljs-operator">=</span> user.clone();  <br>  <br>        System.out.println(user.toString());  <br>  <br>        System.out.println(cloneUser.clone());  <br>          <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="4-6-2-2-3-序列化反序列化"><a href="#4-6-2-2-3-序列化反序列化" class="headerlink" title="4.6.2.2.3. 序列化反序列化"></a>4.6.2.2.3. 序列化反序列化</h6><p><font color="#92d050">1. 创建具体原型</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体原型  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> String name;  <br>  <br>    <span class="hljs-keyword">private</span> Address address;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, Address address)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.address = address;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, address=&quot;</span> + address +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 序列化  </span><br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);  <br>            oos.writeObject(<span class="hljs-built_in">this</span>);  <br>  <br>            <span class="hljs-comment">// 反序列化  </span><br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray()));  <br>            <span class="hljs-keyword">return</span> (User) ois.readObject();  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>    &#125;  <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;  <br>  <br>    <span class="hljs-keyword">private</span> String city;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.city = city;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;city=&#x27;&quot;</span> + city + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        org.example.Prototype.deep.manual.<span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>);  <br>  <br>        org.example.Prototype.deep.manual.<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.example.Prototype.deep.manual.User(<span class="hljs-string">&quot;Bob&quot;</span>, address);  <br>  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">cloneUser</span> <span class="hljs-operator">=</span> user.clone();  <br>  <br>        System.out.println(user.toString());  <br>  <br>        System.out.println(cloneUser.clone());  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-结构型模式（7-种）"><a href="#5-结构型模式（7-种）" class="headerlink" title="5. 结构型模式（7 种）"></a>5. 结构型模式（7 种）</h2><h3 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1. 代理模式"></a>5.1. 代理模式</h3><h4 id="5-1-1-代理模式概述"><a href="#5-1-1-代理模式概述" class="headerlink" title="5.1.1. 代理模式概述"></a>5.1.1. 代理模式概述</h4><p>代理模式是指：<strong>为其他对象提供一个代理对象，以控制对这个对象的访问</strong>。</p><p>代理模式主要解决的问题是：<br>假设你想买一台国外的 iPhone 14，但你无法直接从国外厂商购买，这时你会找一个代购：<br><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8.png"></p><p>对你来说，你只是 “下单购买“，找的是代购，和你直接找厂商买的行为是一样的，并且代购可能在发货前帮你检查下游戏机有没有问题，或者帮你打包得更结实（功能增强）</p><p>代理模式通常包含三个角色：</p><ol><li>抽象主题（Subject）<ol><li>通常是接口，也可以是抽象类<ol><li>静态代理，既可以是接口，也可以是抽象类</li><li>JDK 动态代理，必须是接口</li><li>CGLIB 动态代理，不需要抽象主题</li></ol></li><li>真实主题和代理都需要实现或继承抽象主题，因此在任何使用真实主题的地方都可以替换为代理主题</li></ol></li><li>真实主题（Real Subject）<ol><li>实现或继承了 Subject 的具体类</li><li>真实主题也被称为 “被代理类”</li></ol></li><li>代理（Proxy）<ol><li>实现或继承了 Subject 的具体类</li><li>持有对 <code>RealSubject</code> 的引用</li><li>它可以在执行真实主题的方法前后，添加一些自己的操作（功能增强）</li></ol></li></ol><hr><h4 id="5-1-2-代理模式实现"><a href="#5-1-2-代理模式实现" class="headerlink" title="5.1.2. 代理模式实现"></a>5.1.2. 代理模式实现</h4><h5 id="5-1-2-1-静态代理"><a href="#5-1-2-1-静态代理" class="headerlink" title="5.1.2.1. 静态代理"></a>5.1.2.1. 静态代理</h5><p>静态代理是指：<strong>代理类是在编译时就创建好的，.java 文件是实实在在存在的</strong>。</p><p>场景：火车站开始售票时，有黄牛抢到了一些票，进行代售，但会额外收取小费</p><p><font color="#92d050">1. 创建抽象主题（Subject）</font><br>这里使用的是接口，规定了 “卖票” 的规范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象主题：卖票</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TicketSeller</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建真实主题（Real Subject）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 真实主题：火车站卖票</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TicketSeller</span> &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;火车站成功卖出一张火车票。&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建代理（Proxy）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代理：黄牛代售点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainStationProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TicketSeller</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 TrainStation 的引用（private，防止随意访问）</span><br>    <span class="hljs-keyword">private</span> TrainStation trainStation;  <br><br><span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrainStationProxy</span><span class="hljs-params">(TrainStation trainStation)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.trainStation = trainStation;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span> &#123;  <br>  <br>        <span class="hljs-comment">// 在调用真实方法前，可以做一些增强操作  </span><br>        System.out.println(<span class="hljs-string">&quot;黄牛代售点开始受理卖票业务...&quot;</span>);  <br>  <br>        <span class="hljs-comment">// 调用真实主题的方法  </span><br>        trainStation.sellTicket();  <br>  <br>        <span class="hljs-comment">// 在调用真实方法后，也可以做一些增强操作  </span><br>        System.out.println(<span class="hljs-string">&quot;黄牛代售点收取服务费10元。&quot;</span>);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>          <br>        <span class="hljs-type">TrainStation</span> <span class="hljs-variable">trainStation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainStation</span>();  <br>  <br>        <span class="hljs-type">TrainStationProxy</span> <span class="hljs-variable">trainStationProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainStationProxy</span>(trainStation);  <br>  <br>        trainStationProxy.sellTicket();  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-2-2-JDK-动态代理"><a href="#5-1-2-2-JDK-动态代理" class="headerlink" title="5.1.2.2. JDK 动态代理"></a>5.1.2.2. JDK 动态代理</h5><h6 id="5-1-2-2-1-JDK-动态代理概述"><a href="#5-1-2-2-1-JDK-动态代理概述" class="headerlink" title="5.1.2.2.1. JDK 动态代理概述"></a>5.1.2.2.1. JDK 动态代理概述</h6><p>JDK 动态代理是指：在运行时动态的生成一个实现了指定接口的代理类，所有方法调用都被转发到 <code>InvocationHandler.invoke()</code> 方法</p><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10.png"></p><hr><h6 id="5-1-2-2-2-JDK-动态代理实现"><a href="#5-1-2-2-2-JDK-动态代理实现" class="headerlink" title="5.1.2.2.2. JDK 动态代理实现"></a>5.1.2.2.2. JDK 动态代理实现</h6><p><font color="#92d050">1. 创建抽象主题（Subject）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象主题：卖票</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TicketSeller</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>JDK 动态代理的抽象主题，必须是接口，不能是抽象类</li></ol></blockquote><p><font color="#92d050">2. 创建真实主题（Real Subject）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 真实主题：火车站卖票</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TicketSeller</span> &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;火车站成功卖出一张火车票。&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建通用代理工厂</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 动态代理工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkProxyFactory</span> &#123;<br><br>    <span class="hljs-comment">// 属性：对 Real Subject 的引用</span><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkProxyFactory</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = object;<br>    &#125;<br><br>    <span class="hljs-comment">// 具体方法：获取代理实例</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(InvocationHandler invocationHandler)</span> &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * ============================================</span><br><span class="hljs-comment">         * Proxy.newProxyInstance(ClassLoader, Class&lt;?&gt;[] InvocationHandler)</span><br><span class="hljs-comment">         * --------------------------------------------</span><br><span class="hljs-comment">         * 1. 参数</span><br><span class="hljs-comment">         *      1. ClassLoader</span><br><span class="hljs-comment">         *          1. 真实主题使用的类加载器</span><br><span class="hljs-comment">         *      2. Class&lt;?&gt;[]</span><br><span class="hljs-comment">         *          1. 真实主题实现的接口数组</span><br><span class="hljs-comment">         *      3. InvocationHandler</span><br><span class="hljs-comment">         *          1. 事件处理器</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 2. 作用</span><br><span class="hljs-comment">         *      1. 在运行时动态生成一个代理类，这个代理类实现了我们指定的接口数组然后，返回这个代理类的实例。</span><br><span class="hljs-comment">         *      2. 简单来说就是生成了一个代理类对象</span><br><span class="hljs-comment">         * ============================================</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(),<br>                target.getClass().getInterfaces(),<br>                invocationHandler<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建事件处理器</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 事件处理器：卖票事件处理器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketSellerInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TicketSellerInvocationHandler</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = Objects.requireNonNull(object, <span class="hljs-string">&quot;Target object cannot be null&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        <span class="hljs-comment">// 在调用真实方法前，可以做一些增强操作</span><br>        System.out.println(<span class="hljs-string">&quot;黄牛代售点开始受理卖票业务...&quot;</span>);<br><br>        <span class="hljs-comment">// 调用真实主题的方法（固定用法）</span><br>        method.invoke(target, args);<br><br>        <span class="hljs-comment">// 在调用真实方法后，也可以做一些增强操作</span><br>        System.out.println(<span class="hljs-string">&quot;黄牛代售点收取服务费10元。&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">TrainStation</span> <span class="hljs-variable">trainStation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainStation</span>();<br><br>        <span class="hljs-type">JdkProxyFactory</span> <span class="hljs-variable">jdkProxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkProxyFactory</span>(trainStation);<br><br>        <span class="hljs-type">TicketSellerInvocationHandler</span> <span class="hljs-variable">ticketSellerInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TicketSellerInvocationHandler</span>(trainStation);<br><br>        <span class="hljs-type">TicketSeller</span> <span class="hljs-variable">ticketSeller</span> <span class="hljs-operator">=</span> (TicketSeller) JdkProxyFactory.getProxyInstance(ticketSellerInvocationHandler);<br><br>        ticketSeller.sellTicket();<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="5-1-2-2-3-JDK-动态代理源码解析"><a href="#5-1-2-2-3-JDK-动态代理源码解析" class="headerlink" title="5.1.2.2.3. JDK 动态代理源码解析"></a>5.1.2.2.3. JDK 动态代理源码解析</h6><p><font color="#92d050">1. Proxy.newProxyInstance(ClassLoader, Class [], InvocationHandler)</font><br>在通用代理工厂中，我么首当其用的就是这个方法，我们先来看一下他的源码，他是 Proxy 类中的一个静态方法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/**<br><span class="hljs-bullet"> *</span> ============================================<br><span class="hljs-bullet"> *</span> newProxyInstance 方法<br><span class="hljs-bullet"> *</span> --------------------------------------------<br><span class="hljs-bullet"> *</span> 1. 作用<br><span class="hljs-bullet"> *</span>      1. 在运行时动态生成一个代理类，这个代理类实现了我们指定的接口数组然后，返回这个代理类的实例。<br><span class="hljs-bullet"> *</span>      2. 简单来说就是生成了一个代理类对象<br><span class="hljs-bullet"> *</span><br> * 2. 参数<br><span class="hljs-bullet"> *</span>      1. ClassLoader<br><span class="hljs-bullet"> *</span>          1. 真实主题使用的类加载器<br><span class="hljs-bullet"> *</span>      2. Class&lt;?&gt;[]<br><span class="hljs-bullet"> *</span>          1. 真实主题实现的接口数组<br><span class="hljs-bullet"> *</span>      3. InvocationHandler<br><span class="hljs-bullet"> *</span>          1. 事件处理器<br><span class="hljs-bullet"> *</span> ============================================<br> <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">@CallerSensitive</span><br><span class="hljs-emphasis">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) &#123;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">// 首先判断传入的类加载器是否为 null</span><br><span class="hljs-emphasis">Objects.requireNonNull(h);</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">@SuppressWarnings(&quot;removal&quot;)</span><br><span class="hljs-emphasis">final Class&lt;?&gt; caller = System.getSecurityManager() == null ? null : Reflection.getCallerClass();</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">return newProxyInstance(caller, cons, h);</span><br><span class="hljs-emphasis">&#125;</span><br></code></pre></td></tr></table></figure><p>这里面涉及到 System.getSecurityManager()，其实它是 JVM 内置安全控制，是一个权限检查的 “门卫”，简单来说<code>SecurityManager</code> 是 JVM 的一个全局对象，一旦你设置了它，Java 在执行很多敏感操作时文件操作、网络操作、反射调用、类加载）都会先问它“喂，这个代码允许干这事吗？”如果门卫说“不行”（抛 <code>SecurityException</code>），JVM 就会拒绝这次操作</p><p>其实这主要是因为90 年代末期 Java Applet（嵌在浏览器里的小 Java 程序）很流行，但它们运行在用户电脑上，风险很大<code>SecurityManager</code> 诞生就是为了让这些“不可信”的代码只能做安全范围内的事，比如只能访问它自己允许的文件夹，不能访问整个磁盘</p><p>它主要就是为了<strong>Applet、Java Web Start、嵌入式脚本引擎</strong> 这些 “运行在别人电脑上的代码” 设计的，现在这些技术几乎全灭（Applet 在 JDK 11 就彻底下线了），没人会在浏览器里直接跑 Java 代码了，所以现在这个用法在 JDK 17 中已经被标记为废弃，在 JDK 21 中已经被彻底移除了，现在的安全模型更倾向于模块化封装和外部环境，而不是 JVM 内部的全局拦截器：</p><ol><li>模块化<ol><li>即 Java 9 的 JPMS，能控制哪些模块能访问哪些 API</li></ol></li><li>类加载隔离</li><li>操作系统的杀向<ol><li>也就是 Docker、SELinux 等隔离进程权限</li></ol></li></ol><p>所以这个代码的意思就是，如果没有开启安全管理器，caller 直接设置为 null，如果开启了安全管理器，获取执行 Reflection.getCallerClass(); ，我们来看一下它的源码，它是 Reflection 类中的一个本地方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@CallerSensitive</span>  <br><span class="hljs-variable">@IntrinsicCandidate</span>  <br>public static native Class&lt;?&gt; <span class="hljs-built_in">getCallerClass</span>();<br></code></pre></td></tr></table></figure><p>我们也看不到他的实现，只需要知道它是用获取调用栈中上一个方法的调用者所在的类 对象，即 Class 对象，我们的调用栈是：<br><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9.png"></p><p>factory.getProxyInstace() 的所在类是 Factroy，所以返回的就是 Factory 的 Class 对象</p><p>然后我们再看 getProxyConstructor(caller, loader, interfaces);，它是 Proxy 类的一个静态方法：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;?&gt; <span class="hljs-title">getProxyConstructor</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>&lt;?&gt; caller, ClassLoader loader, <span class="hljs-keyword">Class</span>&lt;?&gt;... interfaces)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">if (interfaces.length == 1) &#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">Class&lt;?&gt; intf = interfaces[0];</span></span><br><span class="hljs-comment"><span class="hljs-function">if (caller != null) &#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">checkProxyAccess(caller, loader, intf);</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">proxyCache</span>.<span class="hljs-title">sub</span><span class="hljs-params">(intf)</span>.<span class="hljs-title">computeIfAbsent</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">loader,</span></span><br><span class="hljs-params"><span class="hljs-function">(ld, clv)</span> -&gt; <span class="hljs-title">new</span> <span class="hljs-title">ProxyBuilder</span><span class="hljs-params">(ld, clv.key()</span>).<span class="hljs-title">build</span><span class="hljs-params">()</span></span><br><span class="hljs-function">);</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">final Class&lt;?&gt;[] intfsArray = interfaces.clone();</span><br><span class="hljs-comment">if (caller != null) &#123;</span><br><span class="hljs-comment">checkProxyAccess(caller, loader, intfsArray);</span><br><span class="hljs-comment">&#125;</span><br>final List&lt;<span class="hljs-keyword">Class</span>&lt;?&gt;&gt; intfs = Arrays.asList(intfsArray);<br>return proxyCache.sub(intfs).computeIfAbsent(<br>loader,<br>(ld, clv) -&gt; new ProxyBuilder(ld, clv.key()).build()<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. InvocationHandler h</font><br>事件处理器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">Object</span> proxy, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>[] args) throws <span class="hljs-title class_">Throwable</span>;<br><br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">invokeDefault</span>(<span class="hljs-title class_">Object</span> proxy, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>... args) throws <span class="hljs-title class_">Throwable</span> &#123;<br><br>        <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">requireNonNull</span>(proxy);<br>        <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">requireNonNull</span>(method);<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">isProxyClass</span>(proxy.<span class="hljs-title function_">getClass</span>())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;&#x27;proxy&#x27; is not a proxy instance&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!method.<span class="hljs-title function_">isDefault</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;\&quot;&quot;</span> + method + <span class="hljs-string">&quot;\&quot; is not a default method&quot;</span>);<br>        &#125;<br>        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>        <span class="hljs-title class_">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span>&gt; proxyClass = (<span class="hljs-title class_">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span>&gt;)proxy.<span class="hljs-title function_">getClass</span>();<br><br>        <span class="hljs-title class_">Class</span>&lt;?&gt; intf = method.<span class="hljs-title function_">getDeclaringClass</span>();<br>        method.<span class="hljs-title function_">checkAccess</span>(<span class="hljs-title class_">Reflection</span>.<span class="hljs-title function_">getCallerClass</span>(), intf, proxyClass, method.<span class="hljs-title function_">getModifiers</span>());<br><br>        <span class="hljs-title class_">MethodHandle</span> mh = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">defaultMethodHandle</span>(proxyClass, method);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-title class_">Object</span>[] params = args != <span class="hljs-literal">null</span> ? args : <span class="hljs-title class_">Proxy</span>.<span class="hljs-property">EMPTY_ARGS</span>;<br>            <span class="hljs-keyword">return</span> mh.<span class="hljs-title function_">invokeExact</span>(proxy, params);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ClassCastException</span> | <span class="hljs-title class_">NullPointerException</span> e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(e.<span class="hljs-title function_">getMessage</span>(), e);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Proxy</span>.<span class="hljs-property">InvocationException</span> e) &#123;<br>            <span class="hljs-keyword">throw</span> e.<span class="hljs-title function_">getCause</span>();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-2-3-CGLIB-动态代理"><a href="#5-1-2-3-CGLIB-动态代理" class="headerlink" title="5.1.2.3. CGLIB 动态代理"></a>5.1.2.3. CGLIB 动态代理</h5><h6 id="5-1-2-3-1-CGLIB-动态代理概述"><a href="#5-1-2-3-1-CGLIB-动态代理概述" class="headerlink" title="5.1.2.3.1. CGLIB 动态代理概述"></a>5.1.2.3.1. CGLIB 动态代理概述</h6><p>CGLIB 动态代理是指：<strong>通过生成目标类的子类，在子类中重写非 final 方法，实现方法拦截，从而完成代理功能</strong>。</p><p>CGLIB 动态代理主要解决的问题是：JDK 动态代理要求真实主题必须实现接口，否则无法被代理。而 CGLIB 可以代理未实现接口的类，从而扩展了代理的适用范围。</p><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>CGLIB 动态代理不能代理 <code>final</code> 类和 <code>final</code> 方法</li></ol></blockquote><hr><h6 id="5-1-2-3-2-CGLIB-动态代理实现"><a href="#5-1-2-3-2-CGLIB-动态代理实现" class="headerlink" title="5.1.2.3.2. CGLIB 动态代理实现"></a>5.1.2.3.2. CGLIB 动态代理实现</h6><p><font color="#92d050">1. 添加相关依赖</font></p><ol><li>cglib<ol><li>Maven<ol><li><a href="https://mvnrepository.com/artifact/cglib/cglib">https://mvnrepository.com/artifact/cglib/cglib</a></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建真实主题（Real Subject）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 真实主题：火车站卖票</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TicketSeller</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;火车站成功卖出一张火车票。&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建通用代理工厂</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通用代理工厂：CGLIB 代理工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br><br>    <span class="hljs-comment">// 属性：对 Real Subject 的引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CglibProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br><span class="hljs-comment">// 具体方法：获取代理实例</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Callback callback)</span> &#123;<br>    <br>        <span class="hljs-comment">// 创建一个工具类，这个类是用来创建动态代理类的</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br><br>        <span class="hljs-comment">// 设置代理类的父类的 Class 对象（CGLIB 动态代理本质上是继承真实主题来实现的）</span><br>        enhancer.setSuperclass(target.getClass());<br><br>        <span class="hljs-comment">// 设置回调函数，Cglib 会根据回调函数的类型进行不同的处理</span><br>        enhancer.setCallback(callback);<br><br>        <span class="hljs-comment">// 创建动态代理对象并返回</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建 Callback</font><br>Callback 就是我们设置的回调函数，CGLIB 提供了多种 Callback 类型。使用这些类型时，CGLIB 会根据 Callback 的具体类型自动执行不同的处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Callback：MethodInterceptor 类型的回调函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTicketCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>  <br>        <span class="hljs-comment">// 在调用真实方法前，可以做一些增强操作  </span><br>        System.out.println(<span class="hljs-string">&quot;黄牛代售点开始受理卖票业务...&quot;</span>);  <br>  <br>        <span class="hljs-comment">// 调用真实主题的方法（固定用法）  </span><br>        methodProxy.invokeSuper(o, objects);  <br>  <br>        <span class="hljs-comment">// 在调用真实方法后，也可以做一些增强操作  </span><br>        System.out.println(<span class="hljs-string">&quot;黄牛代售点收取服务费10元。&quot;</span>);  <br>  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Clinet</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">TrainStation</span> <span class="hljs-variable">trainStation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainStation</span>();<br><br>        <span class="hljs-type">JdkProxyFactory</span> <span class="hljs-variable">jdkProxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkProxyFactory</span>(trainStation);<br><br>        <span class="hljs-type">TicketSellerInvocationHandler</span> <span class="hljs-variable">ticketSellerInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TicketSellerInvocationHandler</span>(trainStation);<br><br>        <span class="hljs-type">TicketSeller</span> <span class="hljs-variable">ticketSeller</span> <span class="hljs-operator">=</span> (TicketSeller) JdkProxyFactory.getProxyInstance(ticketSellerInvocationHandler);<br><br>        ticketSeller.sellTicket();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">6. 添加 JVM 启动参数</font><br>在 <strong>Java 9 及之后版本（你的 JDK 21）</strong>，模块化系统默认禁止访问 <code>java.base</code> 模块的内部类和方法，所以我们需要添加 JVM 启动参数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">--<span class="hljs-keyword">add</span>-opens java.<span class="hljs-keyword">base</span>/java.lang=ALL-UNNAMED<br></code></pre></td></tr></table></figure><hr><h6 id="5-1-2-3-3-CGLIB-提供的-Callback-类型"><a href="#5-1-2-3-3-CGLIB-提供的-Callback-类型" class="headerlink" title="5.1.2.3.3. CGLIB 提供的 Callback 类型"></a>5.1.2.3.3. CGLIB 提供的 Callback 类型</h6><p>CGLIB 提供了多种 Callback 类型，CGLIB 会根据 Callback 的具体类型自动执行不同的处理逻辑：</p><p><font color="#92d050">1. MethodInterceptor</font><br>当真实主题的方法被调用时，会被拦截，直接进入这里的 <code>intercept</code> 方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>  <br>        <span class="hljs-comment">// 在调用真实方法前，可以做一些增强操作    </span><br>System.out.println(<span class="hljs-string">&quot;黄牛代售点开始受理卖票业务...&quot;</span>);  <br>  <br>        <span class="hljs-comment">// 调用真实主题的方法（固定用法）    </span><br>methodProxy.invokeSuper(o, objects);  <br>  <br>        <span class="hljs-comment">// 在调用真实方法后，也可以做一些增强操作    </span><br>System.out.println(<span class="hljs-string">&quot;黄牛代售点收取服务费10元。&quot;</span>);  <br>  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>          <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. NoOp</font><br>它就是一个透明代理，不执行任何操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NoOp</span> &#123;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. FixedValue</font><br>真实主题的方法不会被执行，只在这里返回一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FixedValue</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-桥接模式"><a href="#5-2-桥接模式" class="headerlink" title="5.2. 桥接模式"></a>5.2. 桥接模式</h3><h4 id="5-2-1-桥接模式概述"><a href="#5-2-1-桥接模式概述" class="headerlink" title="5.2.1. 桥接模式概述"></a>5.2.1. 桥接模式概述</h4><p>桥接模式是指：<strong>将抽象部分与它的实现部分分离，使它们可以独立地变化</strong>。</p><p>桥接模式主要解决的问题是：<br>抽象部分和实现部分可以看作业务的不同维度（抽象部分代表主维度，实现部分代表其他维度）。例如，在支付场景中，支付渠道是主维度（如微信支付、支付宝支付），而支付方式则是另一维度（如密码、指纹、人脸）</p><p>在这种情况下，如果直接使用策略模式，可能需要为每种组合都写一个具体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 支付方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pay</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String uid, <span class="hljs-type">double</span> amount)</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 微信 + 密码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPasswordPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String uid, <span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【微信-密码】用户：&quot;</span> + uid + <span class="hljs-string">&quot; 支付金额：&quot;</span> + amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，还会有 微信 + 指纹、微信 + 人脸、支付宝 + 密码、支付宝 + 指纹、支付宝 + 人脸 等组合，这是典型的 “支付渠道 × 支付方式” 场景，会导致类数量迅速增加。</p><p>例如，如果再增加银行支付，就会出现 银行支付 + 指纹、银行支付 + 人脸、银行支付 + 密码 等组合，类会呈爆炸式增长。因此，桥接模式主要用于解决这种多维度组合导致的类爆炸问题。</p><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14.png"></p><p>桥接模式通常包含四个角色：</p><ol><li>抽象化（Abstraction）<ol><li>抽象类</li><li>持有对 <code>Implementor</code> 的引用</li></ol></li><li>扩展抽象化（RefinedAbstraction）<ol><li>继承 Abstraction 的具体类</li></ol></li><li>实现化（Implementor）<ol><li>通常是接口，也可以是抽象类</li></ol></li><li>具体实现化（ConcreteImplementor）<ol><li>具体类</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>并不是说策略模式不好，它本身非常强大，只是策略模式更适合解决单维度的问题，对于多维度组合就显得力不从心</li><li>但是如果我们尝试为两个维度分别设计策略模式，你会发现最终落地的代码与使用桥接模式的代码几乎相同</li><li>桥接模式的核心在于先识别出抽象部分，也就是业务的主维度</li></ol></blockquote><hr><h4 id="5-2-2-桥接模式实现"><a href="#5-2-2-桥接模式实现" class="headerlink" title="5.2.2. 桥接模式实现"></a>5.2.2. 桥接模式实现</h4><p><font color="#92d050">1. 创建实现化（Implementor）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现化：支付方式  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PayMode</span> &#123;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(String uid)</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体实现化（ConcreteImplementor）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体实现化：密码  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PayMode</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(String uid)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;密码验证成功，用户：&quot;</span> + uid);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体实现化：指纹  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FingerprintPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PayMode</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(String uid)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;指纹验证成功，用户：&quot;</span> + uid);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>      <br>&#125;<br><br><br><span class="hljs-comment">// 具体实现化：人脸  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FacePay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PayMode</span> &#123;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(String uid)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;人脸识别成功，用户：&quot;</span> + uid);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建抽象化（Abstraction）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象化：支付渠道  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayChannel</span> &#123;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * ============================================     </span><br><span class="hljs-comment">     * 属性：对 PayMode 的引用  </span><br><span class="hljs-comment">     * --------------------------------------------  </span><br><span class="hljs-comment">     * 1. 访问修饰符  </span><br><span class="hljs-comment">     *      1. protected  </span><br><span class="hljs-comment">     *          1. 不希望其他包的类随意访问  </span><br><span class="hljs-comment">     *          2. 但又希望其他包的子类能够访问  </span><br><span class="hljs-comment">     * ============================================  </span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-keyword">protected</span> PayMode payMode;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PayChannel</span><span class="hljs-params">(PayMode payMode)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.payMode = payMode;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 抽象方法：支付  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String uid, <span class="hljs-type">double</span> amount)</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建扩展抽象化（RefinedAbstraction）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扩展抽象化：微信支付  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PayChannel</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeChatPay</span><span class="hljs-params">(PayMode payMode)</span> &#123;  <br>    <span class="hljs-comment">// 调用父类的构造参数</span><br>        <span class="hljs-built_in">super</span>(payMode);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String uid, <span class="hljs-type">double</span> amount)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;【微信支付】用户：&quot;</span> + uid + <span class="hljs-string">&quot;，金额：&quot;</span> + amount);  <br>        <span class="hljs-keyword">if</span> (payMode.verify(uid)) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;支付成功！&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 扩展抽象化：支付宝支付  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PayChannel</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AliPay</span><span class="hljs-params">(PayMode payMode)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(payMode);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String uid, <span class="hljs-type">double</span> amount)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;【支付宝支付】用户：&quot;</span> + uid + <span class="hljs-string">&quot;，金额：&quot;</span> + amount);  <br>        <span class="hljs-keyword">if</span> (payMode.verify(uid)) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;支付成功！&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">AliPay</span> <span class="hljs-variable">aliPay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliPay</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FacePay</span>());  <br>  <br>        aliPay.pay(<span class="hljs-string">&quot;5527&quot;</span>, <span class="hljs-number">888.8</span>);  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-3-装饰器模式"><a href="#5-3-装饰器模式" class="headerlink" title="5.3. 装饰器模式"></a>5.3. 装饰器模式</h3><h4 id="5-3-1-装饰器模式概述"><a href="#5-3-1-装饰器模式概述" class="headerlink" title="5.3.1. 装饰器模式概述"></a>5.3.1. 装饰器模式概述</h4><p>装饰器模式是指：<strong>在不改变原有对象结构的前提下，动态地为对象增加额外的职责</strong></p><p>装饰器模式通常包含四个角色：</p><ol><li>抽象组件（Component）<ol><li>通常是接口，也可以是抽象类</li></ol></li><li>具体组件（ConcreteComponent）<ol><li>实现或继承 Component 的具体类</li></ol></li><li>抽象装饰（Decorator）<ol><li>实现 Component 的抽象类</li></ol></li><li>具体装饰（ConcreteDecorator）<ol><li>继承 Decorator 的具体类</li></ol></li></ol><hr><h4 id="5-3-2-装饰器模式实现"><a href="#5-3-2-装饰器模式实现" class="headerlink" title="5.3.2. 装饰器模式实现"></a>5.3.2. 装饰器模式实现</h4><p>场景：咖啡店卖咖啡，不同顾客可能要加奶、加糖</p><p><font color="#92d050">1. 创建抽象组件（Component）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象组件  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coffee</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 具体组件（ConcreteComponent）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体组件  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCoffee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Simple Coffee&quot;</span>;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 抽象装饰（Decorator）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象装饰  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;  <br>  <br>    <span class="hljs-keyword">protected</span> Coffee coffee;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CoffeeDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.coffee = coffee;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> coffee.cost();  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> coffee.description();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建具体装饰（ConcreteDecorator）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体装饰器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoffeeDecorator</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MilkDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(coffee);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.cost() + <span class="hljs-number">2</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.description() + <span class="hljs-string">&quot;, Milk&quot;</span>;  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体装饰器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SugarDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoffeeDecorator</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SugarDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(coffee);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.cost() + <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.description() + <span class="hljs-string">&quot;, Sugar&quot;</span>;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Coffee</span> <span class="hljs-variable">coffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleCoffee</span>();  <br>        System.out.println(coffee.description() + <span class="hljs-string">&quot; $&quot;</span> + coffee.cost());  <br>  <br>        <span class="hljs-type">Coffee</span> <span class="hljs-variable">milkCoffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MilkDecorator</span>(coffee);  <br>        System.out.println(milkCoffee.description() + <span class="hljs-string">&quot; $&quot;</span> + milkCoffee.cost());  <br>  <br>        <span class="hljs-type">Coffee</span> <span class="hljs-variable">milkSugarCoffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SugarDecorator</span>(milkCoffee);  <br>        System.out.println(milkSugarCoffee.description() + <span class="hljs-string">&quot; $&quot;</span> + milkSugarCoffee.cost());  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-4-适配器模式"><a href="#5-4-适配器模式" class="headerlink" title="5.4. 适配器模式"></a>5.4. 适配器模式</h3><h4 id="5-4-1-适配器模式概述"><a href="#5-4-1-适配器模式概述" class="headerlink" title="5.4.1. 适配器模式概述"></a>5.4.1. 适配器模式概述</h4><p>适配器模式是指：<strong>将一个类的接口转换成客户期望的另一种接口，使得原本由于接口不兼容而不能一起工作的类能够协同工作</strong></p><p>适配器模式通常包含三个角色：</p><ol><li>目标接口（Target）<ol><li>通常是接口，也可以是抽象类</li></ol></li><li>适配者（Adaptee）</li><li>适配器（Adapter）</li></ol><hr><h4 id="5-4-2-适配器模式实现"><a href="#5-4-2-适配器模式实现" class="headerlink" title="5.4.2. 适配器模式实现"></a>5.4.2. 适配器模式实现</h4><h5 id="5-4-2-1-类适配器"><a href="#5-4-2-1-类适配器" class="headerlink" title="5.4.2.1. 类适配器"></a>5.4.2.1. 类适配器</h5><p><font color="#92d050">1. 创建目标接口（Target）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标接口  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建适配者（Adaptee）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适配者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">specificRequest</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Adaptee：特殊方法&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 适配器（Adapter）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适配器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;  <br>        specificRequest();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>();  <br>  <br>        target.request();  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-4-2-2-对象适配器"><a href="#5-4-2-2-对象适配器" class="headerlink" title="5.4.2.2. 对象适配器"></a>5.4.2.2. 对象适配器</h5><p><font color="#92d050">1. 创建目标接口（Target）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标接口  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建适配者（Adaptee）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适配者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">specificRequest</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Adaptee：特殊方法&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 适配器（Adapter）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适配器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Adaptee adaptee;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;  <br>        adaptee.specificRequest();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Adaptee</span>());  <br>          <br>        target.request();  <br>          <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-5-外观模式"><a href="#5-5-外观模式" class="headerlink" title="5.5. 外观模式"></a>5.5. 外观模式</h3><h4 id="5-5-1-外观模式概述"><a href="#5-5-1-外观模式概述" class="headerlink" title="5.5.1. 外观模式概述"></a>5.5.1. 外观模式概述</h4><p>外观模式是指：子系统中的一组接口提供一个统一的高层接口，使得子系统更易使用。该模式通常包含三个角色：</p><ol><li>外观（Facade）<ol><li>具体类</li><li>对外提供统一的方法，这些方法封装了多个子系统方法的调用，客户端只需调用外观类的方法即可完成复杂操作</li></ol></li><li>子系统（Subsystem）<ol><li>具体类</li><li>各子系统实现其功能，由外观类统一调用，客户端通常不直接与子系统交互</li></ol></li></ol><hr><h4 id="5-5-2-外观模式实现"><a href="#5-5-2-外观模式实现" class="headerlink" title="5.5.2. 外观模式实现"></a>5.5.2. 外观模式实现</h4><p>场景：假设我们有一个家庭影院系统，包含投影仪、音响和 DVD 播放器，但客户只希望通过 “一键观影” 即可体验，不关心系统的内部操作</p><p><font color="#92d050">1. 创建子系统（Subsystem）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子系统：观影仪  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Projector</span> &#123;  <br>      <br>    <span class="hljs-comment">// 具体方法：打开观影仪  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;打开观影仪...&quot;</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-comment">// 具体方法：关闭观影仪  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;关闭观影仪...&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br><br><br><span class="hljs-comment">// 子系统：音响  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoundSystem</span> &#123;  <br>  <br>    <span class="hljs-comment">// 具体方法：打开音响  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;打开音响...&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：关闭音响  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;关闭音响...&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 子系统：DVD 播放器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DvdPlayer</span> &#123;  <br>  <br>    <span class="hljs-comment">// 具体方法：打开 DVD 播放器  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;打开DVD 播放器...&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;播放 DVD&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：关闭DVD 播放器  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;关闭DVD 播放器...&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建外观类（Facade）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeTheaterFacade</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 Projector 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> Projector projector;  <br>      <br>    <span class="hljs-comment">// 属性：对 SoundSystem 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> SoundSystem soundSystem;  <br>      <br>    <span class="hljs-comment">// 属性：对 DvdPlayer 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> DvdPlayer dvdPlayer;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HomeTheaterFacade</span><span class="hljs-params">(Projector projector, SoundSystem soundSystem, DvdPlayer dvdPlayer)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.projector = projector;  <br>        <span class="hljs-built_in">this</span>.soundSystem = soundSystem;  <br>        <span class="hljs-built_in">this</span>.dvdPlayer = dvdPlayer;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：观看电影  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchMovie</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;准备开始观影...&quot;</span>);  <br>        projector.on();  <br>        soundSystem.on();  <br>        dvdPlayer.on();  <br>        dvdPlayer.play();  <br>        System.out.println(<span class="hljs-string">&quot;电影已开始！&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：关闭系统  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endMovie</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;电影结束，关闭设备...&quot;</span>);  <br>        dvdPlayer.off();  <br>        soundSystem.off();  <br>        projector.off();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Projector</span> <span class="hljs-variable">projector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Projector</span>();  <br>  <br>        <span class="hljs-type">SoundSystem</span> <span class="hljs-variable">soundSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoundSystem</span>();  <br>  <br>        <span class="hljs-type">DvdPlayer</span> <span class="hljs-variable">dvdPlayer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DvdPlayer</span>();  <br>  <br>        <span class="hljs-type">HomeTheaterFacade</span> <span class="hljs-variable">homeTheaterFacade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HomeTheaterFacade</span>(projector, soundSystem, dvdPlayer);  <br>  <br>        homeTheaterFacade.watchMovie();  <br>  <br>        homeTheaterFacade.endMovie();  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6. 组合模式"></a>5.6. 组合模式</h3><h4 id="5-6-1-组合模式概述"><a href="#5-6-1-组合模式概述" class="headerlink" title="5.6.1. 组合模式概述"></a>5.6.1. 组合模式概述</h4><p>组合模式是指：将对象组合成树形结构以表示 “整体-部分” 的层次结构，使客户端在使用单个对象和组合对象时保持一致。该模式通常包含三个角色：</p><ol><li>抽象根节点（抽象组件，Component）<ol><li>通常是接口，也可以是抽象类</li><li>定义了 “树枝节点和叶子节点必须实现的方法” 的规范</li></ol></li><li>树枝节点（组合节点，Composite）<ol><li>实现或继承了 Component 的具体类</li><li>维护一个数据结构，用于管理 Component 的引用（即子节点的引用，既可以是树枝节点，也可以是叶子节点）</li><li>可以理解为文件管理系统中的文件夹，既可以存放文件夹，也可以存放文件</li></ol></li><li>叶子节点（Leaf）<ol><li>实现或继承了 Component 的具体类</li><li>最小的处理单元，无子节点</li><li>可以理解为文件管理系统中的文件</li></ol></li></ol><hr><h4 id="5-6-2-组合模式实现"><a href="#5-6-2-组合模式实现" class="headerlink" title="5.6.2. 组合模式实现"></a>5.6.2. 组合模式实现</h4><p><font color="#92d050">1. 创建抽象根节点（Component）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象根节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 接口方法：显示结构</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 参数：</span><br><span class="hljs-comment">     *      1. indent</span><br><span class="hljs-comment">     *          1. 缩进字符串，例如&quot;&quot;、&quot;  &quot;</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String indent)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建树枝节点（Composite）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 树枝节点：文件夹</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FolderNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br><br>    <span class="hljs-comment">// 属性：文件夹名称（private）</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// 属性：维护一个数据结构，用于管理 FileSystemNode 的引用（private）</span><br>    <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FolderNode</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 具体方法：向数据结构中添加 FileSystemNode 的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(FileSystemNode node)</span> &#123;<br>        children.add(node);<br>    &#125;<br><br>    <span class="hljs-comment">// 具体方法：向数据结构中移除 FileSystemNode 的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(FileSystemNode node)</span> &#123;<br>        children.remove(node);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写方法：显示结构</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String indent)</span> &#123;<br>        System.out.println(indent + <span class="hljs-string">&quot;📁 &quot;</span> + name);<br>        <span class="hljs-keyword">for</span> (FileSystemNode child : children) &#123;<br>            child.show(indent + <span class="hljs-string">&quot;    &quot;</span>);<br>        &#125;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建叶子节点（Leaf）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 叶子节点：文件  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileSystemNode</span> &#123;  <br><br>    <span class="hljs-comment">// 属性：文件名称</span><br>    <span class="hljs-keyword">private</span> String name;  <br>    <br><span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileNode</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br><br><span class="hljs-comment">// 重写方法：显示结构</span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String indent)</span> &#123;  <br>        System.out.println(indent + <span class="hljs-string">&quot;📄 &quot;</span> + name);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">FolderNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FolderNode</span>(<span class="hljs-string">&quot;Root&quot;</span>);  <br>        <span class="hljs-type">FileNode</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNode</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);  <br>        <span class="hljs-type">FileNode</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNode</span>(<span class="hljs-string">&quot;b.txt&quot;</span>);  <br>  <br>        <span class="hljs-type">FolderNode</span> <span class="hljs-variable">subFolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FolderNode</span>(<span class="hljs-string">&quot;SubFolder&quot;</span>);  <br>        subFolder.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNode</span>(<span class="hljs-string">&quot;c.txt&quot;</span>));  <br>  <br>        root.add(file1);  <br>        root.add(file2);  <br>        root.add(subFolder);  <br>  <br>        root.show(<span class="hljs-string">&quot;&quot;</span>);  <br>  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 输出结果</span><br>📁 Root<br>    📄 a.txt<br>    📄 b.txt<br>    📁 SubFolder<br>        📄 c.txt<br></code></pre></td></tr></table></figure><hr><h2 id="6-行为模式（11-种）"><a href="#6-行为模式（11-种）" class="headerlink" title="6. 行为模式（11 种）"></a>6. 行为模式（11 种）</h2><h3 id="6-1-观察者模式"><a href="#6-1-观察者模式" class="headerlink" title="6.1. 观察者模式"></a>6.1. 观察者模式</h3><h4 id="6-1-1-观察者模式概述"><a href="#6-1-1-观察者模式概述" class="headerlink" title="6.1.1. 观察者模式概述"></a>6.1.1. 观察者模式概述</h4><p>观察者模式用于<strong>建立对象之间的一种一对多依赖关系</strong>：当一个对象的状态发生变化时，所有依赖它的对象会收到通知并自动更新。该模式通常包含四个角色：</p><ol><li>抽象被观察者（抽象主题，Subject）<ol><li>通常是接口，也可以是抽象类</li><li>定义了 “被观察者必须实现的方法” 的规范</li><li>主要方法包括：<ol><li>registerObserver(Observer o)<ol><li>注册观察者</li></ol></li><li>removeObserver(Observer o)<ol><li>移除观察者</li></ol></li><li>notifyObservers()<ol><li>当状态改变时，通知所有观察者</li></ol></li></ol></li></ol></li><li>具体被观察者（具体主题，ConcreteSubject）<ol><li>实现或继承了 Subject</li><li>通常还维护一个数据结构，用于存储观察者的引用</li><li>当其内部状态改变时，会调用 <code>notifyObservers()</code> 方法通知所有观察者</li></ol></li><li>抽象观察者（Observer）<ol><li>通常是接口，也可以是抽象类</li><li>定义了 “观察者必须实现的方法” 的规范</li><li>主要方法包括：<ol><li>update(…)<ol><li>当观察者在接收到被观察者的通知后，会执行各自的具体更新操作。</li></ol></li></ol></li></ol></li><li>具体观察者（ConcreteObserver）<ol><li>实现或继承了 Observer</li><li>持有对 Subject 的引用，负责向不同 ConcreteSubject 中维护的数据结构注册或移除自己</li></ol></li></ol><p>其缺点是：</p><ol><li>不保证顺序<ol><li>被观察者是向所有注册的观察者广播通知，因此本身不保证顺序</li><li>如果观察者之间存在依赖关系，那</li></ol></li><li>性能问题<ol><li>如果观察者数量非常多，或者观察者的 <code>update</code> 方法非常耗时，通知过程可能会导致性能瓶颈</li></ol></li><li>内存泄露风险<ol><li>如果一个观察者在创建后，被注册到被观察者维护的数据结构中</li><li>但是之后不再使用，而且未被移除，它将无法被垃圾回收，从而导致内存泄漏</li></ol></li></ol><hr><h4 id="6-1-2-观察者模式实现"><a href="#6-1-2-观察者模式实现" class="headerlink" title="6.1.2. 观察者模式实现"></a>6.1.2. 观察者模式实现</h4><p>场景：当气象站（<code>WeatherData</code>）获取最新的天气数据（温度、湿度、气压）时，实时布告板（<code>CurrentConditionsDisplay</code>）上显示这些数据</p><p><font color="#92d050">1. 创建抽象被观察者（Subject）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象被观察者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;  <br>  <br>    <span class="hljs-comment">// 注册观察者  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span>;  <br>  <br>    <span class="hljs-comment">// 移除观察者  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;  <br>  <br>    <span class="hljs-comment">// 当状态改变时，通知所有观察值  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体被观察者（ConcreteObserver）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体被观察者：气象站</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span>&#123;<br><br>    <span class="hljs-comment">// 维护一个数据结构，用于存储观察者的引用</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers;<br><br>    <span class="hljs-comment">// 温度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> temperature;<br><br>    <span class="hljs-comment">// 湿度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> humidity;<br><br>    <span class="hljs-comment">// 气压</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> airPressure;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> airPressure)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>        <span class="hljs-built_in">this</span>.humidity = humidity;<br>        <span class="hljs-built_in">this</span>.airPressure = airPressure;<br>        <span class="hljs-built_in">this</span>.observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// 修改状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">ChangeData</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> airPressure)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>        <span class="hljs-built_in">this</span>.humidity = humidity;<br>        <span class="hljs-built_in">this</span>.airPressure = airPressure;<br>        notifyObservers();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.add(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        <span class="hljs-keyword">if</span> (observers.contains(observer))<br>            observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer: observers) &#123;<br>            observer.update(temperature, humidity, airPressure);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在这里可以看到，所谓的 “通知” 其实就是遍历观察者列表，依次调用每个观察者的 <code>update</code> 方法。</li></ol></blockquote><p><font color="#92d050">3. 创建抽象观察者</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象观察者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> airPressure)</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建具体观察者</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体观察者：实时布告板</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditionsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">float</span> temperature;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">float</span> humidity;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">float</span> airPressure;<br><br>    <span class="hljs-comment">// 对 Subject 的引用</span><br>    <span class="hljs-keyword">private</span> Subject subject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CurrentConditionsDisplay</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.subject = subject;<br>        <span class="hljs-comment">// 在创建时就注册自己</span><br>        subject.registerObserver(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> airPressure)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>        <span class="hljs-built_in">this</span>.humidity = humidity;<br>        <span class="hljs-built_in">this</span>.airPressure = airPressure;<br>        display();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<br>                <span class="hljs-string">&quot;------ 当前布告板 ------&quot;</span><br>                + <span class="hljs-string">&#x27;\n&#x27;</span> +<br>                <span class="hljs-string">&quot;温度：&quot;</span> + temperature<br>                + <span class="hljs-string">&#x27;\n&#x27;</span> +<br>                <span class="hljs-string">&quot;湿度：&quot;</span> + humidity<br>                + <span class="hljs-string">&#x27;\n&#x27;</span> +<br>                <span class="hljs-string">&quot;气压：&quot;</span> + airPressure<br>                + <span class="hljs-string">&#x27;\n&#x27;</span> +<br>                <span class="hljs-string">&quot;-----------------------&quot;</span><br>                + <span class="hljs-string">&#x27;\n&#x27;</span><br>        );<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>  <br>        <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>(<span class="hljs-number">28.6F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">666F</span>);  <br>  <br>        <span class="hljs-type">CurrentConditionsDisplay</span> <span class="hljs-variable">currentConditionsDisplay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditionsDisplay</span>(weatherData);  <br>  <br>        System.out.println(<span class="hljs-string">&quot;初始时布告板状态：&quot;</span> + <span class="hljs-string">&#x27;\n&#x27;</span>);  <br>  <br>        currentConditionsDisplay.display();  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>        System.out.println(<span class="hljs-string">&quot;注意：气象站更新！&quot;</span> + <span class="hljs-string">&#x27;\n&#x27;</span>);  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>        weatherData.ChangeData(<span class="hljs-number">33F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">555F</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-2-模板方法模式"><a href="#6-2-模板方法模式" class="headerlink" title="6.2. 模板方法模式"></a>6.2. 模板方法模式</h3><h4 id="6-2-1-模板方法模式概述"><a href="#6-2-1-模板方法模式概述" class="headerlink" title="6.2.1. 模板方法模式概述"></a>6.2.1. 模板方法模式概述</h4><p>模板方法模式是指：<strong>在一个方法中定义算法的骨架，把一些步骤延迟到子类去实现，这样就能在不改变算法整体结构的前提下，允许子类重新定义某些步骤的具体实现</strong>。</p><p>该模式通常包含两个角色：</p><ol><li>抽象父类（模板类）<ol><li>必须是抽象类，因为需要规定模板方法</li><li>命名以 <code>Abstract</code> 开头，以 <code>Template</code> 结尾</li><li>主要方法包括：<ol><li>模板方法<ol><li>一个具体方法，用来定义算法步骤的执行顺序</li><li>对修改关闭，不能被子类重写</li></ol></li><li>具体方法<ol><li>已实现的方法</li></ol></li><li>抽象方法<ol><li>子类必须重写的方法</li></ol></li><li>钩子方法<ol><li>一个具体方法，子类可以选择性地重写以修改行为</li><li>命名以 <code>hook</code> 开头</li></ol></li></ol></li></ol></li><li>具体子类<ol><li>继承了抽象父类</li></ol></li></ol><p>其缺点是：</p><ol><li>扩展性差<ol><li>流程的骨架若需大幅调整，必须修改父类的模板方法，这会影响到所有子类</li><li>所以它只适合骨架稳定的场景</li></ol></li></ol><hr><h4 id="6-2-2-模板方法模式实现"><a href="#6-2-2-模板方法模式实现" class="headerlink" title="6.2.2. 模板方法模式实现"></a>6.2.2. 模板方法模式实现</h4><p>场景：一个餐厅需要做不同菜系的菜品，每道菜的烹饪流程大致相同：</p><ol><li>准备食材</li><li>烹饪主菜</li><li>根据需要制作配菜</li><li>上菜</li></ol><p><font color="#92d050">1. 创建抽象父类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCookTemplate</span> &#123;<br><br>    <span class="hljs-comment">// 模板方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cook</span><span class="hljs-params">()</span> &#123;<br>        prepareIngredients();<br>        cookDish();<br>        <span class="hljs-keyword">if</span> (hookNeedSideDish()) &#123;<br>            makeSideDish();<br>        &#125;<br>        serve();<br>    &#125;<br><br>    <span class="hljs-comment">// 准备食材</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareIngredients</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 烹饪主菜</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cookDish</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 是否需要配菜，钩子方法，子类可选择实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hookNeedSideDish</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 制作配菜</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSideDish</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作配菜...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 上菜</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serve</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上菜...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体子类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChineseCook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTemplateCook</span>&#123;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareIngredients</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;准备青菜和肉&quot;</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cookDish</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;烹饪主菜&quot;</span>);  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>          <br>        <span class="hljs-type">AbstractCookTemplate</span> <span class="hljs-variable">abstractCookTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChineseCook</span>();  <br>          <br>        abstractCookTemplate.cook();  <br>          <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-3-策略模式"><a href="#6-3-策略模式" class="headerlink" title="6.3. 策略模式"></a>6.3. 策略模式</h3><h4 id="6-3-1-策略模式概述"><a href="#6-3-1-策略模式概述" class="headerlink" title="6.3.1. 策略模式概述"></a>6.3.1. 策略模式概述</h4><p>策略模式是指：将一组算法封装成独立的策略类，使得算法<strong>可以在运行时自由切换</strong>，从而让算法的变化独立于使用算法的客户端。</p><p>策略模式通常包含三个角色：</p><ol><li>抽象策略（Strategy）<ol><li>通常是接口，也可以是抽象类</li><li>定义了 “具体策略必须实现的方法” 的规范</li></ol></li><li>具体策略（ConcreteStrategy）<ol><li>实现或继承了 Strategy</li></ol></li><li>上下文（Context）<ol><li>持有对 Strategy 的引用，负责调用不同 ConcreteStrategy 的方法</li><li>如果有共享数据，需要在上下文中进行维护</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>策略模式的接口天然符合开闭原则（OCP），可以避免大量的 if-else 或 switch 判断</li></ol></blockquote><hr><h4 id="6-3-2-策略模式实现"><a href="#6-3-2-策略模式实现" class="headerlink" title="6.3.2. 策略模式实现"></a>6.3.2. 策略模式实现</h4><p>场景：我们要做一个支付功能，支持 支付宝支付 和 微信支付 两种方式</p><p><font color="#92d050">1. 创建抽象策略（Strategy）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象策略  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;  <br>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体策略（ConcreteStrategy）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 支付宝支付  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPayment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;使用支付宝支付 &quot;</span> + amount + <span class="hljs-string">&quot; 元&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 微信支付  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPayment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;使用微信支付 &quot;</span> + amount + <span class="hljs-string">&quot; 元&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建上下文（Context）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentContext</span> &#123;  <br>  <br>    <span class="hljs-comment">// 对 strategy 的引用  </span><br>    <span class="hljs-keyword">private</span> PaymentStrategy strategy;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PaymentContext</span><span class="hljs-params">(PaymentStrategy strategy)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.strategy = strategy;  <br>    &#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">setPaymentStrategy</span><span class="hljs-params">(PaymentStrategy strategy)</span> &#123;<br><span class="hljs-built_in">this</span>.strategy = strategy;<br>&#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executePayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;  <br>        strategy.pay(amount);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">AlipayPayment</span> <span class="hljs-variable">alipayPayment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlipayPayment</span>();  <br>        <br>        <span class="hljs-type">WechatPayment</span> <span class="hljs-variable">wechatPayment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatPayment</span>();<br>  <br>        <span class="hljs-type">PaymentContext</span> <span class="hljs-variable">paymentContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentContext</span>(alipayPayment);  <br>  <br>        paymentContext.executePayment(<span class="hljs-number">55</span>);  <br>        <br>        paymentContext.setPaymentStrategy(wechatPayment);<br>        <br>        paymentContext.executePayment(<span class="hljs-number">66</span>);  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-4-责任链模式"><a href="#6-4-责任链模式" class="headerlink" title="6.4. 责任链模式"></a>6.4. 责任链模式</h3><h4 id="6-4-1-责任链模式概述"><a href="#6-4-1-责任链模式概述" class="headerlink" title="6.4.1. 责任链模式概述"></a>6.4.1. 责任链模式概述</h4><p>责任链模式是指：将多个处理请求的对象用链式结构连接起来，请求沿着链传递，每个对象可以处理请求，也可以把请求交给链上的下一个对象。</p><p>该模式通常包含三个角色：</p><ol><li>抽象处理者（Handler）<ol><li>必须是抽象类，因为要提供设置下一个处理请求的对象的引用的方法</li></ol></li><li>具体处理者（ConcreteHandler）<ol><li>实现了 Handler</li><li>判断能否处理本次请求，可以处理就处理，否则将请求转发给他的下一个处理请求的对象</li></ol></li><li>客户端（Client）<ol><li>负责组装责任链，并将请求提供给责任链连头的对象</li></ol></li></ol><p>其缺点是：</p><ol><li>性能开销大<ol><li>请求可能会沿着整个链一直传递，直到找到处理者或者到达链尾</li><li>链条很长时，每个请求都要经过多个对象，可能会影响性能</li></ol></li><li>链中断风险<ol><li>如果链条设置不当（比如某个节点没有正确转发请求），请求可能被 “吞掉”，没有任何处理结果</li></ol></li></ol><hr><h4 id="6-4-2-责任链模式实现"><a href="#6-4-2-责任链模式实现" class="headerlink" title="6.4.2. 责任链模式实现"></a>6.4.2. 责任链模式实现</h4><p>场景：一个金额审批的请求需要依次经过 组长 → 经理 → 总监 审批，每个人只处理自己权限范围内的请求</p><p><font color="#92d050">1. 创建抽象处理者（Handler）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象处理者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Approver</span> &#123;  <br>  <br>    <span class="hljs-comment">// 下一个处理请求的对象的引用  </span><br>    <span class="hljs-keyword">protected</span> Approver next;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Approver next)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.next = next;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 金额审批  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">approve</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span>;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体处理者（ConcreteHandler）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体处理者：组长  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeamLeader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">approve</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;  <br>        <span class="hljs-comment">// 小于 1000 的金额能审批  </span><br>        <span class="hljs-keyword">if</span> (amount &lt;= <span class="hljs-number">1000</span>)  <br>            System.out.println(<span class="hljs-string">&quot;TeamLeader approved：&quot;</span> + amount);  <br>        <span class="hljs-comment">// 大于 1000 的金额交给下一个审批  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>)  <br>            next.approve(amount);  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体处理者：经理  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">approve</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;  <br>        <span class="hljs-comment">// 小于 5000 的金额能审批  </span><br>        <span class="hljs-keyword">if</span> (amount &lt;= <span class="hljs-number">5000</span>)  <br>            System.out.println(<span class="hljs-string">&quot;Manager approved: &quot;</span> + amount);  <br>        <span class="hljs-comment">// 大于 5000 的金额交给下一个审批  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>)  <br>            next.approve(amount);  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体处理者：总监  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">approve</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;  <br>        <span class="hljs-comment">// 无论什么金额，都能审批  </span><br>        System.out.println(<span class="hljs-string">&quot;Director approved：&quot;</span> + amount);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建客户端（Client）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">teamLeader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeamLeader</span>();  <br>  <br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();  <br>  <br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>();  <br>  <br>        <span class="hljs-comment">// 组装责任链  </span><br>        teamLeader.setNext(manager);  <br>          <br>        manager.setNext(director);  <br>  <br>        <span class="hljs-comment">// 测试审批  </span><br>        teamLeader.approve(<span class="hljs-number">500</span>);  <br>  <br>        teamLeader.approve(<span class="hljs-number">2000</span>);  <br>  <br>        teamLeader.approve(<span class="hljs-number">10000</span>);  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5. 状态模式"></a>6.5. 状态模式</h3><h4 id="6-5-1-状态模式概述"><a href="#6-5-1-状态模式概述" class="headerlink" title="6.5.1. 状态模式概述"></a>6.5.1. 状态模式概述</h4><p>状态模式是指：允许一个对象在其<strong>内部状态改变时改变它的行为</strong>，使对象看起来好像修改了它的类</p><p>对象在不同状态下表现出不同行为，并且能在运行时根据状态自动切换行为，无需通过大量 <code>if-else</code> 去判断状态。该模式通常包含三个角色：</p><ol><li>抽象状态（State）</li><li>具体状态（ConcreteState）</li><li>上下文（Context）<ol><li>持有对 State 的引用，负责状态转换和调用不同 ConcreteState 的方法</li></ol></li></ol><hr><h4 id="6-5-2-状态模式实现"><a href="#6-5-2-状态模式实现" class="headerlink" title="6.5.2. 状态模式实现"></a>6.5.2. 状态模式实现</h4><p>场景：一个订单需要从 <strong>待支付 → 已支付 → 已发货</strong> 进行状态流转</p><p><font color="#92d050">1. 创建抽象状态</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象状态  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">State</span> &#123;  <br>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体状态</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体状态：待支付  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PendingPaymentState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;订单待支付，执行支付逻辑...&quot;</span>);  <br>        context.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaidState</span>());  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体状态：已支付  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaidState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;订单已支付，执行发货逻辑...&quot;</span>);  <br>        context.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShippedState</span>());  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体状态：发货  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShippedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;订单已发货，执行收货逻辑...&quot;</span>);  <br>        context.setState(<span class="hljs-literal">null</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建上下文</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> State state;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(State state)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.state = state;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.state = state;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (state != <span class="hljs-literal">null</span>) &#123;  <br>            state.handle(<span class="hljs-built_in">this</span>);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;订单流程已结束。&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingPaymentState</span>());  <br>  <br>        context.request();  <br>  <br>        context.request();  <br>  <br>        context.request();  <br>  <br>        context.request();  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-6-备忘录模式"><a href="#6-6-备忘录模式" class="headerlink" title="6.6. 备忘录模式"></a>6.6. 备忘录模式</h3><h4 id="6-6-1-备忘录模式概述"><a href="#6-6-1-备忘录模式概述" class="headerlink" title="6.6.1. 备忘录模式概述"></a>6.6.1. 备忘录模式概述</h4><p>备忘录模式是指：<strong>在不破坏对象封装性的前提下，捕获并保存对象的内部状态，以便之后将对象恢复到先前的状态</strong>。</p><p>简单来说，它就像一种快照机制，让对象可以在任意时刻保存自己的状态，并在需要时回滚到之前的状态。</p><p>该模式通常有三个角色：</p><ol><li>发起人（原发器，Originator）<ol><li>维护一个或多个状态，这些状态需要被保存</li><li>负责创建自身某一时刻的状态的快照（即生成备忘录）</li><li>负责根据传入的备忘录，将自身的状态恢复到当时的状态</li></ol></li><li>备忘录（Memento）<ol><li>用于封装发起人（Originator）在某一时刻的内部状态</li><li>备忘录通常只提供给发起人访问，不允许其他对象修改<ol><li>推荐将 <code>Memento</code> 设计为 <code>Originator</code> 的静态内部类，类的访问修饰符是 <code>public</code>，构造方法的访问修饰符是 <code>private</code>，状态访问方法的访问修饰符是 <code>private</code><ol><li>保证所有类能访问到 <code>Memento</code> 类（能访问到，但无法创建对象）</li><li>保证只能由 <code>Originator</code> 类创建 <code>Memento</code> 对象和访问其保存的状态</li></ol></li><li>如果 <code>Memento</code> 类非常庞大或逻辑复杂，作为内部类可能让 <code>Originator</code> 文件显得臃肿，这是内部类的通病。但在大多数情况下，备忘录只是简单保存状态数据，不会太大，因此放在 <code>Originator</code> 内部更能实现强封装和逻辑内聚</li></ol></li></ol></li><li>负责人（管理者，Caretaker）<ol><li>维护一个数据结构，用来存储备忘录对象的引用</li></ol></li></ol><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AC%94%E8%AE%B0%EF%BC%9A23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11.png"></p><p>其缺点是：</p><ol><li>内存开销大<ol><li>备忘录对象需要存储发起人（Originator）的状态快照，如果状态数据量很大（如大型游戏场景、复杂配置对象等），每创建一个备忘录都会占用大量内存</li><li>随着程序运行，Caretaker 中保存的历史记录会持续增长，若不限制记录数量，最终可能引发 OOM（内存溢出）</li></ol></li></ol><hr><h4 id="6-6-2-备忘录模式实现"><a href="#6-6-2-备忘录模式实现" class="headerlink" title="6.6.2. 备忘录模式实现"></a>6.6.2. 备忘录模式实现</h4><p><font color="#92d050">1. 创建发起人（Originator）、备忘录（Memento）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发起人</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：内部状态（private）</span><br>    <span class="hljs-keyword">private</span> String state;  <br>  <br>    <span class="hljs-comment">// 具体方法：设置内部状态  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.state = state;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：获取内部状态  </span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> state;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：保存内部状态  </span><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(state);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：恢复历史内部状态  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreState</span><span class="hljs-params">(Memento memento)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.state = memento.getState();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 内部类：备忘录（static）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;  <br>  <br>        <span class="hljs-comment">// 属性：状态（private，只能被 Originator 访问）</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String state;  <br>  <br>        <span class="hljs-comment">// 构造方法（private，只能被 Originator 访问）</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">Memento</span><span class="hljs-params">(String state)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.state = state;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 具体方法：获取 state 方法（private，只能被 Originator 访问）</span><br>        <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> state;  <br>        &#125;  <br>  <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>关于内部类的创建，内部类本身和其构造方法都可以使用四种访问修饰符，这里仅讨论 <code>public</code> 和 <code>private</code> 的情况。并且是基于 <strong>static 内部类</strong>，因为非 static 内部类在其他类中创建对象的方式有所不同。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 如果内部类是 public，构造方法也是 public，任何地方都可以访问 和 new 对象</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-comment">// 在 Originator 类中，可以访问和 new Memento</span><br><span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(state);  <br>&#125;  <br><br><span class="hljs-comment">// 在其他类，例如 Caretaker 中，我们也可以访问和 new Originator.Memento()</span><br>Originator.<span class="hljs-type">Memento</span> <span class="hljs-variable">memento</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>.Memento();<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 2. 如果内部类是 private，构造方法也是 private，只能在定义它的类内部访问 和 new 对象</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 在 Originator 类中，可以访问和 new Memento</span><br><span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(state);  <br>&#125;  <br><br><span class="hljs-comment">// 在其他类，例如 Caretaker 中，不可以访问和 new Originator.Memento()</span><br><span class="hljs-keyword">private</span> List&lt;Memento&gt; mementoList; <span class="hljs-comment">// 根本不被允许，因为根本就不知道有 Memento</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 3. 如果内部类是 public，构造方法却是 private，任何地方都可以访问，但只能在定义他的类内部 new 对象</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 在 Originator 类中，可以访问和 new Memento</span><br><span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(state);  <br>&#125;  <br><br><br><span class="hljs-comment">// 在其他类，例如 Caretaker 中，可以访问，但不能 new Originator.Memento()</span><br><span class="hljs-keyword">private</span> List&lt;Memento&gt; mementoList; <span class="hljs-comment">// 允许</span><br>Originator.<span class="hljs-type">Memento</span> <span class="hljs-variable">memento</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>.Memento(); <span class="hljs-comment">// 不允许</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. 内部类被设计为 <strong>static</strong> 是经过深思熟虑的结果<br>    1. 如果不是 static，普通内部类会默认持有外部类的引用，也就是每个 <code>Memento</code> 对象会隐式包含一个 <code>Originator</code> 地址<br>        1. 而我们的 <code>Memento</code> 设计目标仅仅是保存状态，这个引用完全没有必要<br>        2. 此外，还会带来内存泄漏风险，当 <code>Originator</code> 实例本身已经不再需要时，如果它创建的 <code>Memento</code> 依然存在，并且 <code>Memento</code> 持有对该 <code>Originator</code> 的引用，就会导致 GC 无法回收 <code>Originator</code><br>    2. 此外，如果不是 static，外部类在创建该对象时必须依赖一个 <code>Originator</code> 实例，而 static 内部类则无需依赖外部实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 非 static 内部类</span><br><span class="hljs-type">Originator</span> <span class="hljs-variable">originator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>();<br>Originator.<span class="hljs-type">Memento</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> originator.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-string">&quot;state&quot;</span>);<br><br><br><span class="hljs-comment">// 2. static 内部类</span><br>Originator.<span class="hljs-type">Memento</span> <span class="hljs-variable">memento</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>.Memento(); <br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>3. 你可能会想，如果把 <code>Memento</code> 单独拉出来，类设为 <code>public</code>，属性设为 <code>private</code>，且不提供 Setter 方法，不也能防止其他对象修改吗？<br>    1. 确实可以，但使用内部类在封装性上更优，更适合大型系统的设计</p></blockquote><p><font color="#92d050">2. 创建负责人（Caretaker）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：维护一个数据结构，用来管理 Memento 对象（private）</span><br>    <span class="hljs-keyword">private</span> List&lt;Originator.Memento&gt; mementoList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br><br><span class="hljs-comment">// 具体方法：像数据结构中添加 Memento 对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMemento</span><span class="hljs-params">(Originator.Memento memento)</span> &#123;  <br>        mementoList.add(memento);  <br>    &#125;  <br>  <br><span class="hljs-comment">// 具体方法：向数据结构中移除 Memento 对象</span><br>    <span class="hljs-keyword">public</span> Originator.Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">return</span> mementoList.get(index);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>  <br>        <span class="hljs-comment">// 创建发起人  </span><br>        <span class="hljs-type">Originator</span> <span class="hljs-variable">originator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>();  <br>  <br>        <span class="hljs-comment">// 创建负责人  </span><br>        <span class="hljs-type">Caretaker</span> <span class="hljs-variable">caretaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caretaker</span>();  <br>  <br>        <span class="hljs-comment">// 设置状态  </span><br>        originator.setState(<span class="hljs-string">&quot;状态1&quot;</span>);  <br>  <br>        <span class="hljs-comment">// 查看状态  </span><br>        System.out.println(originator.getState());  <br>  <br>        <span class="hljs-comment">// 保存状态  </span><br>        caretaker.addMemento(originator.saveState());  <br>  <br>        <span class="hljs-comment">// 再次设置状态  </span><br>        originator.setState(<span class="hljs-string">&quot;状态2&quot;</span>);  <br>  <br>        <span class="hljs-comment">// 查看状态  </span><br>        System.out.println(originator.getState());  <br>  <br>        <span class="hljs-comment">// 保存状态  </span><br>        caretaker.addMemento(originator.saveState());  <br>  <br>        <span class="hljs-comment">// 恢复状态  </span><br>        originator.restoreState(caretaker.getMemento(<span class="hljs-number">0</span>));  <br>  <br>        <span class="hljs-comment">// 查看状态  </span><br>        System.out.println(originator.getState());  <br>  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-7-命令模式"><a href="#6-7-命令模式" class="headerlink" title="6.7. 命令模式"></a>6.7. 命令模式</h3><h4 id="6-7-1-命令模式概述"><a href="#6-7-1-命令模式概述" class="headerlink" title="6.7.1. 命令模式概述"></a>6.7.1. 命令模式概述</h4><p>命令模式是指：<strong>将请求封装成一个对象，从而可以用不同的请求参数化其他对象，并支持请求的排队、记录、撤销与重做等操作</strong>。该模式通常有五个角色：</p><ol><li>抽象命令（Command）<ol><li>通常是接口，也可以是抽象类</li><li>定义了 “具体命令必须实现的方法” 的规范</li><li>主要方法包括：<ol><li>execute()<ol><li>执行操作</li></ol></li><li>undo()<ol><li>撤销操作</li></ol></li></ol></li></ol></li><li>具体命令（ConcreteCommand）<ol><li>实现或继承了 Command</li><li>命名以 <code>Command</code> 结尾</li></ol></li><li>接收者（实现者，Receiver）</li><li>调用者（请求者，Invoker）</li><li>客户端（Client）</li></ol><hr><h4 id="6-7-2-命令模式实现"><a href="#6-7-2-命令模式实现" class="headerlink" title="6.7.2. 命令模式实现"></a>6.7.2. 命令模式实现</h4><p>场景：一个可编程的遥控器，既能控制电灯的开关，也能控制空调的开关和温度调节。</p><p><font color="#92d050">1. 创建抽象命令（Command）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象命令  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;  <br>  <br>    <span class="hljs-comment">// 接口方法：执行命令</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-comment">// 接口方法：撤销命令</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建接收者（Receiver）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接收者：灯  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：灯的位置（例如客厅、卧室、厨房）  </span><br>    <span class="hljs-keyword">public</span> String location;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Light</span><span class="hljs-params">(String location)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.location = location;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：开灯  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(location + <span class="hljs-string">&quot; 的灯打开了&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：关灯  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(location + <span class="hljs-string">&quot; 的灯关闭了&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 接收者：空调  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AirConditioner</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：空调的位置（例如客厅、卧室、厨房）  </span><br>    String location;  <br>  <br>    <span class="hljs-comment">// 属性：空调的温度  </span><br>    <span class="hljs-type">int</span> temperature;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AirConditioner</span><span class="hljs-params">(String location)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.location = location;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：开空调  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(location + <span class="hljs-string">&quot; 的空调打开了&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：关空调  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(location + <span class="hljs-string">&quot; 的空调关闭了&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 具体方法：温度调节  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTemperature</span><span class="hljs-params">(<span class="hljs-type">int</span> temp)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.temperature = temp;  <br>        System.out.println(location + <span class="hljs-string">&quot; 的空调温度设置为 &quot;</span> + temp + <span class="hljs-string">&quot; 度&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建具体命令</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体命令：负责执行 “开灯” 请求  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 要控制的电灯 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> Light light;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOnCommand</span><span class="hljs-params">(Light light)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.light = light;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：执行命令时，调用电灯的 on() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;  <br>        light.on();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：撤销命令时，调用电灯的 off() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> &#123;  <br>        light.off(); <span class="hljs-comment">// 撤销开灯，就是关灯  </span><br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体命令：负责执行 “关灯” 请求  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOffCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 要控制的电灯 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> Light light;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOffCommand</span><span class="hljs-params">(Light light)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.light = light;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：执行命令时，调用电灯的 off() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;  <br>        light.off();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：撤销命令时，调用电灯的 on() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> &#123;  <br>        light.on();  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体命令：负责执行 “开空调” 请求  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ACOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 要控制的空调 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> AirConditioner airConditioner;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ACOnCommand</span><span class="hljs-params">(AirConditioner airConditioner)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.airConditioner = airConditioner;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：执行命令时，调用空调的 on() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;  <br>        airConditioner.on();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：撤销命令时，调用空调的 off() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> &#123;  <br>        airConditioner.off();  <br>    &#125;  <br>  <br>&#125;<br><br><br><span class="hljs-comment">// 具体命令：负责执行 “关空调” 请求  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ACOffCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;  <br>  <br>    <span class="hljs-comment">// 属性：对 要控制的空调 的引用（private）  </span><br>    <span class="hljs-keyword">private</span> AirConditioner airConditioner;  <br>  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ACOffCommand</span><span class="hljs-params">(AirConditioner airConditioner)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.airConditioner = airConditioner;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：执行命令时，调用空调的 off() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;  <br>        airConditioner.off();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 重写方法：撤销命令时，调用空调的 on() 方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> &#123;  <br>        airConditioner.on();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建调用者</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用者：遥控器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;  <br>    <span class="hljs-keyword">private</span> Command[] onCommands;  <br>    <span class="hljs-keyword">private</span> Command[] offCommands;  <br>    <span class="hljs-keyword">private</span> Command undoCommand;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RemoteControl</span><span class="hljs-params">()</span> &#123;  <br>        onCommands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>[<span class="hljs-number">7</span>];  <br>        offCommands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>[<span class="hljs-number">7</span>];  <br>  <br>        <span class="hljs-comment">// 使用一个“空”命令对象来初始化，避免后面进行空指针检查  </span><br>        <span class="hljs-type">Command</span> <span class="hljs-variable">noCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoCommand</span>();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <br>            onCommands[i] = noCommand;  <br>            offCommands[i] = noCommand;  <br>        &#125;  <br>        undoCommand = noCommand;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 设置插槽对应的命令  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(<span class="hljs-type">int</span> slot, Command onCommand, Command offCommand)</span> &#123;  <br>        onCommands[slot] = onCommand;  <br>        offCommands[slot] = offCommand;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 按下“开”按钮  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onButtonWasPushed</span><span class="hljs-params">(<span class="hljs-type">int</span> slot)</span> &#123;  <br>        onCommands[slot].execute();  <br>        undoCommand = onCommands[slot]; <span class="hljs-comment">// 记录最后一次操作，用于撤销  </span><br>    &#125;  <br>  <br>    <span class="hljs-comment">// 按下“关”按钮  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offButtonWasPushed</span><span class="hljs-params">(<span class="hljs-type">int</span> slot)</span> &#123;  <br>        offCommands[slot].execute();  <br>        undoCommand = offCommands[slot];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 按下“撤销”按钮  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undoButtonWasPushed</span><span class="hljs-params">()</span> &#123;  <br>        System.out.print(<span class="hljs-string">&quot;执行撤销操作: &quot;</span>);  <br>        undoCommand.undo();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 这是一个内部类，实现了空对象模式(Null Object Pattern)，  </span><br>    <span class="hljs-comment">// 这样我们就不必在每次调用前都检查命令是否为null。  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;&#125;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> &#123;&#125;  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-8-中介者模式"><a href="#6-8-中介者模式" class="headerlink" title="6.8. 中介者模式"></a>6.8. 中介者模式</h3><h4 id="6-8-1-中介者模式概述"><a href="#6-8-1-中介者模式概述" class="headerlink" title="6.8.1. 中介者模式概述"></a>6.8.1. 中介者模式概述</h4><p>中介者模式是指：用一个中介对象来封装一系列对象之间的交互，从而使对象不需要显式地相互引用，降低了对象之间的耦合性</p><p>中介者模式通常包含四个角色：</p><ol><li>抽象中介者（Mediator）</li><li>具体中介者（ConcreteMediator）</li><li>抽象同事（Colleague）</li><li>具体同事（ConcreteColleague）</li></ol><hr><h4 id="6-8-2-中介者模式实现"><a href="#6-8-2-中介者模式实现" class="headerlink" title="6.8.2. 中介者模式实现"></a>6.8.2. 中介者模式实现</h4><p><font color="#92d050">1. 创建抽象中介者（Mediator）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象中介者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChatMediator</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User sender)</span>;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 创建具体中介者（ConcreteMediator）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体中介者  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChatMediator</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> &#123;  <br>        users.add(user);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User sender)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (User u : users) &#123;  <br>            <span class="hljs-keyword">if</span> (u != sender) &#123;  <br>                u.receive(message);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 创建抽象同事（Colleague）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象同事  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>      <br>    <span class="hljs-keyword">protected</span> ChatMediator mediator;  <br>      <br>    <span class="hljs-keyword">protected</span> String name;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.mediator = mediator;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;  <br>      <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String message)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 创建具体同事（ConcreteColleague）</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体同事  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChatUser</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(mediator, name);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;  <br>        System.out.println(name + <span class="hljs-string">&quot; 发送: &quot;</span> + message);  <br>        mediator.sendMessage(message, <span class="hljs-built_in">this</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String message)</span> &#123;  <br>        System.out.println(name + <span class="hljs-string">&quot; 收到: &quot;</span> + message);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 创建测试类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>          <br>        <span class="hljs-type">ChatRoom</span> <span class="hljs-variable">chatRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoom</span>();  <br>  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">alice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatUser</span>(chatRoom, <span class="hljs-string">&quot;Alice&quot;</span>);  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatUser</span>(chatRoom, <span class="hljs-string">&quot;Bob&quot;</span>);  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">charlie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatUser</span>(chatRoom, <span class="hljs-string">&quot;Charlie&quot;</span>);  <br>  <br>        chatRoom.addUser(alice);  <br>        chatRoom.addUser(bob);  <br>        chatRoom.addUser(charlie);  <br>  <br>        alice.send(<span class="hljs-string">&quot;大家好！&quot;</span>);  <br>        bob.send(<span class="hljs-string">&quot;你好 Alice！&quot;</span>);  <br>          <br>    &#125;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>23 种设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：MIME 类型</title>
    <link href="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMIME%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMIME%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>MIME 类型用于表示文档、文件或数据的类型，告诉客户端如何解析响应的内容,常用于 HTTP 协议的 <code>Content-Type</code> 和 <code>Accept</code> 头，指明发送或接收的数据格式，一般格式为：<code>type/subtype</code>。以下是一些常见的 MIME 类型：</p><ol><li>文本类型（Text Types）<ol><li><font color="#00b0f0">text&#x2F;html</font>：HTML 文档</li><li><font color="#00b0f0">text&#x2F;plain</font>：纯文本</li><li><font color="#00b0f0">text&#x2F;css</font>：CSS 样式表</li><li><font color="#00b0f0">text&#x2F;javascript</font> 或 <font color="#00b0f0">application&#x2F;javascript</font>：JavaScript 脚本</li><li><font color="#00b0f0">text&#x2F;csv</font>：CSV 格式的文本文件</li></ol></li><li>应用程序类型（Application Types）<ol start="6"><li><font color="#00b0f0">application&#x2F;json</font>：JSON 数据格式</li><li><font color="#00b0f0">application&#x2F;xml</font>：XML 数据格式</li><li><font color="#00b0f0">application&#x2F;xhtml+xml</font>：XHTML 文档</li><li><font color="#00b0f0">application&#x2F;pdf</font>：PDF 文件</li><li><font color="#00b0f0">application&#x2F;zip</font>：ZIP 压缩文件</li><li><font color="#00b0f0">application&#x2F;octet-stream</font>：任意的二进制数据（常用于文件下载）</li><li><font color="#00b0f0">application&#x2F;msword</font>：Microsoft Word 文档</li><li><font color="#00b0f0">application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.document</font>：Word 文档（.docx）</li><li><font color="#00b0f0">application&#x2F;vnd.ms-excel</font>：Microsoft Excel 文档</li><li><font color="#00b0f0">application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet</font>：Excel 文档（.xlsx）</li></ol></li><li>图像类型（Image Types）<ol><li><font color="#00b0f0">image&#x2F;jpeg</font>：JPEG 图像</li><li><font color="#00b0f0">image&#x2F;png</font>：PNG 图像</li><li><font color="#00b0f0">image&#x2F;gif</font>：GIF 图像</li><li><font color="#00b0f0">image&#x2F;svg+xml</font>：SVG 矢量图</li><li><font color="#00b0f0">image&#x2F;webp</font>：WebP 图像格式</li><li><font color="#00b0f0">image&#x2F;bmp</font>：BMP 图像</li></ol></li><li>音频类型（Audio Types）<ol><li><font color="#00b0f0">audio&#x2F;mpeg</font>：MP3 音频</li><li><font color="#00b0f0">audio&#x2F;ogg</font>：OGG 音频</li><li><font color="#00b0f0">audio&#x2F;wav</font>：WAV 音频</li><li><font color="#00b0f0">audio&#x2F;webm</font>：WebM 音频</li></ol></li><li>视频类型（Video Types）<ol><li><font color="#00b0f0">video&#x2F;mp4</font>：MP4 视频</li><li><font color="#00b0f0">video&#x2F;ogg</font>：OGG 视频</li><li><font color="#00b0f0">video&#x2F;webm</font>：WebM 视频</li><li><font color="#00b0f0">video&#x2F;x-msvideo</font>：AVI 视频</li></ol></li><li>字体类型（Font Types）<ol><li><font color="#00b0f0">font&#x2F;woff</font>：WOFF 字体</li><li><font color="#00b0f0">font&#x2F;woff2</font>：WOFF2 字体</li><li><font color="#00b0f0">application&#x2F;font-woff</font>：另一种 WOFF 的 MIME 类型</li><li><font color="#00b0f0">font&#x2F;ttf</font>：TrueType 字体（TTF）</li><li><font color="#00b0f0">font&#x2F;otf</font>：OpenType 字体（OTF）</li></ol></li><li>其他常见类型<ol><li><font color="#00b0f0">multipart&#x2F;form-data</font>：用于表单数据（文件上传）</li><li><font color="#00b0f0">application&#x2F;x-www-form-urlencoded</font>：URL 编码表单数据</li><li><font color="#00b0f0">application&#x2F;javascript</font>：JavaScript 代码</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
      <category>MIME 类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Minio</title>
    <link href="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/"/>
    <url>/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/</url>
    
    <content type="html"><![CDATA[<h1 id="一、导图"><a href="#一、导图" class="headerlink" title="一、导图"></a>一、导图</h1><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio-1.xmind"></p><hr><h1 id="二、Minio-基础"><a href="#二、Minio-基础" class="headerlink" title="二、Minio 基础"></a>二、Minio 基础</h1><h2 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h2><h3 id="Bucket-概述"><a href="#Bucket-概述" class="headerlink" title="Bucket 概述"></a>Bucket 概述</h3><p>Bucket 是存储 Object 的逻辑空间，每个 Bucket 之间的数据是相互隔离的，对用户而言，相当于存放文件的顶层<strong>文件夹</strong></p><hr><h3 id="Bucket-生命周期"><a href="#Bucket-生命周期" class="headerlink" title="Bucket 生命周期"></a>Bucket 生命周期</h3><p>其实，更准确地说，这个操作是针对 Object 生命周期的设置，但从操作维度上来看，它仍归类为 Bucket 生命周期。</p><p>需要特别注意的是，Bucket 生命周期配置和 Bucket 自定义访问策略一样，<strong>都是整体性的配置</strong>，每次设置都会<strong>覆盖之前的所有规则</strong>。我们可以通过 SDK 为指定的 Bucket 配置生命周期策略：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/setBucketLifecycle&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">setBucketLifecycle</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span> <span class="hljs-title class_">String</span> bucketName, <span class="hljs-meta">@RequestBody</span> <span class="hljs-title class_">LifecycleConfiguration</span> lifecycleConfigurationXml</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>minioClient.<span class="hljs-title function_">setBucketLifecycle</span>(<br><span class="hljs-title class_">SetBucketLifecycleArgs</span>.<span class="hljs-title function_">builder</span>()<br>.<span class="hljs-title function_">bucket</span>(bucketName)<br>.<span class="hljs-title function_">config</span>(lifecycleConfigurationXml) <span class="hljs-comment">// 传入 LifecycleConfigutation 类型的 Bucket 生命周期</span><br>.<span class="hljs-title function_">build</span>()<br>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 生命周期设置成功&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置桶生命周期失败：&quot;</span> + e.<span class="hljs-title function_">getMessage</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要传入 XML 格式的配置，客户端请求体示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LifecycleConfiguration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Rule</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>expire-temp-files<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Status</span>&gt;</span>Enabled<span class="hljs-tag">&lt;/<span class="hljs-name">Status</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Filter</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Prefix</span>&gt;</span>temp/<span class="hljs-tag">&lt;/<span class="hljs-name">Prefix</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Expiration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Days</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">Days</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Expiration</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Rule</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Rule</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>expire-logs<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Status</span>&gt;</span>Enabled<span class="hljs-tag">&lt;/<span class="hljs-name">Status</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Filter</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Prefix</span>&gt;</span>logs/<span class="hljs-tag">&lt;/<span class="hljs-name">Prefix</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Expiration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Days</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">Days</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Expiration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">AbortIncompleteMultipartUpload</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">DaysAfterInitiation</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">DaysAfterInitiation</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AbortIncompleteMultipartUpload</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Rule</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Rule</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>delete-old-versions<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Status</span>&gt;</span>Enabled<span class="hljs-tag">&lt;/<span class="hljs-name">Status</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Prefix</span>&gt;</span>archive/<span class="hljs-tag">&lt;/<span class="hljs-name">Prefix</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">NoncurrentVersionExpiration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">NoncurrentDays</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">NoncurrentDays</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">NoncurrentVersionExpiration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Rule</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LifecycleConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">1. LifecycleConfiguration</font><br>根标签，表示这是生命周期配置文件，xmlns 指定了该 XML 遵循 S3 生命周期配置的标准格式。</p><p><font color="#92d050">2. ID</font><br>规则（Rule）的唯一标识，用于管理区分，长度最多支持 255 个字符。</p><p><font color="#92d050">3. Statue</font><br>用于启用或禁用该条规则，可选值包括：</p><ol><li>Enabled</li><li>Disabled</li></ol><p><font color="#92d050">4. Filter</font><br>用于设置对象的过滤条件，从而精确控制生命周期规则的应用对象。常见选项包括：</p><ol><li>Prefix<ol><li>指定对象键名前缀，匹配所有以该前缀开头的对象。</li><li>例如 <code>&lt;Prefix&gt;temp/&lt;/Prefix&gt;</code> 表示匹配所有以 <code>temp/</code> 开头的对象。</li></ol></li><li>And<ol><li>用于组合多个过滤条件，通常结合前缀（Prefix）和标签（Tag）共同生效。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">And</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Prefix</span>&gt;</span>log/<span class="hljs-tag">&lt;/<span class="hljs-name">Prefix</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Tag</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Key</span>&gt;</span>env<span class="hljs-tag">&lt;/<span class="hljs-name">Key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Value</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">Value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Tag</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Tag</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Key</span>&gt;</span>type<span class="hljs-tag">&lt;/<span class="hljs-name">Key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Value</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">Value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Tag</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">And</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Filter</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>标签（Tag）是对象上的，而不是 Bucket 上的</li></ol></blockquote><p><font color="#92d050">5. Expiration</font><br>用于设置对象的过期策略，当对象达到指定时间后将被自动删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 1. 对象创建后，指定天数过期<br><span class="hljs-tag">&lt;<span class="hljs-name">Expiration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Days</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">Days</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Expiration</span>&gt;</span><br><br><br>// 2. 在固定日期后过期，必须使用符合 ISO 8601 标准的时间格式（这里表示对象将在 2025 年 12 月 31 日 00:00:00.000（UTC 时间）过期并被删除）<br><span class="hljs-tag">&lt;<span class="hljs-name">Expiration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Date</span>&gt;</span>2025-12-31T00:00:00.000Z<span class="hljs-tag">&lt;/<span class="hljs-name">Date</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Expiration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">6. NoncurrentVersionExpiration</font><br>适用于<strong>开启版本控制的 Bucket</strong>，当对象成为旧版本后，在指定天数内自动删除该旧版本。只支持 <code>&lt;NoncurrentDays&gt;</code> 设置天数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">NoncurrentVersionExpiration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">NoncurrentDays</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">NoncurrentDays</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">NoncurrentVersionExpiration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">7. AbortIncompleteMultipartUpload</font><br>用于自动清理<strong>未完成的分片上传任务</strong>，从分片上传发起时间算起，超过指定天数后自动终止，避免浪费存储空间。只支持 <code>&lt;DaysAfterInitiation&gt;</code> 设置天数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">AbortIncompleteMultipartUpload</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">DaysAfterInitiation</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">DaysAfterInitiation</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AbortIncompleteMultipartUpload</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Bucket-自定义访问策略"><a href="#Bucket-自定义访问策略" class="headerlink" title="Bucket 自定义访问策略"></a>Bucket 自定义访问策略</h3><p>Bucket 内置策略是 MinIO 提供的简化权限控制方式之一，但我们也可以通过自定义 JSON 实现更细粒度、更复杂的访问控制逻辑。需要注意的是，Bucket 策略采用覆盖式配置，即每次设置都会替换上一次的策略内容，因此同一时间只能存在一个生效策略。</p><p>当请求为不带凭证的匿名访问时，系统只会依据 Bucket 策略来判断是否允许操作。而对于带有凭证的认证请求，则会<strong>先检查用户策略</strong>，再检查<strong>对应的 Bucket 策略</strong>，<strong>两者必须同时允许</strong>，请求才会被执行。正因为这种双重判断机制，就可能出现这样一种情况：匿名用户可以访问某对象，但认证用户因用户策略未授权而无法访问相同资源。</p><p>我们一般通过 MinIO SDK 为指定的 Bucket 设置自定义策略：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/setBucketPolicy&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">setBucketPolicy</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span> <span class="hljs-title class_">String</span> bucketName, <span class="hljs-meta">@RequestBody</span> <span class="hljs-title class_">String</span> policyJson</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>minioClient.<span class="hljs-title function_">setBucketPolicy</span>(<br><span class="hljs-title class_">SetBucketPolicyArgs</span>.<span class="hljs-title function_">builder</span>()<br>.<span class="hljs-title function_">bucket</span>(bucketName)<br>.<span class="hljs-title function_">config</span>(policyJson)<br>.<span class="hljs-title function_">build</span>()<br>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 策略设置成功&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置桶策略失败：&quot;</span> + e.<span class="hljs-title function_">getMessage</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要传入完整的 JSON 策略，示例请求体格式如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;Version&quot;</span>: <span class="hljs-string">&quot;2012-10-17&quot;</span>,<br>  <span class="hljs-string">&quot;Statement&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;Effect&quot;</span>: <span class="hljs-string">&quot;Allow&quot;</span>,<br>      <span class="hljs-string">&quot;Principal&quot;</span>: &#123;<span class="hljs-string">&quot;AWS&quot;</span>: [<span class="hljs-string">&quot;*&quot;</span>]&#125;,<br>      <span class="hljs-string">&quot;Action&quot;</span>: [<span class="hljs-string">&quot;s3:GetObject&quot;</span>],<br>      <span class="hljs-string">&quot;Resource&quot;</span>: [<span class="hljs-string">&quot;arn:aws:s3:::your-bucket-name/*&quot;</span>]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#92d050">1. Version</font><br>表示 Bucket 策略语法的版本，目前写 <code>&quot;2012-10-17&quot;</code> 是标准写法</p><p><font color="#92d050">2. Effect</font><br>表示我们写的这个策略是允许还是禁止，可选值有：</p><ol><li>Allow</li><li>Deny</li></ol><p><font color="#92d050">3. Principal</font><br>指定哪些用户可以执行或拒绝执行某些操作，常见的 <code>Principal</code> 取值包括：</p><ol><li>* <ol><li>表示所有用户，包括匿名用户和认证用户</li></ol></li><li>user-arn<ol><li>表示具体某个用户的用户名，用于精确控制该用户的权限</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>AWS 是指用户</li><li>是可以执行还是拒绝执行，取决于策略中的 <code>Effect</code> 字段：若为 <code>Allow</code>，表示允许执行相应操作；若为 <code>Deny</code>，则表示明确禁止执行。</li></ol></blockquote><p><font color="#92d050">4. Action</font><br>用于指定允许或拒绝执行的具体操作，常见操作包括：</p><ol><li>Bucket 级操作：<ol><li>s3:ListBucket<ol><li>列出桶中的对象列表</li></ol></li><li>s3:GetBucketLocation<ol><li>获取桶的所属区域（Region）信息</li></ol></li><li>s3:ListBucketMultipartUploads<ol><li>查看该桶中正在进行的多部分（分片）上传任务</li></ol></li><li>s3:GetBucketPolicy<ol><li>查看桶的访问策略</li></ol></li><li>s3:PutBucketPolicy<ol><li>设置桶的访问策略</li></ol></li><li>s3:DeleteBucketPolicy<ol><li>删除桶的访问策略</li></ol></li></ol></li><li>Object 级操作：<ol><li>s3:GetObject<ol><li>下载对象</li></ol></li><li>s3:PutObject<ol><li>上传对象</li></ol></li><li>s3:DeleteObject<ol><li>删除对象</li></ol></li><li>s3:AbortMultipartUpload<ol><li>取消一个正在进行的分片上传任务</li></ol></li><li>s3:ListMultipartUploadParts<ol><li>查看指定分片上传任务中已上传的部分</li></ol></li><li>s3:GetObjectVersion<ol><li>获取对象的指定版本（MinIO 默认未启用版本控制，需要我们开启）</li></ol></li></ol></li><li>s3:*<ol><li>表示允许所有操作</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>获取桶的区域信息，即判断桶属于哪个 Region。</li><li>在 MinIO 社区版中，Region 往往是“虚拟”的（默认通常为 <code>us-east-1</code>），但权限上仍然要考虑是否开放，但若未开放 <code>s3:GetBucketLocation</code> 权限，某些 SDK 或 CLI 工具可能因无法获取区域而返回 403 错误。</li></ol></blockquote><p><font color="#92d050">5. Resource</font><br>用于指定允许或拒绝操作的具体资源，常见资源包括：</p><ol><li>arn:aws:s3:::my-bucket<ol><li>表示桶本身，适用于桶级操作，如 <code>s3:ListBucket</code>、<code>s3:GetBucketPolicy</code> 等</li></ol></li><li>arn:aws:s3:::my-bucket&#x2F;*<ol><li>示该桶内的所有对象，适用于对象级操作，如 <code>s3:GetObject</code>、<code>s3:PutObject</code> 等</li></ol></li><li>arn:aws:s3:::my-bucket&#x2F;public&#x2F;*<ol><li>表示桶中某个前缀路径下的对象，例如 <code>public</code> 文件夹下的所有对象，可用于限制访问特定目录内容</li></ol></li></ol><hr><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-概述"><a href="#Object-概述" class="headerlink" title="Object 概述"></a>Object 概述</h3><p>Object 是存储到 Minio 中的基本对象，对用户而言，相当于<strong>文件</strong></p><hr><h2 id="Minio-语法"><a href="#Minio-语法" class="headerlink" title="Minio 语法"></a>Minio 语法</h2><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><h4 id="连接-Minio-服务（配置-Minio-服务别名）"><a href="#连接-Minio-服务（配置-Minio-服务别名）" class="headerlink" title="连接 Minio 服务（配置 Minio 服务别名）"></a>连接 Minio 服务（配置 Minio 服务别名）</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">mc alias <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;Minio 服务别名&gt;</span> <span class="hljs-variable">&lt;Minio 地址&gt;</span> <span class="hljs-variable">&lt;用户名&gt;</span> <span class="hljs-variable">&lt;密码&gt;</span><br>“”“<br><span class="hljs-number">1</span>. 示例值：<br><span class="hljs-number">1</span>. mc alias <span class="hljs-built_in">set</span> myminio http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">9000</span> admin password<br>”“”<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>给 MinIO 服务起别名 <code>myminio</code>，以后就可以通过 <code>myminio</code> 来访问，而不用每次输入 URL 和账号密码：</li></ol></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 1. 使用 Minio 服务别名<br>mc cp <span class="hljs-string">./file.txt</span> myminio/mybucket/<br><br><br><span class="hljs-string">//</span> 2. 不使用 Minio 服务别名<br>mc <span class="hljs-params">--insecure</span> <span class="hljs-params">--config-dir</span> <span class="hljs-string">/root/.mc</span> cp <span class="hljs-string">./file.txt</span> http:<span class="hljs-string">//127.0.0.1</span><span class="hljs-function">:9000</span>/mybucket/file.txt <span class="hljs-params">--access-key</span> root <span class="hljs-params">--secret-key</span> wq666666<br></code></pre></td></tr></table></figure><hr><h3 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h3><h4 id="查看服务信息（基本健康状态）"><a href="#查看服务信息（基本健康状态）" class="headerlink" title="查看服务信息（基本健康状态）"></a>查看服务信息（基本健康状态）</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mc <span class="hljs-keyword">admin</span> <span class="hljs-keyword">info</span> &lt;<span class="hljs-keyword">alias</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio.png"></p><hr><h3 id="用户命令"><a href="#用户命令" class="headerlink" title="用户命令"></a>用户命令</h3><h4 id="修改-Root-用户密码"><a href="#修改-Root-用户密码" class="headerlink" title="修改 Root 用户密码"></a>修改 Root 用户密码</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">mc admin <span class="hljs-keyword">user</span> password <span class="hljs-variable">&lt;alias&gt;</span> <span class="hljs-variable">&lt;username&gt;</span> <span class="hljs-variable">&lt;newpassword&gt;</span><br>“”“<br><span class="hljs-number">1</span>. 注意事项：<br><span class="hljs-number">1</span>. Root 密码长度至少 <span class="hljs-number">8</span> 个字符<br>”“”<br></code></pre></td></tr></table></figure><hr><h3 id="Bucket-命令"><a href="#Bucket-命令" class="headerlink" title="Bucket 命令"></a>Bucket 命令</h3><h4 id="创建-Bucket"><a href="#创建-Bucket" class="headerlink" title="创建 Bucket"></a>创建 Bucket</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">mc mb <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span></span>/<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span></span><br>“”“<br><span class="hljs-bullet">1.</span> alias：<br><span class="hljs-bullet">1.</span> 配置好的 Minio 服务别名<br><span class="hljs-bullet">2.</span> 示例：<br><span class="hljs-bullet">1.</span> mc mb myminio/mybucket<br><span class="hljs-bullet">3.</span> 注意事项：<br><span class="hljs-bullet">1.</span> Bucket 名字长度至少 3 个字符<br>”“”<br></code></pre></td></tr></table></figure><hr><h4 id="删除-Bucket"><a href="#删除-Bucket" class="headerlink" title="删除 Bucket"></a>删除 Bucket</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">mc rb [--force] <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="列出当前用户可访问的所有-Bucket"><a href="#列出当前用户可访问的所有-Bucket" class="headerlink" title="列出当前用户可访问的所有 Bucket"></a>列出当前用户可访问的所有 Bucket</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mc <span class="hljs-built_in">ls</span> &lt;<span class="hljs-built_in">alias</span>&gt;<br></code></pre></td></tr></table></figure><hr><h4 id="设置-Bucket-访问策略"><a href="#设置-Bucket-访问策略" class="headerlink" title="设置 Bucket 访问策略"></a>设置 Bucket 访问策略</h4><p><font color="#92d050">1. Minio 内置访问策略</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">mc anonymous <span class="hljs-keyword">set</span> [download|upload|<span class="hljs-keyword">public</span>|<span class="hljs-keyword">private</span>] &lt;<span class="hljs-keyword">alias</span>&gt;/&lt;bucket-name&gt;<br>“”“<br><span class="hljs-number">1.</span> download：<br><span class="hljs-number">1.</span> 允许匿名用户下载指定 bucket 中的对象，但不允许删除、上传、列出 bucket 中的对象<br><span class="hljs-number">2.</span> 下载对象时，必须知道对象的完整路径，例如 http:<span class="hljs-comment">//minio.example.com/mybucket/myfile.txt</span><br><span class="hljs-number">2.</span> upload：<br><span class="hljs-number">1.</span>允许匿名用户向指定 bucket 上传对象，但不允许删除、下载、列出 bucket 中的对象<br><span class="hljs-number">3.</span> <span class="hljs-keyword">public</span>：<br><span class="hljs-number">1.</span> 允许匿名用户对指定 bucket 进行完整操作，包括上传、下载、列出和删除对象<br><span class="hljs-number">4.</span> <span class="hljs-keyword">private</span>：<br><span class="hljs-number">1.</span> 完全禁止匿名用户访问指定 bucket，所有操作（上传、下载、列出、删除）均不允许<br>”“”<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 自定义访问策略</font><br>推荐使用 SDK 设置，详见上文：Bucket 自定义访问策略</p><hr><h4 id="获取-Bucket-访问策略"><a href="#获取-Bucket-访问策略" class="headerlink" title="获取 Bucket 访问策略"></a>获取 Bucket 访问策略</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mc anonymous <span class="hljs-keyword">get</span> &lt;<span class="hljs-keyword">alias</span>&gt;/&lt;bucket-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><hr><h4 id="启用-Bucket-版本控制"><a href="#启用-Bucket-版本控制" class="headerlink" title="启用 Bucket 版本控制"></a>启用 Bucket 版本控制</h4><p>Bucket 版本控制其实就是 给存储桶里的对象加 “版本号” 的一种机制，用来记录和保留对象的历史版本：</p><ol><li>启用前：<ol><li>同名对象会直接被覆盖或删除。</li></ol></li><li>启用后：<ol><li>上传同名对象，新版本（有唯一版本 ID）</li><li>删除对象，而是生成一个 Delete Marker（删除标记），简单来说就是<code>removeObject(&quot;a.txt&quot;)</code>），MinIO <strong>不会真正删除文件</strong>。它会新增一个特殊的版本，这个版本没有文件内容，<code>isDeleteMarker=true</code>。这个版本会被当作“最新版本”，所以从外部看，这个对象就像被删除了一样。因为旧版本的文件还在，所以可以通过指定历史 <code>versionId</code> 来恢复被“删除”的文件。</li><li>只有永久删除（<code>removeObject</code> 并指定版本 ID）才能把该版本真正删掉。</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mc <span class="hljs-keyword">version</span> <span class="hljs-keyword">enable</span> &lt;<span class="hljs-keyword">alias</span>&gt;/&lt;bucket-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><hr><h4 id="禁用-Bucket-版本控制"><a href="#禁用-Bucket-版本控制" class="headerlink" title="禁用 Bucket 版本控制"></a>禁用 Bucket 版本控制</h4><p>禁用 Bucket 的版本控制，并不会删除已有版本，只是暂停新版本的生成</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">mc <span class="hljs-keyword">version</span> <span class="hljs-keyword">suspend</span> <span class="hljs-symbol">&lt;alias&gt;</span>/<span class="hljs-symbol">&lt;bucket-name&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="设置-Bucket-标签"><a href="#设置-Bucket-标签" class="headerlink" title="设置 Bucket 标签"></a>设置 Bucket 标签</h4><p>推荐使用 SDK 设置</p><hr><h4 id="获取-Bucket-标签"><a href="#获取-Bucket-标签" class="headerlink" title="获取 Bucket 标签"></a>获取 Bucket 标签</h4><p>推荐使用 SDK 获取</p><hr><h4 id="设置-Bucket-生命周期"><a href="#设置-Bucket-生命周期" class="headerlink" title="设置 Bucket 生命周期"></a>设置 Bucket 生命周期</h4><p>推荐使用 SDK 设置</p><hr><h4 id="获取-Bucket-生命周期"><a href="#获取-Bucket-生命周期" class="headerlink" title="获取 Bucket 生命周期"></a>获取 Bucket 生命周期</h4><p>推荐使用 SDK 获取</p><hr><h3 id="Object-命令"><a href="#Object-命令" class="headerlink" title="Object 命令"></a>Object 命令</h3><h4 id="上传-Object"><a href="#上传-Object" class="headerlink" title="上传 Object"></a>上传 Object</h4><p><font color="#92d050">1. 直接上传 单个文件 &#x2F; 整个目录</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mc <span class="hljs-built_in">cp</span> [-r] &lt;本地 单个文件 / 整个目录 路径&gt; &lt;<span class="hljs-built_in">alias</span>&gt;/&lt;bucket-name&gt;/&lt;bucket 路径&gt;<br>“”“<br>1. 示例：<br>1. mc <span class="hljs-built_in">cp</span> ./report.pdf myminio/mybucket/<br>2. mc <span class="hljs-built_in">cp</span> -r ./images/ myminio/mybucket/photos/<br>”“”<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 本地目录同步到 Minio</font><br>使用 mc mirror 能将本地目录同步到 Minio，需要注意的是，这是一个增量同步，即只会同步有差异的，并且还会删除桶中多余但本地不存在的文件</p><p>需要注意的是，只能同步目录，不能同步单个文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">mc mirror <span class="hljs-tag">&lt;<span class="hljs-name">本地</span> <span class="hljs-attr">整个目录</span> <span class="hljs-attr">路径</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket</span> <span class="hljs-attr">路径</span>&gt;</span><br>“”“<br>1. 示例：<br>1. mc mirror ./localdir myminio/bucket/<br>”“”<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们在上传时，如果遇到下面的错误，一般是文件名存在非 UTF-8 编码的字符，对于 Windows 直接粘贴到 Linux 的文件，中文一般是 GBK 和 GB2312，我们可以使用 convmv 工具转换文件名编码</li></ol></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">apt-<span class="hljs-keyword">get</span> install convmv<br><br><br><span class="hljs-comment"># GBK ---&gt; UTF-8</span><br>convmv -f gbk -t utf<span class="hljs-number">-8</span> <span class="hljs-comment">--notest -r /mystudy/jvm</span><br></code></pre></td></tr></table></figure><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio-1.png"></p><blockquote><p>[!NOTE] 注意事项<br>2. 你例如上传的是 jvm 目录，上传到 test&#x2F;jvm 目录，那你就会看到 test&#x2F;jvm&#x2F;jvm&#x2F;详细内容，可以理解为把 jvm 目录这一层也上传到 minio 目录下了</p></blockquote><hr><h4 id="下载-Object"><a href="#下载-Object" class="headerlink" title="下载 Object"></a>下载 Object</h4><p><font color="#92d050">1. 直接下载 单个文件 &#x2F; 整个目录</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">mc <span class="hljs-built_in">cp</span> [-r] &lt;<span class="hljs-built_in">alias</span>&gt;/&lt;bucket-name&gt;/&lt;bucket 路径&gt; &lt;本地路径&gt;<br>“”“<br>1. 示例：<br>1. mc <span class="hljs-built_in">cp</span> myminio/mybucket/report.pdf ./downloads/<br>”“”<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>下载整个目录千万不要忘记加上 -r</li></ol></blockquote><p><font color="#92d050">2. Minio 同步到本地目录</font><br>使用 mc mirror 同样能将 Minio 同步到本地目录，需要注意的是，这是一个增量同步，即只会同步有差异的，对于需要定期同步备份的场景，<code>mc mirror</code> 效率更高，并且还会删除本地多余但桶中不存在的文件</p><p>需要注意的是，只能同步目录，不能同步单个文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">mc mirror <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket</span> <span class="hljs-attr">路径</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">本地路径</span>&gt;</span><br>“”“<br>1. 示例：<br>1. mc mirror myminio/bucket/ ./localdir<br>”“”<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 生成临时下载链接（预签名 URL）</font><br>如果你想让没有 <code>mc</code> 或访问凭证的其他人下载文件，可以生成一个临时的、有时间限制的下载链接（预签名 URL）</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">mc presign &lt;<span class="hljs-built_in">alias</span>&gt;/&lt;bucket-<span class="hljs-built_in">name</span>&gt;/&lt;bucket 路径&gt; <span class="hljs-comment">--expiry &lt;过期秒数&gt;</span><br>“”“<br><span class="hljs-number">1.</span> 示例：<br><span class="hljs-number">1.</span> mc presign myminio/mybucket/<span class="hljs-built_in">file</span>.zip <span class="hljs-comment">--expiry 3600</span><br><span class="hljs-number">2.</span> 注意事项：<br><span class="hljs-number">1.</span> 过期秒数默认是 <span class="hljs-number">7</span> 天<br>”“”<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>使用这种方式经常说版本不新，干脆使用 SDK</li></ol></blockquote><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio-5.png"></p><hr><h4 id="列出-Object"><a href="#列出-Object" class="headerlink" title="列出 Object"></a>列出 Object</h4><p><font color="#92d050">1. 列出根目录下的对象和子目录</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">mc ls <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket</span> <span class="hljs-attr">路径</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 递归列出桶内所有对象，包括所有子目录和子目录中的文件</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">mc ls -r <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket</span> <span class="hljs-attr">路径</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio-2.png"></p><hr><h4 id="删除-Object"><a href="#删除-Object" class="headerlink" title="删除 Object"></a>删除 Object</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">mc <span class="hljs-built_in">rm</span> [-r] [--force] &lt;<span class="hljs-built_in">alias</span>&gt;/&lt;bucket-name&gt;/&lt;bucket 路径&gt;<br>“”“<br>1. 示例：<br>1. mc <span class="hljs-built_in">rm</span> --recursive --force myminio/mybucket/logs/2024/<br>”“”<br></code></pre></td></tr></table></figure><hr><h4 id="移动-Object（重命名-Object）"><a href="#移动-Object（重命名-Object）" class="headerlink" title="移动 Object（重命名 Object）"></a>移动 Object（重命名 Object）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">mc <span class="hljs-built_in">mv</span> &lt;<span class="hljs-built_in">alias</span>&gt;/&lt;bucket-name&gt;/&lt;bucket <span class="hljs-built_in">source</span> 路径&gt; &lt;<span class="hljs-built_in">alias</span>&gt;/&lt;bucket-name&gt;/&lt;bucket destination 路径&gt;<br>“”“<br>1. 示例：<br>1. mc <span class="hljs-built_in">mv</span> myminio/mybucket/file1.txt myminio/mybucket/file2.txt<br>”“”<br></code></pre></td></tr></table></figure><hr><h4 id="拷贝-Object"><a href="#拷贝-Object" class="headerlink" title="拷贝 Object"></a>拷贝 Object</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">mc cp <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket</span> <span class="hljs-attr">source</span> <span class="hljs-attr">路径</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket</span> <span class="hljs-attr">destination</span> <span class="hljs-attr">路径</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="为-Object-设置标签"><a href="#为-Object-设置标签" class="headerlink" title="为 Object 设置标签"></a>为 Object 设置标签</h4><p>需要注意的是，只能为文件设置标签，不能为目录设置标签，并且会覆盖之前设置的标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">mc tag set <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket-name</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">bucket</span> <span class="hljs-attr">路径</span>&gt;</span> &quot;<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&amp;<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&quot;<br></code></pre></td></tr></table></figure><hr><h4 id="查看-Object-的标签"><a href="#查看-Object-的标签" class="headerlink" title="查看 Object 的标签"></a>查看 Object 的标签</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">mc <span class="hljs-keyword">tag</span> get <span class="hljs-variable">&lt;alias&gt;</span>/<span class="hljs-variable">&lt;bucket-name&gt;</span>/<span class="hljs-variable">&lt;bucket 路径&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="删除-Object-的标签"><a href="#删除-Object-的标签" class="headerlink" title="删除 Object 的标签"></a>删除 Object 的标签</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">mc <span class="hljs-keyword">tag</span> remove <span class="hljs-variable">&lt;alias&gt;</span>/<span class="hljs-variable">&lt;bucket-name&gt;</span>/<span class="hljs-variable">&lt;bucket 路径&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="查看-Object-元数据"><a href="#查看-Object-元数据" class="headerlink" title="查看 Object 元数据"></a>查看 Object 元数据</h4><p>既可以查看某目录的，也可以查看具体的文件的元数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">mc <span class="hljs-built_in">stat</span> &lt;<span class="hljs-built_in">alias</span>&gt;/&lt;bucket-name&gt;/&lt;bucket 路径&gt;<br>“”“<br>1. 示例：<br>1. mc <span class="hljs-built_in">stat</span> myminio/mybucket/report.pdf<br>”“”<br></code></pre></td></tr></table></figure><p><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio-3.png"></p><hr><h4 id="列出某-Bucket-中当前用户可访问的所有-Object"><a href="#列出某-Bucket-中当前用户可访问的所有-Object" class="headerlink" title="列出某 Bucket 中当前用户可访问的所有 Object"></a>列出某 Bucket 中当前用户可访问的所有 Object</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mc <span class="hljs-keyword">ls</span> [<span class="hljs-params">--version</span>] &lt;<span class="hljs-keyword">alias</span>&gt;/&lt;bucket-name&gt;<br>“”“<br>1. 注意事项：<br>1. 加上 <span class="hljs-params">--versions</span> 表示查看对象的所有版本（前提是启用了版本控制）<br>”“”<br></code></pre></td></tr></table></figure><hr><h1 id="三、Minio-工具"><a href="#三、Minio-工具" class="headerlink" title="三、Minio 工具"></a>三、Minio 工具</h1><h2 id="mc-命令行"><a href="#mc-命令行" class="headerlink" title="mc 命令行"></a>mc 命令行</h2><h3 id="mc-命令行概述"><a href="#mc-命令行概述" class="headerlink" title="mc 命令行概述"></a>mc 命令行概述</h3><p><code>mc</code> 是一个命令行客户端，只需连接 MinIO 集群中的任意一个节点，便可统一管理整个集群，包括所有节点的桶、对象、用户、策略、健康状态等内容。</p><hr><h3 id="mc-命令行安装"><a href="#mc-命令行安装" class="headerlink" title="mc 命令行安装"></a>mc 命令行安装</h3><h4 id="创建软件安装路径"><a href="#创建软件安装路径" class="headerlink" title="创建软件安装路径"></a>创建软件安装路径</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mystudy/mc<br></code></pre></td></tr></table></figure><hr><h4 id="安装-mc"><a href="#安装-mc" class="headerlink" title="安装 mc"></a>安装 mc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mystudy/mc<br></code></pre></td></tr></table></figure><p>接着参考 <a href="https://min.io/open-source/download?platform=linux">MinIO 官方下载页面</a> 进行安装，安装过程会将 <code>mc</code> 文件下载到<strong>当前目录</strong>，文件名即为 <code>mc</code>（没有扩展名）：<br><img src="/2025/08/12/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio/%E7%AC%94%E8%AE%B0%EF%BC%9AMinio-6.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>会话级别以太网临时代理：</li></ol></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=<span class="hljs-string">&quot;http://172.20.10.3:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-string">&quot;http://172.20.10.3:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">no_proxy</span>=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">HTTP_PROXY</span>=<span class="hljs-variable">$http_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">HTTPS_PROXY</span>=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">NO_PROXY</span>=<span class="hljs-variable">$no_proxy</span><br></code></pre></td></tr></table></figure><hr><h4 id="将-mc-添加到环境变量"><a href="#将-mc-添加到环境变量" class="headerlink" title="将 mc 添加到环境变量"></a>将 mc 添加到环境变量</h4><p>如果你不想每次都先 <code>cd /mystudy/mc</code> 然后写 <code>./mc</code>，可以把 <code>mc</code> 加到 PATH 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mystudy/mc<br><br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> ./mc /usr/local/bin/<br></code></pre></td></tr></table></figure><hr><h1 id="四、搭建-Minio-环境"><a href="#四、搭建-Minio-环境" class="headerlink" title="四、搭建 Minio 环境"></a>四、搭建 Minio 环境</h1><h2 id="1-单机测试环境"><a href="#1-单机测试环境" class="headerlink" title="1. 单机测试环境"></a>1. 单机测试环境</h2><h3 id="1-1-创建宿主机数据挂载目录"><a href="#1-1-创建宿主机数据挂载目录" class="headerlink" title="1.1. 创建宿主机数据挂载目录"></a>1.1. 创建宿主机数据挂载目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mystudy/data/minio<br></code></pre></td></tr></table></figure><hr><h3 id="1-2-启动-Minio-容器"><a href="#1-2-启动-Minio-容器" class="headerlink" title="1.2. 启动 Minio 容器"></a>1.2. 启动 Minio 容器</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  --name minio-test <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -p <span class="hljs-number">9001</span>:<span class="hljs-number">9001</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;MINIO_ROOT_USER=admin&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -e <span class="hljs-string">&quot;MINIO_ROOT_PASSWORD=password&quot;</span> <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  -v /mystudy/data/minio:/data <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  minio/minio <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>  server /data --console-address <span class="hljs-string">&quot;:9001&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>密码长度至少 8 个字符</li><li><code>server /data --console-address &quot;:9001&quot;</code> 是 MinIO 启动命令中的一个子命令，用来启动 MinIO 对象存储服务的：<ol><li>server：<ol><li>启动 MinIO 存储服务</li></ol></li><li>&#x2F;data<ol><li>MinIO 存储数据的根目录</li></ol></li><li>–console-address “:9001”<ol><li>启动控制台 Web UI，监听 9001 端口</li></ol></li></ol></li><li>9000 端口是 Minio 端口，9001 端口是 Web UI 端口</li><li>会话级别以太网临时代理：</li></ol></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=<span class="hljs-string">&quot;http://172.20.10.3:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-string">&quot;http://172.20.10.3:7890&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">no_proxy</span>=<span class="hljs-string">&quot;localhost,127.0.0.1,.svc,.cluster.local,192.168.136.0/24,10.96.0.1,10.244.0.0/16&quot;</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">HTTP_PROXY</span>=<span class="hljs-variable">$http_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">HTTPS_PROXY</span>=<span class="hljs-variable">$https_proxy</span> &amp;&amp; <span class="hljs-built_in">export</span> <span class="hljs-attribute">NO_PROXY</span>=<span class="hljs-variable">$no_proxy</span><br></code></pre></td></tr></table></figure><hr><h3 id="1-3-访问-Minio-Web-UI"><a href="#1-3-访问-Minio-Web-UI" class="headerlink" title="1.3. 访问 Minio Web UI"></a>1.3. 访问 Minio Web UI</h3><p>访问： <a href="http://192.168.136.8:9001/">http://192.168.136.8:9001</a></p><hr><h1 id="五、Spring-整合-Minio"><a href="#五、Spring-整合-Minio" class="headerlink" title="五、Spring 整合 Minio"></a>五、Spring 整合 Minio</h1><h2 id="Minio-配置"><a href="#Minio-配置" class="headerlink" title="Minio 配置"></a>Minio 配置</h2><p>Minio 的相关配置集中在配置类中，MinioConfiguration 配置类在 <code>com.example.minio.configuration</code> 包下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinioConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(name = <span class="hljs-string">&quot;minioClientA&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> MinioClient minioClientA() &#123;<br>        <span class="hljs-keyword">return</span> MinioClient.builder()<br>                .endpoint(<span class="hljs-string">&quot;http://192.168.136.8:9000&quot;</span>)<br>                .credentials(<span class="hljs-string">&quot;adminA&quot;</span>, <span class="hljs-string">&quot;passwordA&quot;</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = <span class="hljs-string">&quot;minioClientB&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> MinioClient minioClientB() &#123;<br>        <span class="hljs-keyword">return</span> MinioClient.builder()<br>                .endpoint(<span class="hljs-string">&quot;http://192.168.136.9:9000&quot;</span>)<br>                .credentials(<span class="hljs-string">&quot;adminB&quot;</span>, <span class="hljs-string">&quot;passwordB&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>MinioClient 用于与 MinIO 服务建立连接，发送请求。而所谓的 Minio 配置，就算将 MinioClient 声明为一个 Bean，使用时直接注入即可</li><li>MinioClient 底层基于 OkHttpClient，使用的是 HTTP 连接池机制，这与我们日常理解的 MySQL 等数据库连接池有所不同，所以 MinioClient 是线程安全的，但是高并发时也会存在瓶颈</li></ol></blockquote><hr><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="创建-Spring-Web-项目，添加相关依赖"><a href="#创建-Spring-Web-项目，添加相关依赖" class="headerlink" title="创建 Spring Web 项目，添加相关依赖"></a>创建 Spring Web 项目，添加相关依赖</h3><p>创建时：</p><ol><li>Web：<ol><li>Spring Web</li></ol></li></ol><p>创建后：添加 <a href="https://mvnrepository.com/artifact/io.minio/minio">minio 依赖</a> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.minio<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>minio<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>由于目前未提供 <code>**-minio-starter</code> 的起步依赖，官方推荐的方式是直接添加 Minio 官方提供的 Minio Java SDK</li></ol></blockquote><hr><h3 id="进行-Minio-配置"><a href="#进行-Minio-配置" class="headerlink" title="进行 Minio 配置"></a>进行 Minio 配置</h3><p>详见上文：Minio 配置</p><hr><h3 id="使用-MinioClient-向-Minio-发送请求"><a href="#使用-MinioClient-向-Minio-发送请求" class="headerlink" title="使用 MinioClient 向 Minio 发送请求"></a>使用 MinioClient 向 Minio 发送请求</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinioController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br>    <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/bucketExists&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Boolean</span> bucketExists(<span class="hljs-meta">@RequestParam</span> String bucketName) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;检查 bucket 是否存在过程失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="业务处理"><a href="#业务处理" class="headerlink" title="业务处理"></a>业务处理</h2><h3 id="Bucket-常用操作"><a href="#Bucket-常用操作" class="headerlink" title="Bucket 常用操作"></a>Bucket 常用操作</h3><h4 id="创建-Bucket-1"><a href="#创建-Bucket-1" class="headerlink" title="创建 Bucket"></a>创建 Bucket</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 创建 Bucket（minioClient.makeBucket(MakeBucketArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 无返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 注意事项：</span><br><span class="hljs-comment">     *      1. 在创建资源之前，通常会先检查其是否已存在，再决定是否执行创建操作。</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/createBucket&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String createBucket(<span class="hljs-meta">@RequestParam</span> String bucketName) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            boolean found = minioClient.bucketExists(<br>                    BucketExistsArgs.builder().bucket(bucketName).build()<br>            );<br><br>            <span class="hljs-keyword">if</span> (!found) &#123;<br>                minioClient.makeBucket(<br>                        MakeBucketArgs.builder().bucket(bucketName).build()<br>                );<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 创建成功&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 已存在，无需创建&quot;</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;创建桶失败：&quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="删除-Bucket-1"><a href="#删除-Bucket-1" class="headerlink" title="删除 Bucket"></a>删除 Bucket</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 删除 Bucket（minioClient.removeBucket(RemoveBucketArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 无返回值，不抛异常即表示成功</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DeleteMapping(<span class="hljs-string">&quot;/deleteBucket&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String deleteBucket(<span class="hljs-meta">@RequestParam</span> String bucketName) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            minioClient.removeBucket(<br>                    RemoveBucketArgs.builder().bucket(bucketName).build()<br>            );<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 删除成功&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;删除桶失败：&quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="列出当前用户可访问的所有-Bucket-1"><a href="#列出当前用户可访问的所有-Bucket-1" class="headerlink" title="列出当前用户可访问的所有 Bucket"></a>列出当前用户可访问的所有 Bucket</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">BucketMethod</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 列出当前用户可访问的所有 Bucket（minioClient.listBuckets()）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 注意事项：</span><br><span class="hljs-comment">     *      1. 列出的每个 bucket 对象都包含存储桶的名称、创建时间等信息</span><br><span class="hljs-comment">     *      2. 这里我只把每个 bucket 的 存储桶名称 拿出来了</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/listBuckets&quot;</span>)<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">String</span>&gt; listBuckets() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> minioClient.listBuckets() <span class="hljs-comment">// 返回的是 List &lt;Bucket&gt;，Bucket 是 MinIO 提供的类，表示一个桶对象。</span><br>                    .stream() <span class="hljs-comment">// 把这个桶列表转换成 Java Stream 流，方便做批量处理，返回的是 Stream &lt;Bucket&gt;</span><br>                    .map(bucket -&gt; bucket.name()) <span class="hljs-comment">// 对每一个 Bucket 对象，取出它的名字，返回 Stream &lt;String&gt;</span><br>                    .collect(Collectors.toList()); <span class="hljs-comment">// 把每一个 Bucket 的名字收集成一个列表，返回 List &lt;String&gt;</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> RuntimeException(<span class="hljs-string">&quot;获取桶列表失败：&quot;</span> + e.getMessage(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="设置-Bucket-访问策略-1"><a href="#设置-Bucket-访问策略-1" class="headerlink" title="设置 Bucket 访问策略"></a>设置 Bucket 访问策略</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MinioClient</span> minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 设置 Bucket 访问策略（minioClient.setBucketPolicy(SetBucketPolicyArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 无返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 注意事项：</span><br><span class="hljs-comment">     *      1. 前端应该传递 JSON 类型的 Bucket 访问策略</span><br><span class="hljs-comment">     *      2. 我们用 String 类型来接受 JSON 类型的 Bucket 访问策略</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/setBucketPolicy&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">setBucketPolicy</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span> <span class="hljs-title class_">String</span> bucketName, <span class="hljs-meta">@RequestBody</span> <span class="hljs-title class_">String</span> policyJson</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            minioClient.<span class="hljs-title function_">setBucketPolicy</span>(<br>                    <span class="hljs-title class_">SetBucketPolicyArgs</span>.<span class="hljs-title function_">builder</span>()<br>                            .<span class="hljs-title function_">bucket</span>(bucketName)<br>                            .<span class="hljs-title function_">config</span>(policyJson) <span class="hljs-comment">// 传入 JSON 格式的字符串类型的 Bucket 策略</span><br>                            .<span class="hljs-title function_">build</span>()<br>            );<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 策略设置成功&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置桶策略失败：&quot;</span> + e.<span class="hljs-title function_">getMessage</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="获取-Bucket-访问策略-1"><a href="#获取-Bucket-访问策略-1" class="headerlink" title="获取 Bucket 访问策略"></a>获取 Bucket 访问策略</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 获取 Bucket 访问策略（minioClient.getBucketPolicy(GetBucketPolicyArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 返回 JSON 格式的 String 字符串（&quot;&#123;\&quot;username\&quot;:\&quot;wangza\&quot;,\&quot;role\&quot;:\&quot;admin\&quot;&#125;&quot;）</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/getBucketPolicy&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getBucketPolicy(<span class="hljs-meta">@RequestParam</span> String bucketName) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> minioClient.getBucketPolicy(<br>                    GetBucketPolicyArgs.builder()<br>                            .bucket(bucketName)<br>                            .build()<br>            );<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;获取桶策略失败：&quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="启用-Bucket-版本控制-1"><a href="#启用-Bucket-版本控制-1" class="headerlink" title="启用 Bucket 版本控制"></a>启用 Bucket 版本控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 启用 Bucket 版本控制（minioClient.setBucketVersioning(SetBucketVersioningArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 无返回值</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/enableBucketVersioning&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">enableBucketVersioning</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String bucketName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            minioClient.setBucketVersioning(<br>                    SetBucketVersioningArgs.builder()<br>                            .bucket(bucketName)<br>                            .config(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VersioningConfiguration</span>(VersioningConfiguration.Status.ENABLED, <span class="hljs-literal">null</span>))<br>                            .build()<br>            );<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;已启用版本控制：&quot;</span> + bucketName;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;启用版本控制失败：&quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="禁用-Bucket-版本控制-1"><a href="#禁用-Bucket-版本控制-1" class="headerlink" title="禁用 Bucket 版本控制"></a>禁用 Bucket 版本控制</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MinioClient</span> minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 禁用 Bucket 版本控制（minioClient.setBucketVersioning(SetBucketVersioningArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 无返回值</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/suspendBucketVersioning&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">suspendBucketVersioning</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span> <span class="hljs-title class_">String</span> bucketName</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            minioClient.<span class="hljs-title function_">setBucketVersioning</span>(<br>                    <span class="hljs-title class_">SetBucketVersioningArgs</span>.<span class="hljs-title function_">builder</span>()<br>                            .<span class="hljs-title function_">bucket</span>(bucketName)<br>                            .<span class="hljs-title function_">config</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VersioningConfiguration</span>(<span class="hljs-title class_">VersioningConfiguration</span>.<span class="hljs-property">Status</span>.<span class="hljs-property">SUSPENDED</span>, <span class="hljs-literal">null</span>))<br>                            .<span class="hljs-title function_">build</span>()<br>            );<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;已暂停版本控制：&quot;</span> + bucketName;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;暂停版本控制失败：&quot;</span> + e.<span class="hljs-title function_">getMessage</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="设置-Bucket-标签-1"><a href="#设置-Bucket-标签-1" class="headerlink" title="设置 Bucket 标签"></a>设置 Bucket 标签</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MinioClient</span> minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 设置 Bucket 的标签（minioClient.setBucketTags(SetBucketTagsArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值</span><br><span class="hljs-comment">     *      1. 无返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 注意事项：</span><br><span class="hljs-comment">     *      1. 前端应该传递 JSON 类型的 Bucket 标签</span><br><span class="hljs-comment">     *      2. 我们用 String 类型来接受 JSON 类型的 Bucket 标签</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/setBucketTags&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">setBucketTags</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span> <span class="hljs-title class_">String</span> bucketName,</span><br><span class="hljs-params">                                <span class="hljs-meta">@RequestBody</span> <span class="hljs-title class_">String</span> tagsJson</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 JSON 转为 Map&lt;String, String&gt;</span><br>            <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt; tags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>()<br>                    .<span class="hljs-title function_">readValue</span>(tagsJson, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">String</span>&gt;&gt;() &#123;&#125;);<br>            minioClient.<span class="hljs-title function_">setBucketTags</span>(<br>                    <span class="hljs-title class_">SetBucketTagsArgs</span>.<span class="hljs-title function_">builder</span>()<br>                            .<span class="hljs-title function_">bucket</span>(bucketName)<br>                            .<span class="hljs-title function_">tags</span>(tags) <span class="hljs-comment">// 传入 JSON 格式的字符串类型的 Bucket 标签</span><br>                            .<span class="hljs-title function_">build</span>()<br>            );<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 标签设置成功&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置桶标签失败：&quot;</span> + e.<span class="hljs-title function_">getMessage</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="获取-Bucket-标签-1"><a href="#获取-Bucket-标签-1" class="headerlink" title="获取 Bucket 标签"></a>获取 Bucket 标签</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RestController</span><br>public class BucketMethod &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private MinioClient minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 获取 Bucket 的标签（minioClient.getBucketTags(GetBucketTagsArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 返回标签的键值对 Map</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/getBucketTags&quot;</span>)<br>    public Map&lt;String, String&gt; <span class="hljs-built_in">getBucketTags</span>(<span class="hljs-variable">@RequestParam</span> String bucketName) &#123;<br>        <span class="hljs-selector-tag">try</span> &#123;<br>            <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">minioClient</span><span class="hljs-selector-class">.getBucketTags</span>(<br>                    GetBucketTagsArgs.<span class="hljs-built_in">builder</span>().<span class="hljs-built_in">bucket</span>(bucketName).<span class="hljs-built_in">build</span>()<br>            )<span class="hljs-selector-class">.get</span>();<br>        &#125; <span class="hljs-selector-tag">catch</span> (Exception e) &#123;<br>            <span class="hljs-selector-tag">throw</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">RuntimeException</span>(<span class="hljs-string">&quot;获取桶标签失败：&quot;</span> + e.<span class="hljs-built_in">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h4 id="设置-Bucket-生命周期-1"><a href="#设置-Bucket-生命周期-1" class="headerlink" title="设置 Bucket 生命周期"></a>设置 Bucket 生命周期</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 设置 Bucket 的生命周期（minioClient.setBucketLifecycle(SetBucketLifecycleArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 无返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. 注意事项：</span><br><span class="hljs-comment">     *      1. 前端应该传递 XML 类型的 Bucket 生命周期</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/setBucketLifecycle&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String setBucketLifecycle(<span class="hljs-meta">@RequestParam</span> String bucketName,<br>                                     <span class="hljs-meta">@RequestBody</span> LifecycleConfiguration lifecycleConfigurationXml) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            minioClient.setBucketLifecycle(<br>                    SetBucketLifecycleArgs.builder()<br>                            .bucket(bucketName)<br>                            .config(lifecycleConfigurationXml) <span class="hljs-comment">// 传入 LifecycleConfigutation 类型的 Bucket 生命周期</span><br>                            .build()<br>            );<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;桶 [&quot;</span> + bucketName + <span class="hljs-string">&quot;] 生命周期设置成功&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置桶生命周期失败：&quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="获取-Bucket-生命周期-1"><a href="#获取-Bucket-生命周期-1" class="headerlink" title="获取 Bucket 生命周期"></a>获取 Bucket 生命周期</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketMethod</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 获取 Bucket 的生命周期（minioClient.getBucketLifecycle(GetBucketLifecycleArgs)）</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 1. 返回值：</span><br><span class="hljs-comment">     *      1. 返回 XML 格式的 String 字符串</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/getBucketLifecycle&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getBucketLifecycle(<span class="hljs-meta">@RequestParam</span> String bucketName) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> minioClient.getBucketLifecycle(<br>                    GetBucketLifecycleArgs.builder()<br>                            .bucket(bucketName)<br>                            .build()<br>            ).toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;获取桶生命周期失败：&quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Object-常用操作"><a href="#Object-常用操作" class="headerlink" title="Object 常用操作"></a>Object 常用操作</h3><h4 id="上传-Object-1"><a href="#上传-Object-1" class="headerlink" title="上传 Object"></a>上传 Object</h4><h5 id="小文件（-1-MB）"><a href="#小文件（-1-MB）" class="headerlink" title="小文件（&lt; 1 MB）"></a>小文件（&lt; 1 MB）</h5><p>对于对于一个小文件（例如50KB），实际数据传输的时间可能只有几毫秒，但是其主要性能瓶颈是**请求开销 (Request Overhead) 与网络延迟 (Latency)**，因为其每一次上传操作斗湖涉及到：</p><ol><li>建立 TCP 链接（三次握手）</li><li>如果使用 HTTPS，还需要进行 TLS &#x2F; SSL 握手</li><li>发送 HTTP 请求</li><li>Minio 进行身份验证、授权和元数据处理</li></ol><p>所以，解决这个问题的核心思想就是并发上传，不要等待一个文件上传完成后再开始下一个。使用线程池并行处理多个上传任务，从而让网络连接和服务器资源一直处于“忙碌”状态，将等待时间转化为有效的数据传输时间</p><p>直接从文件路径或输入流上传即可，SDK 会处理好一切。<code>uploadObject()</code> 是专门为上传文件设计的便捷方法。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>其实 Minio 本身就是用来处理大文件的，对于小文件，性能可能并不好</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据管理</category>
      
      <category>数据的组织方式</category>
      
      <category>对象存储</category>
      
      <category>Minio</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：MySQL</title>
    <link href="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/"/>
    <url>/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h1><h2 id="1-MySQL-体系结构"><a href="#1-MySQL-体系结构" class="headerlink" title="1. MySQL 体系结构"></a>1. MySQL 体系结构</h2><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-3.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>索引由存储引擎层实现，因此不同存储引擎的索引结构可能不同</li></ol></blockquote><hr><h2 id="2-MySQL-语法"><a href="#2-MySQL-语法" class="headerlink" title="2. MySQL 语法"></a>2. MySQL 语法</h2><h3 id="2-1-语法要求"><a href="#2-1-语法要求" class="headerlink" title="2.1. 语法要求"></a>2.1. 语法要求</h3><ol><li>SQL 语句可以单行或多行，但要以分号（<code>;</code>）结尾</li><li>MySQL 默认情况下，每条 SQL 语句的最大长度为 4MB</li></ol><hr><h3 id="2-2-注释写法"><a href="#2-2-注释写法" class="headerlink" title="2.2. 注释写法"></a>2.2. 注释写法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 单行注释</span><br><br><span class="hljs-comment">-- 单行注释</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-3-DDL（库、表、列操作）"><a href="#2-3-DDL（库、表、列操作）" class="headerlink" title="2.3. DDL（库、表、列操作）"></a>2.3. DDL（库、表、列操作）</h3><h4 id="2-3-1-库操作"><a href="#2-3-1-库操作" class="headerlink" title="2.3.1. 库操作"></a>2.3.1. 库操作</h4><h5 id="2-3-1-1-创建数据库"><a href="#2-3-1-1-创建数据库" class="headerlink" title="2.3.1.1. 创建数据库"></a>2.3.1.1. 创建数据库</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>] &lt;repository-<span class="hljs-type">name</span>&gt; [<span class="hljs-keyword">default</span> charset 字符集] [<span class="hljs-keyword">collate</span> 排序规则];<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>若不指定字符集，默认使用 utf8mb4；</li><li>若不指定排序规则，默认使用 utf8mb4_0900_ai_ci</li></ol></blockquote><hr><h5 id="2-3-1-2-删除数据库"><a href="#2-3-1-2-删除数据库" class="headerlink" title="2.3.1.2. 删除数据库"></a>2.3.1.2. 删除数据库</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] &lt;repository-<span class="hljs-type">name</span>&gt;;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-1-3-修改数据库"><a href="#2-3-1-3-修改数据库" class="headerlink" title="2.3.1.3. 修改数据库"></a>2.3.1.3. 修改数据库</h5><p><font color="#92d050">1. 修改数据库名</font></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-number">1.</span> 导出旧数据库（将旧数据库导出到一个 <span class="hljs-keyword">SQL</span> 文件中)<br>mysqldump -p &lt;<span class="hljs-built_in">old</span>-repository-<span class="hljs-type">name</span>&gt; &gt; &lt;<span class="hljs-built_in">old</span>-repository-<span class="hljs-type">name</span>&gt; .<span class="hljs-keyword">sql</span><br><br># <span class="hljs-number">2.</span> 创建新的数据库<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> &lt;<span class="hljs-built_in">new</span>-repository-<span class="hljs-type">name</span>&gt;;<br><br># <span class="hljs-number">3.</span> 将旧库文件导入新库<br>mysql -p &lt;<span class="hljs-built_in">new</span>-repository-<span class="hljs-type">name</span>&gt; &lt; &lt;<span class="hljs-built_in">new</span>-repository-<span class="hljs-type">name</span>&gt;.<span class="hljs-keyword">sql</span><br><br># <span class="hljs-number">4.</span> 删除旧数据库<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DATABASE</span> &lt;<span class="hljs-built_in">old</span>-repository-<span class="hljs-type">name</span>&gt;;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-1-4-查询数据库"><a href="#2-3-1-4-查询数据库" class="headerlink" title="2.3.1.4. 查询数据库"></a>2.3.1.4. 查询数据库</h5><p><font color="#92d050">1. 查询所有数据库</font></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">show databases<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 查看当前使用的数据库</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">databses</span>()</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-1-5-使用数据库"><a href="#2-3-1-5-使用数据库" class="headerlink" title="2.3.1.5. 使用数据库"></a>2.3.1.5. 使用数据库</h5><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">use</span> &lt;repository-<span class="hljs-keyword">name</span>&gt;;<br></code></pre></td></tr></table></figure><hr><h4 id="2-3-2-表操作"><a href="#2-3-2-表操作" class="headerlink" title="2.3.2. 表操作"></a>2.3.2. 表操作</h4><h5 id="2-3-2-1-创建表"><a href="#2-3-2-1-创建表" class="headerlink" title="2.3.2.1. 创建表"></a>2.3.2.1. 创建表</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt; (<br>    &lt;id-<span class="hljs-keyword">column</span>&gt; &lt;数据类型&gt; AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span> [<span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;explanation for this column&#x27;</span>],<br>    &lt;<span class="hljs-keyword">column</span>-<span class="hljs-type">name</span>&gt; &lt;数据类型&gt; <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> [<span class="hljs-keyword">DEFAULT</span> &lt;默认值&gt;] [<span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;explanation for this column&#x27;</span>],<br>    &lt;<span class="hljs-keyword">column</span>-<span class="hljs-type">name</span>&gt; &lt;数据类型&gt; <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> [<span class="hljs-keyword">DEFAULT</span> &lt;默认值&gt;] [<span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;explanation for this column&#x27;</span>]<br>) [ENGINE=&lt;engine-<span class="hljs-keyword">type</span>&gt;] [<span class="hljs-keyword">DEFAULT</span> CHARSET=&lt;字符集&gt;] [<span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">&#x27;explanation for this table&#x27;</span>];<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-2-2-删除表"><a href="#2-3-2-2-删除表" class="headerlink" title="2.3.2.2. 删除表"></a>2.3.2.2. 删除表</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> [<span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>] &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt;;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-2-3-修改表"><a href="#2-3-2-3-修改表" class="headerlink" title="2.3.2.3. 修改表"></a>2.3.2.3. 修改表</h5><p><font color="#92d050">1. 修改表名</font></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> &lt;<span class="hljs-built_in">old</span>-<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt; <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> &lt;<span class="hljs-built_in">new</span>-<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt;; <br></code></pre></td></tr></table></figure><hr><h5 id="2-3-2-4-查询表"><a href="#2-3-2-4-查询表" class="headerlink" title="2.3.2.4. 查询表"></a>2.3.2.4. 查询表</h5><p><font color="#92d050">1. 查看当前使用的数据库所有表</font></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 查看表结构</font></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">desc</span> &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 查看建表语句</font></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt;;<br></code></pre></td></tr></table></figure><hr><h4 id="2-3-3-列操作"><a href="#2-3-3-列操作" class="headerlink" title="2.3.3. 列操作"></a>2.3.3. 列操作</h4><h5 id="2-3-3-1-添加列"><a href="#2-3-3-1-添加列" class="headerlink" title="2.3.3.1. 添加列"></a>2.3.3.1. 添加列</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt; <span class="hljs-keyword">add</span> &lt;<span class="hljs-keyword">column</span>-<span class="hljs-type">name</span>&gt; &lt;数据类型&gt; [<span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;列的注释&#x27;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>一种是在建表时直接指定列，另一种是通过该命令在已有表中添加列</li></ol></blockquote><hr><h5 id="2-3-3-2-删除列"><a href="#2-3-3-2-删除列" class="headerlink" title="2.3.3.2. 删除列"></a>2.3.3.2. 删除列</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt; <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> &lt;<span class="hljs-keyword">column</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-3-3-修改列"><a href="#2-3-3-3-修改列" class="headerlink" title="2.3.3.3. 修改列"></a>2.3.3.3. 修改列</h5><p><font color="#92d050">1. 修改列名</font></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-number">1.</span> 修改列名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt; <span class="hljs-keyword">rename</span> <span class="hljs-keyword">column</span> &lt;<span class="hljs-built_in">old</span>-<span class="hljs-keyword">column</span>-<span class="hljs-type">name</span>&gt; <span class="hljs-keyword">to</span> &lt;<span class="hljs-built_in">new</span>-<span class="hljs-keyword">column</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><hr><h3 id="2-4-DML（数据增删改）"><a href="#2-4-DML（数据增删改）" class="headerlink" title="2.4. DML（数据增删改）"></a>2.4. DML（数据增删改）</h3><h4 id="2-4-1-插入数据"><a href="#2-4-1-插入数据" class="headerlink" title="2.4.1. 插入数据"></a>2.4.1. 插入数据</h4><h5 id="2-4-1-1-高效插入数据的方法"><a href="#2-4-1-1-高效插入数据的方法" class="headerlink" title="2.4.1.1. 高效插入数据的方法"></a>2.4.1.1. 高效插入数据的方法</h5><h6 id="2-4-1-1-1-批量插入"><a href="#2-4-1-1-1-批量插入" class="headerlink" title="2.4.1.1.1. 批量插入"></a>2.4.1.1.1. 批量插入</h6><p>这是提升插入效率<strong>最最最关键</strong>的一步，效果立竿见影，单条 <code>INSERT</code> 语句的性能极差，因为每次插入都需要一次完整的 网络请求 -&gt; SQL 解析 -&gt; 执行 -&gt; 网络返回 流程，例如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students <span class="hljs-keyword">values</span> (<span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students <span class="hljs-keyword">values</span> (<span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">22</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students <span class="hljs-keyword">values</span> (<span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-number">21</span>);<br></code></pre></td></tr></table></figure><p>进行了 3 次 SQL 解析和3次网络往返，我们可以将多条 <code>INSERT</code> 语句合并成一条，这样只执行了一个网络往返和 SQL 解析：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students <span class="hljs-keyword">values</span> <br>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">20</span>),<br>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">22</span>),<br>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-number">21</span>);<br></code></pre></td></tr></table></figure><hr><h6 id="2-4-1-1-2-文件导入"><a href="#2-4-1-1-2-文件导入" class="headerlink" title="2.4.1.1.2. 文件导入"></a>2.4.1.1.2. 文件导入</h6><p>当数据量巨大时（如百万、千万级），<code>LOAD DATA INFILE</code> 是最快的插入方式，它绕过了大量的 SQL 解析，直接在服务端读取文件并插入数据，减少了网络传输和协议处理的开销。</p><p>假设你有一个 <code>/tmp/data.csv</code> 文件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">data1</span>,<span class="hljs-number">100</span><br><span class="hljs-attribute">data2</span>,<span class="hljs-number">200</span><br><span class="hljs-attribute">data3</span>,<span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p>你可以执行 SQL</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">LOAR DATA <span class="hljs-keyword">INFILE</span> <span class="hljs-string">&#x27;/tmp/data.csv&#x27;</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> my_table FIELDS TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;,&#x27;</span> LINES TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;\n&#x27;</span> (col1, col2);<br></code></pre></td></tr></table></figure><p>需要注意的是，默认情况下，出于安全考虑，LOAD DATA LOCAL INFILE 可能被禁用，需要服务器和客户端同时开启 local_infile 选项</p><p><font color="#92d050">1. 服务器端开启</font></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 1. 临时开启</span><br><span class="hljs-built_in">SET</span> <span class="hljs-built_in">GLOBAL</span> local_infile = <span class="hljs-keyword">ON</span>;<br><br><br><span class="hljs-comment">// 2. 永久开启</span><br><span class="hljs-meta">[</span>mysqld<span class="hljs-meta">]</span><br>local_infile=1<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 客户端开启</font><br>启动客户端时加参数 <code>--local-infile=1</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql <span class="hljs-attribute">--local-infile</span>=1 -u 用户名 -p<br></code></pre></td></tr></table></figure><p>在使用 JDBC 的时候：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jdbc:mysql://host:port/dbname?allowLoadLocalInfile=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h6 id="2-4-1-1-3-调整配置"><a href="#2-4-1-1-3-调整配置" class="headerlink" title="2.4.1.1.3. 调整配置"></a>2.4.1.1.3. 调整配置</h6><p>对于大规模数据导入，可以临时调整一些 MySQL 参数来换取更高的写入性能，注意：这些调整会牺牲一定的安全性（ACID特性），导入完成后务必改回默认值！</p><p><font color="#92d050">1. innodb_flush_log_at_trx_commit</font><br>在批量导入时，临时设置为2，修改完成后再设置为 1</p><ol><li>1（默认）<ol><li>最安全，性能最差，每次事务提交都将 redo log 同步刷到磁盘。</li></ol></li><li>2<ol><li>每次事务提交只写入操作系统的缓存，每秒刷盘一次，性能大幅提升。</li><li>如果 MySQL 宕机（非操作系统宕机），可能丢失最后一秒的数据。</li></ol></li><li>0<ol><li>性能最好，安全性最差，每秒才将 redo log 写入 OS 缓存并刷盘。</li><li>MySQL 和操作系统都宕机可能丢失最后一秒数据。</li></ol></li></ol><p><font color="#92d050">2. sync_binlog</font><br>在批量导入时，临时设置为 0 或者一个较大的值（如 1000），完成后改为 1</p><ol><li>1（默认）<ol><li>最安全，每次事务提交都将 binary log 同步刷到磁盘。</li></ol></li><li>N（N &gt; 1）<ol><li>每 N 次事务提交刷盘一次，性能提升。</li></ol></li><li>0<ol><li>不强制同步，由操作系统决定何时写盘，性能最高</li></ol></li></ol><p><font color="#92d050">3. innodb_autoinc_lock_mode</font></p><ol><li>2（默认）<ol><li>对于并发插入性能最好，允许自增锁不阻塞整个插入过程。通常不需要修改。</li><li>如果遇到自增值不连续的问题，可以研究此参数。</li></ol></li></ol><hr><h6 id="2-4-1-1-4-删除索引"><a href="#2-4-1-1-4-删除索引" class="headerlink" title="2.4.1.1.4. 删除索引"></a>2.4.1.1.4. 删除索引</h6><p>插入数据时，每个索引都需要被更新，这是个不小的开销，如果是一次性地向一个<strong>空表</strong>导入大量数据，可以考虑先<strong>删除除唯一索引、主键索引外的其他索引</strong>，数据导入完成后，再重新创建索引，这通常比带着索引插入要快，除非你非要保留什么索引的</p><hr><h6 id="2-4-1-1-5-顺序插入"><a href="#2-4-1-1-5-顺序插入" class="headerlink" title="2.4.1.1.5. 顺序插入"></a>2.4.1.1.5. 顺序插入</h6><ul><li><strong>主键顺序插入</strong>：InnoDB 表是<strong>索引组织表</strong>（Clustered Index），数据本身是按主键顺序存储的。如果你能保证插入的数据是按主键（尤其是自增 ID）顺序排列的，可以避免页分裂（Page Split）和随机磁盘 I&#x2F;O，从而提高效率。</li></ul><hr><h2 id="3-MySQL-日志"><a href="#3-MySQL-日志" class="headerlink" title="3. MySQL 日志"></a>3. MySQL 日志</h2><h3 id="3-1-服务器层日志"><a href="#3-1-服务器层日志" class="headerlink" title="3.1. 服务器层日志"></a>3.1. 服务器层日志</h3><h4 id="3-1-1-错误日志（Error-Log）"><a href="#3-1-1-错误日志（Error-Log）" class="headerlink" title="3.1.1. 错误日志（Error Log）"></a>3.1.1. 错误日志（Error Log）</h4><h5 id="3-1-1-1-错误日志概述"><a href="#3-1-1-1-错误日志概述" class="headerlink" title="3.1.1.1. 错误日志概述"></a>3.1.1.1. 错误日志概述</h5><p>错误日志是 MySQL 服务器在启动、运行和停止过程中生成的文本文件，记录了各种错误、警告和启动信息，帮助你了解服务器的运行状态和故障原因。当 MySQL 出现问题时，第一步就是查看错误日志。</p><hr><h5 id="3-1-1-2-错误日志定位"><a href="#3-1-1-2-错误日志定位" class="headerlink" title="3.1.1.2. 错误日志定位"></a>3.1.1.2. 错误日志定位</h5><p>我们可以通过查询 MySQL 的系统变量，来确认错误日志文件的位置和相关配置：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;log_err%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL.png"></p><p><font color="#92d050">1. log_error</font><br>表示错误日志文件的路径。如果值为 <code>stderr</code>，说明日志不会写入硬盘文件，而是输出到 MySQL 进程的标准错误流。这个输出通常会被 <strong>systemd</strong> 或 <strong>docker</strong> 的日志收集器捕获，而对于标准错误输出，容器环境下通过 <code>docker logs</code> 查看，非容器环境则通过 <code>journalctl</code> 查看。</p><p><font color="#92d050">2. log_error_services</font><br>表示已启用的错误日志服务组件</p><p><font color="#92d050">3. log_error_suppression_list</font><br>列出被过滤掉的特定错误信息对应的错误码</p><p><font color="#92d050">4. log_error_verbosity</font><br>表示日志记录的详细等级：</p><ol><li>1<ol><li>只记录 ERROR（错误）</li></ol></li><li>2<ol><li>记录 ERROR（错误）和 WARNING（警告）</li></ol></li><li>3<ol><li>记录 ERROR（错误）、WARNING（警告）和 INFORMATION（信息）</li></ol></li></ol><hr><h5 id="3-1-1-3-错误日志配置"><a href="#3-1-1-3-错误日志配置" class="headerlink" title="3.1.1.3. 错误日志配置"></a>3.1.1.3. 错误日志配置</h5><p>可以在 my.cnf 文件中配置错误日志相关的参数：</p><p><font color="#92d050">1. 错误日志的路径和名称</font></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">[mysqld]<br>log_error = /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/<span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 错误日志的级别</font></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">log_error_verbosity</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>日志记录的详细等级：</p><ol><li>1<ol><li>只记录 ERROR（错误）</li></ol></li><li>2<ol><li>记录 ERROR（错误）和 WARNING（警告）</li></ol></li><li>3<ol><li>记录 ERROR（错误）、WARNING（警告）和 INFORMATION（信息）</li></ol></li></ol><p><font color="#92d050">3. 错误日志服务组件</font><br>你可以在此配置日志的输出格式和目标，示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">log_error_services</span> = log_filter_internal<span class="hljs-comment">; log_writer_file; log_writer_syslog; log_sink_json;</span><br></code></pre></td></tr></table></figure><ol><li>log_filter_internal<ol><li>日志过滤器，会自动过滤掉不需要的日志</li><li>默认值：<ol><li>启用</li></ol></li></ol></li><li>log_writer_file<ol><li>将日志写入文件，路径由 <code>log_error</code> 指定。</li></ol></li><li>log_writer_syslog<ol><li>将日志发送到系统的 syslog（Linux）或 Event Log（Windows）。</li></ol></li><li>log_sink_json<ol><li>将日志输出格式转换为 JSON，便于 ELK、Splunk 等日志分析工具解析。</li><li>注意，JSON 格式日志不会写入 <code>log_error</code> 指定的文件，而是输出到标准错误流，你可以通过采集标准错误流写入文件，或修改启动脚本将标准错误重定向到文件。</li><li>对于标准错误输出，容器环境下通过 <code>docker logs</code> 查看，非容器环境则通过 <code>journalctl</code> 查看。</li></ol></li></ol><p>我们可以通过以下命令查看当前启用的错误日志服务组件：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;log_error_services&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>除了配置的组件外，还有一个 <code>log_sink_internal</code>，无论 <code>log_error_services</code> 设置什么，默认都会启用它。它负责将日志写入传统的错误日志文件（<code>log_error</code> 指定的文件）或输出到 <code>stderr</code></li><li>这些配置项都可以通过 <code>SHOW VARIABLES LIKE &#39;XXXXX&#39;</code> 查询，不再赘述</li></ol></blockquote><p><font color="#92d050">4. 过滤特定错误信息</font><br>指定一组错误代码（error codes），当这些错误发生时，MySQL 日志系统会选择性地不将它们写入错误日志</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">log_error_suppression_list</span>=<span class="hljs-number">1131</span>, <span class="hljs-number">1268</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 日志记录中的时间</font><br>设置日志记录中的时间，默认采用 UTC 时区，这会导致日志时间比中国时间晚几个小时，给查看和定位问题带来不便。需要注意的是，这个时间设置影响所有日志，而不仅仅是错误日志，因此非常重要。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">log_timestamps</span>=system<br></code></pre></td></tr></table></figure><hr><h5 id="3-1-1-4-错误日志解读"><a href="#3-1-1-4-错误日志解读" class="headerlink" title="3.1.1.4. 错误日志解读"></a>3.1.1.4. 错误日志解读</h5><p>错误日志的条目通常遵循一个固定的格式：<code>时间戳 [子系统] [级别] [错误码] 消息内容</code>，例如：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">2023-10-27T10:30:00.123456Z 0 <span class="hljs-comment">[System ]</span> <span class="hljs-comment">[Note]</span> <span class="hljs-comment">[MY-010931]</span> <span class="hljs-comment">[Server]</span> /usr/sbin/mysqld: ready for connections. Version: &#x27;8.0.34&#x27; socket: &#x27;/var/run/mysqld/mysqld.sock&#x27; port: 3306. <br><br>2023-10-27T10:35:10.987654Z 15 <span class="hljs-comment">[Warning ]</span> <span class="hljs-comment">[MY-010068]</span> <span class="hljs-comment">[Server]</span> Got an error reading communication packets. <br><br>2023-10-27T10:40:20.555555Z 0 <span class="hljs-comment">[ ERROR ]</span> <span class="hljs-comment">[MY-010020]</span> <span class="hljs-comment">[Server]</span> Can&#x27;t start server: Bind on TCP/IP port: Address already in use. <br><br>2023-10-27T10:40:20.555666Z 0 <span class="hljs-comment">[ ERROR ]</span> <span class="hljs-comment">[MY-010119]</span> <span class="hljs-comment">[Server]</span> Aborting<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里的 MY-010931 中，数字部分 “010931” 就是错误码</li></ol></blockquote><hr><h4 id="3-1-2-通用查询日志（General-Query-Log）"><a href="#3-1-2-通用查询日志（General-Query-Log）" class="headerlink" title="3.1.2. 通用查询日志（General Query Log）"></a>3.1.2. 通用查询日志（General Query Log）</h4><hr><h4 id="3-1-3-慢查询日志（Slow-Query-Log）"><a href="#3-1-3-慢查询日志（Slow-Query-Log）" class="headerlink" title="3.1.3. 慢查询日志（Slow Query Log）"></a>3.1.3. 慢查询日志（Slow Query Log）</h4><h5 id="3-1-3-1-慢查询日志概述"><a href="#3-1-3-1-慢查询日志概述" class="headerlink" title="3.1.3.1. 慢查询日志概述"></a>3.1.3.1. 慢查询日志概述</h5><p>慢查询日志是 MySQL 用来记录<strong>执行时间超过预设阈值的 SQL 语句</strong>的日志文件。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>除了记录慢语句，它还可以记录<strong>没有使用索引的查询</strong></li><li>慢查询日志不是只记录查询语句，而是可以记录所有 SQL 语句</li></ol></blockquote><hr><h5 id="3-1-3-2-慢查询日志定位"><a href="#3-1-3-2-慢查询日志定位" class="headerlink" title="3.1.3.2. 慢查询日志定位"></a>3.1.3.2. 慢查询日志定位</h5><p>我们可以通过查询 MySQL 的系统变量，来确认错误慢查询日志文件的位置：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;slow_query_log_file&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-1.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里的 b045… 是一个默认的类似哈希值的名称。由于你没有明确配置日志文件名，它会随机生成，以确保每次启动时日志文件不会冲突</li></ol></blockquote><hr><h5 id="3-1-3-3-慢查询日志配置"><a href="#3-1-3-3-慢查询日志配置" class="headerlink" title="3.1.3.3. 慢查询日志配置"></a>3.1.3.3. 慢查询日志配置</h5><p><font color="#92d050">1. 开启慢查询日志</font></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">slow_query_log</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 设置慢查询日志的阈值</font></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">long_query_time</span> = <span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们可以动态调整 long_query_time，系统上线初期可以设为 <code>1s</code>，解决掉最慢的一批后，逐步降低到 <code>0.5s</code>, <code>0.2s</code> 等，持续优化</li></ol></blockquote><p><font color="#92d050">3. 慢查询日志的路径与文件名</font></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">[mysqld]<br>slow_query_log_file = <span class="hljs-regexp">/var/</span><span class="hljs-built_in">log</span>/mysql/mysql-slow.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 将没有使用索引的查询也记录到慢查询日志</font></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">log_queries_not_using_indexes</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h5 id="3-1-3-4-慢查询日志解读"><a href="#3-1-3-4-慢查询日志解读" class="headerlink" title="3.1.3.4. 慢查询日志解读"></a>3.1.3.4. 慢查询日志解读</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-type">Time</span>: <span class="hljs-number">2025</span><span class="hljs-number">-08</span><span class="hljs-number">-10</span>T15:<span class="hljs-number">30</span>:<span class="hljs-number">10.123456</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><br># <span class="hljs-keyword">User</span>@Host: webuser[webuser] @ web_server [<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>]  Id: <span class="hljs-number">42</span><br><br># Query_time: <span class="hljs-number">2.345123</span>  Lock_time: <span class="hljs-number">0.000123</span>  Rows_sent: <span class="hljs-number">5</span>  Rows_examined: <span class="hljs-number">800000</span><br><br># Rows_affected: <span class="hljs-number">0</span><br><br><span class="hljs-keyword">SET</span> <span class="hljs-type">timestamp</span>=<span class="hljs-number">1754796610</span>;<br><br><span class="hljs-keyword">SELECT</span> product_name, price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> category_id = <span class="hljs-number">123</span> <span class="hljs-keyword">AND</span> status = <span class="hljs-string">&#x27;active&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p><font color="#92d050">1. # Time: 2025-08-10T15:30:10.123456+08:00</font><br>查询语句执行完毕的时间点</p><p><font color="#92d050">2. # User@Host: webuser[webuser] @ web_server [192.168.1.100]  Id: 42</font><br>执行查询的用户名和客户端主机 IP</p><p><font color="#92d050">3. # Query_time: 2.345123  Lock_time: 0.000123  Rows_sent: 5  Rows_examined: 800000</font></p><ol><li>Query_time:<ol><li>查询消耗的总时间，是最重要的优化指标</li><li>单位：<ol><li>秒</li></ol></li></ol></li><li>Lock_time<ol><li>等待表所得时间，如果这个值很高，说明存在严重的锁竞争</li><li>单位：<ol><li>秒</li></ol></li></ol></li><li>Rows_sent<ol><li>发送给客户端的行数</li></ol></li><li>Rows_examined<ol><li>MySQL 在存储引擎层扫描的行数，这是另外一个至关重要的指标</li><li>如果 Rows_examined 很大而 Rows_sent 很小，通常意味着查询效率低下，例如没有合适的索引导致全表扫描</li></ol></li></ol><p><font color="#92d050">4. # Rows_affected: 0</font><br>表示影响的行数</p><p><font color="#92d050">5. SET timestamp&#x3D;1754796610;</font><br>这条语句执行的开始时间，用秒级 Unix 时间戳表示</p><hr><h4 id="3-1-4-二进制日志（Binary-Log-Binlog）"><a href="#3-1-4-二进制日志（Binary-Log-Binlog）" class="headerlink" title="3.1.4. 二进制日志（Binary Log &#x2F; Binlog）"></a>3.1.4. 二进制日志（Binary Log &#x2F; Binlog）</h4><h5 id="3-1-4-1-二进制日志概述"><a href="#3-1-4-1-二进制日志概述" class="headerlink" title="3.1.4.1. 二进制日志概述"></a>3.1.4.1. 二进制日志概述</h5><p>二进制日志是一个记录了所有对数据库进行修改操作的事件的文件集，它以二进制格式存储，不能直接用文本编辑器查看，必须使用专门的工具（如 <code>mysqlbinlog</code>）来解析，因为其设计初衷不是为了人类阅读或调试，而是为了被机器（其他 MySQL 服务器或工具）消费。</p><p>二进制日志的核心用途又三种：</p><ol><li>主从复制<ol><li>在主从架构中，主库（Master）开启 Binlog，记录所有变更</li><li>从库（Slave&#x2F;Replica）会请求主库的 Binlog，并在本地重放（Replay）这些事件，从而实现与主库的数据同步</li></ol></li></ol><hr><h5 id="3-1-4-2-二进制日志用途"><a href="#3-1-4-2-二进制日志用途" class="headerlink" title="3.1.4.2. 二进制日志用途"></a>3.1.4.2. 二进制日志用途</h5><h6 id="3-1-4-2-1-主从复制"><a href="#3-1-4-2-1-主从复制" class="headerlink" title="3.1.4.2.1. 主从复制"></a>3.1.4.2.1. 主从复制</h6><p>主从架构中，主库开启 Binlog，当客户端执行修改操作时，</p><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-2.png"></p><hr><h4 id="3-1-5-中继日志-Relay-Log"><a href="#3-1-5-中继日志-Relay-Log" class="headerlink" title="3.1.5. 中继日志 (Relay Log)"></a>3.1.5. 中继日志 (Relay Log)</h4><hr><h3 id="3-2-引擎层日志"><a href="#3-2-引擎层日志" class="headerlink" title="3.2. 引擎层日志"></a>3.2. 引擎层日志</h3><h4 id="3-2-1-重做日志（Redo-Log）"><a href="#3-2-1-重做日志（Redo-Log）" class="headerlink" title="3.2.1. 重做日志（Redo Log）"></a>3.2.1. 重做日志（Redo Log）</h4><h5 id="3-2-1-1-重做日志概述"><a href="#3-2-1-1-重做日志概述" class="headerlink" title="3.2.1.1. 重做日志概述"></a>3.2.1.1. 重做日志概述</h5><ol><li><p><strong>执行 SQL → 修改内存里的数据页（Buffer Pool）</strong></p><ul><li><p>InnoDB 先把需要修改的数据页加载到内存，然后在内存中修改。</p></li><li><p>这个修改是“未落盘”的，真正的磁盘数据页还没改。</p></li></ul></li><li><p><strong>生成事务日志（<code>redo log</code> &amp; <code>undo log</code>） → 写入日志缓冲区</strong></p><ul><li><p><code>undo log</code>：记录<strong>回滚所需的信息</strong>，保证事务原子性。</p></li><li><p><code>redo log</code>：记录<strong>如何重做这次修改</strong>，保证崩溃后可恢复。</p></li><li><p>这两个日志会先放到<strong>内存里的日志缓冲区</strong>（不是直接落盘）。</p></li></ul></li><li><p><strong>提交时必须先保证 redo log 持久化（WAL 原则）</strong></p><ul><li><p>WAL &#x3D; <strong>Write Ahead Logging</strong>：先写日志，再落盘数据页。</p></li><li><p>当事务 <code>COMMIT</code> 时，InnoDB 会先把 <strong>redo log</strong> 从内存刷到磁盘（<code>innodb_flush_log_at_trx_commit</code> 控制刷盘策略）。</p></li><li><p>这样即使崩溃，redo log 也能重做内存里的修改，保证持久性。</p></li></ul></li><li><p><strong>数据页异步刷盘</strong></p><ul><li>事务提交后，修改过的内存数据页会在之后的某个时机被刷到磁盘（由后台线程或检查点机制触发），不一定立刻落盘。</li></ul></li></ol><hr><h4 id="3-2-2-回滚日志（Undo-Log）"><a href="#3-2-2-回滚日志（Undo-Log）" class="headerlink" title="3.2.2. 回滚日志（Undo Log）"></a>3.2.2. 回滚日志（Undo Log）</h4><p>这是实现事务原子性和多版本并发控制（MVCC）的关键</p><hr><h2 id="4-MySQL-存储引擎"><a href="#4-MySQL-存储引擎" class="headerlink" title="4. MySQL 存储引擎"></a>4. MySQL 存储引擎</h2><h3 id="4-1-存储引擎概述"><a href="#4-1-存储引擎概述" class="headerlink" title="4.1. 存储引擎概述"></a>4.1. 存储引擎概述</h3><p>存储引擎是实现数据存储、索引构建以及数据更新与查询等功能的技术方案，可使用以下命令查看当前数据库支持的存储引擎：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">show engines<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-4.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>存储引擎是基于表的，而非基于库的。不同的表可以使用不同的存储引擎，因此存储引擎也被称为 “表类型”</li></ol></blockquote><hr><h3 id="常用存储引擎"><a href="#常用存储引擎" class="headerlink" title="常用存储引擎"></a>常用存储引擎</h3><h4 id="常用存储引擎对比表"><a href="#常用存储引擎对比表" class="headerlink" title="常用存储引擎对比表"></a>常用存储引擎对比表</h4><table><thead><tr><th>索引名称</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>ARCHIVE</th><th>BLACKHOLE</th><th>CSV</th></tr></thead><tbody><tr><td>支持事务</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>支持 B+tree 索引</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>支持 Hash 索引</td><td>❌（但具有自适应 Hash 功能）</td><td>❌</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>支持空间索引</td><td>✅（5.7 +）</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>支持全文索引</td><td>✅（5.6 +）</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>支持外键约束</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>锁机制</td><td>行锁<br>表锁</td><td>表锁</td><td>表锁</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>写性能</td><td>中高（行锁支持高并发）</td><td>低（表锁严重影响并发）</td><td>高（虽有表锁，但是内存操作）</td><td>高（仅追加，不支持修改）</td><td>极高（不写真实数据）</td><td>中（受限于I&#x2F;O）</td></tr><tr><td>读性能</td><td>高</td><td>高</td><td>极高</td><td>低（不支持索引，需全表扫描）</td><td>无（无真实数据可读）</td><td>低（不支持索引，需全表扫描）</td></tr><tr><td>文件格式</td><td>表名.ibd</td><td>表名.MYD<br>表名.MYI<br>表名.sdi</td><td>表名.sdi</td><td>表名.ARZ<br>表名.sdi</td><td>表名.sdi</td><td>表名.CSV<br>表名.CSM<br>表名.sdi</td></tr></tbody></table><hr><h4 id="InnoDB（默认）"><a href="#InnoDB（默认）" class="headerlink" title="InnoDB（默认）"></a>InnoDB（默认）</h4><h5 id="InnoDB-概述"><a href="#InnoDB-概述" class="headerlink" title="InnoDB 概述"></a>InnoDB 概述</h5><p>InnoDB 是 MySQL 的默认存储引擎，功能强大。由于它支持事务处理和外键约束，具备良好的数据完整性与并发性能，因此被广泛应用于各类场景。<strong>对于绝大多数应用场景，强烈推荐使用 InnoDB</strong>。</p><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-23.png"></p><p>关于表空间（Tablespaces），它的存储结构如下：</p><hr><h5 id="InnoDB-内存架构"><a href="#InnoDB-内存架构" class="headerlink" title="InnoDB 内存架构"></a>InnoDB 内存架构</h5><p>对于一台专用于运行 MySQL 的服务器来说，其 <strong>80% 左右的可用内存</strong> 通常会分配给 MySQL，用于缓存数据和提升查询性能。</p><p><font color="#92d050">1. Buffer Pool（缓冲池）</font></p><p><font color="#92d050">2. Change Buffer（更改缓冲区）</font><br>更改缓冲区专门用于 非唯一的二级索引页（即不包括主键索引和唯一索引页）的延迟更新。</p><hr><h5 id="InnoDB-磁盘结构"><a href="#InnoDB-磁盘结构" class="headerlink" title="InnoDB 磁盘结构"></a>InnoDB 磁盘结构</h5><h6 id="System-Tablespace（系统表空间）"><a href="#System-Tablespace（系统表空间）" class="headerlink" title="System Tablespace（系统表空间）"></a>System Tablespace（系统表空间）</h6><p>系统表空间是一个磁盘文件（默认是 <code>ibdata1</code>），用来放所有 InnoDB 的“全局性”数据和内部结构，主要用来存放以下几种至关重要的数据：</p><ol><li>数据字典<ol><li>注意事项：<ol><li>在 <strong>MySQL 8.0 及更高版本</strong>中，数据字典被重构了，它被移出了系统表空间，存放在一个名为 <code>mysql.ibd</code> 的独立表空间中，并且以事务性的方式进行管理，这大大提高了可靠性</li><li>但在老版本（5.7及之前），它就在 <code>ibdata1</code> 里</li></ol></li></ol></li><li>Undo Log<ol><li>注意事项：<ol><li>从 <strong>MySQL 5.6</strong> 开始，Undo 日志可以配置为存放在独立的 Undo 表空间中，而不是系统表空间里，这有助于减少 <code>ibdata1</code> 的膨胀问题</li><li>在 <strong>MySQL 8.0</strong> 中，这已经是默认行为。</li></ol></li></ol></li><li>Change Buffer<ol><li>有一个常见的误区是，Change Buffer 只保存在内存中，其实其本身也是需要被持久化的</li></ol></li><li>Doublewrite Buffer</li><li>用户创建的表和索引数据<ol><li>在早期的 MySQL 版本中，你创建的所有 InnoDB 表的数据和索引都会被默认存放在这个共享的系统表空间里</li><li>现在是默认开启了 <code>innodb_file_per_table</code>，即放在独立表空间中，你也可以关闭这个，这样就依旧放到系统表空间中了</li></ol></li></ol><p>在过去的 MySQL 版本中，有一个经典的问题就是 ibdata1 不断增大，这主要是因为它存放了 Undo 日志，只要数据库还在运行，就会有新的事务产生 Undo 日志。这些日志占据了文件中被删除表留下的空洞，导致文件系统层面无法看到可收缩的空间。</p><p>唯一的收缩方法是进行逻辑备份（如 <code>mysqldump</code>），删除所有数据文件，重新初始化数据库，然后恢复数据，过程非常繁琐和危险。</p><p>系统表空间可以不止是一个文件，是否由单个文件或多个文件组成，完全取决于你的 MySQL 配置文件中的 <code>innodb_data_file_path</code> 这个参数的设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">innodb_data_file_path</span> = ibdata1:<span class="hljs-number">12</span>M<span class="hljs-comment">;ibdata2:50M:autoextend</span><br></code></pre></td></tr></table></figure><p>文件大小的单位是 M 和 G，需要注意的是，我们必须在最后一个文件中标记 :autoextend，这表示当空间用完时，该文件会自动增长</p><p>我们默认情况下，其实就是：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">innodb_data_file_path</span> = ibdata1:<span class="hljs-number">12</span>M:autoextend<br></code></pre></td></tr></table></figure><hr><h6 id="4-2-1-4-2-File-Per-Table-Tablespaces（独立表空间）"><a href="#4-2-1-4-2-File-Per-Table-Tablespaces（独立表空间）" class="headerlink" title="4.2.1.4.2. File-Per-Table Tablespaces（独立表空间）"></a>4.2.1.4.2. File-Per-Table Tablespaces（独立表空间）</h6><p>我们设置 <code>innodb_file_per_table = ON</code>（现代 MySQL 版本的默认设置）时，为每个表创建的那个 <code>.ibd</code> 文件就是一个独立的表空间。可以把它想象成一个<strong>为单张表量身定做的、自给自足的微型数据库文件</strong>。</p><p>这个 <code>.ibd</code> 文件的内部结构是高度组织化的，遵循一个清晰的层级：<br><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-22.png"></p><p>页是 InnoDB 进行磁盘 I&#x2F;O 和内存管理的<strong>最小单位</strong>。无论你只读取一行数据还是修改一个字节，InnoDB 都必须将包含该数据的整个页加载到内存中，修改后，再将整个页写回磁盘。默认大小是 <strong>16KB</strong>。这个大小可以在初始化数据库实例时通过 <code>innodb_page_size</code> 参数修改（但一旦设定就不能更改）</p><p>每个表的文件表空间包含单个lnnoDB表的数据和索引l，并存储在文件系统上的单个数据文件中，就不会放到系统表空间了</p><p>参数：innodb_file_per_table 若开启</p><hr><table><thead><tr><th><strong>引擎</strong></th><th><strong>特点</strong></th><th><strong>适合场景</strong></th><th>当前状况</th></tr></thead><tbody><tr><td><strong>InnoDB（默认）</strong></td><td>支持事务、行级锁、外键约束、ACID 特性，性能优良。</td><td>高并发、事务性应用、需要保证数据一致性、支持外键约束的场景（例如在线交易系统、金融应用）</td><td>MySQL 默认引擎，功能强大，适合大多数场景，强烈推荐使用 InnoDB。</td></tr><tr><td><strong>MyISAM</strong></td><td>不支持事务和外键，支持表级锁不支持行锁，读性能高，写性能较差。</td><td>以读操作为主的场景，如数据仓库、日志分析、静态内容存储等</td><td>不推荐使用</td></tr><tr><td><strong>MEMORY</strong></td><td>数据存储在内存中，读写速度非常快，但数据会丢失。</td><td>临时表、缓存数据、临时存储数据的场景。适用于需要快速存取的临时数据处理（例如会话存储）</td><td>直接上手 Redis 它不香吗</td></tr><tr><td><strong>ARCHIVE</strong></td><td>高压缩、适合存储大量只读数据。支持 INSERT 但不支持 UPDATE。</td><td>存档数据、历史数据存储场景，特别是数据量大且访问频率较低的情况</td><td>适合存储历史数据，例如三个月前或三年前的数据，常用于数据归档。</td></tr><tr><td><strong>BLACKHOLE</strong></td><td>不存储数据，所有插入操作都被丢弃，读取为空。</td><td>数据复制、测试用的空引擎，模拟写入操作而不存储数据</td><td>临时测试场景，也不推荐使用</td></tr></tbody></table><h4 id="4-2-1-InnoDB（默认）"><a href="#4-2-1-InnoDB（默认）" class="headerlink" title="4.2.1. InnoDB（默认）"></a>4.2.1. InnoDB（默认）</h4><p>在底层是使用 表明.ibd 进行存储，这是一个表空间文件，用于存储该表的表结构元数据（8.0 之前是 frm，8.0 之后是 sdi）、数据和索引，他们都是保存在页中，有一个变量 <code>innodb_file_per_table</code> 是来控制它的是不是每一个表名都对应一个表空间文件，默认是开启的<br><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-5.png"></p><h5 id="4-2-1-1-逻辑存储结构"><a href="#4-2-1-1-逻辑存储结构" class="headerlink" title="4.2.1.1. 逻辑存储结构"></a>4.2.1.1. 逻辑存储结构</h5><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-6.png"></p><h5 id="4-2-1-2-InnoDB-架构"><a href="#4-2-1-2-InnoDB-架构" class="headerlink" title="4.2.1.2. InnoDB 架构"></a>4.2.1.2. InnoDB 架构</h5><h5 id="4-2-1-3-内存架构"><a href="#4-2-1-3-内存架构" class="headerlink" title="4.2.1.3. 内存架构"></a>4.2.1.3. 内存架构</h5><h6 id="4-2-1-3-1-Buffer-Pool（缓冲池）"><a href="#4-2-1-3-1-Buffer-Pool（缓冲池）" class="headerlink" title="4.2.1.3.1. Buffer Pool（缓冲池）"></a>4.2.1.3.1. Buffer Pool（缓冲池）</h6><p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则先从磁盘中加载并缓存，然后进行操作），操作完成后，然后再以一定频率刷新到磁盘</p><ol><li>读<ol><li>先去 Buffer Pool 找数据页</li><li>如果没命中，去磁盘读取这个页（16KB 一页</li><li>先把页放进 Buffer Pool（这样下次再读这个页就能命中）</li><li>再从 Buffer Pool 把刚读进来的页里的数据返回给客户端</li></ol></li><li>写<ol><li>先去 Buffer Pool 找数据页。</li><li>如果没命中，去磁盘读取这个页（16KB 一页）</li><li>先把页放进 Buffer Pool</li><li>在内存中修改数据页（页变成“脏页”）</li><li>事务提交后，不是立刻写回磁盘，而是由 后台刷新线程 在合适时机批量写回（减少随机写，合并成顺序写）</li><li>Redo Log 负责在崩溃时恢复脏页的修改，保证数据不丢</li></ol></li></ol><p>Buffer Pool 出现的原因是，磁盘 I&#x2F;O 速度远比内存慢（几百倍甚至上千倍），如果每次查询或更新都去磁盘读写，性能会非常差，因此把经常用的页放在内存里，让读写尽量走内存。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：<br>free page：空闲page，未被使用。<br>clean page：被使用page，数据没有被修改过。<br>dirtypage：脏页，被使用page，数据被修改过，但是还没刷盘，也中数据与磁盘的数据产生了不一致。</p><p>大小由innodb_buffer_pool_siz 控制</p><hr><h6 id="4-2-1-3-2-Change-Buffer（更改缓冲区）"><a href="#4-2-1-3-2-Change-Buffer（更改缓冲区）" class="headerlink" title="4.2.1.3.2. Change Buffer（更改缓冲区）"></a>4.2.1.3.2. Change Buffer（更改缓冲区）</h6><p>Change Buffer：更改缓冲区（针对于非唯一二级索引页，即除主键索引和唯一索引），在执行DML（数据增删改）语句时，如果这些数据Page没有在BufferPool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区ChangeBuffer中，在未来数据被读取时，再将数据合并恢复到BufferPool中，再将合并后的数据刷新到磁盘中。</p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘lO。</p><p>对于聚集索引，通常都是按照主键顺序插入的，但是你二级索引就不是了，就是随机的了<br><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-24.png"></p><hr><h6 id="4-2-1-3-3-Adaptive-Hash-Index（自适应哈希）"><a href="#4-2-1-3-3-Adaptive-Hash-Index（自适应哈希）" class="headerlink" title="4.2.1.3.3. Adaptive Hash Index（自适应哈希）"></a>4.2.1.3.3. Adaptive Hash Index（自适应哈希）</h6><p>AdaptiveHashIndex：自适应hash索引l，用于优化对BufferPool数据的查询。InnoDB存储引l擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引l，称之为自适应hash 索引。</p><p>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</p><p>daptive_hash_index 是自适应哈希的开关</p><p>因为哈希索引很快，如果没有哈希碰撞只需要一次检索就可以了，而 B+Tree 需要多次，所以如果可以的话还是哈希块，但是哈希不适合范围的查询</p><hr><h6 id="4-2-1-3-4-Log-Buffer"><a href="#4-2-1-3-4-Log-Buffer" class="headerlink" title="4.2.1.3.4. Log Buffer"></a>4.2.1.3.4. Log Buffer</h6><p>LogBuffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redolog、undolog），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘1&#x2F;0。</p><p>参数：<br>innodb_log_buffer_size：缓冲区大小<br>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机</p><hr><h5 id="4-2-1-4-磁盘结构"><a href="#4-2-1-4-磁盘结构" class="headerlink" title="4.2.1.4. 磁盘结构"></a>4.2.1.4. 磁盘结构</h5><h6 id="4-2-1-4-3-General-Tablespaces（通用表空间）"><a href="#4-2-1-4-3-General-Tablespaces（通用表空间）" class="headerlink" title="4.2.1.4.3. General Tablespaces（通用表空间）"></a>4.2.1.4.3. General Tablespaces（通用表空间）</h6><p>GeneralTablespaces：通用表空间，需要通过CREATETABLESPACE语法创建通用表空间，如果我们不去创建，那他就不会有，在创建表时，可以指定该表空间。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">CREATETABLESPACEXXXXADD<br>DATAFILE file<span class="hljs-emphasis">_name&#x27;</span><br><span class="hljs-emphasis">ENGINE engine_</span>name;<br></code></pre></td></tr></table></figure><p>xxxxxxxx tablespace ts_itheima</p><hr><h6 id="4-2-1-4-4-Undo-Tablespaces（撤销表空间）"><a href="#4-2-1-4-4-Undo-Tablespaces（撤销表空间）" class="headerlink" title="4.2.1.4.4. Undo Tablespaces（撤销表空间）"></a>4.2.1.4.4. Undo Tablespaces（撤销表空间）</h6><p>UndoTablespaces：撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（undo_001   undo_002   初始大小16M），用于存储undolog日志。</p><hr><h6 id="4-2-1-4-5-Temporary-Tablespaces（临时表）"><a href="#4-2-1-4-5-Temporary-Tablespaces（临时表）" class="headerlink" title="4.2.1.4.5. Temporary Tablespaces（临时表）"></a>4.2.1.4.5. Temporary Tablespaces（临时表）</h6><p>nnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><hr><h6 id="4-2-1-4-6-Doublewrite-Buffer-Files（双写缓冲区）"><a href="#4-2-1-4-6-Doublewrite-Buffer-Files（双写缓冲区）" class="headerlink" title="4.2.1.4.6. Doublewrite Buffer Files（双写缓冲区）"></a>4.2.1.4.6. Doublewrite Buffer Files（双写缓冲区）</h6><p>双写缓冲区，innoDB引擎将数据页从BufferPool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p>xx.dblwr<br><code>#ib_16384_0.dblwr</code><br><code>#ib_16384_1.dblwr</code></p><hr><h6 id="4-2-1-4-7-Redo-Log（重做日志）"><a href="#4-2-1-4-7-Redo-Log（重做日志）" class="headerlink" title="4.2.1.4.7. Redo Log（重做日志）"></a>4.2.1.4.7. Redo Log（重做日志）</h6><p>用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redologbuffer）以及重做日志文件（redolog），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p>它以循环方式写入重做日志文件，涉及两个文件：ib_logfile0   ib_logfile1</p><hr><h5 id="4-2-1-5-后台线程"><a href="#4-2-1-5-后台线程" class="headerlink" title="4.2.1.5. 后台线程"></a>4.2.1.5. 后台线程</h5><ol><li><p>Master Thread<br> 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo 页的回收 。</p></li><li><p>IO Thread<br> 在 InnoDB 存储引擎中大量使用了 AIO 来处理 IO 请求，这样可以极大地提高数据库的性能，而 IO Thread 主要负责这些 IO 请求的回调。</p></li></ol><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><ol start="3"><li><p>Purge Thread<br> 主要用于回收事务已经提交了的 undo log，在事务提交之后，undo log 可能不用了，就用它来回收。</p></li><li><p>Page Cleaner Thread<br> 协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p></li></ol><hr><h4 id="4-2-2-MyISAM"><a href="#4-2-2-MyISAM" class="headerlink" title="4.2.2. MyISAM"></a>4.2.2. MyISAM</h4><p>MyISAM在底层是使用表明.MYD（数据），表名.MYI（索引），表明.sdi（表结构） 用来存储</p><hr><h4 id="4-2-3-Memory"><a href="#4-2-3-Memory" class="headerlink" title="4.2.3. Memory"></a>4.2.3. Memory</h4><p>在底层使用 表民.sdi 用于存储表结构，因为其信息都在内存中进行存放</p><hr><h2 id="5-MySQL-索引"><a href="#5-MySQL-索引" class="headerlink" title="5. MySQL 索引"></a>5. MySQL 索引</h2><h3 id="5-1-索引概述"><a href="#5-1-索引概述" class="headerlink" title="5.1. 索引概述"></a>5.1. 索引概述</h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些<br>数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>其优点是：</p><ol><li>提高数据检索的效率，降低数据库的 I&#x2F;O 成本</li><li>通过索引列队数据进行排序，降低数据排序的成本，降低 CPU 的消耗</li></ol><p>其缺点是：</p><ol><li>索引列也需要占用空间</li><li>索引大大提高了查询效率，同时也降低了更新的效率</li></ol><hr><h3 id="5-2-常用索引结构"><a href="#5-2-常用索引结构" class="headerlink" title="5.2. 常用索引结构"></a>5.2. 常用索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree 索引</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash 索引</td><td>底层数据结构是用哈希表实现的,只有精确匹配索引列的查询才有效,不支持范围查询，查询效率高与 B+tree<br>通常只需要一次检索就可以了（通常是指不产生 hash 碰撞）</td></tr><tr><td>R-tree(空间索引)</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-text(全文索引l)</td><td>是一种通过建立倒排索引l,快速匹配文档的方式。类似于Lucene,Solr,ES，用的也很少</td></tr></tbody></table><h4 id="5-2-1-B-Tree-索引"><a href="#5-2-1-B-Tree-索引" class="headerlink" title="5.2.1. B+Tree 索引"></a>5.2.1. B+Tree 索引</h4><p>首先我们来看看二叉树是什么<br><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-7.png"></p><p>当顺序插入时，会形成一个链表，查询性能大大降低并且由于一个下面只有两个分支，在大数据量情况下，层级较深，检索速度慢</p><p>关于第一个问题，我们可以想到红黑树：<br><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-8.png"></p><p>但是红黑树本质上还是一个二叉树，所以第二个问题还是存在，然后我们又引入 B-Tree，其可以有多个 key，我们可以在这个网站中详细演示 B-Tree 的形成过程： <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a><br><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-9.png"></p><p>所以我们就引入了 B+Tree，我们可以在这个网站中演示 B+Tree： <a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a><br><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-10.png"></p><p>上面的部分只起到了索引的作用，而下面的叶子节点才真正的存储数据，并且他们还形成了一个链表，都能指向下一个</p><p>而我们 MySQL 对经典的 B+Tree 进行了一个优化，在原来的基础上增加了一个指向相邻子节点的链表指针，<br> <img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-11.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>一个页是 16K，既<code>16*1024=16384</code> 个字节，既<code>16*1024*8=131072</code> 位，InnoDB 的指针固定占用 6个字节的空间</li><li>所以我们就能算出上层页能有多少个主键，多少个指针，假设主键是 bigint，占用 8个字节，指针固定比主键多一个那我们就可以<code>8*n +(n+1)*6 = 16*1024</code>，所以我们就能算出来n 是 1170</li><li>InnoDB 主键 B+Tree 叶子节点是真正的行数据，没有另外一个地方再存数据，也就谈不上再保存一份的冗余</li><li>指针不是固定永远只指向一个页，例如左下角6、12那个页，如果一直放数据，放不下了，就会涉及到页分裂，<strong>申请一个新的叶子页</strong>（同一层级，大小也是 16K）把原来页的一部分记录（大约一半）<strong>移动</strong>到新的页中，更新上一层（第二层页）的指针，让它能同时指向<strong>原来的页</strong>和<strong>新页</strong></li></ol></blockquote><hr><h4 id="5-2-2-Hash-索引"><a href="#5-2-2-Hash-索引" class="headerlink" title="5.2.2. Hash 索引"></a>5.2.2. Hash 索引</h4><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-12.png"></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><hr><h3 id="5-3-索引存储形式"><a href="#5-3-索引存储形式" class="headerlink" title="5.3. 索引存储形式"></a>5.3. 索引存储形式</h3><p>在 <code>InnoDB</code> 存储引擎中，根据索引的存储形式，可以分为聚集索引和二级索引：</p><ol><li>&#x3D;&#x3D;聚集索引&#x3D;&#x3D;：<br> 1.一个表中<strong>只能有且必须有一个</strong>聚集索引。<ol><li>聚集索引将数据和索引存储在一起，索引结构的叶子节点直接保存行数据</li><li>聚集索引的选取规则：<ol><li>如果存在<strong>主键索引</strong>，主键索引即为聚集索引</li><li>如果没有主键索引，第一个<strong>唯一索引</strong>会作为聚集索引</li><li>如果既没有主键也没有唯一索引，<code>InnoDB</code> 会自动为表生成一个<strong>隐藏</strong>的 <code>rowid</code> 作为聚集索引</li></ol></li></ol></li><li>&#x3D;&#x3D;二级索引&#x3D;&#x3D;：<ol><li>一个表中可以存在多个二级索引</li><li>二级索引将数据和索引分开存储，索引结构的叶子节点存储的是对应主键的值。</li><li>在 <code>InnoDB</code> 存储引擎中，当你查询二级索引列的数据时，过程如下：<ol><li>查询会首先通过二级索引查找该列的值，并返回二级索引中的存储的主键值</li><li>得到主键值后，查询会使用主键值回到聚集索引中查找实际的数据行。</li></ol></li></ol></li></ol><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-15.png"></p><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-16.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里是一个指向主键的指针啊</li><li>这里的二级索引是一个单列的索引，如果是联合索引假如 name，age联合，那它的就是既存 name、age又存指向主键的指针：</li></ol></blockquote><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-19.png"></p><hr><h3 id="5-4-索引的分类"><a href="#5-4-索引的分类" class="headerlink" title="5.4. 索引的分类"></a>5.4. 索引的分类</h3><table><thead><tr><th><strong>索引类型</strong></th><th><strong>关键字</strong></th><th><strong>描述</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>主键索引</strong></td><td><code>PRIMARY KEY</code></td><td>每个表只能有一个主键索引，主键列不允许有 NULL 值。</td><td>用于唯一标识表中的每一行，通常是表的主键（例如，<code>id</code> 列）。</td></tr><tr><td><strong>唯一索引</strong></td><td><code>UNIQUE</code></td><td>保证索引列的值是唯一的，但可以有 NULL 值。</td><td>用于确保数据的唯一性，适用于需要保持唯一性的字段（如邮箱地址、用户名等）。</td></tr><tr><td><strong>普通索引</strong></td><td><code>INDEX</code> 或 <code>KEY</code></td><td>普通索引是最基本的索引类型，不保证值唯一。</td><td>用于提高查询速度，适用于不要求唯一性但需要快速查找的字段。</td></tr><tr><td><strong>全文索引</strong></td><td><code>FULLTEXT</code></td><td>用于全文搜索，通常在 <code>TEXT</code> 类型的列上使用，支持单词的查找。</td><td>用于执行全文搜索，如在文章或评论内容中查找关键词。（直接上手 ElasticSearch）</td></tr><tr><td><strong>复合索引（联合索引）</strong></td><td><code>INDEX</code> 或 <code>KEY</code></td><td>由多个列组成的索引。</td><td>当查询涉及多个字段时，可以使用复合索引来提高查询性能，避免多个单列索引的使用。</td></tr></tbody></table><blockquote><p>[!NOTE] 注意事项</p><ol><li>一列可以同时有多个不同类型的索引（例如普通索引 + 唯一索引 + 全文索引），但不能有多个相同类型的索引（如两个唯一索引）。</li></ol></blockquote><hr><h3 id="5-5-索引相关命令"><a href="#5-5-索引相关命令" class="headerlink" title="5.5. 索引相关命令"></a>5.5. 索引相关命令</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment"># 1. 添加索引</span><br><span class="hljs-comment"># 1.1. 主键索引</span><br>通过创建主键约束来自动生成主键索引。<br><br><span class="hljs-comment"># 1.2. 唯一索引</span><br>create unique index <span class="hljs-variable">&lt;index-name&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-variable">&lt;table-name&gt;</span> (<span class="hljs-variable">&lt;column-name&gt;</span>);<br><br><span class="hljs-comment"># 1.3. 普通索引</span><br>create index <span class="hljs-variable">&lt;index-name&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-variable">&lt;table-name&gt;</span> (<span class="hljs-variable">&lt;column-name&gt;</span>);<br><br><span class="hljs-comment"># 1.4. 全文索引</span><br>create fulltext index <span class="hljs-variable">&lt;index-name&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-variable">&lt;table-name&gt;</span> (<span class="hljs-variable">&lt;column-name&gt;</span>);<br><br><span class="hljs-comment"># 1.5. 复合索引（联合索引）</span><br>create index <span class="hljs-variable">&lt;index-name&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-variable">&lt;table-name&gt;</span> (<span class="hljs-variable">&lt;column1&gt;</span>, <span class="hljs-variable">&lt;column2&gt;</span>, ...);<br><br><br><span class="hljs-comment"># 2. 删除索引</span><br><span class="hljs-keyword">drop</span> index <span class="hljs-variable">&lt;index-name&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-variable">&lt;table-name&gt;</span>;<br><br><br><span class="hljs-comment"># 3. 查询索引</span><br>show index <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table-name&gt;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>&lt;index-name&gt;</code> 是为索引自定义的名称，主要用于后续的维护、查看和删除操作</li><li>唯一索引和唯一约束效果相同，只是语义上的差异：<ul><li><font color="#00b0f0">唯一索引</font>：<ul><li>更偏向结构设计的“规范性”</li></ul></li><li><font color="#00b0f0">唯一约束</font>：<ul><li>更偏向数据库“性能调优”的语义表达</li></ul></li></ul></li><li>在业务场景中，如果存在多个查询条件，考虑针对查询字段建立联合索引，而不是单列索引</li><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</li></ol></blockquote><hr><h3 id="5-6-索引使用原则"><a href="#5-6-索引使用原则" class="headerlink" title="5.6. 索引使用原则"></a>5.6. 索引使用原则</h3><h4 id="5-6-1-最左前缀法则"><a href="#5-6-1-最左前缀法则" class="headerlink" title="5.6.1. 最左前缀法则"></a>5.6.1. 最左前缀法则</h4><p>MySQL 中的<strong>最左前缀法则</strong>，是指在使用<strong>联合索引</strong>（即由多个列组成的索引）时，<strong>查询条件必须从索引的最左边列开始，才能有效利用索引</strong>，而且一旦中间某个条件列断了，后面的列就无法再用到该索引。</p><p>假设我们有一个联合索引是 user_name, age, city</p><p>能用全索引的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM t <span class="hljs-type">WHERE</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Tom&#x27;</span> <span class="hljs-type">AND</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-type">AND</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Beijing&#x27;</span>;<br></code></pre></td></tr></table></figure><p>部分匹配的时候，只要我们用到了最左边列，就还能使用索引，但是用不到全列：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> user_name = <span class="hljs-string">&#x27;Tom&#x27;</span> <span class="hljs-keyword">AND</span> age = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>但如果没有用最左边的，索引会直接失效，失效了哪肯定就是全文检索了：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> city = <span class="hljs-string">&#x27;Beijing&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果中间的缺失，哪就是中间断链，左边能用，右边不能用：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> user_name = <span class="hljs-string">&#x27;Tom&#x27;</span> <span class="hljs-keyword">AND</span> city = <span class="hljs-string">&#x27;Beijing&#x27;</span>;<br></code></pre></td></tr></table></figure><p>需要注意的是，范围条件会阶段后续的匹配，例如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> user_name = <span class="hljs-string">&#x27;Tom&#x27;</span> <span class="hljs-keyword">AND</span> age &gt; <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> city = <span class="hljs-string">&#x27;Beijing&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>age</code> 是范围匹配（<code>&gt;</code>），后面的 <code>city</code> 失效，只用到 <code>(user_name, age)</code> 索引部分</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>MySQL 在用联合索引的时候，不是看你 SQL 里条件的书写顺序，而是看能不能从联合索引的最左列开始连续匹配，例如下面的代码，优化器会自动调整匹配顺序，把 <code>(user_name → age → city)</code> 这段连续匹配上去</li></ol></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">age</span> = <span class="hljs-number">20</span> AND user_name = <span class="hljs-string">&#x27;Tom&#x27;</span> AND city = <span class="hljs-string">&#x27;Beijing&#x27;</span> AND status = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="5-6-2-索引失效原则"><a href="#5-6-2-索引失效原则" class="headerlink" title="5.6.2. 索引失效原则"></a>5.6.2. 索引失效原则</h4><p>除了上卖弄的联合索引的失效情况，还有以下几个情况：</p><p><font color="#92d050">1. 对索引列使用函数或者计算表达式</font><br>如果在索引列上用函数或计算表达式，索引失效，因为索引存的是原始值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">WHERE</span> DATE(create_time) = &#x27;<span class="hljs-number">2023</span>-<span class="hljs-number">08</span>-<span class="hljs-number">10</span>&#x27;  <br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 隐式类型转换</font><br>如果列和查询值类型不一致，导致隐式类型转换，索引可能失效。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">WHERE numeric_col</span> = <span class="hljs-string">&#x27;123abc&#x27;</span><br></code></pre></td></tr></table></figure><p>这个最常见的情况就是，字符串类型的列，你不加引号，索引将失效</p><p><font color="#92d050">3. 模糊查询</font><br>如果 仅仅是尾部模糊查询，不会导致索引失效，如果是头部模糊查询，索引将失效</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 不会导致索引失效</span><br>WHERE profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;软件%&#x27;</span>;<br><br><br><span class="hljs-comment">// 会导致索引失效</span><br>WHERE profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 使用 <code>OR</code> 连接多个条件且无覆盖索引</font><br>如果多个条件用 <code>OR</code> 连接，且这些条件有的使用缩影，有的没有使用索引，哪所有索引都不会被使用 </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">WHERE a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> OR b <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>要么对其建立索引，要么拆成 UNION</p><p><font color="#92d050">5. 数据分布影响</font><br>如果 MySQL 判断使用索引比全表扫描还慢，那它就不会使用索引</p><hr><h4 id="5-6-3-SQL-提示"><a href="#5-6-3-SQL-提示" class="headerlink" title="5.6.3. SQL 提示"></a>5.6.3. SQL 提示</h4><p>当有多个索引的时候，SQL 会自动挑选出一个索引进行执行，那你就可以使用 SQL 提示，加入一些人为的提示来达到优化的目的</p><p><font color="#92d050">1. 使用某个索引</font></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">use <span class="hljs-keyword">index</span>(idx_user_pro) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 不要用某个索引</font></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">ignore <span class="hljs-keyword">index</span>(idx_user_pro) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 强制使用某个索引</font></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">force <span class="hljs-keyword">index</span>(idx_user_pro) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="5-6-4-覆盖索引"><a href="#5-6-4-覆盖索引" class="headerlink" title="5.6.4. 覆盖索引"></a>5.6.4. 覆盖索引</h4><p><strong>覆盖索引</strong>（Covering Index）是指查询的所有字段都包含在索引里，MySQL 不需要回表（访问数据行）就能直接从索引里拿到所有需要的数据</p><p>例如这个，本身就是一个典型的覆盖索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Arm&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-17.png"></p><p>这个也是一个典型的覆盖索引</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> id, <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Arm&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-18.png"></p><p>需要注意的是，假设 name，age 都有一个索引，都是二级索引，那就不是覆盖索引，因为 SQL 会挑一个索引去执行对吧，例如使用 name 的索引去执行，然后回表查询去查到 age 再返回给我们，这就不是覆盖查询，因为回表了</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, age <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Arm&#x27;</span> <span class="hljs-keyword">and</span> age = <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><p>所以我们不推荐 select * 的一个原因就是它很容易就不是覆盖索引了</p><p>如果我们去使用联合索引，就能很简单的产生覆盖索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, age <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Arm&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-20.png"></p><p>那如果你还查了一个 city，而city不与 name、age 产生联合，那就还需要回表查询出 city</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, age, city <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Arm&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="5-6-5-前缀索引"><a href="#5-6-5-前缀索引" class="headerlink" title="5.6.5. 前缀索引"></a>5.6.5. 前缀索引</h4><p>当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘lO，影响查<br>询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>这个其实很简单，与我们创建索引的方式语法基本上一直，只需要在 column-name 后面加上(n)，表示 n 个字符</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> <span class="hljs-keyword">index</span> &lt;<span class="hljs-keyword">index</span>-<span class="hljs-type">name</span>&gt; <span class="hljs-keyword">on</span> &lt;<span class="hljs-keyword">table</span>-<span class="hljs-type">name</span>&gt; (&lt;<span class="hljs-keyword">column</span>-<span class="hljs-type">name</span>(n)&gt;);<br></code></pre></td></tr></table></figure><p>至于前缀的长度，可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">select</span> count(<span class="hljs-keyword">distinct</span> email) / count<span class="hljs-comment">(*) from tb_user ;</span><br><span class="hljs-comment">select count(distinct substring(email,1,5)) / count(*)</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-21.png"></p><p>需要注意的是，你回表查询之后，不是立即返回，因为你这里只是校验了一个前缀，你还需要进去校验全部的，除此之外你肯定还需要继续找找前缀相同的不是直接返回奥</p><hr><h2 id="6-MySQL-事务"><a href="#6-MySQL-事务" class="headerlink" title="6. MySQL 事务"></a>6. MySQL 事务</h2><h3 id="6-1-事务的特性（ACID）"><a href="#6-1-事务的特性（ACID）" class="headerlink" title="6.1. 事务的特性（ACID）"></a>6.1. 事务的特性（ACID）</h3><ol><li>&#x3D;&#x3D;原子性&#x3D;&#x3D;<ol><li>事务中的所有操作要么全部执行成功，要么全部执行失败回滚。</li><li>对于数据库来说，事务是一个不可分割的最小操作单元。</li></ol></li><li>&#x3D;&#x3D;一致性&#x3D;&#x3D;：<ol><li>事务执行前后，数据库都处于一致的状态。</li><li>也就是说，事务执行前后，数据库的状态应该满足所有的定义约束、触发器、级联操作等。</li></ol></li><li>&#x3D;&#x3D;隔离性&#x3D;&#x3D;：<ol><li>事务的执行不会受到其他事务的干扰。</li><li>多个事务并发执行时，一个事务的中间状态对其他事务是不可见的。</li></ol></li><li>&#x3D;&#x3D;持久性&#x3D;&#x3D;：<ol><li>事务一旦提交，其结果就永久保存到数据库中。</li><li>即使系统发生故障，事务的结果也不会丢失。</li></ol></li></ol><hr><h3 id="6-2-事务提交的方式"><a href="#6-2-事务提交的方式" class="headerlink" title="6.2. 事务提交的方式"></a>6.2. 事务提交的方式</h3><p>一句话：我不管你是<strong>一次操作批量插入</strong>还是<strong>多次操作大量插入</strong>，只要涉及到多个数据，就给我开启手动提交：</p><ol><li>&#x3D;&#x3D;自动提交&#x3D;&#x3D;：<ol><li>在 MySQL 中，默认情况下，每条 SQL 语句都被视为一个独立的事务，并在执行后立即自动提交。</li><li>这意味着每条 SQL 语句执行后，数据库会自动处理提交，无需显式使用 <code>COMMIT</code> 命令。</li><li>在这种模式下，操作是独立的，无法将多个操作作为一个整体事务进行管理，需要一条一条的执行。</li></ol></li><li>&#x3D;&#x3D;手动提交&#x3D;&#x3D;：<ol><li>关闭自动提交，改为手动管理事务，使我们能够自行决定何时提交一组操作。如果其中任一操作失败，事务将回滚至初始状态，确保数据一致性。</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>事务只对 DML 语句有影响，原因是：<ul><li>DQL 不受事务影响，因为 DQL 不会对数据库进行改变</li><li>DDL 和 DCL 不受事务一下，纯粹是事务管不到他们</li></ul></li></ol></blockquote><hr><h3 id="6-3-自动提交事务"><a href="#6-3-自动提交事务" class="headerlink" title="6.3. 自动提交事务"></a>6.3. 自动提交事务</h3><p>在 MySQL 中，默认启用了自动提交模式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. 查询是否开启自动提交（1开，0关）</span><br><span class="hljs-attribute">select</span> @<span class="hljs-variable">@autocommit</span>;<br><br><br><span class="hljs-comment"># 2. 开启自动提交</span><br><span class="hljs-attribute">set</span> autocommit = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h3 id="6-4-手动提交事务"><a href="#6-4-手动提交事务" class="headerlink" title="6.4. 手动提交事务"></a>6.4. 手动提交事务</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 1. 查询是否开启自动提交（1开，0关）</span><br><span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@autocommit;<br><br><br><span class="hljs-comment"># 2. 关闭自动提交</span><br><span class="hljs-built_in">set</span> autocommit = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-comment"># 3. 开始事务</span><br><span class="hljs-built_in">start</span> transaction; / <span class="hljs-keyword">begin</span>;<br><br><br><span class="hljs-comment"># 4. 执行 SQL 操作</span><br>UPDATE accounts <span class="hljs-built_in">SET</span> balance = balance - <span class="hljs-number">100</span> <span class="hljs-built_in">WHERE</span> id = <span class="hljs-number">1</span>;<br>UPDATE accounts <span class="hljs-built_in">SET</span> balance = balance + <span class="hljs-number">100</span> <span class="hljs-built_in">WHERE</span> id = <span class="hljs-number">2</span>;<br><br><br><span class="hljs-comment"># 5. 提交事务 / 回滚事务</span><br><span class="hljs-comment"># 5.1. 提交事务（将事务中的所有操作永久保存到数据库中）</span><br>commit;<br><br><span class="hljs-comment"># 5.2. 回滚事务（撤销事务中的所有操作）</span><br>rollback;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 SQL 中，<code>commit</code> 和 <code>rollback</code> 是互斥的，一个事务只能执行其中一个</li><li>我们通常是使用编程语言来控制的，成功了就提交，不成功就回滚</li></ol></blockquote><hr><h3 id="6-5-事务隔离性问题"><a href="#6-5-事务隔离性问题" class="headerlink" title="6.5. 事务隔离性问题"></a>6.5. 事务隔离性问题</h3><p>以下这三种现象看似与 <strong>查询操作</strong> 相关，但它们本质上是由于 <strong>事务隔离性</strong> 不足，导致<strong>并发事务</strong>之间在数据访问和修改时发生 <strong>冲突</strong>。</p><ol><li>&#x3D;&#x3D;脏读&#x3D;&#x3D;：<ol><li>假设事务 A 正在对某些数据进行增删改操作，但尚未提交，事务 B 需要读取这些数据。如果事务 B 正好读取了事务 A 正在修改的数据，则事务 B 读取到的数据就是 “脏” 的。</li><li>这些数据被称为“脏数据”，因为事务 A 可能在后续回滚或再次修改，导致事务 B 读取到的数据实际上未被最终提交，可能会导致错误的业务逻辑，尤其是事务 B 后续依赖这些数据时。</li></ol></li><li>&#x3D;&#x3D;不可重复读&#x3D;&#x3D;：<ol><li>发生在 <strong>同一事务</strong> 内 <strong>多次查询</strong> <strong>同一行数据</strong> 时。</li><li>例如，事务 B 初次查询某行数据，然后事务 A 对这行数据进行了<strong>修改</strong>或<strong>删除</strong>。如果事务 B 再次查询同一行数据，会发现读取到的数据发生了变化，导致 <strong>不可重复读</strong>。</li></ol></li><li>&#x3D;&#x3D;幻读&#x3D;&#x3D;：<ol><li>发生在 <strong>同一事务</strong> 内 <strong>多次查询</strong> <strong>结果集</strong> 时</li><li>例如，事务 B 查询某个条件范围的数据（如 <code>age &gt; 50</code>），然后事务 A 向该范围内<strong>插入</strong>数据。事务 B 再次查询时，发现数据集发生了变化，查询结果与第一次查询不同，这就是 <strong>幻读</strong>。（只有插入才会导致幻读，更新、删除不会导致幻读）</li></ol></li></ol><hr><h3 id="6-6-事务隔离级别"><a href="#6-6-事务隔离级别" class="headerlink" title="6.6. 事务隔离级别"></a>6.6. 事务隔离级别</h3><h4 id="6-6-1-READ-UNCOMMITTED（读未提交）"><a href="#6-6-1-READ-UNCOMMITTED（读未提交）" class="headerlink" title="6.6.1. READ UNCOMMITTED（读未提交）"></a>6.6.1. READ UNCOMMITTED（读未提交）</h4><ol><li>&#x3D;&#x3D;执行 查询 语句&#x3D;&#x3D;：<ol><li>查询语句本身不会对数据加锁，因此其他事务仍然可以对相关数据执行增删改查操作，可能导致 <strong>不可重复读</strong> 和 <strong>幻读</strong></li><li>如果查询的数据正好被其他事务修改，则会发生发生 <strong>脏读</strong></li><li>简单来说：查询有 脏读、不可重复读、幻读 问题</li></ol></li><li>&#x3D;&#x3D;执行 增、删、改 语句&#x3D;&#x3D;：<ol><li>对操作的数据，会加上行级排他锁（X锁），防止其他事务对这些数据进行增删改操作（可以读取数据，具体是进行脏读还是读取已提交的版本，取决于它的事务的隔离级别）。X锁会一直保持，直到事务结束（提交或回滚）时释放</li><li>如果数据正在被其他事务操作且已加锁，会产生锁冲突，当前事务会等待对方事务结束（提交或回滚），然后再加锁并执行操作。</li><li>如果数据未被锁定，则可以直接进行增删改操作。</li></ol></li><li>&#x3D;&#x3D;使用场景&#x3D;&#x3D;:<ol><li>数据一致性要求不高，性能最高</li></ol></li></ol><hr><h4 id="6-6-2-READ-COMMITTED（读已提交，默认）"><a href="#6-6-2-READ-COMMITTED（读已提交，默认）" class="headerlink" title="6.6.2. READ COMMITTED（读已提交，默认）"></a>6.6.2. READ COMMITTED（读已提交，默认）</h4><ol><li>&#x3D;&#x3D;执行 查询 语句&#x3D;&#x3D;：<ol><li>查询语句<strong>不会对数据加锁</strong>，因此其他事务仍然可以对相关数据执行增删改查操作，可能导致 <strong>不可重复读</strong> 和 <strong>幻读</strong></li><li>查询语句<strong>仅读取其他事务已提交的最新数据版本</strong>（<strong>避免脏读</strong>，不会等待提交，直接找最近提交的）。</li><li>简单来说：查询有 不可重复读、幻读 问题</li></ol></li><li>&#x3D;&#x3D;执行 增、删、改 语句&#x3D;&#x3D;：<ol><li>对操作的数据，会加上<strong>行级排他锁（X锁）</strong>，防止其他事务对这些数据进行增删改操作（可以读取数据，具体是进行脏读还是读取已提交的版本，取决于它的事务的隔离级别）。X锁会一直保持，直到事务结束（提交或回滚）时释放</li><li>如果数据正在被其他事务操作且已加锁，会产生锁冲突，当前事务会等待对方事务结束（提交或回滚），然后再加锁并执行操作。</li><li>如果数据未被锁定，则可以直接进行增删改操作。</li></ol></li><li>&#x3D;&#x3D;使用场景&#x3D;&#x3D;：<ol><li>数据库的默认隔离级别，日常用这个就行，不可重复读、幻读这些都是小问题，谁还真一次事务执行多次查询啊</li></ol></li></ol><hr><h4 id="6-6-3-REPEATABLE-READ（可重复读）"><a href="#6-6-3-REPEATABLE-READ（可重复读）" class="headerlink" title="6.6.3. REPEATABLE READ（可重复读）"></a>6.6.3. REPEATABLE READ（可重复读）</h4><ol><li>&#x3D;&#x3D;执行 查询 语句&#x3D;&#x3D;：<ol><li>查询语句虽然<strong>不会对数据加锁</strong>，因此其他事务仍然可以对相关数据执行增删改查操作</li><li><strong>但会</strong>在首次查询时创建一个 <strong>一致性数据快照</strong>。后续的查询将基于此快照进行，确保数据一致性。<ol><li>如果其他事务对数据进行删除或修改操作，这些变动不会影响快照的内容。因此，后续查询结果与第一次查询一致，避免了<strong>不可重复读</strong>。</li><li>然而，<strong>幻读</strong>仍然可能发生。若其他事务插入了符合查询条件的新记录（例如，<code>age &gt; 25</code>），那么在事务 A 下一次查询时，新增的记录会出现在查询结果中，导致两次查询结果不同，从而产生<strong>幻读</strong>。</li></ol></li><li>查询语句<strong>仅读取其他事务已提交的最新数据版本</strong>（<strong>避免脏读</strong>，不会等待提交，直接找最近提交的）。</li><li>简单来说：查询有 幻读 问题</li></ol></li><li>&#x3D;&#x3D;执行 增、删、该 语句&#x3D;&#x3D;：<ol><li>对操作数据加<strong>行级排他锁（X锁）</strong>，并对<strong>数据范围</strong>的 <strong>“间隙” 加锁</strong>（例如，当 <code>WHERE id &gt; 100</code> 时，锁定 <code>id &gt; 100</code> 的区间，注意是区间，不是行数据），以阻止其他事务插入或修改该区间的数据（可以读取数据，具体是进行脏读还是读取已提交的版本，取决于它的事务的隔离级别）</li><li>如果数据正在被其他事务操作且已加锁，会产生锁冲突，当前事务会等待对方事务结束（提交或回滚），然后再加锁并执行操作。</li><li>如果数据未被锁定，则可以直接进行增删改操作。</li></ol></li><li>&#x3D;&#x3D;使用场景&#x3D;&#x3D;：<ol><li>一致性较高</li></ol></li></ol><hr><h4 id="6-6-4-SERIALIZABLE（可串行化）"><a href="#6-6-4-SERIALIZABLE（可串行化）" class="headerlink" title="6.6.4. SERIALIZABLE（可串行化）"></a>6.6.4. SERIALIZABLE（可串行化）</h4><ol><li>&#x3D;&#x3D;执行 查询 语句&#x3D;&#x3D;：<ol><li>查询语句会对数据加 共享锁（S锁），并对<strong>数据范围</strong>的 <strong>“间隙” 加锁</strong>（例如，当 <code>WHERE id &gt; 100</code> 时，锁定 <code>id &gt; 100</code> 的区间，注意是区间，不是行数据）以阻止其他事务插入或修改该区间的数据（可以读取数据，具体是进行脏读还是读取已提交的版本，取决于它的事务的隔离级别）</li><li>若使用索引查询，锁定匹配的索引范围和间隙</li><li>若全表扫描，可能直接加表级锁</li><li>简单来说：查询无 脏读、不可重复度、幻读 问题</li></ol></li><li>&#x3D;&#x3D;执行 增、删、该 语句&#x3D;&#x3D;：<ol><li>对操作数据加<strong>行级排他锁（X锁）</strong>，并对<strong>数据范围</strong>的 <strong>“间隙” 加锁</strong>（例如，当 <code>WHERE id &gt; 100</code> 时，锁定 <code>id &gt; 100</code> 的区间，注意是区间，不是行数据），以阻止其他事务插入或修改该区间的数据（可以读取数据，具体是进行脏读还是读取已提交的版本，取决于它的事务的隔离级别）</li><li>如果数据正在被其他事务操作且已加锁，会产生锁冲突，当前事务会等待对方事务结束（提交或回滚），然后再加锁并执行操作。</li><li>如果数据未被锁定，则可以直接进行增删改操作。</li></ol></li><li>&#x3D;&#x3D;使用场景&#x3D;&#x3D;：<ol><li>一致性最高，性能最低</li></ol></li></ol><hr><h3 id="6-7-事务的原理"><a href="#6-7-事务的原理" class="headerlink" title="6.7. 事务的原理"></a>6.7. 事务的原理</h3><p><img src="/2025/08/10/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL/%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL-26.png"></p><h2 id="7-MVCC"><a href="#7-MVCC" class="headerlink" title="7. MVCC"></a>7. MVCC</h2>]]></content>
    
    
    <categories>
      
      <category>数据管理</category>
      
      <category>关系型数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
