<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>源码：String 源码解析</title>
    <link href="/2025/12/25/%E6%BA%90%E7%A0%81%EF%BC%9AString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/12/25/%E6%BA%90%E7%A0%81%EF%BC%9AString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><hr><h2 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/25/%E6%BA%90%E7%A0%81%EF%BC%9AString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/25/源码：String源码解析/</a></p></li><li><p>代码洪荒（面试宝典）</p></li></ol><hr><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="根据-byte-类型的数组创建-String-对象"><a href="#根据-byte-类型的数组创建-String-对象" class="headerlink" title="根据 byte 类型的数组创建 String 对象"></a>根据 byte 类型的数组创建 String 对象</h4><h4 id="根据-int-类型的数组创建-String-对象"><a href="#根据-int-类型的数组创建-String-对象" class="headerlink" title="根据 int 类型的数组创建 String 对象"></a>根据 int 类型的数组创建 String 对象</h4><h4 id="根据-char-类型的数组创建-String-对象"><a href="#根据-char-类型的数组创建-String-对象" class="headerlink" title="根据 char 类型的数组创建 String 对象"></a>根据 char 类型的数组创建 String 对象</h4><h4 id="根据-String-对象创建-String-对象"><a href="#根据-String-对象创建-String-对象" class="headerlink" title="根据 String 对象创建 String 对象"></a>根据 String 对象创建 String 对象</h4><h4 id="根据字面量创建-String-对象"><a href="#根据字面量创建-String-对象" class="headerlink" title="根据字面量创建 String 对象"></a>根据字面量创建 String 对象</h4><h4 id="根据字符串拼接语法糖创建-String-对象"><a href="#根据字符串拼接语法糖创建-String-对象" class="headerlink" title="根据字符串拼接语法糖创建 String 对象"></a>根据字符串拼接语法糖创建 String 对象</h4>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嘎嘎乱杀</title>
    <link href="/2025/12/19/%E5%98%8E%E5%98%8E%E4%B9%B1%E6%9D%80/"/>
    <url>/2025/12/19/%E5%98%8E%E5%98%8E%E4%B9%B1%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<h2 id="1-🐉"><a href="#1-🐉" class="headerlink" title="1. 🐉"></a>1. 🐉</h2><ol><li>需要加引号的，在全文第一次出现时加引号（例如：”AAAA“），后面再出现不用加引号（例如：AAAA）</li></ol><hr><h2 id="2-🍎"><a href="#2-🍎" class="headerlink" title="2. 🍎"></a>2. 🍎</h2><ol><li><hr><ol><li>JKJK 概述</li></ol></li><li><hr><ol><li>JKJK 优缺点</li></ol></li><li><hr><ol><li>JKJK 相关算法</li><li>JKJK 相关命令</li><li>JKJK 相关分类</li><li>JKJK 相关策略</li><li>JKJK 相关事件</li><li>JKJK 相关状态</li><li>JKJK 相关流程</li><li>JKJK 相关条件</li><li>JKJK 相关原因</li><li>JKJK 相关特性</li></ol></li><li><hr><ol><li>JKJK 架构体系</li><li>JKJK 组成部分</li><li>JKJK 基础体系</li><li>JKJK 体系结构</li></ol></li><li><hr><ol><li>JKJK 前置基础</li></ol></li><li><hr><ol><li>JKJK 过期策略<ol><li>缓存淘汰策略</li><li>数据保留策略</li></ol></li></ol></li><li><hr><ol><li>JKJK 底层实现</li><li>JKJK 底层原理</li></ol></li><li><hr><ol><li>JKJK 问题爆破</li></ol></li><li><hr><ol><li>JKJK 解决方案</li></ol></li><li><hr><ol><li>JKJK 数据类型</li></ol></li><li><hr><ol><li>JKJK 生命周期</li></ol></li><li><hr><ol><li>JKJK 空间大小<ol><li>内存空间大小</li><li>硬盘空间大小</li></ol></li></ol></li><li><hr><ol><li>JKJK 事务机制</li></ol></li><li><hr><ol><li>JKJK 视频讲解</li></ol></li><li><hr><ol><li>JKJK 持久化机制</li></ol></li><li><hr><ol><li>JKJK IO 工作模式</li></ol></li><li><hr><ol><li>JKJK 多线程并发安全性</li></ol></li><li><hr><ol><li>JKJK 适用场景与应用场景</li></ol></li><li><p>AAAA 实现思路</p></li><li><p>AAAA 编写方式</p></li><li><p>AAAA 实现方式</p></li><li><p>AAAA 处理方式</p></li><li><p>AAAA 使用方式</p></li></ol><hr><h2 id="3-🍌（名词）"><a href="#3-🍌（名词）" class="headerlink" title="3. 🍌（名词）"></a>3. 🍌（名词）</h2><h3 id="3-1-类"><a href="#3-1-类" class="headerlink" title="3.1. 类"></a>3.1. 类</h3><ol><li>—– 👈 —–<ol><li>创建</li></ol></li><li>—– 👆 —–<ol><li>—– 分类 —–<ol><li><hr><ol><li>具体类<ol><li>简单类<ol><li>BO 简单类</li><li>VO 简单类</li><li>DTO 简单类</li><li>Entity 简单类</li></ol></li><li>普通类</li><li>包装类<ol><li>Byte 包装类</li><li>Short 包装类</li><li>Integer 包装类<ol><li>Long 包装类</li></ol></li><li>Float 包装类</li><li>Double 包装类</li><li>Character 包装类</li><li>Boolean 包装类</li></ol></li><li>内部类</li></ol></li><li>枚举类</li><li>纪录类</li><li>抽象类</li></ol></li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 无 —–<ol><li>及其子类、加载器子系统</li></ol></li><li>—– 的 —–<ol><li>类对象、元数据区、全限定名、加载过程、编译过程、编译错误</li></ol></li></ol></li><li>—– 👇 —–（偏的没边、涉及 AAAA、无敌句子）<ol><li><hr><ol><li>基本数据类型的元素在自动装箱后的包装类实例</li></ol></li><li><hr><ol><li>基本数据类型的数据在自动装箱后的包装类实例</li></ol></li></ol></li></ol><hr><h3 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2. 方法"></a>3.2. 方法</h3><ol><li>—– 👈 —–<ol><li>调用、执行、要去执行</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>方法</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>实例方法<ol><li>抽象方法</li><li>实例具体方法</li><li>实例接口方法（普通）</li><li>实例接口方法（default）</li></ol></li><li>静态方法<ol><li>静态块</li><li>静态具体方法</li><li>静态接口方法（default）</li></ol></li><li>构造方法</li></ol></li><li><hr><ol><li>OrderController.createOrder（即静态方法）<ol><li>OrderController.createOrder(Thread t)</li><li>OrderController.createOrder(myThread)</li></ol></li><li>OrderController#createOrder（即实例方法）<ol><li>OrderController#createOrder(Thread t)</li><li>OrderController#createOrder(myThread)</li></ol></li></ol></li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 无 —–<ol><li>所属类、所属实例、执行完毕（正常退出、异常退出）、正常退出（发生异常、未发生异常）、异常退出</li></ol></li><li>—– 的 —–<ol><li>具体逻辑、返回结果</li></ol></li><li>—– 对应的 —–<ol><li>类、栈帧、异常处理器表</li></ol></li></ol></li></ol><hr><h3 id="3-3-属性"><a href="#3-3-属性" class="headerlink" title="3.3. 属性"></a>3.3. 属性</h3><ol><li>—– 👈 —–<ol><li>维护</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>属性</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>变量<ol><li>静态变量</li><li>实例变量</li><li>方法参数</li><li>局部变量</li></ol></li><li>常量<ol><li>静态常量</li><li>普通常量</li></ol></li></ol></li><li><hr><ol><li>OrderController-&gt;orderId（即实例变量、普通常量）</li><li>OrderController::MAX_ORDERS（即静态变量、静态常量）</li></ol></li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 动 —–<ol><li>记录</li></ol></li><li>—– 的 —–<ol><li>生命周期</li></ol></li></ol></li></ol><hr><h3 id="3-4-规范"><a href="#3-4-规范" class="headerlink" title="3.4. 规范"></a>3.4. 规范</h3><ol><li>—– 👈 —–<ol><li>采用</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>规范</li></ol></li></ol></li></ol><hr><h3 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5. 数组"></a>3.5. 数组</h3><ol><li>—– 👈 —–<ol><li>遍历、重写</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>数组</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>一维数组</li><li>二维数组</li><li>三维数组</li></ol></li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 无 —–<ol><li>位置、索引、为空、已满</li></ol></li><li>—– 的 —–<ol><li>长度、类型、基本存储单元</li></ol></li></ol></li></ol><hr><h3 id="3-6-对象"><a href="#3-6-对象" class="headerlink" title="3.6. 对象"></a>3.6. 对象</h3><ol><li>—– 👈 —–<ol><li>创建</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>对象</li></ol></li></ol></li></ol><hr><h3 id="3-7-策略"><a href="#3-7-策略" class="headerlink" title="3.7. 策略"></a>3.7. 策略</h3><ol><li>—– 👈 —–<ol><li>采用</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>策略</li></ol></li></ol></li></ol><hr><h3 id="3-8-算法"><a href="#3-8-算法" class="headerlink" title="3.8. 算法"></a>3.8. 算法</h3><ol><li>—– 👈 —–<ol><li>使用</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>算法</li></ol></li></ol></li></ol><hr><h3 id="3-9-异常"><a href="#3-9-异常" class="headerlink" title="3.9. 异常"></a>3.9. 异常</h3><ol><li>—– 👈 —–<ol><li>处理、抛出、声明抛出、向外抛出、捕获并处理</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>异常</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>错误</li><li>异常<ol><li>受检异常</li><li>非受检异常</li></ol></li></ol></li><li><hr><ol><li>原始异常</li></ol></li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 无 —–<ol><li>链、信息</li></ol></li></ol></li></ol><hr><h3 id="3-10-故障"><a href="#3-10-故障" class="headerlink" title="3.10. 故障"></a>3.10. 故障</h3><ol><li>—– 👆 —–<ol><li>—– 分类 —–<ol><li><hr><ol><li>服务故障</li><li>网络故障</li></ol></li></ol></li></ol></li></ol><hr><h3 id="3-11-线程"><a href="#3-11-线程" class="headerlink" title="3.11. 线程"></a>3.11. 线程</h3><ol><li>—– 👈 —–<ol><li>创建、运行、“暂停”</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>线程</li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 动 —–<ol><li>调用、执行、要去执行</li></ol></li><li>—– 无 —–<ol><li>共享、私有</li></ol></li><li>—– 对应的 —–<ol><li>程序计数器、虚拟机栈</li></ol></li></ol></li></ol><hr><h3 id="3-12-时间"><a href="#3-12-时间" class="headerlink" title="3.12. 时间"></a>3.12. 时间</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>时间</li></ol></li></ol></li><li>—– 👇 —–<ol><li><hr><ol><li>AAAA 被允许的最长时间，以 BBBB 为单位<ol><li>如果超时，AAAA</li><li>-1 表示无限等待</li></ol></li></ol></li><li><hr><ol><li>AAAA 被允许的最长时间为：BBBB<ol><li>如果超时，AAAA</li><li>-1 表示无限等待</li></ol></li></ol></li></ol></li></ol><hr><h3 id="3-13-阶段"><a href="#3-13-阶段" class="headerlink" title="3.13. 阶段"></a>3.13. 阶段</h3><ol><li>—– 👈 —–<ol><li>进行</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>阶段</li></ol></li></ol></li></ol><hr><h3 id="3-14-CPU"><a href="#3-14-CPU" class="headerlink" title="3.14. CPU"></a>3.14. CPU</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>CPU</li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 的 —–<ol><li>架构</li></ol></li><li>—– 对应的 —–<ol><li>机器码指令</li></ol></li></ol></li></ol><hr><h3 id="3-15-JVM"><a href="#3-15-JVM" class="headerlink" title="3.15. JVM"></a>3.15. JVM</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>JVM</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>HotSpot JVM</li></ol></li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 动 —–<ol><li>执行</li></ol></li><li>—– 无 —–<ol><li>规范、参数、字节码指令</li></ol></li></ol></li></ol><hr><h3 id="3-16-内部类"><a href="#3-16-内部类" class="headerlink" title="3.16. 内部类"></a>3.16. 内部类</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>内部类</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>实例内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li><li>Lambda 表达式</li></ol></li></ol></li></ol></li></ol><hr><h3 id="3-17-多线程"><a href="#3-17-多线程" class="headerlink" title="3.17. 多线程"></a>3.17. 多线程</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>多线程</li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 无 —–<ol><li>并发场景、并发安全</li></ol></li></ol></li><li>—– 👇 —–<ol><li><hr><ol><li>并发对 AAAA 进行 BBBBB</li></ol></li><li><hr><ol><li>并发场景下的安全问题</li></ol></li></ol></li></ol><hr><h3 id="3-18-修饰符"><a href="#3-18-修饰符" class="headerlink" title="3.18. 修饰符"></a>3.18. 修饰符</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>修饰符</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>访问修饰符</li><li>非访问修饰符<ol><li>类级别的非访问修饰符</li><li>属性级别的非访问修饰符</li><li>方法级别的非访问修饰符</li></ol></li></ol></li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 动 —–<ol><li>修饰</li></ol></li></ol></li></ol><hr><h3 id="3-19-语法糖"><a href="#3-19-语法糖" class="headerlink" title="3.19. 语法糖"></a>3.19. 语法糖</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>语法糖</li></ol></li></ol></li><li>—– 👇 —–<ol><li><hr><ol><li>在类的编译阶段中被编译器自动转换为 AAAA</li></ol></li><li><hr><ol><li>在类的编译阶段中会被编译器自动转换为以下的逻辑：AAAA</li></ol></li></ol></li></ol><hr><h3 id="3-20-垃圾回收"><a href="#3-20-垃圾回收" class="headerlink" title="3.20. 垃圾回收"></a>3.20. 垃圾回收</h3><ol><li>—– 👈 —–<ol><li>执行</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>垃圾回收</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>新生代回收</li><li>老年代回收</li><li>整堆回收</li><li>混合回收</li></ol></li></ol></li></ol></li></ol><hr><h3 id="3-21-内存空间"><a href="#3-21-内存空间" class="headerlink" title="3.21. 内存空间"></a>3.21. 内存空间</h3><ol><li>—– 👈 —–<ol><li>占用、分配、管理、节省、申请、动态扩展、动态缩减</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>内存空间</li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 无 —–<ol><li>为空、已满、不足、碎片</li></ol></li><li>—– 的 —–<ol><li>边界、使用率、空闲比例</li></ol></li></ol></li><li>—– 👇 —–<ol><li><hr><ol><li>AAAA 被允许的最大的内存空间，以 BBBB 为单位<ol><li>如果超出，AAAA</li><li>-1 表示无限大小</li></ol></li></ol></li><li><hr><ol><li>AAAA 被允许的最大的内存空间为：BBBB<ol><li>如果超出，AAAA</li><li>-1 表示无限大小</li></ol></li></ol></li><li><hr><ol><li>AAAA 被允许的最小的内存空间，以 BBBB 为单位<ol><li>如果低于，AAAA</li><li>-1 表示无限大小</li></ol></li></ol></li><li><hr><ol><li>AAAA 被允许的最小的内存空间为：BBBB<ol><li>如果低于，AAAA</li><li>-1 表示无限大小</li></ol></li></ol></li></ol></li></ol><hr><h3 id="3-22-Java-版本"><a href="#3-22-Java-版本" class="headerlink" title="3.22. Java 版本"></a>3.22. Java 版本</h3><ol><li>—– 👉 —–<ol><li>—– 无 —–<ol><li>不再支持、弃用</li></ol></li></ol></li><li>—– 👇 —–<ol><li><hr><ol><li>HotSpot JVM 在 Java8</li></ol></li><li><hr><ol><li>HotSpot JVM 在 Java8 之前</li></ol></li><li><hr><ol><li>HotSpot JVM 在 Java8 及以后</li></ol></li><li><hr><ol><li>HotSpot JVM 在 Java8 及以后、在 Java 10 之前</li></ol></li></ol></li></ol><hr><h3 id="3-23-Java-程序"><a href="#3-23-Java-程序" class="headerlink" title="3.23. Java 程序"></a>3.23. Java 程序</h3><ol><li>—– 👈 —–<ol><li>运行、有序关闭、强制关闭</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>Java 程序</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>Java 服务</li></ol></li><li><hr><ol><li>Java 服务组</li></ol></li></ol></li></ol></li></ol><hr><h3 id="3-24-Java-代码"><a href="#3-24-Java-代码" class="headerlink" title="3.24. Java 代码"></a>3.24. Java 代码</h3><ol><li>—– 👈 —–<ol><li>编写、执行</li></ol></li><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>Java 代码</li></ol></li></ol></li></ol><hr><h3 id="3-25-Java-泛型"><a href="#3-25-Java-泛型" class="headerlink" title="3.25. Java 泛型"></a>3.25. Java 泛型</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>Java 泛型</li></ol></li></ol></li><li>—– 👉 —–<ol><li>—– 动 —–<ol><li>擦除</li></ol></li></ol></li></ol><hr><h3 id="3-26-IO-工作模式"><a href="#3-26-IO-工作模式" class="headerlink" title="3.26. IO 工作模式"></a>3.26. IO 工作模式</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>IO 工作模式</li></ol></li></ol></li><li>—– 👇 —–<ol><li><hr><ol><li>采取了 AAAA 设计模式，采用了 BBBB 规范，基于 CCCC 框架，底层使用 DDDD 库，最终实现了 EEEE IO 工作模式的 FFFF。所以 GGGG 客户端自带线程池和连接池</li></ol></li><li><hr><ol><li>采取了 AAAA 设计模式，采用了 BBBB 规范，基于 CCCC 库，底层使用 DDDD 库，最终实现了 EEEE IO 工作模式的 FFFF。所以 GGGG 客户端自带线程池和连接池</li></ol></li></ol></li></ol><hr><h3 id="3-27-try-catch-finally-语句"><a href="#3-27-try-catch-finally-语句" class="headerlink" title="3.27. try-catch-finally 语句"></a>3.27. try-catch-finally 语句</h3><ol><li>—– 👆 —–<ol><li>—– 原名 —–<ol><li>try-catch-finally 语句</li></ol></li><li>—– 分类 —–<ol><li><hr><ol><li>try 块</li><li>catch 块</li><li>finally 块</li></ol></li></ol></li></ol></li></ol><hr><h2 id="4-🌈"><a href="#4-🌈" class="headerlink" title="4. 🌈"></a>4. 🌈</h2><h3 id="4-1-Why-Solve-What-Doing-Purpose"><a href="#4-1-Why-Solve-What-Doing-Purpose" class="headerlink" title="4.1. Why-Solve-What-Doing-Purpose"></a>4.1. Why-Solve-What-Doing-Purpose</h3><h4 id="4-1-1-Why"><a href="#4-1-1-Why" class="headerlink" title="4.1.1. Why"></a>4.1.1. Why</h4><ol><li>你可能疑惑：AAAA</li><li>那么问题来了：AAAA</li><li>想象这样一些问题：AAAA</li><li>因为它有这样一些 “坑”：AAAA</li><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：AAAA</li></ol><hr><h4 id="4-1-2-Solve"><a href="#4-1-2-Solve" class="headerlink" title="4.1.2. Solve"></a>4.1.2. Solve</h4><ol><li>为了解决这一问题，AAAA</li><li>解决 AAAA 的方法主要包括：BBBB</li><li>AAAA 被引入的真正原因是：BBBB</li></ol><hr><h4 id="4-1-3-Purpose"><a href="#4-1-3-Purpose" class="headerlink" title="4.1.3. Purpose"></a>4.1.3. Purpose</h4><ol><li>从而达到 AAAA 的目的</li></ol><hr><h3 id="4-2-Math"><a href="#4-2-Math" class="headerlink" title="4.2. Math"></a>4.2. Math</h3><ol><li>$\frac{a}{b}$</li><li>$O(k)$</li><li>$\log_2 (2^{32}) &#x3D; 32$</li></ol><hr><h3 id="5-口号"><a href="#5-口号" class="headerlink" title="5. 口号"></a>5. 口号</h3><ol><li>AAAA 的口号是：”AAAA“</li></ol><hr><h3 id="5-1-分类"><a href="#5-1-分类" class="headerlink" title="5.1. 分类"></a>5.1. 分类</h3><ol><li>以 AAAA 分类：BBBB</li></ol><hr><h3 id="5-2-我们知道"><a href="#5-2-我们知道" class="headerlink" title="5.2. 我们知道"></a>5.2. 我们知道</h3><ol><li>我们知道 “AAAA”</li><li>我们知道：AAAA</li></ol><hr><h3 id="5-3-被称之为"><a href="#5-3-被称之为" class="headerlink" title="5.3. 被称之为"></a>5.3. 被称之为</h3><ol><li>被称之为 “AAAA”</li></ol><hr><h3 id="5-4-需要注意的是"><a href="#5-4-需要注意的是" class="headerlink" title="5.4. 需要注意的是"></a>5.4. 需要注意的是</h3><ol><li>需要注意的是：AAAA</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>一般使用注意事项代替（优先），也可以在括号内、长篇大论、这两种情况：<ol><li>情况一<ol><li>AAAA</li><li>AAAA<ol><li>需要注意的是：<ol><li>AAAA</li><li>AAAA</li></ol></li></ol></li></ol></li><li>情况二<ol><li>AAAA</li><li>AAAA</li><li>需要注意的是：<ol><li>AAAA</li><li>AAAA</li></ol></li></ol></li><li>需要注意的是：<ol><li>如果是这两种情况，但是内容只有一行，直接写在括号内</li><li>如果是这两种情况，一般也不需要这样写，我们直接在内容中写也可以</li></ol></li></ol></li></ol></blockquote><hr><h3 id="5-5-Java-有一个规定"><a href="#5-5-Java-有一个规定" class="headerlink" title="5.5. Java 有一个规定"></a>5.5. Java 有一个规定</h3><ol><li>Java 有一个规定：AAAA</li></ol><hr><h3 id="5-6-我们需要分别讨论"><a href="#5-6-我们需要分别讨论" class="headerlink" title="5.6. 我们需要分别讨论"></a>5.6. 我们需要分别讨论</h3><ol><li>AAAA 有所不同，我们需要分别讨论</li></ol><hr><h3 id="5-7-Java-语言的设计团队"><a href="#5-7-Java-语言的设计团队" class="headerlink" title="5.7. Java 语言的设计团队"></a>5.7. Java 语言的设计团队</h3><ol><li>Java 语言的设计团队</li></ol><hr><h3 id="5-8-也就是说、简单来说、我的意思是、简单理解为"><a href="#5-8-也就是说、简单来说、我的意思是、简单理解为" class="headerlink" title="5.8. 也就是说、简单来说、我的意思是、简单理解为"></a>5.8. 也就是说、简单来说、我的意思是、简单理解为</h3><ol><li>也就是说：AAAA</li><li>简单来说：AAAA</li><li>我的意思是：AAAA</li><li>简单理解为：AAAA</li></ol><hr><h3 id="5-9-在某时前，当某时、在某时后、在某某中、在过程中"><a href="#5-9-在某时前，当某时、在某时后、在某某中、在过程中" class="headerlink" title="5.9. 在某时前，当某时、在某时后、在某某中、在过程中"></a>5.9. 在某时前，当某时、在某时后、在某某中、在过程中</h3><ol><li>在 AAAA 之前，BBBB</li><li>当 AAAA 时，BBBB</li><li>在 AAAA 之后，BBBB</li><li>在 AAAA 中，BBBB</li><li>在 AAAA 的过程中，BBBB</li></ol><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工具：HexoMD路径修复</title>
    <link href="/2025/12/18/%E5%B7%A5%E5%85%B7%EF%BC%9AHexoMD%E8%B7%AF%E5%BE%84%E4%BF%AE%E5%A4%8D/"/>
    <url>/2025/12/18/%E5%B7%A5%E5%85%B7%EF%BC%9AHexoMD%E8%B7%AF%E5%BE%84%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Py-代码"><a href="#1-Py-代码" class="headerlink" title="1. Py 代码"></a>1. Py 代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> filedialog, messagebox, scrolledtext<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HexoPathFixerFinal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-variable language_">self</span>.root = root<br>        <span class="hljs-variable language_">self</span>.root.title(<span class="hljs-string">&quot;Hexo MD 路径修复&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.root.geometry(<span class="hljs-string">&quot;700x550&quot;</span>)<br><br>        <span class="hljs-comment"># --- 第一部分：目录选择 ---</span><br>        tk.Label(root, text=<span class="hljs-string">&quot;1. 选择 MD 文件所在目录:&quot;</span>, font=(<span class="hljs-string">&#x27;Arial&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;bold&#x27;</span>)).pack(pady=(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>))<br>        <span class="hljs-variable language_">self</span>.target_entry = tk.Entry(root, width=<span class="hljs-number">80</span>)<br>        <span class="hljs-variable language_">self</span>.target_entry.pack(pady=<span class="hljs-number">5</span>, padx=<span class="hljs-number">20</span>)<br>        tk.Button(root, text=<span class="hljs-string">&quot;浏览&quot;</span>, command=<span class="hljs-variable language_">self</span>.select_target).pack()<br><br>        tk.Label(root, text=<span class="hljs-string">&quot;2. 选择备份存放位置:&quot;</span>, font=(<span class="hljs-string">&#x27;Arial&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;bold&#x27;</span>)).pack(pady=(<span class="hljs-number">15</span>, <span class="hljs-number">0</span>))<br>        <span class="hljs-variable language_">self</span>.backup_entry = tk.Entry(root, width=<span class="hljs-number">80</span>)<br>        <span class="hljs-variable language_">self</span>.backup_entry.pack(pady=<span class="hljs-number">5</span>, padx=<span class="hljs-number">20</span>)<br>        tk.Button(root, text=<span class="hljs-string">&quot;浏览&quot;</span>, command=<span class="hljs-variable language_">self</span>.select_backup).pack()<br><br>        <span class="hljs-comment"># --- 第二部分：执行日志 ---</span><br>        tk.Label(root, text=<span class="hljs-string">&quot;任务执行日志:&quot;</span>, font=(<span class="hljs-string">&#x27;Arial&#x27;</span>, <span class="hljs-number">9</span>)).pack(pady=(<span class="hljs-number">15</span>, <span class="hljs-number">0</span>))<br>        <span class="hljs-variable language_">self</span>.log_area = scrolledtext.ScrolledText(root, height=<span class="hljs-number">12</span>, width=<span class="hljs-number">85</span>, state=<span class="hljs-string">&#x27;disabled&#x27;</span>, bg=<span class="hljs-string">&#x27;#f8f9fa&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.log_area.pack(pady=<span class="hljs-number">5</span>, padx=<span class="hljs-number">20</span>)<br><br>        <span class="hljs-comment"># --- 第三部分：执行按钮 ---</span><br>        <span class="hljs-variable language_">self</span>.run_btn = tk.Button(root, text=<span class="hljs-string">&quot;一键执行 (备份并修复)&quot;</span>, <br>                                 command=<span class="hljs-variable language_">self</span>.execute_task, <br>                                 bg=<span class="hljs-string">&#x27;#27ae60&#x27;</span>, fg=<span class="hljs-string">&#x27;white&#x27;</span>, font=(<span class="hljs-string">&#x27;Arial&#x27;</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&#x27;bold&#x27;</span>),<br>                                 height=<span class="hljs-number">2</span>, width=<span class="hljs-number">35</span>)<br>        <span class="hljs-variable language_">self</span>.run_btn.pack(pady=<span class="hljs-number">20</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, message</span>):<br>        <span class="hljs-variable language_">self</span>.log_area.configure(state=<span class="hljs-string">&#x27;normal&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.log_area.insert(tk.END, <span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;datetime.now().strftime(<span class="hljs-string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] <span class="hljs-subst">&#123;message&#125;</span>\n&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.log_area.see(tk.END)<br>        <span class="hljs-variable language_">self</span>.log_area.configure(state=<span class="hljs-string">&#x27;disabled&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.root.update_idletasks() <span class="hljs-comment"># 实时刷新 UI</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_target</span>(<span class="hljs-params">self</span>):<br>        path = filedialog.askdirectory()<br>        <span class="hljs-keyword">if</span> path:<br>            <span class="hljs-variable language_">self</span>.target_entry.delete(<span class="hljs-number">0</span>, tk.END)<br>            <span class="hljs-variable language_">self</span>.target_entry.insert(<span class="hljs-number">0</span>, path)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_backup</span>(<span class="hljs-params">self</span>):<br>        path = filedialog.askdirectory()<br>        <span class="hljs-keyword">if</span> path:<br>            <span class="hljs-variable language_">self</span>.backup_entry.delete(<span class="hljs-number">0</span>, tk.END)<br>            <span class="hljs-variable language_">self</span>.backup_entry.insert(<span class="hljs-number">0</span>, path)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_task</span>(<span class="hljs-params">self</span>):<br>        src = <span class="hljs-variable language_">self</span>.target_entry.get()<br>        dst_root = <span class="hljs-variable language_">self</span>.backup_entry.get()<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> src <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> dst_root:<br>            messagebox.showwarning(<span class="hljs-string">&quot;提示&quot;</span>, <span class="hljs-string">&quot;请先完整选择路径！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># --- 阶段 1：备份任务 ---</span><br>        <span class="hljs-comment"># 命名格式：backup_2025-12-17T22-02</span><br>        timestamp = datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%dT%H-%M&quot;</span>)<br>        backup_name = <span class="hljs-string">f&quot;backup_<span class="hljs-subst">&#123;timestamp&#125;</span>&quot;</span><br>        backup_path = os.path.join(dst_root, backup_name)<br>        <br>        <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;正在启动备份任务，目标文件夹: <span class="hljs-subst">&#123;backup_name&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># IO 工作模式：同步阻塞 IO</span><br>            <span class="hljs-comment"># 线程状态：在拷贝大量文件时，线程处于 RUNNING 状态中的阻塞</span><br>            shutil.copytree(src, backup_path)<br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">&quot;备份任务执行成功（正常退出）。&quot;</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># 捕获受检异常 (OSError/IOError) 或 Error (如磁盘满)</span><br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;备份执行失败 (异常退出): <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span>)<br>            messagebox.showerror(<span class="hljs-string">&quot;错误&quot;</span>, <span class="hljs-string">&quot;备份阶段异常，修复任务已终止。&quot;</span>)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># --- 阶段 2：修复任务 ---</span><br>        <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">&quot;正在对 Java 服务组内的 MD 文件进行路径扫描...&quot;</span>)<br>        s_count, f_count = <span class="hljs-variable language_">self</span>.repair_logic(src)<br><br>        <span class="hljs-comment"># --- 阶段 3：汇总汇报 ---</span><br>        <span class="hljs-keyword">if</span> f_count == <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;任务执行成功：共处理 <span class="hljs-subst">&#123;s_count&#125;</span> 个文件。&quot;</span>)<br>            messagebox.showinfo(<span class="hljs-string">&quot;成功&quot;</span>, <span class="hljs-string">f&quot;任务执行成功 (正常退出)！\n\n备份目录：<span class="hljs-subst">&#123;backup_name&#125;</span>\n修复文件：<span class="hljs-subst">&#123;s_count&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;任务执行完毕 (异常退出)：成功 <span class="hljs-subst">&#123;s_count&#125;</span>，失败 <span class="hljs-subst">&#123;f_count&#125;</span>&quot;</span>)<br>            messagebox.showwarning(<span class="hljs-string">&quot;任务完成但有错误&quot;</span>, <span class="hljs-string">f&quot;部分文件处理失败，请检查日志。&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repair_logic</span>(<span class="hljs-params">self, directory</span>):<br>        success_count = <span class="hljs-number">0</span><br>        fail_count = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 精准正则：保留 ! 标识，处理文件名中的括号</span><br>        pattern = <span class="hljs-string">r&#x27;(?P&lt;prefix&gt;!?\[.*?\])\(source/_posts/.*?/(?P&lt;filename&gt;.+)\)&#x27;</span><br>        <br>        <span class="hljs-comment"># 扫描顺序：无序 (Random)</span><br>        <span class="hljs-keyword">for</span> root, _, files <span class="hljs-keyword">in</span> os.walk(directory):<br>            <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>                <span class="hljs-keyword">if</span> file.endswith(<span class="hljs-string">&#x27;.md&#x27;</span>):<br>                    file_path = os.path.join(root, file)<br>                    <span class="hljs-keyword">try</span>:<br>                        <span class="hljs-comment"># 使用 utf-8-sig 处理可能存在的 BOM 头</span><br>                        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                            content = f.read()<br>                        <br>                        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;source/_posts/&quot;</span> <span class="hljs-keyword">in</span> content:<br>                            new_content = re.sub(pattern, <span class="hljs-string">r&#x27;\g&lt;prefix&gt;(\g&lt;filename&gt;)&#x27;</span>, content)<br>                            <span class="hljs-keyword">if</span> new_content != content:<br>                                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                                    f.write(new_content)<br>                                <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;已修复: <span class="hljs-subst">&#123;file&#125;</span>&quot;</span>)<br>                                success_count += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">except</span> (IOError, OSError) <span class="hljs-keyword">as</span> e:<br>                        <span class="hljs-comment"># 属于受检异常 (Checked Exception)</span><br>                        <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;受检异常: 无法读写文件 <span class="hljs-subst">&#123;file&#125;</span>，原因: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>                        fail_count += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                        <span class="hljs-comment"># 属于非受检异常 (Unchecked Exception)</span><br>                        <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;非受检异常: 处理文件 <span class="hljs-subst">&#123;file&#125;</span> 时崩溃，原因: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>                        fail_count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> success_count, fail_count<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app_root = tk.Tk()<br>    HexoPathFixerFinal(app_root)<br>    app_root.mainloop()<br></code></pre></td></tr></table></figure><hr><h2 id="2-打包成-exe-文件"><a href="#2-打包成-exe-文件" class="headerlink" title="2. 打包成 exe 文件"></a>2. 打包成 exe 文件</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 1. 安装打包工具</span><br>pip install pyinstaller<br><br><br><span class="hljs-comment"># 2. 打包成 exe 文件</span><br>pyinstaller <span class="hljs-operator">-</span>-onefile <span class="hljs-operator">-</span>-windowed <span class="hljs-operator">-</span>-icon<span class="hljs-operator">=</span><span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\I</span>CO<span class="hljs-char escape_">\H</span>exo MD 路径修复.ico&quot;</span> <span class="hljs-operator">-</span>-distpath <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合&quot;</span> <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\H</span>exo MD 路径修复.py&quot;</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">1. --onefile</span><br><span class="hljs-string">1. 打包为单个 .exe 文件。</span><br><span class="hljs-string">2. --windowed</span><br><span class="hljs-string">1. 确保 GUI 程序无控制台窗口</span><br><span class="hljs-string">3. --distpath &quot;</span>D:\文件集合\<span class="hljs-string">&quot;  &quot;</span>D:\文件集合\Hexo MD 路径修复.py<span class="hljs-string">&quot;</span><br><span class="hljs-string">1. D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\ </span>是输出位置</span><br><span class="hljs-string">2. D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\H</span>exo MD 路径修复.py 是输入位置</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Hexo MD 路径修复</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工具：Obsidian 图片排序与重命名</title>
    <link href="/2025/12/16/%E5%B7%A5%E5%85%B7%EF%BC%9AObsidian%E5%9B%BE%E7%89%87%E6%8E%92%E5%BA%8F%E4%B8%8E%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    <url>/2025/12/16/%E5%B7%A5%E5%85%B7%EF%BC%9AObsidian%E5%9B%BE%E7%89%87%E6%8E%92%E5%BA%8F%E4%B8%8E%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Py-代码"><a href="#1-Py-代码" class="headerlink" title="1. Py 代码"></a>1. Py 代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> filedialog, messagebox, ttk<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> zipfile<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> unquote<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernRenamerApp</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-variable language_">self</span>.root = root<br>        <span class="hljs-variable language_">self</span>.root.title(<span class="hljs-string">&quot;Obsidian 图片排序与重命名&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.root.geometry(<span class="hljs-string">&quot;780x750&quot;</span>)<br>        <br>        <span class="hljs-comment"># --- 现代 UI 配色与字体配置 ---</span><br>        <span class="hljs-variable language_">self</span>.colors = &#123;<br>            <span class="hljs-string">&quot;bg&quot;</span>: <span class="hljs-string">&quot;#f0f2f5&quot;</span>,          <span class="hljs-comment"># 整体背景灰</span><br>            <span class="hljs-string">&quot;card_bg&quot;</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,     <span class="hljs-comment"># 卡片背景白</span><br>            <span class="hljs-string">&quot;primary&quot;</span>: <span class="hljs-string">&quot;#1890ff&quot;</span>,     <span class="hljs-comment"># 主色调蓝</span><br>            <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-string">&quot;#52c41a&quot;</span>,     <span class="hljs-comment"># 成功色绿</span><br>            <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;#333333&quot;</span>,        <span class="hljs-comment">#由于文字</span><br>            <span class="hljs-string">&quot;gray_text&quot;</span>: <span class="hljs-string">&quot;#888888&quot;</span>    <span class="hljs-comment"># 辅助文字</span><br>        &#125;<br>        <span class="hljs-variable language_">self</span>.root.configure(bg=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;bg&quot;</span>])<br>        <br>        <span class="hljs-comment"># 配置全局样式</span><br>        <span class="hljs-variable language_">self</span>.setup_styles()<br><br>        <span class="hljs-comment"># --- 变量初始化 ---</span><br>        <span class="hljs-variable language_">self</span>.md_path = tk.StringVar()<br>        <span class="hljs-variable language_">self</span>.attachment_dir = tk.StringVar()<br>        <span class="hljs-variable language_">self</span>.enable_backup_var = tk.BooleanVar(value=<span class="hljs-literal">True</span>) <br>        <span class="hljs-variable language_">self</span>.backup_path_var = tk.StringVar()<br>        <span class="hljs-variable language_">self</span>.ext_var = tk.StringVar(value=<span class="hljs-string">&quot;png&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.delete_unused_var = tk.BooleanVar(value=<span class="hljs-literal">False</span>)<br><br>        <span class="hljs-comment"># --- 构建界面 ---</span><br>        <span class="hljs-variable language_">self</span>.create_widgets()<br>        <span class="hljs-variable language_">self</span>.toggle_backup_state()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_styles</span>(<span class="hljs-params">self</span>):<br>        style = ttk.Style()<br>        style.theme_use(<span class="hljs-string">&#x27;clam&#x27;</span>)  <span class="hljs-comment"># 使用 clam 作为基础来自定义</span><br><br>        <span class="hljs-comment"># 自定义 Frame 背景（用于卡片效果）</span><br>        style.configure(<span class="hljs-string">&quot;Card.TLabelframe&quot;</span>, background=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;card_bg&quot;</span>], relief=<span class="hljs-string">&quot;flat&quot;</span>, borderwidth=<span class="hljs-number">0</span>)<br>        style.configure(<span class="hljs-string">&quot;Card.TLabelframe.Label&quot;</span>, background=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;card_bg&quot;</span>], foreground=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;primary&quot;</span>], font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&quot;bold&quot;</span>))<br>        style.configure(<span class="hljs-string">&quot;Card.TFrame&quot;</span>, background=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;card_bg&quot;</span>])<br>        <br>        <span class="hljs-comment"># 普通按钮</span><br>        style.configure(<span class="hljs-string">&quot;TButton&quot;</span>, padding=<span class="hljs-number">6</span>, relief=<span class="hljs-string">&quot;flat&quot;</span>, background=<span class="hljs-string">&quot;#e6e6e6&quot;</span>, foreground=<span class="hljs-string">&quot;#333&quot;</span>)<br>        style.<span class="hljs-built_in">map</span>(<span class="hljs-string">&quot;TButton&quot;</span>, background=[(<span class="hljs-string">&quot;active&quot;</span>, <span class="hljs-string">&quot;#d9d9d9&quot;</span>)])<br><br>        <span class="hljs-comment"># 强调按钮 (Action Button)</span><br>        style.configure(<span class="hljs-string">&quot;Accent.TButton&quot;</span>, font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;bold&quot;</span>), background=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;primary&quot;</span>], foreground=<span class="hljs-string">&quot;white&quot;</span>, borderwidth=<span class="hljs-number">0</span>)<br>        style.<span class="hljs-built_in">map</span>(<span class="hljs-string">&quot;Accent.TButton&quot;</span>, background=[(<span class="hljs-string">&quot;active&quot;</span>, <span class="hljs-string">&quot;#40a9ff&quot;</span>)]) <span class="hljs-comment"># 悬停变亮</span><br><br>        <span class="hljs-comment"># 勾选框和标签</span><br>        style.configure(<span class="hljs-string">&quot;TCheckbutton&quot;</span>, background=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;card_bg&quot;</span>], font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>, <span class="hljs-number">10</span>))<br>        style.configure(<span class="hljs-string">&quot;TLabel&quot;</span>, background=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;card_bg&quot;</span>], font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>, <span class="hljs-number">10</span>), foreground=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;text&quot;</span>])<br>        style.configure(<span class="hljs-string">&quot;Gray.TLabel&quot;</span>, background=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;card_bg&quot;</span>], font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>, <span class="hljs-number">9</span>), foreground=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;gray_text&quot;</span>])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_widgets</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 主容器 (带内边距)</span><br>        main_container = tk.Frame(<span class="hljs-variable language_">self</span>.root, bg=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;bg&quot;</span>])<br>        main_container.pack(fill=<span class="hljs-string">&quot;both&quot;</span>, expand=<span class="hljs-literal">True</span>, padx=<span class="hljs-number">20</span>, pady=<span class="hljs-number">20</span>)<br><br>        <span class="hljs-comment"># === 卡片 1：资源选择 ===</span><br>        <span class="hljs-variable language_">self</span>.create_card(main_container, <span class="hljs-string">&quot;1. 资源选择&quot;</span>, <span class="hljs-variable language_">self</span>.build_resource_section)<br><br>        <span class="hljs-comment"># === 卡片 2：备份设置 ===</span><br>        <span class="hljs-variable language_">self</span>.create_card(main_container, <span class="hljs-string">&quot;2. 安全备份&quot;</span>, <span class="hljs-variable language_">self</span>.build_backup_section)<br><br>        <span class="hljs-comment"># === 卡片 3：规则与执行 ===</span><br>        <span class="hljs-variable language_">self</span>.create_card(main_container, <span class="hljs-string">&quot;3. 执行配置&quot;</span>, <span class="hljs-variable language_">self</span>.build_action_section)<br><br>        <span class="hljs-comment"># === 日志区域 (不带卡片标题，显得更像控制台) ===</span><br>        log_frame = tk.Frame(main_container, bg=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;bg&quot;</span>])<br>        log_frame.pack(fill=<span class="hljs-string">&quot;both&quot;</span>, expand=<span class="hljs-literal">True</span>, pady=(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>))<br>        <br>        tk.Label(log_frame, text=<span class="hljs-string">&quot;运行日志&quot;</span>, bg=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;bg&quot;</span>], fg=<span class="hljs-variable language_">self</span>.colors[<span class="hljs-string">&quot;gray_text&quot;</span>], font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>, <span class="hljs-number">9</span>)).pack(anchor=<span class="hljs-string">&quot;w&quot;</span>, pady=(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>))<br>        <br>        <span class="hljs-variable language_">self</span>.log_text = tk.Text(log_frame, height=<span class="hljs-number">10</span>, font=(<span class="hljs-string">&quot;Consolas&quot;</span>, <span class="hljs-number">10</span>), relief=<span class="hljs-string">&quot;flat&quot;</span>, padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">10</span>, borderwidth=<span class="hljs-number">0</span>)<br>        <span class="hljs-variable language_">self</span>.log_text.pack(fill=<span class="hljs-string">&quot;both&quot;</span>, expand=<span class="hljs-literal">True</span>)<br>        <br>        <span class="hljs-comment"># 给日志加个简单的边框效果</span><br>        <span class="hljs-variable language_">self</span>.log_text.config(highlightbackground=<span class="hljs-string">&quot;#d9d9d9&quot;</span>, highlightthickness=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_card</span>(<span class="hljs-params">self, parent, title, build_func</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;辅助函数：快速创建白色卡片风格的区域&quot;&quot;&quot;</span><br>        card = ttk.LabelFrame(parent, text=<span class="hljs-string">f&quot; <span class="hljs-subst">&#123;title&#125;</span> &quot;</span>, style=<span class="hljs-string">&quot;Card.TLabelframe&quot;</span>, padding=<span class="hljs-number">15</span>)<br>        card.pack(fill=<span class="hljs-string">&quot;x&quot;</span>, pady=(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>))<br>        build_func(card)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build_resource_section</span>(<span class="hljs-params">self, parent</span>):<br>        <span class="hljs-comment"># 使用 Grid 布局让输入框对其</span><br>        parent.columnconfigure(<span class="hljs-number">1</span>, weight=<span class="hljs-number">1</span>) <span class="hljs-comment"># 让中间列自动拉伸</span><br><br>        ttk.Label(parent, text=<span class="hljs-string">&quot;MD 文件:&quot;</span>).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>, sticky=<span class="hljs-string">&quot;w&quot;</span>, pady=<span class="hljs-number">5</span>)<br>        ttk.Entry(parent, textvariable=<span class="hljs-variable language_">self</span>.md_path).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>, sticky=<span class="hljs-string">&quot;ew&quot;</span>, padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">5</span>)<br>        ttk.Button(parent, text=<span class="hljs-string">&quot;📂 浏览&quot;</span>, command=<span class="hljs-variable language_">self</span>.select_md, width=<span class="hljs-number">8</span>).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">2</span>, pady=<span class="hljs-number">5</span>)<br><br>        ttk.Label(parent, text=<span class="hljs-string">&quot;附件文件夹:&quot;</span>).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>, sticky=<span class="hljs-string">&quot;w&quot;</span>, pady=<span class="hljs-number">5</span>)<br>        ttk.Entry(parent, textvariable=<span class="hljs-variable language_">self</span>.attachment_dir).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>, sticky=<span class="hljs-string">&quot;ew&quot;</span>, padx=<span class="hljs-number">10</span>, pady=<span class="hljs-number">5</span>)<br>        ttk.Button(parent, text=<span class="hljs-string">&quot;📂 浏览&quot;</span>, command=<span class="hljs-variable language_">self</span>.select_dir, width=<span class="hljs-number">8</span>).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">2</span>, pady=<span class="hljs-number">5</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build_backup_section</span>(<span class="hljs-params">self, parent</span>):<br>        parent.columnconfigure(<span class="hljs-number">1</span>, weight=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 第一行：开关</span><br>        ttk.Checkbutton(parent, text=<span class="hljs-string">&quot;启用自动备份 (强烈推荐)&quot;</span>, variable=<span class="hljs-variable language_">self</span>.enable_backup_var, <br>                        command=<span class="hljs-variable language_">self</span>.toggle_backup_state).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>, columnspan=<span class="hljs-number">3</span>, sticky=<span class="hljs-string">&quot;w&quot;</span>)<br>        <br>        <span class="hljs-comment"># 第二行：路径选择</span><br>        ttk.Label(parent, text=<span class="hljs-string">&quot;备份保存位置:&quot;</span>).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>, sticky=<span class="hljs-string">&quot;w&quot;</span>, pady=(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br>        <span class="hljs-variable language_">self</span>.entry_backup = ttk.Entry(parent, textvariable=<span class="hljs-variable language_">self</span>.backup_path_var)<br>        <span class="hljs-variable language_">self</span>.entry_backup.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>, sticky=<span class="hljs-string">&quot;ew&quot;</span>, padx=<span class="hljs-number">10</span>, pady=(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br>        <span class="hljs-variable language_">self</span>.btn_backup = ttk.Button(parent, text=<span class="hljs-string">&quot;📂 选择&quot;</span>, command=<span class="hljs-variable language_">self</span>.select_backup_dir, width=<span class="hljs-number">8</span>)<br>        <span class="hljs-variable language_">self</span>.btn_backup.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">2</span>, pady=(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br><br>        <span class="hljs-comment"># 提示文字</span><br>        ttk.Label(parent, text=<span class="hljs-string">&quot;命名格式: 笔记名_backup_YYYY-MM-DDTHH-mm.zip&quot;</span>, style=<span class="hljs-string">&quot;Gray.TLabel&quot;</span>).grid(row=<span class="hljs-number">2</span>, column=<span class="hljs-number">1</span>, sticky=<span class="hljs-string">&quot;w&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build_action_section</span>(<span class="hljs-params">self, parent</span>):<br>        <span class="hljs-comment"># 选项行</span><br>        opt_frame = ttk.Frame(parent, style=<span class="hljs-string">&quot;Card.TFrame&quot;</span>)<br>        opt_frame.pack(fill=<span class="hljs-string">&quot;x&quot;</span>, pady=(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>))<br>        <br>        ttk.Label(opt_frame, text=<span class="hljs-string">&quot;处理图片后缀:&quot;</span>).pack(side=<span class="hljs-string">&quot;left&quot;</span>)<br>        ttk.Combobox(opt_frame, textvariable=<span class="hljs-variable language_">self</span>.ext_var, values=[<span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-string">&quot;jpeg&quot;</span>], width=<span class="hljs-number">8</span>, state=<span class="hljs-string">&quot;readonly&quot;</span>).pack(side=<span class="hljs-string">&quot;left&quot;</span>, padx=<span class="hljs-number">10</span>)<br>        <br>        ttk.Separator(opt_frame, orient=<span class="hljs-string">&quot;vertical&quot;</span>).pack(side=<span class="hljs-string">&quot;left&quot;</span>, fill=<span class="hljs-string">&quot;y&quot;</span>, padx=<span class="hljs-number">15</span>)<br>        <br>        ttk.Checkbutton(opt_frame, text=<span class="hljs-string">&quot;删除未引用的冗余图片 (慎用)&quot;</span>, variable=<span class="hljs-variable language_">self</span>.delete_unused_var).pack(side=<span class="hljs-string">&quot;left&quot;</span>)<br><br>        <span class="hljs-comment"># 大按钮</span><br>        <span class="hljs-variable language_">self</span>.run_btn = ttk.Button(parent, text=<span class="hljs-string">&quot;🚀 立即备份并处理&quot;</span>, style=<span class="hljs-string">&quot;Accent.TButton&quot;</span>, command=<span class="hljs-variable language_">self</span>.start_process)<br>        <span class="hljs-variable language_">self</span>.run_btn.pack(fill=<span class="hljs-string">&quot;x&quot;</span>, ipady=<span class="hljs-number">5</span>) <span class="hljs-comment"># ipady 增加按钮高度</span><br><br>    <span class="hljs-comment"># --- 逻辑功能保持不变 (V4.3的核心逻辑) ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-variable language_">self</span>.log_text.insert(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;datetime.now().strftime(<span class="hljs-string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] <span class="hljs-subst">&#123;msg&#125;</span>\n&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.log_text.see(<span class="hljs-string">&quot;end&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toggle_backup_state</span>(<span class="hljs-params">self</span>):<br>        state = <span class="hljs-string">&quot;normal&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.enable_backup_var.get() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;disabled&quot;</span><br>        <span class="hljs-variable language_">self</span>.entry_backup.config(state=state)<br>        <span class="hljs-variable language_">self</span>.btn_backup.config(state=state)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_md</span>(<span class="hljs-params">self</span>):<br>        f = filedialog.askopenfilename(filetypes=[(<span class="hljs-string">&quot;Markdown&quot;</span>, <span class="hljs-string">&quot;*.md&quot;</span>)])<br>        <span class="hljs-keyword">if</span> f: <span class="hljs-variable language_">self</span>.md_path.<span class="hljs-built_in">set</span>(f)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_dir</span>(<span class="hljs-params">self</span>):<br>        d = filedialog.askdirectory()<br>        <span class="hljs-keyword">if</span> d: <span class="hljs-variable language_">self</span>.attachment_dir.<span class="hljs-built_in">set</span>(d)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_backup_dir</span>(<span class="hljs-params">self</span>):<br>        d = filedialog.askdirectory()<br>        <span class="hljs-keyword">if</span> d: <span class="hljs-variable language_">self</span>.backup_path_var.<span class="hljs-built_in">set</span>(d)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_process</span>(<span class="hljs-params">self</span>):<br>        md_file = <span class="hljs-variable language_">self</span>.md_path.get()<br>        att_dir = <span class="hljs-variable language_">self</span>.attachment_dir.get()<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> md_file <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> att_dir:<br>            <span class="hljs-keyword">return</span> messagebox.showwarning(<span class="hljs-string">&quot;提示&quot;</span>, <span class="hljs-string">&quot;请先选择 [Markdown笔记] 和 [附件目录]&quot;</span>)<br><br>        <span class="hljs-comment"># 1. 备份流程</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.enable_backup_var.get():<br>            backup_dest = <span class="hljs-variable language_">self</span>.backup_path_var.get()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> backup_dest:<br>                <span class="hljs-keyword">return</span> messagebox.showwarning(<span class="hljs-string">&quot;提示&quot;</span>, <span class="hljs-string">&quot;请选择备份保存的文件夹！&quot;</span>)<br>            <br>            success = <span class="hljs-variable language_">self</span>.perform_backup(md_file, att_dir, backup_dest)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> success:<br>                <span class="hljs-keyword">return</span> <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">&quot;用户跳过备份步骤。&quot;</span>)<br><br>        <span class="hljs-comment"># 2. 重命名流程</span><br>        <span class="hljs-variable language_">self</span>.process_renaming_logic(md_file, att_dir)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">perform_backup</span>(<span class="hljs-params">self, md_file, att_dir, backup_dest</span>):<br>        <span class="hljs-keyword">try</span>:<br>            note_name = os.path.splitext(os.path.basename(md_file))[<span class="hljs-number">0</span>]<br>            <span class="hljs-comment"># 格式：_backup_YYYY-MM-DDTHH-mm</span><br>            timestamp = datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%dT%H-%M&quot;</span>)<br>            zip_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;note_name&#125;</span>_backup_<span class="hljs-subst">&#123;timestamp&#125;</span>.zip&quot;</span><br>            zip_path = os.path.join(backup_dest, zip_name)<br><br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;正在创建备份: <span class="hljs-subst">&#123;zip_name&#125;</span> ...&quot;</span>)<br><br>            <span class="hljs-keyword">with</span> zipfile.ZipFile(zip_path, <span class="hljs-string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED) <span class="hljs-keyword">as</span> zf:<br>                zf.write(md_file, arcname=os.path.basename(md_file))<br>                <span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(att_dir):<br>                    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>                        full_path = os.path.join(root, file)<br>                        rel_path = os.path.relpath(full_path, os.path.dirname(att_dir))<br>                        zf.write(full_path, arcname=rel_path)<br>            <br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;✅ 备份成功！&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;❌ 备份失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            messagebox.showerror(<span class="hljs-string">&quot;备份失败&quot;</span>, <span class="hljs-string">f&quot;备份操作出错，已终止。\n错误信息: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_renaming_logic</span>(<span class="hljs-params">self, md_file, att_dir</span>):<br>        ext = <span class="hljs-variable language_">self</span>.ext_var.get().lower()<br>        note_name = os.path.splitext(os.path.basename(md_file))[<span class="hljs-number">0</span>]<br>        note_name = re.sub(<span class="hljs-string">r&#x27;[\\/*?:&quot;&lt;&gt;|]&#x27;</span>, <span class="hljs-string">&quot;_&quot;</span>, note_name)<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(md_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                content = f.read()<br><br>            pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;!\[(.*?)\]\((.*?)\)&#x27;</span>)<br>            matches = <span class="hljs-built_in">list</span>(pattern.finditer(content))<br>            <br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;--- 开始分析笔记内容 ---&quot;</span>)<br>            <br>            rename_map = &#123;&#125; <br>            new_files_generated = <span class="hljs-built_in">set</span>()<br>            count = <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> matches:<br>                rel_path = unquote(<span class="hljs-keyword">match</span>.group(<span class="hljs-number">2</span>))<br>                img_name = os.path.basename(rel_path)<br>                <br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> img_name.lower().endswith(<span class="hljs-string">f&quot;.<span class="hljs-subst">&#123;ext&#125;</span>&quot;</span>): <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> img_name <span class="hljs-keyword">in</span> rename_map: <span class="hljs-keyword">continue</span><br><br>                full_old_path = os.path.join(att_dir, img_name)<br>                <br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(full_old_path):<br>                    <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;⚠ 找不到附件: <span class="hljs-subst">&#123;img_name&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">continue</span><br>                <br>                <span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span>:<br>                    new_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;note_name&#125;</span>.<span class="hljs-subst">&#123;ext&#125;</span>&quot;</span><br>                <span class="hljs-keyword">else</span>:<br>                    new_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;note_name&#125;</span>-<span class="hljs-subst">&#123;count - <span class="hljs-number">1</span>&#125;</span>.<span class="hljs-subst">&#123;ext&#125;</span>&quot;</span><br>                <br>                new_files_generated.add(new_name)<br>                temp_name = <span class="hljs-string">f&quot;TEMP_<span class="hljs-subst">&#123;uuid.uuid4().<span class="hljs-built_in">hex</span>&#125;</span>.<span class="hljs-subst">&#123;ext&#125;</span>&quot;</span><br>                <br>                rename_map[img_name] = &#123;<br>                    <span class="hljs-string">&quot;temp&quot;</span>: temp_name, <span class="hljs-string">&quot;final&quot;</span>: new_name,<br>                    <span class="hljs-string">&quot;old_path&quot;</span>: full_old_path,<br>                    <span class="hljs-string">&quot;temp_path&quot;</span>: os.path.join(att_dir, temp_name),<br>                    <span class="hljs-string">&quot;final_path&quot;</span>: os.path.join(att_dir, new_name)<br>                &#125;<br>                count += <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rename_map:<br>                <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">&quot;没有发现需要重命名的图片。&quot;</span>)<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;计划重命名 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(rename_map)&#125;</span> 个文件...&quot;</span>)<br><br>            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> rename_map.items():<br>                <span class="hljs-keyword">try</span>: os.rename(v[<span class="hljs-string">&quot;old_path&quot;</span>], v[<span class="hljs-string">&quot;temp_path&quot;</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e: <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;Error (Temp): <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> rename_map.items():<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">if</span> os.path.exists(v[<span class="hljs-string">&quot;final_path&quot;</span>]): os.remove(v[<span class="hljs-string">&quot;final_path&quot;</span>])<br>                    os.rename(v[<span class="hljs-string">&quot;temp_path&quot;</span>], v[<span class="hljs-string">&quot;final_path&quot;</span>])<br>                    <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;重命名: <span class="hljs-subst">&#123;k&#125;</span> -&gt; <span class="hljs-subst">&#123;v[<span class="hljs-string">&#x27;final&#x27;</span>]&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e: <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;Error (Final): <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">replace_link</span>(<span class="hljs-params">m</span>):<br>                path_decoded = unquote(m.group(<span class="hljs-number">2</span>))<br>                name = os.path.basename(path_decoded)<br>                <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> rename_map:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;![<span class="hljs-subst">&#123;m.group(<span class="hljs-number">1</span>)&#125;</span>](<span class="hljs-subst">&#123;rename_map[name][<span class="hljs-string">&#x27;final&#x27;</span>]&#125;</span>)&quot;</span><br>                <span class="hljs-keyword">return</span> m.group(<span class="hljs-number">0</span>)<br><br>            new_content = pattern.sub(replace_link, content)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(md_file, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(new_content)<br><br>            deleted = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.delete_unused_var.get():<br>                <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> os.listdir(att_dir):<br>                    <span class="hljs-keyword">if</span> f.lower().endswith(<span class="hljs-string">f&quot;.<span class="hljs-subst">&#123;ext&#125;</span>&quot;</span>) <span class="hljs-keyword">and</span> f <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> new_files_generated:<br>                        <span class="hljs-keyword">try</span>:<br>                            os.remove(os.path.join(att_dir, f))<br>                            deleted += <span class="hljs-number">1</span><br>                            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;已删除冗余: <span class="hljs-subst">&#123;f&#125;</span>&quot;</span>)<br>                        <span class="hljs-keyword">except</span>: <span class="hljs-keyword">pass</span><br>            <br>            msg = <span class="hljs-string">f&quot;处理完成！\n共重命名 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(rename_map)&#125;</span> 张图片。&quot;</span><br>            <span class="hljs-keyword">if</span> deleted &gt; <span class="hljs-number">0</span>: msg += <span class="hljs-string">f&quot;\n已清理 <span class="hljs-subst">&#123;deleted&#125;</span> 张废弃图片。&quot;</span><br>            messagebox.showinfo(<span class="hljs-string">&quot;成功&quot;</span>, msg)<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;❌ 运行错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            messagebox.showerror(<span class="hljs-string">&quot;Error&quot;</span>, <span class="hljs-built_in">str</span>(e))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    root = tk.Tk()<br>    app = ModernRenamerApp(root)<br>    root.mainloop()<br></code></pre></td></tr></table></figure><hr><h2 id="2-打包成-exe-文件"><a href="#2-打包成-exe-文件" class="headerlink" title="2. 打包成 exe 文件"></a>2. 打包成 exe 文件</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 1. 安装打包工具</span><br>pip install pyinstaller<br><br><br><span class="hljs-comment"># 2. 打包成 exe 文件</span><br>pyinstaller <span class="hljs-operator">-</span>-onefile <span class="hljs-operator">-</span>-windowed <span class="hljs-operator">-</span>-icon<span class="hljs-operator">=</span><span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\I</span>CO<span class="hljs-char escape_">\O</span>bsidian 图片排序与重命名.ico&quot;</span> <span class="hljs-operator">-</span>-distpath <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合&quot;</span> <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\O</span>bsidian 图片排序与重命名.py&quot;</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">1. --onefile</span><br><span class="hljs-string">1. 打包为单个 .exe 文件。</span><br><span class="hljs-string">2. --windowed</span><br><span class="hljs-string">1. 确保 GUI 程序无控制台窗口</span><br><span class="hljs-string">3. --distpath &quot;</span>D:\文件集合\<span class="hljs-string">&quot;  &quot;</span>D:\文件集合\Obsidian 图片排序与重命名.py<span class="hljs-string">&quot;</span><br><span class="hljs-string">1. D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\ </span>是输出位置</span><br><span class="hljs-string">2. D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\O</span>bsidian 图片排序与重命名.py 是输入位置</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Obsidian 图片排序与重命名</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 异常</title>
    <link href="/2025/12/14/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%BC%82%E5%B8%B8/"/>
    <url>/2025/12/14/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO🐉"><a href="#一、TODO🐉" class="headerlink" title="一、TODO🐉"></a>一、TODO🐉</h1><hr><h1 id="二、脑图-🐉"><a href="#二、脑图-🐉" class="headerlink" title="二、脑图 🐉"></a>二、脑图 🐉</h1><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/12/14/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%BC%82%E5%B8%B8/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%BC%82%E5%B8%B8.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/14/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%BC%82%E5%B8%B8/">http://blog.wangjia.ink/2025/12/14/笔记：Java异常/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/Java-1-2c9974fbda5e809ea776fbd12f9718e8?source=copy_link">https://www.notion.so/Java-1-2c9974fbda5e809ea776fbd12f9718e8?source=copy_link</a></p></li></ol><hr><h1 id="三、Java-异常基础-🐉"><a href="#三、Java-异常基础-🐉" class="headerlink" title="三、Java 异常基础 🐉"></a>三、Java 异常基础 🐉</h1><h2 id="1-Java-异常基础体系-🐉"><a href="#1-Java-异常基础体系-🐉" class="headerlink" title="1. Java 异常基础体系 🐉"></a>1. Java 异常基础体系 🐉</h2><p><img src="/2025/12/14/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%BC%82%E5%B8%B8/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%BC%82%E5%B8%B8.png"></p><hr><h2 id="2-Java-异常相关分类-🐉"><a href="#2-Java-异常相关分类-🐉" class="headerlink" title="2. Java 异常相关分类 🐉"></a>2. Java 异常相关分类 🐉</h2><ol><li>错误</li><li>异常<ol><li>受检异常</li><li>非受检异常</li></ol></li></ol><h3 id="2-1-错误-🐉"><a href="#2-1-错误-🐉" class="headerlink" title="2.1. 错误 🐉"></a>2.1. 错误 🐉</h3><p>错误是指：<code>Error</code> 普通类及其子类，是由于严重的系统级问题而抛出的异常。<code>Java</code> 程序通常无法自行修复该问题</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们在方法中，不应该抛出错误或捕获并处理错误</li></ol></blockquote><hr><h3 id="2-2-异常-🐉"><a href="#2-2-异常-🐉" class="headerlink" title="2.2. 异常 🐉"></a>2.2. 异常 🐉</h3><h4 id="2-2-1-异常相关分类-🐉"><a href="#2-2-1-异常相关分类-🐉" class="headerlink" title="2.2.1. 异常相关分类 🐉"></a>2.2.1. 异常相关分类 🐉</h4><ol><li>受检异常</li><li>非受检异常</li></ol><hr><h4 id="2-2-2-受检异常"><a href="#2-2-2-受检异常" class="headerlink" title="2.2.2. 受检异常"></a>2.2.2. 受检异常</h4><h5 id="2-2-2-1-受检异常概述-🐉"><a href="#2-2-2-1-受检异常概述-🐉" class="headerlink" title="2.2.2.1. 受检异常概述 🐉"></a>2.2.2.1. 受检异常概述 🐉</h5><p>受检异常是指：<code>Exception</code> 普通类及其子类（需要注意的是：不能是 <code>RuntimeException</code> 普通类及其子类），是由于 <code>Java</code> 程序外部的问题（例如：文件读写问题）而抛出的异常。我们通常可以在捕获并处理受检异常的过程中，使用间隔重试的方式或其他的方式，最终实现抛出该异常的任务执行成功，从而达到 “保住 <code>Java</code> 程序、保住任务” 的目的</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果我们在方法中抛出受检异常，编译器会强制我们必须处理该异常</li></ol></blockquote><hr><h5 id="2-2-2-2-受检异常处理方式-🐉"><a href="#2-2-2-2-受检异常处理方式-🐉" class="headerlink" title="2.2.2.2. 受检异常处理方式  🐉"></a>2.2.2.2. 受检异常处理方式  🐉</h5><p>如果我们在方法中抛出受检异常，编译器会强制我们必须处理这个异常：</p><ol><li>声明抛出异常</li><li>捕获并处理异常</li></ol><h6 id="2-2-2-2-1-声明抛出异常-🐉"><a href="#2-2-2-2-1-声明抛出异常-🐉" class="headerlink" title="2.2.2.2.1. 声明抛出异常 🐉"></a>2.2.2.2.1. 声明抛出异常 🐉</h6><p>声明抛出异常是指：在方法中并不会捕获并处理该异常，而是继续向上抛出该异常，让调用该方法的方法（术语是：调用方）去处理该异常。在调用方处理该受检异常的过程中，既可以声明抛出异常，又可以捕获并处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>throws</code> 用于声明该方法可能抛出的异常，告知调用方需要处理这些异常（需要注意的是：<code>throws</code> 可以用于声明该方法可能抛出的非受检异常，但是没必要）</li><li><code>Java</code> 有一个规定：当我们重写某方法时，我们在方法中不能抛出原方法未声明抛出的受检异常<ol><li>需要注意的是：<ol><li>这个规定只针对受检异常，不针对非受检异常</li><li>这也是 <code>Runnable</code> 任务不能抛出受检异常的原因</li></ol></li></ol></li></ol></blockquote><hr><h6 id="2-2-2-2-2-捕获并处理异常-🐉"><a href="#2-2-2-2-2-捕获并处理异常-🐉" class="headerlink" title="2.2.2.2.2. 捕获并处理异常 🐉"></a>2.2.2.2.2. 捕获并处理异常 🐉</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在上述代码中，我们在 <code>catch</code> 块中编写的处理异常的 <code>Java</code> 代码，其实是一种 “吞噬异常” 的行为，是非常坏的习惯，因为我们可能永远无法知道这个异常的存在</li></ol></blockquote><hr><h4 id="2-2-3-非受检异常-🐉"><a href="#2-2-3-非受检异常-🐉" class="headerlink" title="2.2.3. 非受检异常 🐉"></a>2.2.3. 非受检异常 🐉</h4><h5 id="2-2-3-1-非受检异常概述-🐉"><a href="#2-2-3-1-非受检异常概述-🐉" class="headerlink" title="2.2.3.1. 非受检异常概述 🐉"></a>2.2.3.1. 非受检异常概述 🐉</h5><p>非受检异常（运行时异常）是指：<code>RuntimeException</code> 普通类及其子类的类，是由于 <code>Java</code> 程序内部的问题而抛出的异常。虽然我们可以通过捕获并处理非受检异常，从而达到 “保住 <code>Java</code> 程序” 的目的。但是如果我们不修改 <code>Java</code> 代码，就会一直存在该问题，我的意思是：如果我们不修改 <code>Java</code> 代码，虽然能实现 “保住 <code>Java</code> 程序”，但是不能实现 “保住任务”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果我们在某方法中抛出非受检异常，编译器并不会强制我们必须处理该异常</li><li>一些内置的非受检异常，即便我们在方法中并没有抛出它们，但是也有可能在运行 <code>Java</code> 程序的过程中抛出该异常（需要注意的是：受检异常并不会出现这样的情况）</li></ol></blockquote><hr><h2 id="3-Java-异常组成部分-🐉"><a href="#3-Java-异常组成部分-🐉" class="headerlink" title="3. Java 异常组成部分 🐉"></a>3. Java 异常组成部分 🐉</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <br>  <span class="hljs-comment">// Throwable-&gt;detailMessage</span><br>  <span class="hljs-attr">&quot;detailMessage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;异常信息...&quot;</span><span class="hljs-punctuation">,</span>   <br>  <br>  <span class="hljs-comment">// Throwable-&gt;StackTrace</span><br>  <span class="hljs-attr">&quot;stackTrace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;declaringClass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.example.Service&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;methodName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myServiceMethod&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;fileName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Service.java&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;lineNumber&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">15</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;declaringClass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.example.Controller&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;methodName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myControllerMethod&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;fileName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Controller.java&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;lineNumber&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-comment">// Throwable-&gt;cause</span><br>  <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>     <span class="hljs-attr">&quot;detailMessage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;原始异常的异常信息...&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;stackTrace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>           <span class="hljs-attr">&quot;declaringClass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.example.Dao&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;methodName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myDaoMethod&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;fileName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dao.java&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;lineNumber&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">88</span><br>        <span class="hljs-punctuation">&#125;</span><br>     <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;suppressedExceptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-comment">// Throwable-&gt;suppressedExceptions</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 当捕获并处理该异常时，如果又抛出了其他的异常，这些异常就会被存储到这里（需要注意的是：当使用 try-with-resources 语法糖时，常发生这样的情况）</span><br>  <span class="hljs-attr">&quot;suppressedExceptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>  <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-Java-异常底层原理-🐉"><a href="#4-Java-异常底层原理-🐉" class="headerlink" title="4. Java 异常底层原理 🐉"></a>4. Java 异常底层原理 🐉</h2><p>详见笔记：<code>JVM</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJVM.md">笔记：JVM</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/">http://blog.wangjia.ink/2025/12/10/笔记：JVM/</a></li></ol></li></ol><hr><h2 id="5-Java-异常链-🐉"><a href="#5-Java-异常链-🐉" class="headerlink" title="5. Java 异常链 🐉"></a>5. Java 异常链 🐉</h2><p><code>Java</code> 异常链是指：在捕获并处理异常的过程时，抛出一个新的异常，并且被处理的异常（术语是：原始异常）要作为新异常的构造方法参数（即作为新异常的 <code>Throwable-&gt;cause</code>）</p><p>在日常开发中，当我们捕获并处理一个低层的异常时，可以抛出一个高层的、贴近业务的异常（例如：在三层架构中，我们可以在 <code>DAO</code> 层中抛出一个低层的异常。当 <code>Serivice</code> 层捕获并处理该异常时，抛出一个高层的、贴近业务的异常。当 <code>Controller</code> 层捕获并处理该异常时，返回该异常的异常信息给客户端）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DAO 层</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">// Service 层</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> userDao.findUserById(id);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserQueryException</span>(<span class="hljs-string">&quot;...&quot;</span>, e);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">// Controller 层</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUserProfile</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> userService.getUserName(id);<br>            System.out.println(<span class="hljs-string">&quot;...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (UserQueryException e) &#123;<br>        <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在我们使用 <code>Java</code> 异常链的过程中，一定要保留原始异常（即被处理的异常），方便后续排查（因为我们需要根据原始异常的堆栈信息来追溯异常链出现的根本原因）</li></ol></blockquote><hr><h2 id="6-try-catch-finally-语句-🐉"><a href="#6-try-catch-finally-语句-🐉" class="headerlink" title="6. try-catch-finally 语句 🐉"></a>6. try-catch-finally 语句 🐉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>() &#123;<br>log.info(<span class="hljs-string">&quot;...&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>log.info(<span class="hljs-string">&quot;...&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>log.info(<span class="hljs-string">&quot;...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>在 <code>try-catch-finally</code> 语句中，当线程执行 <code>catch</code> 块中的 <code>Java</code> 代码时，如果调用 <code>return</code> 了，那么该线程还会执行 <code>finally</code> 块中的 <code>Java</code> 代码吗？<ol><li>线程会执行 <code>finally</code> 块中的 <code>Java</code> 代码。我们可以简单理解为：当线程调用 <code>return</code> 时，会先执行 <code>finally</code> 块中的 <code>Java</code> 代码，再执行 <code>return</code>（需要注意的是：当线程执行 <code>finally</code> 块中的 <code>Java</code> 代码时，如果调用了 <code>return</code>，也是这个流程）</li></ol></li><li>在 <code>try-catch-finally</code> 语句中，如果 <code>finally</code> 块也有 <code>return</code>，那么会发生什么样的情况？<ol><li><code>finally</code> 块中的 <code>return</code>，会覆盖 <code>try</code> 块中的 <code>return</code>、<code>catch</code> 块中的 <code>return</code></li></ol></li><li>在执行 <code>try-catch-finally</code> 语句中，线程在什么情况并不会执行 <code>finally</code> 块中的 <code>Java</code> 代码（需要注意的是：如果不考虑服务故障）？<ol><li>线程当执行 <code>try</code> 块中的 <code>Java</code> 代码、<code>catch</code> 块中的 <code>Java</code> 代码时，调用了 <code>System.exit</code>，强制关闭了 <code>JVM</code></li></ol></li></ol></li></ol></blockquote><hr><h2 id="7-try-with-resources-语法糖-🐉"><a href="#7-try-with-resources-语法糖-🐉" class="headerlink" title="7. try-with-resources 语法糖 🐉"></a>7. try-with-resources 语法糖 🐉</h2><p>详见源码：<code>AutoCloseable</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.AutoCloseable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.AutoCloseable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.AutoCloseable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/10/源码：java.lang.AutoCloseable源码解析/</a></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 异常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>影视</title>
    <link href="/2025/12/13/%E5%BD%B1%E8%A7%86/"/>
    <url>/2025/12/13/%E5%BD%B1%E8%A7%86/</url>
    
    <content type="html"><![CDATA[<h2 id="电视剧"><a href="#电视剧" class="headerlink" title="电视剧"></a>电视剧</h2><ol><li>亮剑</li><li>老九门</li><li>特警力量</li><li>武林外传</li><li>无心法师</li><li>路从今夜白</li><li>封神英雄传</li></ol>]]></content>
    
    
    <categories>
      
      <category>影视</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>名言</title>
    <link href="/2025/12/11/%E5%90%8D%E8%A8%80/"/>
    <url>/2025/12/11/%E5%90%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<ol><li>虽不中亦不远矣</li><li>把书读厚了，再把书读薄了</li><li>天下贤才尽数会于麾下</li><li>天下贤才尽数听令而动</li></ol>]]></content>
    
    
    <categories>
      
      <category>名言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工具：快捷语料管理</title>
    <link href="/2025/12/11/%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%96%99%E7%AE%A1%E7%90%86/"/>
    <url>/2025/12/11/%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%96%99%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Py-代码"><a href="#1-Py-代码" class="headerlink" title="1. Py 代码"></a>1. Py 代码</h2><p><font color="#92d050">1. 安装相关依赖</font></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pip install keyboard  pyperclip pyautogui PyQt6 -<span class="hljs-selector-tag">i</span> https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 编写 Py 代码</font></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> keyboard<br><span class="hljs-keyword">import</span> pyperclip<br><span class="hljs-keyword">import</span> pyautogui<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> (QApplication, QMainWindow, QWidget, QVBoxLayout,<br>                             QHBoxLayout, QListWidget, QPushButton, QLabel,<br>                             QDialog, QMessageBox, QInputDialog, QGridLayout,<br>                             QFrame, QSizePolicy, QGraphicsDropShadowEffect, QLineEdit, QTextEdit,<br>                             QAbstractItemView)<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt, pyqtSignal, QObject<br><span class="hljs-keyword">from</span> PyQt6.QtGui <span class="hljs-keyword">import</span> QColor, QFont, QCursor, QScreen<br><span class="hljs-comment"># --- 数据存储 ---</span><br>DEFAULT_DATA_FILE = <span class="hljs-string">r&quot;D:\文件集合\快捷语料管理.json&quot;</span><br>DATA_FILE = DEFAULT_DATA_FILE  <span class="hljs-comment"># 可以自定义修改此变量</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(DATA_FILE):<br>        <span class="hljs-comment"># 如果文件不存在，创建默认数据</span><br>        default_data = &#123;<span class="hljs-string">&quot;常用回复&quot;</span>: [<span class="hljs-string">&quot;你好，请问有什么可以帮您？&quot;</span>, <span class="hljs-string">&quot;当前进度：&#123;0% | 50% | 100%&#125;&quot;</span>],<br>                        <span class="hljs-string">&quot;代码片段&quot;</span>: [<span class="hljs-string">&quot;print(f&#x27;结果是: &#123;result&#125;&#x27;)&quot;</span>, <span class="hljs-string">&quot;SELECT * FROM &#123;table&#125; WHERE id = &#123;id&#125;&quot;</span>]&#125;<br>        save_data(default_data)<br>        <span class="hljs-keyword">return</span> default_data<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(DATA_FILE, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-keyword">return</span> json.load(f)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;加载数据失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;常用回复&quot;</span>: [], <span class="hljs-string">&quot;代码片段&quot;</span>: []&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_data</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">try</span>:<br>        os.makedirs(os.path.dirname(DATA_FILE), exist_ok=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(DATA_FILE, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            json.dump(data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;保存数据失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><span class="hljs-comment"># --- 全局样式表 (QSS) ---</span><br><span class="hljs-comment"># 这是一个现代深色主题的 CSS 配置</span><br>STYLESHEET = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">QMainWindow, QDialog &#123;</span><br><span class="hljs-string">    background-color: #1e1e1e;</span><br><span class="hljs-string">    color: #e0e0e0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">/* 列表控件样式 */</span><br><span class="hljs-string">QListWidget &#123;</span><br><span class="hljs-string">    background-color: #252526;</span><br><span class="hljs-string">    border: 1px solid #3e3e42;</span><br><span class="hljs-string">    border-radius: 6px;</span><br><span class="hljs-string">    padding: 5px;</span><br><span class="hljs-string">    outline: none;</span><br><span class="hljs-string">    font-size: 14px;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QListWidget::item &#123;</span><br><span class="hljs-string">    padding: 8px;</span><br><span class="hljs-string">    border-radius: 4px;</span><br><span class="hljs-string">    color: #cccccc;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QListWidget::item:selected &#123;</span><br><span class="hljs-string">    background-color: #37373d;</span><br><span class="hljs-string">    color: #ffffff;</span><br><span class="hljs-string">    border-left: 3px solid #007acc; /* 选中时左侧蓝色条 */</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QListWidget::item:hover &#123;</span><br><span class="hljs-string">    background-color: #2a2d2e;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">/* 按钮通用样式 */</span><br><span class="hljs-string">QPushButton &#123;</span><br><span class="hljs-string">    background-color: #333333;</span><br><span class="hljs-string">    color: #ffffff;</span><br><span class="hljs-string">    border: 1px solid #454545;</span><br><span class="hljs-string">    padding: 6px 12px;</span><br><span class="hljs-string">    border-radius: 4px;</span><br><span class="hljs-string">    font-size: 13px;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QPushButton:hover &#123;</span><br><span class="hljs-string">    background-color: #3e3e42;</span><br><span class="hljs-string">    border-color: #555;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QPushButton:pressed &#123;</span><br><span class="hljs-string">    background-color: #2d2d30;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">/* 蓝色强调按钮 (用于主要操作) */</span><br><span class="hljs-string">QPushButton.primary &#123;</span><br><span class="hljs-string">    background-color: #007acc;</span><br><span class="hljs-string">    border: 1px solid #007acc;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QPushButton.primary:hover &#123;</span><br><span class="hljs-string">    background-color: #0062a3;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">/* 标签样式 */</span><br><span class="hljs-string">QLabel &#123;</span><br><span class="hljs-string">    color: #cccccc;</span><br><span class="hljs-string">    font-family: &quot;Segoe UI&quot;, &quot;Microsoft YaHei&quot;, sans-serif;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QLabel.header &#123;</span><br><span class="hljs-string">    font-size: 16px;</span><br><span class="hljs-string">    font-weight: bold;</span><br><span class="hljs-string">    color: #ffffff;</span><br><span class="hljs-string">    margin-bottom: 5px;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QLabel.hint &#123;</span><br><span class="hljs-string">    color: #888888;</span><br><span class="hljs-string">    font-size: 12px;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">/* 快捷窗口输入框风格 */</span><br><span class="hljs-string">QDialog#QuickSelector &#123;</span><br><span class="hljs-string">    border: 1px solid #454545;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QLineEdit &#123;</span><br><span class="hljs-string">    background-color: #252526;</span><br><span class="hljs-string">    border: 1px solid #3e3e42;</span><br><span class="hljs-string">    border-radius: 4px;</span><br><span class="hljs-string">    padding: 6px;</span><br><span class="hljs-string">    color: #e0e0e0;</span><br><span class="hljs-string">    font-size: 14px;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QLineEdit:focus &#123;</span><br><span class="hljs-string">    border-color: #007acc;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QTextEdit &#123;</span><br><span class="hljs-string">    background-color: #252526;</span><br><span class="hljs-string">    border: 1px solid #3e3e42;</span><br><span class="hljs-string">    border-radius: 4px;</span><br><span class="hljs-string">    padding: 6px;</span><br><span class="hljs-string">    color: #e0e0e0;</span><br><span class="hljs-string">    font-size: 14px;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">QTextEdit:focus &#123;</span><br><span class="hljs-string">    border-color: #007acc;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># --- 信号处理 ---</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HotkeySignal</span>(<span class="hljs-title class_ inherited__">QObject</span>):<br>    trigger = pyqtSignal()<br><span class="hljs-comment"># --- 自定义输入对话框 (用于拉长新建语句对话框) ---</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomInputDialog</span>(<span class="hljs-title class_ inherited__">QDialog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, title, label, initial_text=<span class="hljs-string">&quot;&quot;</span>, parent=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__(parent)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(title)<br>        <span class="hljs-variable language_">self</span>.setMinimumWidth(<span class="hljs-number">600</span>)  <span class="hljs-comment"># 拉长对话框</span><br>        layout = QVBoxLayout(<span class="hljs-variable language_">self</span>)<br>        lbl = QLabel(label)<br>        layout.addWidget(lbl)<br>        <span class="hljs-variable language_">self</span>.text_edit = QTextEdit()<br>        <span class="hljs-variable language_">self</span>.text_edit.setPlainText(initial_text)<br>        <span class="hljs-variable language_">self</span>.text_edit.setMinimumHeight(<span class="hljs-number">100</span>)  <span class="hljs-comment"># 增加高度</span><br>        layout.addWidget(<span class="hljs-variable language_">self</span>.text_edit)<br>        buttons = QHBoxLayout()<br>        ok_btn = QPushButton(<span class="hljs-string">&quot;确定&quot;</span>)<br>        ok_btn.clicked.connect(<span class="hljs-variable language_">self</span>.accept)<br>        cancel_btn = QPushButton(<span class="hljs-string">&quot;取消&quot;</span>)<br>        cancel_btn.clicked.connect(<span class="hljs-variable language_">self</span>.reject)<br>        buttons.addWidget(ok_btn)<br>        buttons.addWidget(cancel_btn)<br>        layout.addLayout(buttons)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getText</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.text_edit.toPlainText()<br><span class="hljs-comment"># --- 快捷选择窗口 (类似 Alfred/Spotlight 风格) ---</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSelector</span>(<span class="hljs-title class_ inherited__">QDialog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, parent=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__(parent)<br>        <span class="hljs-variable language_">self</span>.setObjectName(<span class="hljs-string">&quot;QuickSelector&quot;</span>) <span class="hljs-comment"># 用于QSS定位</span><br>        <span class="hljs-variable language_">self</span>.data = data<br>        <span class="hljs-variable language_">self</span>.current_text = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.drag_position = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 用于拖拽</span><br>        <span class="hljs-variable language_">self</span>.option_buttons = []  <span class="hljs-comment"># 存储选项按钮</span><br>        <br>        <span class="hljs-comment"># 窗口设置</span><br>        <span class="hljs-variable language_">self</span>.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.Tool)<br>        <span class="hljs-variable language_">self</span>.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground) <span class="hljs-comment"># 允许圆角透明</span><br>        <span class="hljs-variable language_">self</span>.resize(<span class="hljs-number">500</span>, <span class="hljs-number">400</span>)  <span class="hljs-comment"># 略微增加高度以容纳搜索框</span><br>        <br>        <span class="hljs-comment"># 主布局容器 (用于绘制背景和圆角)</span><br>        <span class="hljs-variable language_">self</span>.container = QFrame(<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-variable language_">self</span>.container.setGeometry(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>)<br>        <span class="hljs-variable language_">self</span>.container.setStyleSheet(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            QFrame &#123;</span><br><span class="hljs-string">                background-color: #1e1e1e;</span><br><span class="hljs-string">                border: 1px solid #454545;</span><br><span class="hljs-string">                border-radius: 10px;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>)<br>        <br>        <span class="hljs-comment"># 添加阴影效果</span><br>        shadow = QGraphicsDropShadowEffect(<span class="hljs-variable language_">self</span>)<br>        shadow.setBlurRadius(<span class="hljs-number">20</span>)<br>        shadow.setColor(QColor(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">150</span>))<br>        shadow.setOffset(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>        <span class="hljs-variable language_">self</span>.container.setGraphicsEffect(shadow)<br>        <span class="hljs-variable language_">self</span>.layout = QVBoxLayout(<span class="hljs-variable language_">self</span>.container)<br>        <span class="hljs-variable language_">self</span>.layout.setContentsMargins(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>)<br>        <br>        <span class="hljs-comment"># 顶部提示区</span><br>        <span class="hljs-variable language_">self</span>.info_label = QLabel(<span class="hljs-string">&quot;选择模块&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.info_label.setStyleSheet(<span class="hljs-string">&quot;font-size: 18px; font-weight: bold; color: #fff; border: none;&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)<br>        <span class="hljs-variable language_">self</span>.layout.addWidget(<span class="hljs-variable language_">self</span>.info_label)<br>        <span class="hljs-comment"># 分割线</span><br>        line = QFrame()<br>        line.setFrameShape(QFrame.Shape.HLine)<br>        line.setStyleSheet(<span class="hljs-string">&quot;background-color: #333; border: none; max-height: 1px;&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.layout.addWidget(line)<br>        <br>        <span class="hljs-comment"># 搜索框</span><br>        <span class="hljs-variable language_">self</span>.search_edit = QLineEdit()<br>        <span class="hljs-variable language_">self</span>.search_edit.setPlaceholderText(<span class="hljs-string">&quot;搜索...&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.search_edit.textChanged.connect(<span class="hljs-variable language_">self</span>.filter_list)<br>        <span class="hljs-variable language_">self</span>.layout.addWidget(<span class="hljs-variable language_">self</span>.search_edit)<br>        <br>        <span class="hljs-comment"># 列表控件</span><br>        <span class="hljs-variable language_">self</span>.list_widget = QListWidget()<br>        <span class="hljs-variable language_">self</span>.list_widget.setStyleSheet(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            QListWidget &#123; border: none; background: transparent; &#125;</span><br><span class="hljs-string">            QListWidget::item &#123; padding: 10px; font-size: 15px; &#125;</span><br><span class="hljs-string">            QListWidget::item:selected &#123; background-color: #2d2d30; color: #4fc1ff; border: none; border-radius: 6px; &#125;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.list_widget.itemActivated.connect(<span class="hljs-variable language_">self</span>.on_item_clicked)  <span class="hljs-comment"># Enter 键触发</span><br>        <span class="hljs-variable language_">self</span>.list_widget.itemClicked.connect(<span class="hljs-variable language_">self</span>.on_item_clicked)<br>        <span class="hljs-variable language_">self</span>.layout.addWidget(<span class="hljs-variable language_">self</span>.list_widget)<br>        <br>        <span class="hljs-comment"># 选项按钮区域</span><br>        <span class="hljs-variable language_">self</span>.options_container = QWidget()<br>        <span class="hljs-variable language_">self</span>.options_container.setStyleSheet(<span class="hljs-string">&quot;background: transparent; border: none;&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.options_layout = QGridLayout()<br>        <span class="hljs-variable language_">self</span>.options_layout.setSpacing(<span class="hljs-number">10</span>) <span class="hljs-comment"># 按钮间距</span><br>        <span class="hljs-variable language_">self</span>.options_container.setLayout(<span class="hljs-variable language_">self</span>.options_layout)<br>        <span class="hljs-variable language_">self</span>.options_container.hide()<br>        <span class="hljs-variable language_">self</span>.layout.addWidget(<span class="hljs-variable language_">self</span>.options_container)<br>        <span class="hljs-comment"># 底部提示</span><br>        <span class="hljs-variable language_">self</span>.hint_label = QLabel(<span class="hljs-string">&quot;Esc 退出 | ↑↓Enter 选择 | 鼠标点击/拖拽&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.hint_label.setStyleSheet(<span class="hljs-string">&quot;color: #666; font-size: 11px; border: none;&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.hint_label.setAlignment(Qt.AlignmentFlag.AlignRight)<br>        <span class="hljs-variable language_">self</span>.layout.addWidget(<span class="hljs-variable language_">self</span>.hint_label)<br>        <span class="hljs-variable language_">self</span>.step = <span class="hljs-string">&quot;MODULE&quot;</span><br>        <span class="hljs-variable language_">self</span>.all_items = []  <span class="hljs-comment"># 用于搜索过滤</span><br>        <span class="hljs-variable language_">self</span>.load_modules()<br>        <span class="hljs-variable language_">self</span>.search_edit.setFocus()  <span class="hljs-comment"># 默认焦点在搜索框</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_modules</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.step = <span class="hljs-string">&quot;MODULE&quot;</span><br>        <span class="hljs-variable language_">self</span>.info_label.setText(<span class="hljs-string">&quot;📦 选择模块&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.list_widget.clear()<br>        <span class="hljs-variable language_">self</span>.list_widget.show()<br>        <span class="hljs-variable language_">self</span>.options_container.hide()<br>        <span class="hljs-variable language_">self</span>.all_items = <span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.data.keys())<br>        <span class="hljs-variable language_">self</span>.list_widget.addItems(<span class="hljs-variable language_">self</span>.all_items)<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.list_widget.count() &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.list_widget.setCurrentRow(<span class="hljs-number">0</span>) <span class="hljs-comment"># 默认选中第一个</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_sentences</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.step = <span class="hljs-string">&quot;SENTENCE&quot;</span><br>        <span class="hljs-variable language_">self</span>.info_label.setText(<span class="hljs-string">f&quot;📄 [<span class="hljs-subst">&#123;self.selected_module&#125;</span>] 选择内容&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.list_widget.clear()<br>        sentences = <span class="hljs-variable language_">self</span>.data.get(<span class="hljs-variable language_">self</span>.selected_module, [])<br>        <span class="hljs-variable language_">self</span>.all_items = sentences[:]<br>        <span class="hljs-variable language_">self</span>.list_widget.addItems(<span class="hljs-variable language_">self</span>.all_items)<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.list_widget.count() &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.list_widget.setCurrentRow(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_list</span>(<span class="hljs-params">self, text</span>):<br>        <span class="hljs-variable language_">self</span>.list_widget.clear()<br>        filtered = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.all_items <span class="hljs-keyword">if</span> text.lower() <span class="hljs-keyword">in</span> item.lower()]<br>        <span class="hljs-variable language_">self</span>.list_widget.addItems(filtered)<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.list_widget.count() &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.list_widget.setCurrentRow(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_item_clicked</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.step == <span class="hljs-string">&quot;MODULE&quot;</span>:<br>            <span class="hljs-variable language_">self</span>.selected_module = item.text()<br>            <span class="hljs-variable language_">self</span>.search_edit.clear()  <span class="hljs-comment"># 清空搜索</span><br>            <span class="hljs-variable language_">self</span>.load_sentences()<br>        <span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.step == <span class="hljs-string">&quot;SENTENCE&quot;</span>:<br>            <span class="hljs-variable language_">self</span>.current_text = item.text()<br>            <span class="hljs-variable language_">self</span>.start_resolving()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_resolving</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.step = <span class="hljs-string">&quot;RESOLVING&quot;</span><br>        <span class="hljs-variable language_">self</span>.search_edit.hide()  <span class="hljs-comment"># 隐藏搜索框</span><br>        <span class="hljs-variable language_">self</span>.list_widget.hide()<br>        <span class="hljs-variable language_">self</span>.options_container.show()<br>        <span class="hljs-variable language_">self</span>.hint_label.setText(<span class="hljs-string">&quot;Esc 退出 | ←→Enter 选择 | 鼠标点击&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.resolve_next_variable()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">resolve_next_variable</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">match</span> = re.search(<span class="hljs-string">r&#x27;\&#123;([^&#123;&#125;]+?)\&#125;&#x27;</span>, <span class="hljs-variable language_">self</span>.current_text)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>            full_match = <span class="hljs-keyword">match</span>.group(<span class="hljs-number">0</span>)<br>            content = <span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>)<br>            options = [opt.strip() <span class="hljs-keyword">for</span> opt <span class="hljs-keyword">in</span> content.split(<span class="hljs-string">&#x27;|&#x27;</span>)]<br>            options.append(<span class="hljs-string">&quot;Null&quot;</span>)  <span class="hljs-comment"># 添加 Null 选项</span><br>            <br>            <span class="hljs-comment"># 计算调整后的起始和结束位置</span><br>            start = <span class="hljs-keyword">match</span>.start()<br>            end = <span class="hljs-keyword">match</span>.end()<br>            adj_start = start - <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> start &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.current_text[start - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">else</span> start<br>            adj_end = end + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> end &lt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.current_text) <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.current_text[end] == <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">else</span> end<br>            <br>            <span class="hljs-comment"># 高亮显示当前要填空的部分</span><br>            display_text = <span class="hljs-variable language_">self</span>.current_text.replace(full_match, <span class="hljs-string">f&quot;&lt;span style=&#x27;color: #4fc1ff;&#x27;&gt;[ ??? ]&lt;/span&gt;&quot;</span>, <span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-variable language_">self</span>.info_label.setText(<span class="hljs-string">f&quot;✏️ 填空模式&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.info_label.setTextFormat(Qt.TextFormat.RichText) <span class="hljs-comment"># 允许HTML</span><br>            <br>            <span class="hljs-comment"># 显示上下文预览</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&#x27;preview_label&#x27;</span>):<br>                <span class="hljs-variable language_">self</span>.preview_label = QLabel(display_text)<br>                <span class="hljs-variable language_">self</span>.preview_label.setStyleSheet(<span class="hljs-string">&quot;color: #bbb; font-size: 14px; padding: 10px; background: #252526; border-radius: 5px;&quot;</span>)<br>                <span class="hljs-variable language_">self</span>.preview_label.setWordWrap(<span class="hljs-literal">True</span>)<br>                <span class="hljs-comment"># 插入到 layout 中间</span><br>                <span class="hljs-variable language_">self</span>.layout.insertWidget(<span class="hljs-number">3</span>, <span class="hljs-variable language_">self</span>.preview_label)  <span class="hljs-comment"># 调整插入位置，因为添加了搜索框</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-variable language_">self</span>.preview_label.setText(display_text)<br>                <span class="hljs-variable language_">self</span>.preview_label.show()<br>            <span class="hljs-comment"># 清除旧按钮</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.options_layout.count())):<br>                <span class="hljs-variable language_">self</span>.options_layout.itemAt(i).widget().setParent(<span class="hljs-literal">None</span>)<br>            <br>            <span class="hljs-variable language_">self</span>.option_buttons = []<br>            <span class="hljs-comment"># 生成大号卡片式按钮</span><br>            <span class="hljs-keyword">for</span> idx, opt <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(options):<br>                btn = QPushButton(opt <span class="hljs-keyword">if</span> opt != <span class="hljs-string">&quot;Null&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Null (空)&quot;</span>)<br>                btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))<br>                btn.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  <span class="hljs-comment"># 允许键盘焦点</span><br>                <span class="hljs-comment"># 针对选项按钮的特殊样式</span><br>                btn.setStyleSheet(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                    QPushButton &#123;</span><br><span class="hljs-string">                        background-color: #2d2d30;</span><br><span class="hljs-string">                        border: 1px solid #3e3e42;</span><br><span class="hljs-string">                        font-size: 16px;</span><br><span class="hljs-string">                        padding: 15px;</span><br><span class="hljs-string">                        text-align: left;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string">                    QPushButton:hover &#123;</span><br><span class="hljs-string">                        background-color: #37373d;</span><br><span class="hljs-string">                        border-left: 4px solid #007acc;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string">                    QPushButton:focus &#123;</span><br><span class="hljs-string">                        border: 2px solid #007acc;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string">                &quot;&quot;&quot;</span>)<br>                btn.clicked.connect(<span class="hljs-keyword">lambda</span> checked, o=opt, s=adj_start, e=adj_end: <span class="hljs-variable language_">self</span>.choice_made(o, s, e))<br>                <span class="hljs-variable language_">self</span>.options_layout.addWidget(btn, idx // <span class="hljs-number">2</span>, idx % <span class="hljs-number">2</span>)<br>                <span class="hljs-variable language_">self</span>.option_buttons.append(btn)<br>            <br>            <span class="hljs-comment"># 设置焦点到第一个按钮</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.option_buttons:<br>                <span class="hljs-variable language_">self</span>.option_buttons[<span class="hljs-number">0</span>].setFocus()<br>                <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&#x27;preview_label&#x27;</span>): <span class="hljs-variable language_">self</span>.preview_label.hide()<br>            <span class="hljs-variable language_">self</span>.finish_and_paste()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">choice_made</span>(<span class="hljs-params">self, option, adj_start, adj_end</span>):<br>        replace_with = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">if</span> option == <span class="hljs-string">&quot;Null&quot;</span> <span class="hljs-keyword">else</span> option<br>        <span class="hljs-variable language_">self</span>.current_text = <span class="hljs-variable language_">self</span>.current_text[:adj_start] + replace_with + <span class="hljs-variable language_">self</span>.current_text[adj_end:]<br>        <span class="hljs-variable language_">self</span>.resolve_next_variable()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">finish_and_paste</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.hide()<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        pyperclip.copy(<span class="hljs-variable language_">self</span>.current_text)<br>        ctrl_key = <span class="hljs-string">&quot;command&quot;</span> <span class="hljs-keyword">if</span> sys.platform == <span class="hljs-string">&quot;darwin&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;ctrl&quot;</span><br>        pyautogui.hotkey(ctrl_key, <span class="hljs-string">&#x27;v&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.close()<br>    <br>    <span class="hljs-comment"># 实现拖拽</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mousePressEvent</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.button() == Qt.MouseButton.LeftButton:<br>            <span class="hljs-variable language_">self</span>.drag_position = event.globalPosition().toPoint() - <span class="hljs-variable language_">self</span>.frameGeometry().topLeft()<br>            event.accept()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mouseMoveEvent</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.buttons() == Qt.MouseButton.LeftButton <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.drag_position <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-variable language_">self</span>.move(event.globalPosition().toPoint() - <span class="hljs-variable language_">self</span>.drag_position)<br>            event.accept()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mouseReleaseEvent</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-variable language_">self</span>.drag_position = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">keyPressEvent</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.key() == Qt.Key.Key_Escape:<br>            <span class="hljs-variable language_">self</span>.close()<br>        <span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.step == <span class="hljs-string">&quot;RESOLVING&quot;</span>:<br>            <span class="hljs-keyword">if</span> event.key() <span class="hljs-keyword">in</span> (Qt.Key.Key_Left, Qt.Key.Key_Right, Qt.Key.Key_Up, Qt.Key.Key_Down):<br>                current_focus = <span class="hljs-variable language_">self</span>.focusWidget()<br>                <span class="hljs-keyword">if</span> current_focus <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.option_buttons:<br>                    idx = <span class="hljs-variable language_">self</span>.option_buttons.index(current_focus)<br>                    rows, cols = <span class="hljs-variable language_">self</span>.options_layout.rowCount(), <span class="hljs-variable language_">self</span>.options_layout.columnCount()<br>                    row, col = <span class="hljs-built_in">divmod</span>(idx, cols)<br>                    <span class="hljs-keyword">if</span> event.key() == Qt.Key.Key_Left:<br>                        col = (col - <span class="hljs-number">1</span>) % cols<br>                    <span class="hljs-keyword">elif</span> event.key() == Qt.Key.Key_Right:<br>                        col = (col + <span class="hljs-number">1</span>) % cols<br>                    <span class="hljs-keyword">elif</span> event.key() == Qt.Key.Key_Up:<br>                        row = (row - <span class="hljs-number">1</span>) % rows<br>                    <span class="hljs-keyword">elif</span> event.key() == Qt.Key.Key_Down:<br>                        row = (row + <span class="hljs-number">1</span>) % rows<br>                    new_idx = row * cols + col<br>                    <span class="hljs-keyword">if</span> new_idx &lt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.option_buttons):<br>                        <span class="hljs-variable language_">self</span>.option_buttons[new_idx].setFocus()<br>            <span class="hljs-keyword">elif</span> event.key() == Qt.Key.Key_Return <span class="hljs-keyword">or</span> event.key() == Qt.Key.Key_Enter:<br>                current_focus = <span class="hljs-variable language_">self</span>.focusWidget()<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(current_focus, QPushButton):<br>                    current_focus.click()<br>        <span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.search_edit.hasFocus():<br>            <span class="hljs-keyword">if</span> event.key() == Qt.Key.Key_Down:<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.list_widget.count() &gt; <span class="hljs-number">0</span>:<br>                    <span class="hljs-variable language_">self</span>.list_widget.setFocus()<br>                    <span class="hljs-variable language_">self</span>.list_widget.setCurrentRow(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">elif</span> event.key() == Qt.Key.Key_Up:<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.list_widget.count() &gt; <span class="hljs-number">0</span>:<br>                    <span class="hljs-variable language_">self</span>.list_widget.setFocus()<br>                    <span class="hljs-variable language_">self</span>.list_widget.setCurrentRow(<span class="hljs-variable language_">self</span>.list_widget.count() - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.list_widget.hasFocus():<br>            <span class="hljs-keyword">if</span> event.key() == Qt.Key.Key_Up <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.list_widget.currentRow() == <span class="hljs-number">0</span>:<br>                <span class="hljs-variable language_">self</span>.search_edit.setFocus()<br>            <span class="hljs-keyword">elif</span> event.key() == Qt.Key.Key_Down <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.list_widget.currentRow() == <span class="hljs-variable language_">self</span>.list_widget.count() - <span class="hljs-number">1</span>:<br>                <span class="hljs-variable language_">self</span>.search_edit.setFocus()<br>        <span class="hljs-built_in">super</span>().keyPressEvent(event)<br><span class="hljs-comment"># --- 主管理界面 (VS Code 风格) ---</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagerWindow</span>(<span class="hljs-title class_ inherited__">QMainWindow</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">&quot;快捷语料管理&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.resize(<span class="hljs-number">900</span>, <span class="hljs-number">600</span>)<br>        <span class="hljs-variable language_">self</span>.data = load_data()<br>        <span class="hljs-variable language_">self</span>.init_ui()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_ui</span>(<span class="hljs-params">self</span>):<br>        central_widget = QWidget()<br>        <span class="hljs-variable language_">self</span>.setCentralWidget(central_widget)<br>        main_layout = QHBoxLayout(central_widget)<br>        main_layout.setSpacing(<span class="hljs-number">0</span>)<br>        main_layout.setContentsMargins(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># --- 左侧栏 (模块) ---</span><br>        left_panel = QWidget()<br>        left_panel.setStyleSheet(<span class="hljs-string">&quot;background-color: #252526; border-right: 1px solid #1e1e1e;&quot;</span>)<br>        left_layout = QVBoxLayout(left_panel)<br>        left_layout.setContentsMargins(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>)<br>        lbl_mod = QLabel(<span class="hljs-string">&quot;📂 模块列表&quot;</span>)<br>        lbl_mod.setProperty(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;header&quot;</span>) <span class="hljs-comment"># 使用 QSS 类选择器</span><br>        left_layout.addWidget(lbl_mod)<br>        <span class="hljs-variable language_">self</span>.module_list = QListWidget()<br>        <span class="hljs-variable language_">self</span>.module_list.setStyleSheet(<span class="hljs-string">&quot;border: none; background-color: transparent;&quot;</span>) <span class="hljs-comment"># 让列表融入背景</span><br>        <span class="hljs-variable language_">self</span>.module_list.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)<br>        <span class="hljs-variable language_">self</span>.module_list.model().rowsMoved.connect(<span class="hljs-variable language_">self</span>.on_module_reordered)<br>        <span class="hljs-variable language_">self</span>.module_list.itemClicked.connect(<span class="hljs-variable language_">self</span>.refresh_sentences)<br>        left_layout.addWidget(<span class="hljs-variable language_">self</span>.module_list)<br>        <span class="hljs-comment"># 左侧按钮组</span><br>        btn_layout_l = QHBoxLayout()<br>        btn_add_mod = QPushButton(<span class="hljs-string">&quot;+&quot;</span>)<br>        btn_add_mod.setToolTip(<span class="hljs-string">&quot;添加模块&quot;</span>)<br>        btn_add_mod.clicked.connect(<span class="hljs-variable language_">self</span>.add_module)<br>        btn_del_mod = QPushButton(<span class="hljs-string">&quot;-&quot;</span>)<br>        btn_del_mod.setToolTip(<span class="hljs-string">&quot;删除模块&quot;</span>)<br>        btn_del_mod.clicked.connect(<span class="hljs-variable language_">self</span>.del_module)<br>        btn_layout_l.addWidget(btn_add_mod)<br>        btn_layout_l.addWidget(btn_del_mod)<br>        left_layout.addLayout(btn_layout_l)<br>        <span class="hljs-comment"># --- 右侧栏 (句子) ---</span><br>        right_panel = QWidget()<br>        right_panel.setStyleSheet(<span class="hljs-string">&quot;background-color: #1e1e1e;&quot;</span>)<br>        right_layout = QVBoxLayout(right_panel)<br>        right_layout.setContentsMargins(<span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>)<br>        lbl_sent = QLabel(<span class="hljs-string">&quot;📝 句子内容&quot;</span>)<br>        lbl_sent.setProperty(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;header&quot;</span>)<br>        right_layout.addWidget(lbl_sent)<br>        <br>        lbl_hint = QLabel(<span class="hljs-string">&quot;双击条目进行编辑，使用 &#123;A | B&#125; 创建选项&quot;</span>)<br>        lbl_hint.setProperty(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;hint&quot;</span>)<br>        right_layout.addWidget(lbl_hint)<br>        <span class="hljs-variable language_">self</span>.sentence_list = QListWidget()<br>        <span class="hljs-variable language_">self</span>.sentence_list.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)<br>        <span class="hljs-variable language_">self</span>.sentence_list.model().rowsMoved.connect(<span class="hljs-variable language_">self</span>.on_sentence_reordered)<br>        <span class="hljs-variable language_">self</span>.sentence_list.itemDoubleClicked.connect(<span class="hljs-variable language_">self</span>.edit_sentence)<br>        right_layout.addWidget(<span class="hljs-variable language_">self</span>.sentence_list)<br>        <span class="hljs-comment"># 右侧按钮组</span><br>        btn_layout_r = QHBoxLayout()<br>        btn_add_sent = QPushButton(<span class="hljs-string">&quot;添加句子&quot;</span>)<br>        btn_add_sent.setProperty(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;primary&quot;</span>) <span class="hljs-comment"># 设为主要按钮样式</span><br>        btn_add_sent.setCursor(Qt.CursorShape.PointingHandCursor)<br>        btn_add_sent.clicked.connect(<span class="hljs-variable language_">self</span>.add_sentence)<br>        <br>        btn_del_sent = QPushButton(<span class="hljs-string">&quot;删除选中&quot;</span>)<br>        btn_del_sent.clicked.connect(<span class="hljs-variable language_">self</span>.del_sentence)<br>        <br>        btn_layout_r.addStretch() <span class="hljs-comment"># 把按钮推到右边</span><br>        btn_layout_r.addWidget(btn_del_sent)<br>        btn_layout_r.addWidget(btn_add_sent)<br>        right_layout.addLayout(btn_layout_r)<br>        <span class="hljs-comment"># 设置左右比例 1:2</span><br>        main_layout.addWidget(left_panel, <span class="hljs-number">1</span>)<br>        main_layout.addWidget(right_panel, <span class="hljs-number">2</span>)<br>        <span class="hljs-variable language_">self</span>.refresh_modules()<br>    <span class="hljs-comment"># --- CRUD 逻辑 ---</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">refresh_modules</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.module_list.clear()<br>        modules = <span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.data.keys())<br>        <span class="hljs-keyword">for</span> i, mod <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(modules, <span class="hljs-number">1</span>):<br>            <span class="hljs-variable language_">self</span>.module_list.addItem(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>. <span class="hljs-subst">&#123;mod&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.module_list.count() &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.module_list.setCurrentRow(<span class="hljs-number">0</span>)<br>            <span class="hljs-variable language_">self</span>.refresh_sentences()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">refresh_sentences</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.sentence_list.clear()<br>        current_item = <span class="hljs-variable language_">self</span>.module_list.currentItem()<br>        <span class="hljs-keyword">if</span> current_item:<br>            <span class="hljs-comment"># 提取实际模块名（去除编号）</span><br>            current_mod = current_item.text().split(<span class="hljs-string">&#x27;. &#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>            items = <span class="hljs-variable language_">self</span>.data.get(current_mod, [])<br>            <span class="hljs-keyword">for</span> i, sent <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(items, <span class="hljs-number">1</span>):<br>                <span class="hljs-variable language_">self</span>.sentence_list.addItem(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>. <span class="hljs-subst">&#123;sent&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_module_reordered</span>(<span class="hljs-params">self, parent, start, end, destination, row</span>):<br>        <span class="hljs-comment"># 重新排序数据中的模块</span><br>        modules = <span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.data.keys())<br>        moved_mod = modules.pop(start)<br>        modules.insert(row, moved_mod)<br>        <span class="hljs-variable language_">self</span>.data = &#123;mod: <span class="hljs-variable language_">self</span>.data[mod] <span class="hljs-keyword">for</span> mod <span class="hljs-keyword">in</span> modules&#125;<br>        <span class="hljs-variable language_">self</span>.save()<br>        <span class="hljs-variable language_">self</span>.refresh_modules()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_sentence_reordered</span>(<span class="hljs-params">self, parent, start, end, destination, row</span>):<br>        current_item = <span class="hljs-variable language_">self</span>.module_list.currentItem()<br>        <span class="hljs-keyword">if</span> current_item:<br>            current_mod = current_item.text().split(<span class="hljs-string">&#x27;. &#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>            sentences = <span class="hljs-variable language_">self</span>.data[current_mod]<br>            moved_sent = sentences.pop(start)<br>            sentences.insert(row, moved_sent)<br>            <span class="hljs-variable language_">self</span>.save()<br>            <span class="hljs-variable language_">self</span>.refresh_sentences()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_module</span>(<span class="hljs-params">self</span>):<br>        name, ok = QInputDialog.getText(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&quot;新建模块&quot;</span>, <span class="hljs-string">&quot;模块名称:&quot;</span>)<br>        <span class="hljs-keyword">if</span> ok <span class="hljs-keyword">and</span> name:<br>            <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.data:<br>                <span class="hljs-variable language_">self</span>.data[name] = []<br>                <span class="hljs-variable language_">self</span>.save()<br>                <span class="hljs-variable language_">self</span>.refresh_modules()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">del_module</span>(<span class="hljs-params">self</span>):<br>        item = <span class="hljs-variable language_">self</span>.module_list.currentItem()<br>        <span class="hljs-keyword">if</span> item:<br>            mod_name = item.text().split(<span class="hljs-string">&#x27;. &#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>            confirm = QMessageBox.question(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&quot;确认&quot;</span>, <span class="hljs-string">f&quot;删除模块 &#x27;<span class="hljs-subst">&#123;mod_name&#125;</span>&#x27; 及其所有句子?&quot;</span>, QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)<br>            <span class="hljs-keyword">if</span> confirm == QMessageBox.StandardButton.Yes:<br>                <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.data[mod_name]<br>                <span class="hljs-variable language_">self</span>.save()<br>                <span class="hljs-variable language_">self</span>.refresh_modules()<br>                <span class="hljs-variable language_">self</span>.sentence_list.clear()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_sentence</span>(<span class="hljs-params">self</span>):<br>        current_item = <span class="hljs-variable language_">self</span>.module_list.currentItem()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_item:<br>            <span class="hljs-keyword">return</span> QMessageBox.warning(<span class="hljs-variable language_">self</span>, <span class="hljs-string">&quot;提示&quot;</span>, <span class="hljs-string">&quot;请先选择一个模块&quot;</span>)<br>        current_mod = current_item.text().split(<span class="hljs-string">&#x27;. &#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>        dialog = CustomInputDialog(<span class="hljs-string">&quot;新建句子&quot;</span>, <span class="hljs-string">&quot;输入句子 (支持 &#123;A|B&#125; 格式):&quot;</span>)<br>        <span class="hljs-keyword">if</span> dialog.<span class="hljs-built_in">exec</span>() == QDialog.DialogCode.Accepted:<br>            text = dialog.getText()<br>            <span class="hljs-keyword">if</span> text:<br>                <span class="hljs-variable language_">self</span>.data[current_mod].append(text)<br>                <span class="hljs-variable language_">self</span>.save()<br>                <span class="hljs-variable language_">self</span>.refresh_sentences()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">del_sentence</span>(<span class="hljs-params">self</span>):<br>        current_item = <span class="hljs-variable language_">self</span>.module_list.currentItem()<br>        row = <span class="hljs-variable language_">self</span>.sentence_list.currentRow()<br>        <span class="hljs-keyword">if</span> current_item <span class="hljs-keyword">and</span> row &gt;= <span class="hljs-number">0</span>:<br>            current_mod = current_item.text().split(<span class="hljs-string">&#x27;. &#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.data[current_mod][row]<br>            <span class="hljs-variable language_">self</span>.save()<br>            <span class="hljs-variable language_">self</span>.refresh_sentences()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">edit_sentence</span>(<span class="hljs-params">self, item</span>):<br>        current_item = <span class="hljs-variable language_">self</span>.module_list.currentItem()<br>        <span class="hljs-keyword">if</span> current_item:<br>            current_mod = current_item.text().split(<span class="hljs-string">&#x27;. &#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># 提取实际句子（去除编号）</span><br>            sent_text = item.text().split(<span class="hljs-string">&#x27;. &#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>            dialog = CustomInputDialog(<span class="hljs-string">&quot;编辑句子&quot;</span>, <span class="hljs-string">&quot;内容:&quot;</span>, sent_text)<br>            <span class="hljs-keyword">if</span> dialog.<span class="hljs-built_in">exec</span>() == QDialog.DialogCode.Accepted:<br>                text = dialog.getText()<br>                <span class="hljs-keyword">if</span> text:<br>                    row = <span class="hljs-variable language_">self</span>.sentence_list.currentRow()<br>                    <span class="hljs-variable language_">self</span>.data[current_mod][row] = text<br>                    <span class="hljs-variable language_">self</span>.save()<br>                    <span class="hljs-variable language_">self</span>.refresh_sentences()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">self</span>):<br>        save_data(<span class="hljs-variable language_">self</span>.data)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    <br>    <span class="hljs-comment"># 应用全局样式表</span><br>    app.setStyleSheet(STYLESHEET)<br>    <br>    manager = ManagerWindow()<br>    manager.show()<br>    hotkey_signal = HotkeySignal()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show_quick_selector</span>():<br>        latest_data = load_data()<br>        selector = QuickSelector(latest_data)<br>        <br>        <span class="hljs-comment"># 让窗口出现在屏幕中心</span><br>        screen = app.primaryScreen()<br>        screen_geometry = screen.geometry()<br>        center_point = screen_geometry.center()<br>        frame_geometry = selector.frameGeometry()<br>        frame_geometry.moveCenter(center_point)<br>        selector.move(frame_geometry.topLeft())<br>        <br>        selector.<span class="hljs-built_in">exec</span>()<br>    hotkey_signal.trigger.connect(show_quick_selector)<br>    <span class="hljs-comment"># 非阻塞热键监听</span><br>    keyboard.add_hotkey(<span class="hljs-string">&#x27;ctrl + alt&#x27;</span>, <span class="hljs-keyword">lambda</span>: hotkey_signal.trigger.emit())<br>    sys.exit(app.<span class="hljs-built_in">exec</span>())<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><hr><h2 id="2-打包成-exe-文件"><a href="#2-打包成-exe-文件" class="headerlink" title="2. 打包成 exe 文件"></a>2. 打包成 exe 文件</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 1. 安装打包工具</span><br>pip install pyinstaller<br><br><br><span class="hljs-comment"># 2. 打包成 exe 文件</span><br>pyinstaller <span class="hljs-operator">-</span>-onefile <span class="hljs-operator">-</span>-windowed <span class="hljs-operator">-</span>-icon<span class="hljs-operator">=</span><span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\I</span>CO<span class="hljs-char escape_">\快</span>捷语料管理.ico&quot;</span> <span class="hljs-operator">-</span>-distpath <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合&quot;</span> <span class="hljs-string">&quot;D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\快</span>捷语料管理.py&quot;</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">1. --onefile</span><br><span class="hljs-string">1. 打包为单个 .exe 文件。</span><br><span class="hljs-string">2. --windowed</span><br><span class="hljs-string">1. 确保 GUI 程序无控制台窗口</span><br><span class="hljs-string">3. --distpath &quot;</span>D:\文件集合\<span class="hljs-string">&quot;  &quot;</span>D:\文件集合\快捷语料管理.py<span class="hljs-string">&quot;</span><br><span class="hljs-string">1. D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\ </span>是输出位置</span><br><span class="hljs-string">2. D:<span class="hljs-char escape_">\文</span>件集合<span class="hljs-char escape_">\快</span>捷语料管理.py 是输入位置</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><h3 id="3-1-数据存储位置"><a href="#3-1-数据存储位置" class="headerlink" title="3.1. 数据存储位置"></a>3.1. 数据存储位置</h3><p><img src="/2025/12/11/%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%96%99%E7%AE%A1%E7%90%86/%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%96%99%E7%AE%A1%E7%90%86.png"></p><hr><h3 id="3-2-快捷键位置"><a href="#3-2-快捷键位置" class="headerlink" title="3.2. 快捷键位置"></a>3.2. 快捷键位置</h3><p><img src="/2025/12/11/%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%96%99%E7%AE%A1%E7%90%86/%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%96%99%E7%AE%A1%E7%90%86-1.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>快捷语料管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 语法糖</title>
    <link href="/2025/12/11/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2025/12/11/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO-🐉"><a href="#一、TODO-🐉" class="headerlink" title="一、TODO 🐉"></a>一、TODO 🐉</h1><hr><h1 id="二、脑图-🐉"><a href="#二、脑图-🐉" class="headerlink" title="二、脑图 🐉"></a>二、脑图 🐉</h1><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/11/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E8%AF%AD%E6%B3%95%E7%B3%96/">http://blog.wangjia.ink/2025/12/11/笔记：Java语法糖/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/Java-2d3974fbda5e806388f1f65db943aee7?source=copy_link">https://www.notion.so/Java-2d3974fbda5e806388f1f65db943aee7?source=copy_link</a></p></li></ol><hr><h1 id="三、Java-语法糖基础-🐉"><a href="#三、Java-语法糖基础-🐉" class="headerlink" title="三、Java 语法糖基础 🐉"></a>三、Java 语法糖基础 🐉</h1><h2 id="1-Java-语法糖相关分类-🐉"><a href="#1-Java-语法糖相关分类-🐉" class="headerlink" title="1. Java 语法糖相关分类 🐉"></a>1. Java 语法糖相关分类 🐉</h2><ol><li>枚举语法糖</li><li>隐式引用语法糖</li><li>增强 <code>for</code> 循环语法糖</li><li>可变方法参数语法糖</li><li><code>Java</code> 泛型擦拭语法糖</li><li><code>Lambda</code> 表达式语法糖</li><li><code>try-with-resources</code> 语法糖</li><li>自动装箱语法糖、自动拆箱语法糖</li></ol><h3 id="1-1-枚举语法糖-🐉"><a href="#1-1-枚举语法糖-🐉" class="headerlink" title="1.1. 枚举语法糖 🐉"></a>1.1. 枚举语法糖 🐉</h3><p>详见笔记：<code>Java</code> 数据类型</p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">笔记：Java数据类型</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">http://blog.wangjia.ink/2025/11/27/笔记：Java数据类型/</a></li></ol></li></ol><hr><h3 id="1-2-隐式引用语法糖-🐉"><a href="#1-2-隐式引用语法糖-🐉" class="headerlink" title="1.2. 隐式引用语法糖 🐉"></a>1.2. 隐式引用语法糖 🐉</h3><p>详见笔记：<code>JVM</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJVM.md">笔记：JVM</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/">http://blog.wangjia.ink/2025/12/10/笔记：JVM/</a></li></ol></li></ol><hr><h3 id="1-3-字符串拼接语法糖-🐉"><a href="#1-3-字符串拼接语法糖-🐉" class="headerlink" title="1.3. 字符串拼接语法糖 🐉"></a>1.3. 字符串拼接语法糖 🐉</h3><p>详见笔记：<code>String</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：String源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/25/%E6%BA%90%E7%A0%81%EF%BC%9AString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/25/源码：String源码解析/</a></li></ol></li></ol><hr><h3 id="1-4-增强-for-循环语法糖-🐉"><a href="#1-4-增强-for-循环语法糖-🐉" class="headerlink" title="1.4. 增强 for 循环语法糖 🐉"></a>1.4. 增强 for 循环语法糖 🐉</h3><p>详见笔记：<code>Java</code> 函数式编程</p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">笔记：Java函数式编程</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/01/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">http://blog.wangjia.ink/2025/12/01/笔记：Java函数式编程/</a></li></ol></li></ol><hr><h3 id="1-5-可变方法参数语法糖-🐉"><a href="#1-5-可变方法参数语法糖-🐉" class="headerlink" title="1.5. 可变方法参数语法糖 🐉"></a>1.5. 可变方法参数语法糖 🐉</h3><p>详见笔记：<code>Java</code> 数据类型</p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">笔记：Java数据类型</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">http://blog.wangjia.ink/2025/11/27/笔记：Java数据类型/</a></li></ol></li></ol><hr><h3 id="1-6-Java-泛型擦除语法糖-🐉"><a href="#1-6-Java-泛型擦除语法糖-🐉" class="headerlink" title="1.6. Java 泛型擦除语法糖 🐉"></a>1.6. Java 泛型擦除语法糖 🐉</h3><p>详见笔记：<code>Java</code> 数据类型</p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">笔记：Java数据类型</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">http://blog.wangjia.ink/2025/11/27/笔记：Java数据类型/</a></li></ol></li></ol><hr><h3 id="1-7-Lambda-表达式语法糖-🐉"><a href="#1-7-Lambda-表达式语法糖-🐉" class="headerlink" title="1.7. Lambda 表达式语法糖 🐉"></a>1.7. Lambda 表达式语法糖 🐉</h3><p>详见笔记：<code>Java</code> 函数式编程</p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">笔记：Java函数式编程</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/01/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">http://blog.wangjia.ink/2025/12/01/笔记：Java函数式编程/</a></li></ol></li></ol><hr><h3 id="1-8-try-with-resources-语法糖-🐉"><a href="#1-8-try-with-resources-语法糖-🐉" class="headerlink" title="1.8. try-with-resources 语法糖 🐉"></a>1.8. try-with-resources 语法糖 🐉</h3><p>详见源码：<code>AutoCloseable</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.AutoCloseable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.AutoCloseable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.AutoCloseable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/10/源码：java.lang.AutoCloseable源码解析/</a></li></ol></li></ol><hr><h3 id="1-9-自动装箱语法糖、自动拆箱语法糖-🐉"><a href="#1-9-自动装箱语法糖、自动拆箱语法糖-🐉" class="headerlink" title="1.9. 自动装箱语法糖、自动拆箱语法糖 🐉"></a>1.9. 自动装箱语法糖、自动拆箱语法糖 🐉</h3><p>详见笔记：<code>Java</code> 数据类型</p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">笔记：Java数据类型</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">http://blog.wangjia.ink/2025/11/27/笔记：Java数据类型/</a></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Kafka</title>
    <link href="/2025/12/11/%E7%AC%94%E8%AE%B0%EF%BC%9AKafka/"/>
    <url>/2025/12/11/%E7%AC%94%E8%AE%B0%EF%BC%9AKafka/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：JVM</title>
    <link href="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/"/>
    <url>/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><ul><li><input disabled="" type="checkbox"> 从 2025&#x2F;12&#x2F;21T10:28 锁定彩虹</li></ul><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/">http://blog.wangjia.ink/2025/12/10/笔记：JVM/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/JVM-2c5974fbda5e8009850fdcc845fe0424?source=copy_link">https://www.notion.so/JVM-2c5974fbda5e8009850fdcc845fe0424?source=copy_link</a></p></li></ol><hr><h1 id="三、JVM-基础"><a href="#三、JVM-基础" class="headerlink" title="三、JVM 基础"></a>三、JVM 基础</h1><h2 id="JVM-概述"><a href="#JVM-概述" class="headerlink" title="JVM 概述"></a>JVM 概述</h2><p>我们知道：<code>Java</code> 的口号是： ”一次编写，到处运行“。那么问题来了：像 <code>C</code>、<code>C++</code> 等语言，可能需要针对不同的操作系统、不同的 <code>CPU</code> 架构，编写多个版本的代码。那么为什么 <code>Java</code> 能实现一次编写，到处运行？</p><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-29.png"></p><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-30.png"></p><p>为了解决这一问题，我们首先要了解一个概念：执行 Java 代码的，是 CPU。而 CPU 只看得懂该 CPU 对应的机器码。所以想要被 CPU 执行的 Java 代码，必须将 Java 代码编译成 CPU 对应的机器码。但是我们发现了，如果我们要将 Java 代码编译成 CPU 对应的机器码，那 CPU 有很多的，甚至即便是同一个 CPU，如果操作系统不同，那么调用约定也不同（C++ 也需要这样编写吗？同一个 CPU 也需要写几套代码？）。例如在 Windows 上 “调用一个方法时，前 4 个参数放在寄存器重，剩下的放栈里”，在 Linux 上 “不行，前 6 个参数都放在寄存器里”。我们也就要像 C、C++ 等语言一样，针对不同的 CPU 写多个代码，那就不符合 Java 的 “一次编写，到处运行 ” 的口号了。所以其实<br>Java 语言的设计团队，就设计了 JVM。其实 JVM 是由 C++ 代码编写的，我们安装 JVM 其实就是安装它已经在那个操作系统上的 CPU 上的机器码了。我们只需要把 Java 代码解释成 Java 字节码，当 JVM 执行 Java 字节码的时候，其实就是 JVM 根据 Java 字节码调用其对应的方法</p><p>所以 Java “一次编写，到处运行” 的秘密是：Java 设计团队帮我们做了不同操作系统、不同 CPU 的 JVM，例如：</p><ol><li>Windows + x86_64 &#x3D; Windows-x64 JVM</li><li>Linux + x86_64 &#x3D; Linux-x64 JVM</li><li>Linux + ARM64 &#x3D; Linux-aarch64 JVM</li><li>…</li></ol><p>因为这些 JVM 它们都是根据相同的一套字节码，区调用对应的方法，所以我们只需要编写一次 Java 代码就可以到处运行了，不需要我们自己去适配，我们只需要编写 Java 代码，至于 JVM 如何根据不同操作系统、不同 CPU 的特点，如何调用方法，那是 JVM 的事情，和我们无关了</p><hr><h2 id="类的编译过程"><a href="#类的编译过程" class="headerlink" title="类的编译过程"></a>类的编译过程</h2><h2 id="1-类的加载过程"><a href="#1-类的加载过程" class="headerlink" title="1. 类的加载过程"></a>1. 类的加载过程</h2><h3 id="1-1-类的加载过程组成部分-🐉"><a href="#1-1-类的加载过程组成部分-🐉" class="headerlink" title="1.1. 类的加载过程组成部分 🐉"></a>1.1. 类的加载过程组成部分 🐉</h3><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-28.png"></p><hr><h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><h5 id="验证阶段概述"><a href="#验证阶段概述" class="headerlink" title="验证阶段概述"></a>验证阶段概述</h5><p>验证阶段是类的加载过程中的第二个阶段，用于：</p><ol><li>格式验证</li><li>语义验证</li><li>字节码验证</li><li>符号引用验证</li></ol><p>从而达到确保 <code>JVM</code> 加载合法的、合理的、符合规范的字节码的目的</p><hr><h5 id="验证阶段相关流程"><a href="#验证阶段相关流程" class="headerlink" title="验证阶段相关流程"></a>验证阶段相关流程</h5><hr><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>准备阶段是类的加载过程中的第三个阶段，用于：</p><ol><li>分配静态变量、静态常量的内存空间</li><li>赋予默认值给静态变量</li><li>赋予真实值给静态常量 ❌❌❌</li></ol><p>从而达到为静态变量、静态常量提供一个 “安全” 的初始状态，防止出现野指针或非法内存访问的目的</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>HotSpot JVM 在 Java8 之前，静态变量、静态常量存储在方法区。HotSpot JVM 在 Java8 及以后，静态变量、静态常量存储在堆区（因为静态变量、静态常量存储在类对象中）</li></ol></blockquote><p>在 <code>Java8</code> 之前，静态变量、静态常量存储在方法区。但是在 <code>Java8</code> 及之后，静态变量、静态常量存储在堆区（因为静态变量、静态常量存储在类对象中，而类对象一定是在堆区被 <code>JVM</code> 分配内存空间的（因为 <code>JIT</code> 不会对类对象进行逃逸分析，因为无需也不应该对类对象进行逃逸分析，而且也无法对类对象进行逃逸分析），所以静态变量、静态常量存储在堆区）</p><hr><h4 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4><h5 id="解析阶段概述"><a href="#解析阶段概述" class="headerlink" title="解析阶段概述"></a>解析阶段概述</h5><p>解析阶段是类的加载过程中的第四个阶段</p><hr><h2 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2. 运行时数据区"></a>2. 运行时数据区</h2><h3 id="2-1-运行时数据区组成部分-🐉"><a href="#2-1-运行时数据区组成部分-🐉" class="headerlink" title="2.1. 运行时数据区组成部分 🐉"></a>2.1. 运行时数据区组成部分 🐉</h3><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-14.png"></p><hr><h3 id="2-2-本地方法栈-🐉"><a href="#2-2-本地方法栈-🐉" class="headerlink" title="2.2. 本地方法栈 🐉"></a>2.2. 本地方法栈 🐉</h3><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 <code>HotSpot JVM</code> 中，虚拟机栈、本地方法栈被合并为同一个栈</li><li>并非所有类型的 <code>JVM</code> 都支持 <code>native</code> 方法（因为在 <code>JVM</code> 规范中，如果不打算让 <code>JVM</code> 支持 <code>native</code> 方法，那么该 <code>JVM</code> 就可以不实现本地方法栈）</li></ol></blockquote><hr><h3 id="2-3-程序计数器"><a href="#2-3-程序计数器" class="headerlink" title="2.3. 程序计数器"></a>2.3. 程序计数器</h3><h4 id="2-3-1-程序计数器概述-🐉"><a href="#2-3-1-程序计数器概述-🐉" class="headerlink" title="2.3.1. 程序计数器概述 🐉"></a>2.3.1. 程序计数器概述 🐉</h4><p>程序计数器（<code>PC</code> 寄存器）用于存储当前线程要去执行的下一条 <code>JVM</code> 字节码指令的内存地址</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>程序寄存器是线程私有的内存，每个线程都拥有独立的程序寄存器</li><li><code>JVM</code> 既不会垃圾回收程序计数器，也不会因为程序计数器而抛出 <code>OutOfMemoryError</code> 错误、、<code>StackOverflowError</code> 错误</li><li>程序计数器实际记录的是 <code>JVM</code> 字节码指令的偏移量</li><li>执行引擎负责读取并执行 <code>JVM</code> 字节码指令。当执行引擎读取 <code>JVM</code> 字节码指令时，会将该 <code>JVM</code> 字节码指令的偏移量转换为其内存地址，然后再读取该 <code>JVM</code> 字节码指令。在执行引擎读取到 <code>JVM</code> 字节码指令后，程序计数器就会存储当前线程要去执行的下一条 <code>JVM</code> 字节码指令的内存地址，然后执行引擎才开始执行该 <code>JVM</code> 字节码指令（需要注意的是：这是一个非常重要的细节）</li><li>如果线程执行的是 <code>native</code> 方法，那么程序计数器存储的是 <code>undefined</code>（因为 <code>native</code> 方法本质上是离开了 <code>JVM</code> 的控制范围）</li></ol></blockquote><hr><h4 id="2-3-2-程序计数器空间大小-🐉"><a href="#2-3-2-程序计数器空间大小-🐉" class="headerlink" title="2.3.2. 程序计数器空间大小 🐉"></a>2.3.2. 程序计数器空间大小 🐉</h4><p>我们几乎可以忽略不计程序计数器的内存空间（因为程序计数器只需要记录一个内存地址）：</p><ol><li>在 <code>32 bit</code> 的 <code>JVM</code> 中，程序计数器占用 <code>4 byte</code> 的内存空间</li><li>在 <code>64 bit</code> 的 <code>JVM</code> 中，程序计数器占用 <code>8 byte</code> 的内存空间</li></ol><hr><h4 id="2-3-3-程序计数器组成部分-🐉"><a href="#2-3-3-程序计数器组成部分-🐉" class="headerlink" title="2.3.3. 程序计数器组成部分 🐉"></a>2.3.3. 程序计数器组成部分 🐉</h4><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-15.png"></p><hr><h3 id="2-4-虚拟机栈-🐉"><a href="#2-4-虚拟机栈-🐉" class="headerlink" title="2.4. 虚拟机栈 🐉"></a>2.4. 虚拟机栈 🐉</h3><h4 id="2-4-1-虚拟机栈概述-🐉"><a href="#2-4-1-虚拟机栈概述-🐉" class="headerlink" title="2.4.1. 虚拟机栈概述 🐉"></a>2.4.1. 虚拟机栈概述 🐉</h4><blockquote><p>[!NOTE] 注意事项</p><ol><li>虚拟机栈是线程私有的内存空间，每个线程都拥有独立的虚拟机栈</li><li><code>JVM</code> 既会垃圾回收虚拟机栈，也会因为虚拟机栈而抛出 <code>OutOfMemoryError</code> 错误、<code>StackOverflowError</code> 错误：<ol><li><code>OutOfMemoryError</code> 错误<ol><li><code>OutOfMemoryError: unable to create new native thread</code><ol><li>如果虚拟机栈可以动态扩展内存空间，当 <code>JVM</code> 的内存空间已满，无法再分配虚拟机栈的内存空间时，就会抛出 <code>OutOfMemoryError</code> 错误（需要注意的是：<code>HotSpot JVM</code> 并不支持虚拟机栈动态扩展内存空间）</li><li>当创建本地线程，<code>JVM</code> 的内存空间已满，无法再分配该本地线程对应的程序计数器的内存空间、该本地线程对应的虚拟机栈的内存空间时，也会抛出 <code>OutOfMemoryError</code> 错误</li></ol></li></ol></li><li><code>StackOverflowError</code> 错误<ol><li>当虚拟机栈的内存空间已满，无法再分配线程执行的方法对应的栈帧的内存空间时，<code>JVM</code> 就会抛出 <code>StackOverflowError</code> 错误</li></ol></li></ol></li></ol></blockquote><hr><h4 id="2-4-2-虚拟机栈组成部分-🐉"><a href="#2-4-2-虚拟机栈组成部分-🐉" class="headerlink" title="2.4.2. 虚拟机栈组成部分 🐉"></a>2.4.2. 虚拟机栈组成部分 🐉</h4><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-1.png"></p><hr><h4 id="2-4-3-局部变量表"><a href="#2-4-3-局部变量表" class="headerlink" title="2.4.3. 局部变量表"></a>2.4.3. 局部变量表</h4><h5 id="2-4-3-1-局部变量表概述-🐉"><a href="#2-4-3-1-局部变量表概述-🐉" class="headerlink" title="2.4.3.1. 局部变量表概述 🐉"></a>2.4.3.1. 局部变量表概述 🐉</h5><p>局部变量表用于存储方法参数、局部变量</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>局部变量表能够存储基本数据类型的元素、引用数据类型的元素（需要注意的是：局部变量表实际存储的是引用数据类型的元素的引用）、返回地址（即在 <code>Java5</code> 之前的 <code>returnAddress</code> 类型，我们知道有这个东西就行）</li><li>静态变量、静态常量、实例变量、实例常量在不同阶段会被赋予默认。但是方法参数、局部变量并不会被赋予默认值。因此我们在使用方法参数、局部变量之前，必须对其进行手动赋值，否则会导致类的编译错误</li></ol></blockquote><hr><h5 id="2-4-3-2-局部变量表底层实现-🐉"><a href="#2-4-3-2-局部变量表底层实现-🐉" class="headerlink" title="2.4.3.2. 局部变量表底层实现 🐉"></a>2.4.3.2. 局部变量表底层实现 🐉</h5><p>局部变量表的底层是：一个一维数组</p><p>局部变量表使用的一维数组的基本存储单元是变量槽（<code>Slot</code>）</p><ol><li>在 <code>32 bit</code> 的 <code>JVM</code> 中，一个 <code>Slot</code> 占用 <code>4 byte</code> 的内存空间</li><li>在 <code>64 bit</code> 的 <code>JVM</code> 中，一个 <code>Slot</code> 占用 <code>8 byte</code> 的内存空间</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>当线程调用某类的构造方法时，指向被构造的实例的内存地址的引用（即 <code>this</code>），就被存储在局部变量表的数组索引为 <code>0</code> 的数组位置中（需要注意的是：这是 <code>Java</code> 中的一个语法糖，也是我们为什么能在构造方法中使用 <code>this</code> 的原因）</li><li>当线程调用某实例的实例方法时，指向该方法所属实例的内存地址的引用（即 <code>this</code>），就被存储在局部变量表的数组索引为 <code>0</code> 的数组位置中（需要注意的是：这是 <code>Java</code> 中的一个语法糖，也是为什么我们能在实例方法中使用 <code>this</code> 的原因）</li><li>当线程调用某类的静态方法时，根本就不存在 <code>this</code>，导致我们不能在静态方法中使用 <code>this</code></li></ol></blockquote><hr><h5 id="2-4-3-3-局部变量表空间大小-🐉"><a href="#2-4-3-3-局部变量表空间大小-🐉" class="headerlink" title="2.4.3.3. 局部变量表空间大小 🐉"></a>2.4.3.3. 局部变量表空间大小 🐉</h5><p>在类的编译过程中，<code>JVM</code> 中的解释器就已经确定了局部变量表的内存空间，在运行 <code>Java</code> 程序的过程中无法更改局部变量表的内存空间：</p><ol><li>占用 <code>32 bit</code> 及以下的内存空间的数据（例如 <code>byte</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>char</code>、<code>boolean</code> 类型的数据、引用数据类型的数据、返回地址）占用一个 <code>Slot</code></li><li>占用 <code>64 bit</code> 的内存空间的数据（例如 <code>long</code>、<code>double</code> 类型的数据）占用两个 <code>Slot</code></li></ol><p>而在 <code>32 bit</code> 的 <code>JVM</code> 中，一个 <code>Slot</code> 占用 <code>4 byte</code> 的内存空间。在 <code>64 bit</code> 的 <code>JVM</code> 中，一个 <code>Slot</code> 占用 <code>8 byte</code> 的内存空间。所以我们只需知道方法中的方法参数、局部变量占用几个 <code>Slot</code>，就可以知道该方法对应的栈帧中的局部变量表的内存空间</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 <code>JVM</code> 中，<code>byte</code> 类型的数据、<code>short</code> 类型的数据、<code>char</code> 类型的数据、<code>boolean</code> 类型的数据被 <code>JVM</code> 当作 <code>int</code> 类型的数据（因为 <code>int</code> 类型数据的范围涵盖它们，而且在 <code>JVM</code> 中其实并没有专门处理它们的 <code>JVM</code> 字节码指令（需要注意的是：如果它们被存储在堆区（例如是实例的实例变量），那么它们该占用多少内存空间，就占用多少内存空间））</li><li><code>Slot</code> 是可以复用的（例如：在局部变量 <code>A</code> 的生命周期结束后，如果我们又声明了新的局部变量 <code>B</code>，那么 <code>B</code> 可能复用 <code>A</code> 的 <code>Slot</code>，从而达到节省内存空间的目的）。以如下代码为例，局部变量 <code>b</code> 会复用局部变量 <code>a</code> 的 <code>Slot</code>。因此整个 <code>main</code> 方法只需要占用两个 <code>Slot</code>，所以在 <code>32 bit</code> 的 <code>JVM</code> 中，<code>main</code> 方法对应的栈帧中的局部变量表占用 <code>8 byte</code> 的内存空间。在 <code>64 bit</code> 的 <code>JVM</code> 中，<code>main</code> 方法对应的栈帧中的局部变量表占用 <code>16 byte</code> 的内存空间</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <br>        &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>            System.out.println(a);  <br>        &#125;  <br>  <br>        &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;  <br>            System.out.println(b);  <br>        &#125;  <br>        <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="2-4-4-方法返回地址-🐉"><a href="#2-4-4-方法返回地址-🐉" class="headerlink" title="2.4.4. 方法返回地址 🐉"></a>2.4.4. 方法返回地址 🐉</h4><p>当线程调用方法时，会先把程序计数器中的内容（当前线程要去执行的下一条 <code>JVM</code> 字节码指令的内存地址）存储在被调用的方法对应的方法返回地址中，然后再开始执行该方法</p><p>如果线程在执行方法的过程中未抛出异常，那么当线程执行到以下 <code>JVM</code> 字节码指令时，就会取出该方法对应的栈帧中的方法返回地址中的内容，并存储在程序计数器中（需要注意的是：这就是方法正常退出（未抛出异常））：<br>    1. <code>ireturn</code><br>        1. 返回 <code>byte</code> 类型的数据、<code>short</code> 类型的数据、<code>int</code> 类型的数据、<code>char</code> 类型的数据、<code>boolean</code>  类型的数据<br>    2. <code>lreturn</code><br>        1. 返回 <code>long</code> 类型的数据<br>    3. <code>freturn</code><br>        1. 返回 <code>float</code> 类型的数据<br>    4. <code>dreturn</code><br>        1. 返回 <code>double</code> 类型的数据<br>    5. <code>areturn</code><br>        1. 返回引用数据类型的数据<br>    6. <code>return</code><br>        1. 仅返回（需要注意的是：仅返回适用于无返回值的方法）</p><p>但是如果线程在执行方法的过程中抛出了异常，那么线程就会去查该方法对应的异常处理器表（需要注意的是：异常处理器表被存储在方法区）：</p><ol><li>如果异常处理器表中有匹配的异常<ol><li>线程就跳转到 <code>Targer</code> 处，然后执行 <code>Target</code> 处的 <code>Java</code> 代码（即线程执行 <code>catch</code> 块。需要注意的是：不会再回到抛出异常的位置，继续执行原来的代码）</li></ol></li><li>如果异常处理器表中没有匹配的异常<ol><li>线程就会弹出该方法对应的栈帧，并继续向外抛出异常（即抛出异常给调用方）</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>方法退出分为方法正常退出（发生异常、未发生异常）、方法异常退出（需要注意的是：方法正常退出（发生异常）是在 <code>catch</code> 块中，捕获并处理了异常，并且没有抛出新的异常）</li><li>当我们捕获并处理异常时，抛出了一个新的异常，那么线程同样会再去查异常处理器表。但是如果我们没有使用嵌套 <code>catch</code> 块，就很可能无法捕获并处理这个新的异常</li></ol></blockquote><hr><h4 id="2-4-5-动态链接-🐉"><a href="#2-4-5-动态链接-🐉" class="headerlink" title="2.4.5. 动态链接 🐉"></a>2.4.5. 动态链接 🐉</h4><p>动态链接用于存储栈帧对应的方法对应的类的类的元数据区中的运行时常量池的内存地址</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>动态链接是一个指针，动态链接存储的是一个内存地址</li></ol></blockquote><hr><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><hr><h4 id="2-4-6-一些附加信息-🐉"><a href="#2-4-6-一些附加信息-🐉" class="headerlink" title="2.4.6. 一些附加信息 🐉"></a>2.4.6. 一些附加信息 🐉</h4><p>在 <code>JVM</code> 规范中，栈帧被允许添加一些附加信息（例如添加一些调试信息，从而达到调试的目的）</p><hr><h3 id="2-5-堆区"><a href="#2-5-堆区" class="headerlink" title="2.5. 堆区"></a>2.5. 堆区</h3><h4 id="2-5-1-堆区组成部分"><a href="#2-5-1-堆区组成部分" class="headerlink" title="2.5.1. 堆区组成部分"></a>2.5.1. 堆区组成部分</h4><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-19.png"></p><hr><h4 id="2-5-2-堆区概述"><a href="#2-5-2-堆区概述" class="headerlink" title="2.5.2. 堆区概述"></a>2.5.2. 堆区概述</h4><p>堆区是 <code>JVM</code> 管理内存空间的核心区域，也是整个 <code>JVM</code> 中内存空间最大的区域，几乎所有的实例都会在堆区被 <code>JVM</code> 分配内存空间（因为需要考虑逃逸分析）</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>堆区是线程共享的内存空间（但是需要考虑 <code>TLAB</code>），在单个 <code>JVM</code> 中全局唯一</li><li><code>JVM</code> 既会对堆区进行 <code>GC</code>，也会因为堆区而抛出 <code>OutOfMemoryError</code> 错误：<ol><li><code>OutOfMemoryError: Java heap space</code><ol><li>堆区内存空间不足</li></ol></li></ol></li></ol></blockquote><hr><h4 id="2-5-3-堆区空间大小"><a href="#2-5-3-堆区空间大小" class="headerlink" title="2.5.3. 堆区空间大小"></a>2.5.3. 堆区空间大小</h4><p>堆区在运行时具有初始的内存空间（需要注意的是：堆区的初始的内存空间由 <code>-Xms512m</code> 决定），并且 <code>JVM</code> 支持动态扩展、动态缩减堆区的内存空间，但是受到堆区的最大的内存空间的限制（需要注意的是：堆区的最大的内存空间由 <code>-Xmx2048m</code> 决定）。一旦堆区的内存空间超出堆区的最大的内存空间的限制，<code>JVM</code> 就可能会抛出 <code>OutOfMemoryError</code> 错误（因为需要考虑 <code>GC</code>）</p><hr><h4 id="2-5-4-实例被-JVM-在堆区分配内存空间-🌈"><a href="#2-5-4-实例被-JVM-在堆区分配内存空间-🌈" class="headerlink" title="2.5.4. 实例被 JVM 在堆区分配内存空间 🌈"></a>2.5.4. 实例被 JVM 在堆区分配内存空间 🌈</h4><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-20.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 <code>JVM</code> 执行完 <code>GC</code> 之后，<code>JVM</code> 会根据堆区的内存空间的空闲比例，动态扩展、动态缩减堆区的内存空间</li></ol></blockquote><hr><h4 id="2-5-5-TLAB"><a href="#2-5-5-TLAB" class="headerlink" title="2.5.5. TLAB"></a>2.5.5. TLAB</h4><h5 id="2-5-5-1-TLAB-概述"><a href="#2-5-5-1-TLAB-概述" class="headerlink" title="2.5.5.1. TLAB 概述"></a>2.5.5.1. TLAB 概述</h5><p>想象这样一个问题：<code>JVM</code> 为了快速为实例在堆区分配内存空间，采用了 “指针碰撞” 技术（即使用一个指针指向 <code>Eden</code> 区已经使用的内存空间的边界，当 <code>JVM</code> 为实例分配内存空间时，只需要检查剩余的内存空间是否足够，然后按需顺序偏移指针，即可完成为实例在堆区分配内存空间）</p><p>但是我们知道 “堆区是线程共享的内存空间”，在多线程并发场景下，就会出现多线程并发对堆区进行修改的情况。传统的解决方案是加锁，但这会成为一个显著的性能瓶颈</p><p>为了解决这一问题，<code>JVM</code> 提供了 <code>TLAB</code>。<code>TLAB</code> 将实例在线程共享的堆区被 <code>JVM</code> 分配内存空间，变成了实例在线程私有的 <code>TLAB</code> 被 <code>JVM</code> 分配内存空间</p><hr><h5 id="2-5-5-2-TLAB-相关流程"><a href="#2-5-5-2-TLAB-相关流程" class="headerlink" title="2.5.5.2. TLAB 相关流程"></a>2.5.5.2. TLAB 相关流程</h5><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-5.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>当线程申请新 <code>TLAB</code> 时，<code>JVM</code> 是通过 <code>CAS</code> 保证多线程并发安全的（需要注意的是：旧 <code>TLAB</code> 的剩余空间会使用一个 <code>int</code> 类型的数组填充，这部分空间会被 <code>GC</code>）</li><li><code>JVM</code> 为了快速为实例在 <code>TLAB</code> 分配内存空间，采用了 “指针碰撞” 技术（因为 <code>TLAB</code> 是线程私有的，因此不存在多线程并发场景下的安全问题）</li></ol></blockquote><hr><h4 id="2-5-6-逃逸分析"><a href="#2-5-6-逃逸分析" class="headerlink" title="2.5.6. 逃逸分析"></a>2.5.6. 逃逸分析</h4><h5 id="2-5-6-1-逃逸分析概述"><a href="#2-5-6-1-逃逸分析概述" class="headerlink" title="2.5.6.1. 逃逸分析概述"></a>2.5.6.1. 逃逸分析概述</h5><p>逃逸分析是指：<code>JIT</code> 在编译 <code>Java</code> 代码时，会分析一个实例在被创建后，是否被外部（即其他线程、调用对象的构造方法的方法之外的方法）引用。如果 <code>JIT</code> 发现一个实例并没有逃逸，就可以对这个实例进行深度的底层优化，从而极大提升性能。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>从工程实践的角度来看：能使用方法参数、局部变量，就使用方法参数、局部变量</li></ol></blockquote><hr><h5 id="2-5-6-2-逃逸分析相关分类"><a href="#2-5-6-2-逃逸分析相关分类" class="headerlink" title="2.5.6.2. 逃逸分析相关分类"></a>2.5.6.2. 逃逸分析相关分类</h5><ol><li>方法逃逸</li><li>线程逃逸</li></ol><h5 id="2-5-6-3-方法逃逸"><a href="#2-5-6-3-方法逃逸" class="headerlink" title="2.5.6.3. 方法逃逸"></a>2.5.6.3. 方法逃逸</h5><p>方法逃逸是指：在某方法中调用某对象的构造方法，创建某实例，但是该实例作为该方法的返回结果返回给了其他方法，导致其他方法可能访问该实例</p><hr><h5 id="2-5-6-4-线程逃逸"><a href="#2-5-6-4-线程逃逸" class="headerlink" title="2.5.6.4. 线程逃逸"></a>2.5.6.4. 线程逃逸</h5><p>线程逃逸是指：某实例被赋值给静态变量、静态常量，导致其他线程可能访问该实例</p><hr><h5 id="2-5-6-5-实例没有逃逸时，JIT-对其进行的优化"><a href="#2-5-6-5-实例没有逃逸时，JIT-对其进行的优化" class="headerlink" title="2.5.6.5. 实例没有逃逸时，JIT 对其进行的优化"></a>2.5.6.5. 实例没有逃逸时，JIT 对其进行的优化</h5><ol><li>栈上分配</li><li>标量替换</li><li>锁消除</li></ol><h6 id="2-5-6-5-1-栈上分配"><a href="#2-5-6-5-1-栈上分配" class="headerlink" title="2.5.6.5.1. 栈上分配"></a>2.5.6.5.1. 栈上分配</h6><p>我们知道 “几乎所有的实例都会在堆区分配内存空间”，但是堆区中的实例是需要被 <code>GC</code> 的</p><p>而栈上分配是指：如果 <code>JIT</code> 发现一个实例并没有逃逸，就可以将实例在堆区分配内存空间，变成实例在栈帧分配内存空间。这样实例就可以随栈帧被弹出而被自动销毁，完全不需要被 <code>GC</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>HotSpot JVM</code> 并没有实现真正意义上的栈上分配（因为 <code>HotSpot JVM</code> 主要是通过标量替换实现优化的）</li></ol></blockquote><hr><h6 id="2-5-6-5-2-标量替换"><a href="#2-5-6-5-2-标量替换" class="headerlink" title="2.5.6.5.2. 标量替换"></a>2.5.6.5.2. 标量替换</h6><hr><h6 id="2-5-6-5-3-锁销除"><a href="#2-5-6-5-3-锁销除" class="headerlink" title="2.5.6.5.3. 锁销除"></a>2.5.6.5.3. 锁销除</h6><p>锁销除是指：如果 <code>JIT</code> 发现一个实例并没有逃逸，就可以将该实例上加的 <code>synchronized</code> 锁去掉（因为根本不存在多线程并发场景下的安全问题）</p><hr><h3 id="2-6-方法区"><a href="#2-6-方法区" class="headerlink" title="2.6. 方法区"></a>2.6. 方法区</h3><h4 id="2-6-1-方法区组成部分"><a href="#2-6-1-方法区组成部分" class="headerlink" title="2.6.1. 方法区组成部分"></a>2.6.1. 方法区组成部分</h4><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-7.png"></p><hr><h4 id="2-6-2-方法区概述"><a href="#2-6-2-方法区概述" class="headerlink" title="2.6.2. 方法区概述"></a>2.6.2. 方法区概述</h4><blockquote><p>[!NOTE] 注意事项</p><ol><li>方法区是线程共享的内存空间，在单个 <code>JVM</code> 中全局唯一</li><li><code>JVM</code> 既会对方法区进行 <code>GC</code>，也会因为方法区而抛出 <code>OutOfMemoryError</code> 错误：<ol><li><code>OutOfMemoryError: Metaspace</code><ol><li>元空间内存不足</li></ol></li><li><code>OutOfMemoryError: PermGen space</code><ol><li>永久代内存不足</li></ol></li></ol></li><li>每一个实例都会存储一个指向其对应的类的类元数据区的内存地址（需要注意的是：存储的位置是对象头中的 <code>Klass Word</code>）</li><li>在 <code>Java8</code> 之前，静态变量、静态常量存储在方法区。但是在 <code>Java8</code> 及之后，静态变量、静态常量存储在堆区（因为静态变量、静态常量存储在类对象中，而类对象一定是在堆区被 <code>JVM</code> 分配内存空间的（因为 <code>JIT</code> 不会对类对象进行逃逸分析，因为无需也不应该对类对象进行逃逸分析，而且也无法对类对象进行逃逸分析），所以静态变量、静态常量存储在堆区）</li><li>在 <code>Java8</code> 之前的永久代，在 <code>Java8</code> 及以后的元空间，都是对 <code>JVM</code> 规范中的方法区的实现。永久代与元空间的区别在于：<ol><li>永久代的内存空间是堆区的内存空间的部分，内存空间往往较小（例如几十 <code>MB</code>），很容易导致 <code>JVM</code> 抛出 <code>OutOfMemoryError</code> 错误</li><li>而元空间的内存空间是本地内存空间的部分，内存空间甚至可以动态扩展至整个物理内存空间的上限</li></ol></li></ol></blockquote><hr><h4 id="2-6-3-类型信息"><a href="#2-6-3-类型信息" class="headerlink" title="2.6.3. 类型信息"></a>2.6.3. 类型信息</h4><p>类型信息主要包括：</p><ol><li>类的全限定名</li><li>类继承的类（即父类）的全限定名</li><li>类实现的接口的全限定名列表（因为一个类可以实现多个接口）</li><li><code>Java</code> 修饰符<ol><li>访问修饰符<ol><li><code>public</code></li><li><code>protected</code></li><li><code>package-private</code></li><li><code>private</code></li></ol></li><li>非访问修饰符<ol><li>类级别的非访问修饰符<ol><li><code>final</code></li><li><code>static</code></li><li><code>strictfp</code></li><li><code>abstract</code></li><li><code>sealed</code></li><li><code>non-sealed</code></li></ol></li></ol></li></ol></li><li>类在类的加载阶段涉及到的加载器</li></ol><p><code>static</code>：<strong>需修正</strong>。在 Java 中，<strong>顶级类（Top-level Class）不能使用 <code>static</code> 修饰</strong>。只有内部类（Nested Class）可以使用 <code>static</code>。</p><p>类元信息是<strong>所有引用类型</strong>的元数据，主要包括：</p><ol><li>类的全限定名<ol><li>例如 <code>java/lang/String</code></li><li>注意事项<ol><li>当我们日常编写时，类的全限定名是用点号，例如 <code>java.lang.String</code></li><li>但是在 JVM 内部、字节码文件（.class 文件）以及 JNI 描述符中，类的全限定名是用斜杠，例如 java&#x2F;lang&#x2F;String</li></ol></li></ol></li><li>父类的全限定名<ol><li>注意事项<ol><li>是直接父类的全限定类名</li><li>除了 <code>java.lang.Object</code>，所有类都应该有父类</li></ol></li></ol></li><li>实现接口的全限定名列表<ol><li>因为一个类可能实现多个接口，所以用列表进行记录</li></ol></li><li>类的修饰符<ol><li>访问修饰符<ol><li>public</li><li>protected</li><li>package-private（默认）</li><li>private</li></ol></li><li>非访问修饰符<ol><li>final</li><li>static</li><li>abstract</li></ol></li><li>注意事项<ol><li>这些信息在 <code>.class</code> 文件中都包含在 <code>access_flags</code> 字段</li><li>除此之外，还会记录类型本身的种类标识符，用于 JVM 判断该类到底是普通类、接口、枚举类，还是注解类型<ol><li>class</li><li>interface</li><li>enum</li><li>@interface</li></ol></li><li>虽然我们通常认为 <code>enum</code> 是一种特殊的 <code>class</code>，<code>@interface</code> 是一种特殊的 <code>interface</code>，但本质上它们都是处于同一级别的关键字，并在字节码层面通过不同的访问标志加以区分</li></ol></li></ol></li><li>类加载器引用<ol><li>加载该类的类加载器的引用</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>无论是类、接口还是枚举、注解，在 JVM 的底层实现和运行层面，它们最终都被表示为 <strong>Class</strong>，因此都会在类的元数据信息中占有一席之地。</li></ol></blockquote><hr><h2 id="3-垃圾回收器"><a href="#3-垃圾回收器" class="headerlink" title="3. 垃圾回收器"></a>3. 垃圾回收器</h2><h3 id="3-1-垃圾回收器前置基础"><a href="#3-1-垃圾回收器前置基础" class="headerlink" title="3.1. 垃圾回收器前置基础"></a>3.1. 垃圾回收器前置基础</h3><h4 id="3-1-1-垃圾回收相关策略-🌈"><a href="#3-1-1-垃圾回收相关策略-🌈" class="headerlink" title="3.1.1. 垃圾回收相关策略 🌈"></a>3.1.1. 垃圾回收相关策略 🌈</h4><ol><li>串行垃圾回收策略<ol><li>在同一时间段内，垃圾回收器仅允许一个线程执行垃圾回收。在线程执行垃圾回收的过程中，垃圾回收器会 “暂停” 所有执行 <code>Java</code> 代码的线程，直到该线程执行完垃圾回收（术语是：<code>STW</code>）</li></ol></li><li>并行垃圾回收策略<ol><li>在同一时间段内，垃圾回收器使用多个线程同时执行垃圾回收。在线程执行垃圾回收的过程中，垃圾回收器会执行 <code>STW</code></li></ol></li><li>并发垃圾回收策略<ol><li>在线程执行垃圾回收的过程中，垃圾回收器允许同时运行其他的执行 <code>Java</code> 代码的线程、执行垃圾回收的线程</li><li>需要注意的是：<ol><li>如果 <code>CPU</code> 的核数不足，执行垃圾回收的线程、其他的执行 <code>Java</code> 代码的线程可能会以交替的方式运行，这种情况才符合传统意义上的并发</li><li>即便并发垃圾回收器采用了并发垃圾回收策略，也并不代表 <code>Java</code> 程序不会垃圾回收器执行 <code>STW</code> 的情况，只不过这个情况没有被体现在并发垃圾回收策略中</li></ol></li></ol></li></ol><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-18.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>迄今为止，并不存在任何一种垃圾回收器能够实现 <code>Java</code> 程序不会出现垃圾回收器执行 <code>STW</code> 的情况</li></ol></blockquote><hr><h4 id="垃圾标记相关算法"><a href="#垃圾标记相关算法" class="headerlink" title="垃圾标记相关算法"></a>垃圾标记相关算法</h4><h5 id="垃圾标记算法概述"><a href="#垃圾标记算法概述" class="headerlink" title="垃圾标记算法概述"></a>垃圾标记算法概述</h5><p>我们知道 “几乎所有的实例都会被 <code>JVM</code> 分配堆区的内存空间”，而 <code>JVM</code> 中的垃圾回收器在清理堆区之前，必须区分该堆区中哪些实例是 “存活的”，哪些实例是 “死亡” 的</p><hr><h5 id="垃圾标记算法相关分类"><a href="#垃圾标记算法相关分类" class="headerlink" title="垃圾标记算法相关分类"></a>垃圾标记算法相关分类</h5><ol><li>引用计数算法</li><li>可达性分析算法</li></ol><hr><h4 id="垃圾清除相关算法"><a href="#垃圾清除相关算法" class="headerlink" title="垃圾清除相关算法"></a>垃圾清除相关算法</h4><ol><li>标记-清除算法</li><li>标记-复制算法</li><li>标记-整理算法</li></ol><h5 id="3-1-4-1-标记-清除算法"><a href="#3-1-4-1-标记-清除算法" class="headerlink" title="3.1.4.1. 标记-清除算法"></a>3.1.4.1. 标记-清除算法</h5><h6 id="3-1-4-1-1-标记-清除算法概述"><a href="#3-1-4-1-1-标记-清除算法概述" class="headerlink" title="3.1.4.1.1. 标记-清除算法概述"></a>3.1.4.1.1. 标记-清除算法概述</h6><p>标记-清除算法是垃圾清除算法中最基本、最古老的一种，也是许多垃圾清除算法的基础</p><hr><h6 id="标记-清除算法相关流程"><a href="#标记-清除算法相关流程" class="headerlink" title="标记-清除算法相关流程"></a>标记-清除算法相关流程</h6><h4 id="3-1-2-垃圾回收相关事件-🌈"><a href="#3-1-2-垃圾回收相关事件-🌈" class="headerlink" title="3.1.2. 垃圾回收相关事件 🌈"></a>3.1.2. 垃圾回收相关事件 🌈</h4><h5 id="3-1-2-1-新生代回收-🌈"><a href="#3-1-2-1-新生代回收-🌈" class="headerlink" title="3.1.2.1. 新生代回收 🌈"></a>3.1.2.1. 新生代回收 🌈</h5><h6 id="3-1-2-1-1-新生代回收概述-🌈"><a href="#3-1-2-1-1-新生代回收概述-🌈" class="headerlink" title="3.1.2.1.1. 新生代回收概述 🌈"></a>3.1.2.1.1. 新生代回收概述 🌈</h6><p>新生代回收（<code>Minor GC</code>、<code>Young GC</code>）是指：垃圾回收器垃圾回收堆区中的新生代的内存空间</p><hr><h6 id="3-1-2-1-2-新生代回收触发条件-🌈"><a href="#3-1-2-1-2-新生代回收触发条件-🌈" class="headerlink" title="3.1.2.1.2. 新生代回收触发条件 🌈"></a>3.1.2.1.2. 新生代回收触发条件 🌈</h6><ol><li>当堆区中的 <code>Eden</code> 区的剩余的内存空间不足，<code>JVM</code> 不能直接为新的实例分配堆区中的 <code>Eden</code> 区的内存空间时，就会触发垃圾回收器执行 <code>Minor GC</code></li></ol><hr><h5 id="3-1-2-2-老年代回收-🌈"><a href="#3-1-2-2-老年代回收-🌈" class="headerlink" title="3.1.2.2. 老年代回收  🌈"></a>3.1.2.2. 老年代回收  🌈</h5><p>老年代回收（<code>Major GC</code>）是指：垃圾回收器垃圾回收堆区中的老年代的内存空间</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Major GC</code> 这个词很容易引起混淆。因为在不同的垃圾回收器中，<code>Major GC</code> 有不同的含义：<ol><li>在 <code>CMS GC</code> 中，<code>Major GC</code> 是指：垃圾回收器垃圾回收堆区中的老年代的内存空间</li><li>在其他的垃圾回收器中，在垃圾回收器执行 <code>Major GC</code> 的过程中，该垃圾回收器通常也会执行 <code>Minor GC</code>。因此，我们通常认为 <code>Major GC ≈ Full GC</code></li></ol></li></ol></blockquote><hr><h5 id="3-1-2-3-整堆回收-🌈"><a href="#3-1-2-3-整堆回收-🌈" class="headerlink" title="3.1.2.3. 整堆回收 🌈"></a>3.1.2.3. 整堆回收 🌈</h5><p>整堆回收（<code>Full GC</code>）是指：垃圾回收器垃圾回收堆区的内存空间、方法区的内存空间</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>垃圾回收器执行<code>Full GC</code> 的开销非常大，一个优秀的 <code>Java</code> 程序应该尽量避免触发垃圾回收器执行 <code>Full GC</code></li></ol></blockquote><hr><h5 id="3-1-2-4-混合回收-🌈"><a href="#3-1-2-4-混合回收-🌈" class="headerlink" title="3.1.2.4. 混合回收 🌈"></a>3.1.2.4. 混合回收 🌈</h5><p>混合回收是 <code>G1 GC</code> 独有的概念，同时也是该垃圾回收器的精髓。混合回收（<code>Mixed GC</code>）是指：垃圾回收器垃圾回收堆区中的新生代的 <code>Region</code> 的内存空间、部分堆区中的老年代的 <code>Region</code> 的内存空间</p><hr><h3 id="3-2-垃圾回收器相关分类-🌈"><a href="#3-2-垃圾回收器相关分类-🌈" class="headerlink" title="3.2. 垃圾回收器相关分类 🌈"></a>3.2. 垃圾回收器相关分类 🌈</h3><ol><li>以垃圾回收器垃圾回收的内存区域分类：<ol><li>整堆垃圾回收器<ol><li><code>ZGC</code></li><li><code>G1 GC</code></li></ol></li><li>新生代垃圾回收器<ol><li><code>Serial GC</code></li><li><code>ParNew GC</code></li><li><code>Parallel Scavenge GC</code></li></ol></li><li>老年代垃圾回收器<ol><li><code>CMS GC</code></li><li><code>Serial Old GC</code></li><li><code>Parallel Old GC</code></li></ol></li></ol></li><li>以垃圾回收器使用的垃圾回收策略分类：<ol><li>串行垃圾回收器<ol><li><code>Serial GC</code></li><li><code>Serial Old GC</code></li></ol></li><li>并行垃圾回收器<ol><li><code>ParNew GC</code></li><li><code>Parallel Old GC</code></li><li><code>Parallel Scavenge GC</code></li></ol></li><li>并发垃圾回收器<ol><li><code>ZGC</code></li><li><code>G1 GC</code></li><li><code>CMS GC</code></li></ol></li></ol></li></ol><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-21.png"></p><hr><h3 id="3-3-垃圾回收器常用组合-🌈"><a href="#3-3-垃圾回收器常用组合-🌈" class="headerlink" title="3.3. 垃圾回收器常用组合 🌈"></a>3.3. 垃圾回收器常用组合 🌈</h3><p><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-23.png"></p><table><thead><tr><th>垃圾回收器组合</th><th>Serial GC + Serial Old GC</th><th>Parallel Scavenge GC + Parallel Old GC</th><th>Parnew GC + CMS GC</th><th>G1 GC</th><th>ZGC</th></tr></thead><tbody><tr><td><strong>支持 Minor GC</strong></td><td>✅（<code>Serial GC</code> 负责执行 <code>Minor GC</code>）</td><td>✅（<code>Parallel Scavenge GC</code> 负责执行 <code>Minor GC</code>）</td><td>✅（<code>Parnew GC</code> 负责执行 <code>Minor GC</code>）</td><td>✅</td><td>—</td></tr><tr><td><strong>支持 Major GC</strong></td><td>❌</td><td>❌</td><td>✅（<code>CMS GC</code> 负责执行 <code>Major GC</code>）</td><td>❌</td><td>—</td></tr><tr><td><strong>支持 Mixed GC</strong></td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>—</td></tr><tr><td><strong>支持 Full GC</strong></td><td>✅（<code>Serial Old GC</code> 负责执行 <code>Full GC</code>）</td><td>✅（<code>Parallel Old GC</code> 负责执行 <code>Full GC</code>）</td><td>✅（<code>Serial Old GC</code> 负责执行 <code>Full GC</code>）</td><td>✅</td><td>—</td></tr></tbody></table><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>HotSpot JVM</code> 在 <code>Java9</code> 及以后，不再支持红色虚线的组合</li><li><code>HotSpot JVM</code> 在 <code>Java14</code> 及以后，不再支持 <code>CMS GC</code></li><li><code>HotSpot JVM</code> 在 <code>Java14</code> 及以后弃用绿色虚线的组合（需要注意的是：该组合至今仍能使用）</li></ol></blockquote><hr><h4 id="3-3-1-Serial-GC-Serial-Old-GC-🌈"><a href="#3-3-1-Serial-GC-Serial-Old-GC-🌈" class="headerlink" title="3.3.1. Serial GC + Serial Old GC 🌈"></a>3.3.1. Serial GC + Serial Old GC 🌈</h4><h5 id="3-3-1-1-Serial-GC-Serial-Old-GC-概述-🌈"><a href="#3-3-1-1-Serial-GC-Serial-Old-GC-概述-🌈" class="headerlink" title="3.3.1.1. Serial GC + Serial Old GC 概述 🌈"></a>3.3.1.1. Serial GC + Serial Old GC 概述 🌈</h5><p><code>Serial GC + Serial Old GC</code> 支持 <code>Minor GC</code>、<code>Full GC</code>：</p><ol><li><code>Serial GC</code> 使用单线程，采用串行垃圾回收策略，使用标记-复制算法执行 <code>Minor GC</code></li><li><code>Serial Old GC</code> 使用单线程，采用串行垃圾回收策略，使用标记-整理算法执行 <code>Full GC</code></li></ol><hr><h5 id="3-3-1-2-Serial-GC-Serial-Old-GC-相关流程-🌈"><a href="#3-3-1-2-Serial-GC-Serial-Old-GC-相关流程-🌈" class="headerlink" title="3.3.1.2. Serial GC + Serial Old GC 相关流程 🌈"></a>3.3.1.2. Serial GC + Serial Old GC 相关流程 🌈</h5><h6 id="3-3-1-2-1-Minor-GC-流程-🌈"><a href="#3-3-1-2-1-Minor-GC-流程-🌈" class="headerlink" title="3.3.1.2.1. Minor GC 流程  🌈"></a>3.3.1.2.1. Minor GC 流程  🌈</h6><p>当堆区中的 <code>Eden</code> 区的剩余的内存空间不足，<code>JVM</code> 不能直接为新的实例分配堆区中的 <code>Eden</code> 区的内存空间时，就会触发 <code>Serial GC</code> 执行 <code>Minor GC</code>:</p><ol><li><code>Serial GC</code> 首先会执行 <code>STW</code></li><li>然后 <code>Serial GC</code> 使用单线程，采用串行垃圾回收策略，使用标记-复制算法执行 <code>Minor GC</code></li><li>在 <code>Serial GC</code> 执行完 <code>Minor GC</code> 后，<code>Serial GC</code> 会恢复运行被 “暂停” 的线程</li></ol><hr><h6 id="3-3-1-2-2-Full-GC-流程-🌈"><a href="#3-3-1-2-2-Full-GC-流程-🌈" class="headerlink" title="3.3.1.2.2. Full GC 流程 🌈"></a>3.3.1.2.2. Full GC 流程 🌈</h6><p>触发 <code>Serial Old GC</code> 执行 <code>Full GC</code> 的条件：</p><ol><li>当堆区中的老年代的剩余的内存空间不足，垃圾回收器在执行 <code>Minor GC</code> 的过程中，堆区中的 <code>Survivor 0</code> 区、<code>Survivor 1</code> 区中的实例晋升到堆区中的老年代失败时，就会触发 <code>Serial Old GC</code> 执行 <code>Full GC</code></li><li>当堆区中的老年代的剩余的内存空间不足，<code>JVM</code> 不能直接为新的实例分配堆区中的老年代的内存空间时，就会触发 <code>Serial Old GC</code> 执行 <code>Full GC</code></li><li>垃圾回收器在执行 <code>Minor GC</code> 之前，<code>JVM</code> 会先检查堆区中的老年代的剩余的、最大的、连续的内存空间，是否大于堆区中的新生代中的所有实例的内存空间之和（因为如果大于，就说明垃圾回收器执行 <code>Minor GC</code> 是绝对安全的）。然后 <code>JVM</code> 会再检查堆区中的老年代的剩余的、最大的、连续的内存空间，是否大于历次从堆区中的 <code>Survivor 0</code> 区、<code>Survivor 1</code> 区晋升到堆区中的老年代的实例的内存空间之和的平均值（因为垃圾回收器执行 <code>Full GC</code> 的开销非常大，所以 <code>JVM</code> 是能不让垃圾回收器执行 <code>Full GC</code>，就不让垃圾回收器执行 <code>Full GC</code>）。当 <code>JVM</code> 发现两者的条件不满足时，就会触发 <code>Serial Old GC</code> 执行 <code>Full GC</code>（术语是：空间分配担保失败）</li><li>调用 <code>System.gc</code><ol><li>当线程调用 <code>System.gc</code> 时，<code>JVM</code> 会建议垃圾回收器执行 <code>Full GC</code>（需要注意的是：只是建议，不保证一定会执行）</li></ol></li><li>当方法区的内存空间不足时</li></ol><p><code>Serial Old GC</code> 执行 <code>Full GC</code> 的流程：</p><ol><li><code>Serial Old GC</code> 首先会执行 <code>STW</code></li><li>然后 <code>Serial Old GC</code> 使用单线程，采用串行垃圾回收策略，使用标记-整理算法执行 <code>Full GC</code></li><li>在 <code>Serial Old GC</code> 执行完 <code>Full GC</code> 后，<code>Serial Old GC</code> 会恢复运行被 “暂停” 的线程</li></ol><hr><h4 id="3-3-2-Parallel-Scavenge-GC-Parallel-Old-GC-🌈"><a href="#3-3-2-Parallel-Scavenge-GC-Parallel-Old-GC-🌈" class="headerlink" title="3.3.2. Parallel Scavenge GC + Parallel Old GC 🌈"></a>3.3.2. Parallel Scavenge GC + Parallel Old GC 🌈</h4><h5 id="3-3-2-1-Parallel-Scavenge-GC-Parallel-Old-GC-概述-🌈"><a href="#3-3-2-1-Parallel-Scavenge-GC-Parallel-Old-GC-概述-🌈" class="headerlink" title="3.3.2.1. Parallel Scavenge GC + Parallel Old GC 概述 🌈"></a>3.3.2.1. Parallel Scavenge GC + Parallel Old GC 概述 🌈</h5><p><code>Parallel Scavenge GC + Parallel Old GC</code> 是 <code>HotSpot JVM</code> 在 <code>Java8</code> 的默认的垃圾回收器，支持 <code>Minor GC</code>、<code>Full GC</code>：</p><ol><li><code>Parallel Scavenge GC</code> 使用多线程，采用并行垃圾回收策略，使用标记-复制算法执行 <code>Minor GC</code></li><li><code>Parallel Old GC</code> 使用多线程，采用并行垃圾回收策略，使用标记-整理算法执行 <code>Full GC</code></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Parallel Scavenge GC + Parallel Old GC</code> 也被称之为 “吞吐量优先的垃圾回收器组合”</li><li><code>Parallel Scavenge GC + Parallel Old GC</code> 具备自适应调节的能力。我们只需要配置少量 <code>JVM</code> 参数，<code>Parallel Scavenge GC</code> 就会根据运行 <code>Java</code> 程序时的状况，自动调整部分 <code>JVM</code> 参数，从而达到贴近我们配置的 <code>JVM</code> 参数的目的：<ol><li><code>-XX:MaxGCPauseMillis</code><ol><li>用于配置 <code>Parallel Scavenge GC + Parallel Old GC</code> 在执行垃圾回收的过程中，执行 <code>STW</code> 的被允许的最长时间</li></ol></li><li><code>-XX:GCTimeRatio</code><ol><li>用于配置 <code>Parallel Scavenge GC + Parallel Old GC</code> 执行垃圾回收的时间，占运行 <code>Java</code> 程序的总时间的比例</li></ol></li><li><code>-XX:+UseAdaptiveSizePolicy</code><ol><li>用于开启 <code>Parallel Scavenge GC + Parallel Old GC</code> 的自适应调节的功能</li></ol></li></ol></li></ol></blockquote><hr><h5 id="3-3-2-2-Parallel-Scavenge-GC-Parallel-Old-GC-相关流程-🌈"><a href="#3-3-2-2-Parallel-Scavenge-GC-Parallel-Old-GC-相关流程-🌈" class="headerlink" title="3.3.2.2. Parallel Scavenge GC + Parallel Old GC 相关流程 🌈"></a>3.3.2.2. Parallel Scavenge GC + Parallel Old GC 相关流程 🌈</h5><p><code>Parallel Scavenge GC + Parallel Old GC</code> 的流程相似于 <code>Serial GC + Serial Old GC</code> 的流程，只不过 <code>Parallel Scavenge GC + Parallel Old GC</code> 是使用多线程执行垃圾回收，并且具备自适应的调节的能力</p><hr><h4 id="3-3-3-ParNew-GC-CMS-GC-🌈"><a href="#3-3-3-ParNew-GC-CMS-GC-🌈" class="headerlink" title="3.3.3. ParNew GC + CMS GC 🌈"></a>3.3.3. ParNew GC + CMS GC 🌈</h4><h5 id="3-3-3-1-ParNew-GC-CMS-GC-概述-🌈"><a href="#3-3-3-1-ParNew-GC-CMS-GC-概述-🌈" class="headerlink" title="3.3.3.1. ParNew GC + CMS GC 概述 🌈"></a>3.3.3.1. ParNew GC + CMS GC 概述 🌈</h5><p><code>ParNew GC + CMS GC</code> 支持 <code>Minor GC</code>、<code>Major GC</code>、<code>Full GC</code>：</p><ol><li><code>ParNew GC</code> 使用多线程，采用并行垃圾回收策略，使用标记-复制算法执行 <code>Minor GC</code></li><li><code>CMS GC</code> 使用多线程，采用并行垃圾回收策略、并发垃圾回收策略，使用标记-清除算法执行 <code>Major GC</code></li><li><code>Serial Old GC</code> 使用单线程，采用串行垃圾回收策略，使用标记-整理算法执行 <code>Full GC</code>（需要注意的是：<code>Serial Old GC</code> 是 <code>CMS GC</code> 的后备垃圾回收器）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然 <code>CMS GC</code> 是一个老年代垃圾回收器。但是 <code>CMS GC</code> 无法搭配在 <code>HotSpot JVM</code> 在 <code>Java4</code> 及以后就存在的 <code>Parallel Scavenge GC</code>。因此，<code>ParNew GC</code> 诞生的使命就是作为 <code>CMS GC</code> 配套的新生代垃圾回收器</li><li>由于 <code>CMS GC</code> 的后备垃圾回收器是 <code>Serial Old GC</code>，这是 <code>G1 GC</code> 取代 <code>CMS GC</code> 的核心原因之一</li><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>既然使用标记-清除算法会产生内存空间碎片，那么为什么 <code>CMS GC</code> 在执行 <code>Major GC</code> 时，不使用标记-整理算法？<ol><li>因为标记-整理算法需要移动存活的实例，而移动存活的实例会改变该实例的内存地址</li><li>所以如果 <code>CMS GC</code> 在运行并发清除阶段时，使用标记-整理算法，就必须执行 <code>STW</code>，否则会导致引用关系错乱</li></ol></li></ol></li></ol></blockquote><hr><h5 id="3-3-3-2-ParNew-GC-CMS-GC-相关流程-🌈"><a href="#3-3-3-2-ParNew-GC-CMS-GC-相关流程-🌈" class="headerlink" title="3.3.3.2. ParNew GC + CMS GC 相关流程 🌈"></a>3.3.3.2. ParNew GC + CMS GC 相关流程 🌈</h5><h6 id="3-3-3-2-1-Minor-GC-流程-🌈"><a href="#3-3-3-2-1-Minor-GC-流程-🌈" class="headerlink" title="3.3.3.2.1. Minor GC 流程 🌈"></a>3.3.3.2.1. Minor GC 流程 🌈</h6><p><code>ParNew GC</code> 执行 <code>Minor GC</code> 的流程相似于 <code>Parallel Scavenge GC</code> 执行 <code>Minor GC</code> 的流程，只不过 <code>ParNew GC</code> 不具备自适应调节的能力</p><hr><h6 id="3-3-3-2-2-Major-GC-流程-🌈"><a href="#3-3-3-2-2-Major-GC-流程-🌈" class="headerlink" title="3.3.3.2.2. Major GC 流程 🌈"></a>3.3.3.2.2. Major GC 流程 🌈</h6><p>当堆区中的剩余的老年代的内存空间的使用率达到某阈值时，就会触发 <code>CMS GC</code> 执行 <code>Major GC</code>：</p><ol><li>初始标记阶段（<code>Initial Mark Phase</code>）<ol><li>在<code>CMS GC</code> 进行初始标记阶段的过程中，<code>CMS GC</code> 使用多线程，采用并行垃圾回收策略，标记出 <code>GC Roots</code> 直接可达的实例（需要注意的是：不做深度遍历)</li><li>在 <code>CMS GC</code> 进行初始标记阶段的过程中，<code>CMS GC</code> 会执行 <code>STW</code>。但是由于 <code>CMS GC</code> 需要标记的实例的数量较少，所以 <code>CMS GC</code> 执行 <code>STW</code> 的时间较短</li></ol></li><li>并发标记阶段（<code>Concurrent Mark Phase</code>）<ol><li>在 <code>CMS GC</code> 进行并发标记阶段的过程中，<code>CMS GC</code> 使用多线程，采用并发垃圾回收策略，遍历整个实例图，标记出所有 <code>GC Roots</code> 可达的实例</li><li><code>CMS GC</code> 进行并发标记阶段会耗费较长时间。但是在 <code>CMS GC</code> 进行并发标记阶段的过程中，<code>CMS GC</code> 不会执行 <code>STW</code></li></ol></li><li>重新标记阶段（<code>Remark Phase</code>）<ol><li>在 <code>CMS GC</code> 进行重新标记阶段的过程中，<code>CMS GC</code> 使用多线程，采用并行垃圾回收策略，修正在 <code>CMS GC</code> 进行并发标记阶段的过程中，由于其他的线程继续运行，而导致标记不准确的部分实例</li><li>在 <code>CMS GC</code> 进行重新标记阶段的过程中，<code>CMS GC</code> 会执行 <code>STW</code>（需要注意的是：在 <code>CMS GC</code> 进行重新标记阶段的过程中，执行 <code>STW</code> 的时间，会比在 <code>CMS GC</code> 进行初始标记阶段的过程中，执行 <code>STW</code> 的时间要长）</li></ol></li><li>并发清除阶段（<code>Concurrent Sweep Phase</code>）<ol><li>在 <code>CMS GC</code> 进行并发清除阶段的过程中，<code>CMS GC</code> 使用多线程，采用并发垃圾回收策略，使用标记-清理算法执行 <code>Major GC</code></li><li>在 <code>CMS GC</code> 进行并发清除阶段的过程中，<code>CMS GC</code> 不会执行 <code>STW</code></li></ol></li><li>重置线程阶段（<code>Reset Thread Phase</code>）<ol><li>在 <code>CMS GC</code> 进行重置线程阶段的过程中，<code>CMS GC</code> 使用多线程，采用并发垃圾回收策略，“恢复” 在本次在 <code>CMS GC</code> 执行 <code>Major GC</code> 的过程中，使用到的数据结构、实例被标记的状态，为下次 <code>CMS GC</code> 执行 <code>Major GC</code> 做准备</li><li>在 <code>CMS GC</code> 进行重置线程阶段的过程中，<code>CMS GC</code> 不会执行 <code>STW</code><br><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-24.png"></li></ol></li></ol><hr><h6 id="3-3-3-2-3-Full-GC-流程-🌈"><a href="#3-3-3-2-3-Full-GC-流程-🌈" class="headerlink" title="3.3.3.2.3. Full GC 流程 🌈"></a>3.3.3.2.3. Full GC 流程 🌈</h6><p>想象这样一个问题：虽然 <code>CMS GC</code> 的策略是 “主动预防“。但是在运行 <code>Java</code> 程序的过程中，仍然可能出现一些极端的情况（例如：<code>CMS GC</code> 执行 <code>Major GC</code> 垃圾回收堆区中的老年代中的实例的速度，赶不上堆区中的 <code>Survivor 0</code> 区、<code>Survivor 1</code> 区中的实例晋升到堆区中的老年代的速度）</p><p>为了解决这一问题，<code>CMS GC</code> 会使用 <code>CMS GC</code> 的后备垃圾回收器（即 <code>Serial Old GC</code>）执行 <code>Full GC</code></p><hr><h4 id="3-3-4-G1-GC-🌈"><a href="#3-3-4-G1-GC-🌈" class="headerlink" title="3.3.4. G1 GC 🌈"></a>3.3.4. G1 GC 🌈</h4><h5 id="3-3-4-1-G1-GC-概述-🌈"><a href="#3-3-4-1-G1-GC-概述-🌈" class="headerlink" title="3.3.4.1. G1 GC 概述 🌈"></a>3.3.4.1. G1 GC 概述 🌈</h5><p><code>G1 GC</code> 是 <code>HotSpot JVM</code> 在 <code>Java9</code> 及以后的默认的垃圾回收器，支持 <code>Minor GC</code>、<code>Mixed GC</code>、<code>Full GC</code>：</p><ol><li><code>G1 GC</code> 使用多线程，采用并发垃圾回收策略，使用标记-复制算法执行 <code>Minor GC</code></li><li><code>G1 GC</code> 使用多线程，采用并行垃圾回收策略、并发垃圾回收策略，使用标记-清除算法、标记-复制算法执行 <code>Mixed GC</code>（需要注意的是：<code>G1 GC</code> 使用标记-清除算法垃圾回收的是 <code>Humongous</code> 区）</li><li><code>G1 GC</code> 使用单线程或多线程（需要注意的是：看 <code>HotSpot JVM</code> 的 <code>Java</code> 版本），采用并发垃圾回收策略，使用标记-整理算法执行 <code>FUll GC</code></li></ol><p>在之前的垃圾回收器中，<code>JVM</code> 将堆区的内存空间划分新生代、老年代。但是在 <code>G1 GC</code> 中，<code>JVM</code> 将堆区的内存空间划分为多个内存空间相等的 <code>Region</code></p><p>除此之外，<code>G1 GC</code> 还引入一种新的内存区域（即 <code>Humongous</code> 区）。多个连续的 <code>Region</code> 组成一个 <code>Humongous</code> 区，专门用于存储超大实例。如果实例需要的内存空间超过一个 <code>Region</code> 的 <code>50%</code> 的内存空间，<code>JVM</code> 就会为该实例分配 <code>Humongous</code> 区的内存空间（需要注意的是：我们通常把 <code>Humongous</code> 区看作是堆区中的老年代中的一部分）<br><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-26.png"></p><p>那么问题来了：既然 <code>G1 GC</code> 执行垃圾回收是按照 <code>Region</code> 为单位，那么 <code>G1 GC</code> 该如何判断其他 <code>Region</code> 中的实例，是否引用 <code>G1 GC</code> 要垃圾回收的 <code>Region</code> 中的实例？</p><p>为了解决这一问题，<code>G1 GC</code> 引入了记忆集（<code>Rset</code>、<code>Remembered Set</code>） 。每个 <code>Region</code> 都维护了一个 <code>RSet</code>，专门用于记录引用该 <code>Region</code> 中的实例的其他 <code>Region</code> 中的实例<br><img src="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM/%E7%AC%94%E8%AE%B0%EF%BC%9AJVM-25.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>JVM</code> 默认根据堆区的最大的内存空间，将堆区的内存空间划分为 <code>2048</code> 个内存空间相等的 <code>Region</code>，每个 <code>Region</code> 的内存空间为 <code>1MB - 32MB</code>（例如：堆区的最大内存空间为 <code>32GB</code>，那么每个 <code>Region</code> 的内存空间为 <code>16MB</code>。所以在刚运行 <code>Java</code> 程序，堆区的内存空间为 <code>4GB</code> 时，<code>Region</code> 只有 <code>256</code> 个）<ol><li>需要注意的是：<ol><li><code>Region</code> 的内存空间必须为  $2^n$ <code>MB</code></li><li>我们可以通过配置 <code>JVM</code> 参数，手动指定 <code>Region</code> 的内存空间（需要注意的是：在这种情况下，<code>Region</code> 的数量不再固定为 <code>2048</code> 个）</li></ol></li></ol></li><li><code>G1 GC</code> 具备自适应调节的能力。我们只需要配置少量 <code>JVM</code> 参数，<code>G1 GC</code> 就会根据运行 <code>Java</code> 程序时的状况，自动调整部分 <code>JVM</code> 参数，从而达到贴近我们配置的 <code>JVM</code> 参数的目的：<ol><li><code>-XX:MaxGCPauseMillis</code><ol><li>用于配置 <code>Parallel Scavenge GC + Parallel Old GC</code> 在执行垃圾回收的过程中，执行 <code>STW</code> 的被允许的最长时间（需要注意的是：对 <code>G1 GC</code> 执行 <code>Full GC</code> 不起作用）</li></ol></li></ol></li></ol></blockquote><hr><h5 id="3-3-4-2-G1-GC-相关流程-🌈"><a href="#3-3-4-2-G1-GC-相关流程-🌈" class="headerlink" title="3.3.4.2. G1 GC 相关流程 🌈"></a>3.3.4.2. G1 GC 相关流程 🌈</h5><h6 id="3-3-4-2-1-Minor-GC-流程-🌈"><a href="#3-3-4-2-1-Minor-GC-流程-🌈" class="headerlink" title="3.3.4.2.1. Minor GC 流程 🌈"></a>3.3.4.2.1. Minor GC 流程 🌈</h6><p>当堆区中的 <code>Eden</code> 区的内存空间不足，<code>JVM</code> 不能直接为新的实例分配堆区中的 <code>Eden</code> 区的内存空间时，就会触发 <code>G1 GC</code> 执行 <code>Minor GC</code>（需要注意的是：在 <code>G1 GC</code> 中，<code>Minor GC</code> 被称之为 “<code>Yong-Only Phase</code>”）：</p><ol><li><code>G1 GC</code> 首先会执行 <code>STW</code></li><li>然后 <code>G1 GC</code> 会将所有堆区中的新生代的 <code>Region</code> 存储到回收集合（<code>Cset</code>、<code>Collection Set</code>）</li><li>接着 <code>G1 GC</code> 会使用多线程，采用并行垃圾回收策略，使用标记-复制算法执行 <code>MINOR GC</code></li><li>在 <code>G1 GC</code> 执行完 <code>Minor GC</code> 后，<code>G1 GC</code> 会恢复运行被 “暂停” 的线程</li></ol><hr><h6 id="3-3-4-2-2-Mixed-GC-流程-🌈"><a href="#3-3-4-2-2-Mixed-GC-流程-🌈" class="headerlink" title="3.3.4.2.2. Mixed GC 流程 🌈"></a>3.3.4.2.2. Mixed GC 流程 🌈</h6><p>当堆区中的老年代的内存空间的使用率达到阈值时，就会触发 <code>G1 GC</code> 执行 <code>Mixed GC</code>（需要注意的是：在 <code>G1 GC</code> 中，<code>Mixed GC</code> 被称之为 “<code>Space-Reclamation Phase</code>”）：</p><ol><li>初始标记阶段（<code>Initial Mark Phase</code>）<ol><li>在 <code>G1 GC</code> 进行初始标记阶段的过程中，<code>G1 GC</code> 使用多线程，采用并行垃圾回收策略，标记出 <code>GC Roots</code> 直接可达的实例（需要注意的是：不做深度遍历）</li><li>在 <code>G1 GC</code> 进行初始标记阶段的过程中，<code>G1 GC</code> 会执行 <code>STW</code>。但是由于 <code>G1 GC</code> 需要标记的实例的数量较少，所以 <code>G1 GC</code> 执行 <code>STW</code> 的时间较短</li></ol></li><li>并发标记阶段（<code>Concurrent Mark Phase</code>）<ol><li>在 <code>G1 GC</code> 进行并发标记阶段的过程中，<code>G1 GC</code> 使用多线程，采用并发垃圾回收策略，遍历整个实例图，标记出所有 <code>GC Roots</code> 可达的实例</li><li><code>G1 GC</code> 进行并发标记阶段会耗费较长时间。但是在 <code>G1 GC</code> 进行并发标记阶段的过程中，<code>G1 GC</code> 不会执行 <code>STW</code></li></ol></li><li>重新标记阶段（<code>Remark Phase</code>）<ol><li>在 <code>G1 GC</code> 进行重新标记阶段的过程中，<code>G1 GC</code> 使用多线程，采用并行垃圾回收策略，修正在 <code>G1 GC</code> 进行并发标记阶段的过程中，由于其他的线程继续运行，而导致标记不准确的部分实例</li><li>在 <code>G1 GC</code> 进行重新标记阶段的过程中，<code>G1 GC</code> 会执行 <code>STW</code>（需要注意的是：在 <code>G1 GC</code> 进行重新标记阶段的过程中，执行 <code>STW</code> 的时间，会比在 <code>G1 GC</code> 进行初始标记阶段的过程中，执行 <code>STW</code> 的时间要长）</li></ol></li><li>筛选清理阶段（<code>Cleanup Phase</code>）<ol><li>在 <code>G1 GC</code> 进行筛选清理阶段的过程中，<code>G1 GC</code> 会将所有堆区中的新生代的 <code>Region</code> 存储代 <code>Cset</code>。然后 <code>G1 GC</code> 会排序所有 <code>Region</code> 的 “回收价值”，并根据我们配置的 <code>JVM</code> 参数，将部分高 “回收价值” 的堆区中的老年代的 <code>Region</code> 存储到 <code>Cset</code></li><li>在 <code>G1 GC</code> 进行筛选清理阶段，<code>G1 GC</code> 会执行 <code>STW</code></li></ol></li><li>混合回收阶段（<code>Mixed GC Phase</code>）<ol><li>在 <code>G1 GC</code> 进行混合回收阶段的过程中，<code>G1 GC</code> 使用多线程，采用并行垃圾回收策略，使用标记-复制算法执行 <code>Mixed GC</code>（需要注意的是：实际会垃圾回收所有堆区中的新生代的 <code>Region</code> 和部分高 “回收价值” 的堆区中的老年代的 <code>Region</code> ）</li><li>在 <code>G1 GC</code> 进行混合回收阶段的过程中，<code>G1 GC</code> 会执行 <code>STW</code></li></ol></li></ol><hr><h6 id="3-3-4-2-3-Full-GC-流程-🌈"><a href="#3-3-4-2-3-Full-GC-流程-🌈" class="headerlink" title="3.3.4.2.3. Full GC 流程 🌈"></a>3.3.4.2.3. Full GC 流程 🌈</h6><p>虽然 <code>G1 GC</code> 的策略也是 “主动预防”。但是在运行 <code>Java</code> 程序的过程中，也可能出现一些极端情况。为了解决这一问题，<code>G1 GC</code> 会执行 <code>Full GC</code>：</p><ol><li><code>HotSpot JVM</code> 在 <code>Java 10</code> 之前，<code>G1 GC</code> 使用单线程，采用串行垃圾回收策略，使用标记-整理算法执行 <code>Full GC</code></li><li><code>HotSpot JVM</code> 在 <code>Java10</code> 及以后，<code>G1 GC</code> 使用多线程，采用并行垃圾回收策略，使用标记-整理算法执行 <code>Full GC</code></li></ol><p>触发 <code>G1 GC</code> 执行 <code>Full GC</code> 的条件相似于触发 <code>Serial Old GC</code> 执行 <code>Full GC</code> 的条件，只不过 <code>G1 GC</code> 并不存在传统意义上的 “空间担保分配”（因为它是基于 <code>Region</code> 的）。但是当堆区中的空闲的 <code>Region</code> 的数量不足，<code>G1 GC</code> 在执行 <code>Minor GC</code>、<code>Major GC</code> 的过程中，将 <code>Region</code> 中的实例复制到另一个 <code>Region</code> 失败时，就会触发 <code>G1 GC</code> 执行 <code>Full GC</code>（需要注意的是：这本质上也是一种 “空间担保分配”）</p><hr><h4 id="3-3-5-对象的-finalization-机制"><a href="#3-3-5-对象的-finalization-机制" class="headerlink" title="3.3.5. 对象的 finalization 机制"></a>3.3.5. 对象的 finalization 机制</h4><p><code>Object</code> 类提供了 <code>void finalize()</code> 方法，若某个类对其进行了重写，那么在 <code>GC</code> 该对象之前，会先调用 <code>finalize()</code>，允许对象在销毁前执行一些自定义逻辑</p><p>然而，在调用 <code>finalize()</code> 的时候，可能导致对象 “复活”（即重新与引用链上的某个对象建立关联）。因此，<code>JVM</code> 在判断对象是否可回收时，通常需要经历两次标记过程：</p><ol><li>第一次标记<ol><li><code>GC</code> 通过可达性分析，发现某些对象与 <code>GC Roots</code> 之间已不存在引用链，判定它们为 “可回收候选对象”</li></ol></li><li>第二次标记<ol><li>如果对象没有重写 <code>finalize()</code> 方法，或其 <code>finalize() </code>方法已经被调用过了<ol><li>该对象会被直接判定为不可复活，继续进入回收流程</li></ol></li><li>如果对象重写了 <code>finalize()</code> 方法，并且尚未被执行过<ol><li><code>GC</code> 会将该对象插入到 <code>F-Queue</code> 队列</li><li>随后，一个由虚拟机自动创建的、低优先级的 <code>Finalizer</code> 线程会异步触发 <code>finalize() </code>方法的执行</li><li>在下一个 <code>GC</code> 周期中，当进行新一轮的可达性分析时，<code>GC</code> 会再次检查那些曾经在 <code>F-Queue</code> 中、并且其 <code>finalize()</code> 方法已经被执行完毕的对象<ol><li>如果该对象重新与引用链上的某个对象建立了联系，那么它将被移出即将回收的集合，实现 “复活”</li><li>如果该对象依然没有与引用链上的某个对象建立了联系，那么它就会被最终判定为垃圾，在下一次垃圾回收时被真正地回收</li></ol></li></ol></li></ol></li></ol><p>需要注意的是，从 <code>Java9</code> 开始，<code>Object</code> 类的 <code>void finalize()</code> 方法已经被正式弃用了</p><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 性能</title>
    <link href="/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%80%A7%E8%83%BD/"/>
    <url>/2025/12/10/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p><code>Xmind</code></p></li><li><p><code>Edraw</code></p></li><li><p><code>Hexo</code> 地址</p></li><li><p>代码洪荒（面试宝典）</p></li></ol><hr><h1 id="三、影响-Java-性能的核心因素"><a href="#三、影响-Java-性能的核心因素" class="headerlink" title="三、影响 Java 性能的核心因素"></a>三、影响 Java 性能的核心因素</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 性能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 修饰符</title>
    <link href="/2025/12/09/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2025/12/09/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO-🐉"><a href="#一、TODO-🐉" class="headerlink" title="一、TODO 🐉"></a>一、TODO 🐉</h1><hr><h1 id="二、脑图-🐉"><a href="#二、脑图-🐉" class="headerlink" title="二、脑图 🐉"></a>二、脑图 🐉</h1><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/09/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E4%BF%AE%E9%A5%B0%E7%AC%A6/">http://blog.wangjia.ink/2025/12/09/笔记：Java修饰符/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/Java-2cb974fbda5e801abc7beee5d47d8307?source=copy_link">https://www.notion.so/Java-2cb974fbda5e801abc7beee5d47d8307?source=copy_link</a></p></li></ol><hr><h1 id="三、Java-修饰符基础-🐉"><a href="#三、Java-修饰符基础-🐉" class="headerlink" title="三、Java 修饰符基础 🐉"></a>三、Java 修饰符基础 🐉</h1><h2 id="1-Java-修饰符相关分类-🐉"><a href="#1-Java-修饰符相关分类-🐉" class="headerlink" title="1. Java 修饰符相关分类 🐉"></a>1. Java 修饰符相关分类 🐉</h2><ol><li>访问修饰符<ol><li><code>public</code><ol><li>天下皆公（<code>EveryWhere</code>）</li></ol></li><li><code>protected</code><ol><li>类内部 + 同包兄弟 + 子女特权</li><li>如果是别人封装好的，类内部是做不到了，同包兄弟是做不成了，只能尝试子女特权（需要注意的是：还可以调用它封装好的方法）</li></ol></li><li><code>package-private</code><ol><li>类内部 + 同包兄弟</li><li>如果是别人封装好的，类内部是做不到了，同包兄弟是做不成了，访问是做不到了（需要注意的是：除非调用它封装好的方法）</li></ol></li><li><code>private</code><ol><li>独守秘密（类内部）</li><li>如果是别人封装好的，类内部是做不到了，访问是做不到了（需要注意的是：除非调用它封装好的方法）</li></ol></li></ol></li><li>非访问修饰符<ol><li>类级别的非访问修饰符<ol><li><code>final</code><ol><li>不可被继承的类（即断子绝孙）</li></ol></li><li><code>static</code><ol><li>静态内部类</li><li>我们可以使用上层类的类名，直接访问该类</li></ol></li><li><code>strictfp</code><ol><li>严格浮点计算</li><li>用于保证在该类中，所有涉及到 <code>float</code>、<code>double</code> 数据类型的数据的计算，即便使用不同的 <code>CPU</code>，也能得到一致的结果</li></ol></li><li><code>abstract</code><ol><li>抽象类</li></ol></li><li><code>sealed</code><ol><li>密封类</li><li>我们需要使用 <code>permits</code>，指定可以继承该类的子类</li><li>必须由 <code>final</code>、<code>sealed</code>、<code>non-sealed</code> 中的任意一个修饰符修饰继承该类的子类</li></ol></li><li><code>non-sealed</code><ol><li>非密封类</li></ol></li></ol></li><li>属性级别的非访问修饰符<ol><li><code>final</code><ol><li>不可被修改的属性</li><li>要么当定义该属性时赋值给该属性，要么在构造方法中赋值给该属性</li></ol></li><li><code>static</code><ol><li>静态属性</li><li>我们可以使用类名，直接访问该属性</li></ol></li><li><code>volatile</code><ol><li>保证该属性的可见性和有序性</li></ol></li><li><code>transient</code><ol><li>当序列化该属性时，忽略该属性</li><li>当反序列化该属性时，赋予默认值给该属性</li></ol></li></ol></li><li>方法级别的非访问修饰符<ol><li><code>final</code><ol><li>不可被重写的方法</li></ol></li><li><code>static</code><ol><li>静态方法</li><li>我们可以使用类名，直接调用该方法</li></ol></li><li><code>native</code><ol><li>本地方法</li><li>非 <code>Java</code> 语言实现该方法的具体逻辑</li></ol></li><li><code>strictfp</code><ol><li>严格浮点计算</li><li>用于保证在该方法中，所有涉及到 <code>float</code>、<code>double</code> 数据类型的数据的计算，即便使用不同的 <code>CPU</code>，也能得到一致的结果</li></ol></li><li><code>default</code><ol><li>接口方法的默认实现</li></ol></li><li><code>abstract</code><ol><li>抽象方法</li><li>继承该类的非抽象子类，必须重写该方法</li></ol></li><li><code>synchronized</code><ol><li>加 <code>synchronized</code> 锁</li></ol></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>内部类可以访问<code>private</code> 修饰符修饰的实例变量、普通常量、实例方法、构造方法、实例内部类、匿名内部类、<code>Lambda</code> 表达式</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 修饰符</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.List＜E＞ 源码解析</title>
    <link href="/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.List%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.List%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.io.Serializable源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-List＜E＞-概述"><a href="#3-1-List＜E＞-概述" class="headerlink" title="3.1. List＜E＞ 概述"></a>3.1. List＜E＞ 概述</h3><p><code>List＜E＞</code> 是一个接口</p><hr><h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> &#123;<br>        Objects.requireNonNull(operator);<br>        <span class="hljs-keyword">final</span> ListIterator&lt;E&gt; li = <span class="hljs-built_in">this</span>.listIterator();<br>        <span class="hljs-keyword">while</span> (li.hasNext()) &#123;<br>            li.set(operator.apply(li.next()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span> &#123;<br>        Object[] a = <span class="hljs-built_in">this</span>.toArray();<br>        Arrays.sort(a, (Comparator) c);<br>        ListIterator&lt;E&gt; i = <span class="hljs-built_in">this</span>.listIterator();<br>        <span class="hljs-keyword">for</span> (Object e : a) &#123;<br>            i.next();<br>            i.set((E) e);<br>        &#125;<br>    &#125;<br><br>    E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br>    E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span>;<br><br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span>;<br><br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br>    List&lt;E&gt; <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span>;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ImmutableCollections.emptyList();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.List12&lt;&gt;(e1);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.List12&lt;&gt;(e1, e2);<br>    &#125;<br><br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E... elements)</span> &#123;<br>        <span class="hljs-keyword">return</span> ImmutableCollections.listOf(elements);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">copyOf</span><span class="hljs-params">(Collection&lt;? extends E&gt; coll)</span> &#123;<br>        <span class="hljs-keyword">return</span> ImmutableCollections.listCopy(coll);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.NavigableSet＜E＞源码解析</title>
    <link href="/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.NavigableSet%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.NavigableSet%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.SortedSet%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.SortedSet＜E＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-NavigableSet＜E＞-概述"><a href="#3-1-NavigableSet＜E＞-概述" class="headerlink" title="3.1. NavigableSet＜E＞ 概述"></a>3.1. NavigableSet＜E＞ 概述</h3><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NavigableSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SortedSet</span>&lt;E&gt; &#123;<br><br>    E <span class="hljs-title function_">lower</span><span class="hljs-params">(E e)</span>;<br><br>E <span class="hljs-title function_">floor</span><span class="hljs-params">(E e)</span>;<br><br>    E <span class="hljs-title function_">ceiling</span><span class="hljs-params">(E e)</span>;<br><br>    E <span class="hljs-title function_">higher</span><span class="hljs-params">(E e)</span>;<br><br>    E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span>;<br><br>    E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span>;<br><br>    NavigableSet&lt;E&gt; <span class="hljs-title function_">descendingSet</span><span class="hljs-params">()</span>;<br><br>    Iterator&lt;E&gt; <span class="hljs-title function_">descendingIterator</span><span class="hljs-params">()</span>;<br><br>    NavigableSet&lt;E&gt; <span class="hljs-title function_">subSet</span><span class="hljs-params">(E fromElement, <span class="hljs-type">boolean</span> fromInclusive,</span><br><span class="hljs-params">                           E toElement,   <span class="hljs-type">boolean</span> toInclusive)</span>;<br><br>    NavigableSet&lt;E&gt; <span class="hljs-title function_">headSet</span><span class="hljs-params">(E toElement, <span class="hljs-type">boolean</span> inclusive)</span>;<br><br>    NavigableSet&lt;E&gt; <span class="hljs-title function_">tailSet</span><span class="hljs-params">(E fromElement, <span class="hljs-type">boolean</span> inclusive)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.Set＜E＞ 源码解析</title>
    <link href="/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Set%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Set%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Set%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.Set＜E＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Set＜E＞-概述"><a href="#3-1-Set＜E＞-概述" class="headerlink" title="3.1. Set＜E＞ 概述"></a>3.1. Set＜E＞ 概述</h3><p><code>Set＜E＞</code> 是一个接口</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Set</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (Set&lt;E&gt;) ImmutableCollections.EMPTY_SET;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.Set12&lt;&gt;(e1);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.Set12&lt;&gt;(e1, e2);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3, E e4)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3, e4);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3, E e4, E e5)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3, e4, e5);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3, E e4, E e5, E e6)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);<br>    &#125;<br><br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;varargs&quot;)</span><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E... elements)</span> &#123;<br>        <span class="hljs-keyword">return</span> ImmutableCollections.setOf(elements);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">copyOf</span><span class="hljs-params">(Collection&lt;? extends E&gt; coll)</span> &#123;<br>        <span class="hljs-keyword">if</span> (coll <span class="hljs-keyword">instanceof</span> ImmutableCollections.AbstractImmutableSet &amp;&amp; coll.getClass() != ImmutableCollections.SubList.class) &#123;<br>            <span class="hljs-keyword">return</span> (Set&lt;E&gt;) coll;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (Set&lt;E&gt;) Set.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(coll).toArray());<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.SortedSet＜E＞ 源码解析</title>
    <link href="/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.SortedSet%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.SortedSet%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.SortedSet%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.SortedSet＜E＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-SortedSet＜E＞-概述"><a href="#3-1-SortedSet＜E＞-概述" class="headerlink" title="3.1. SortedSet＜E＞ 概述"></a>3.1. SortedSet＜E＞ 概述</h3><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SortedSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Set</span>&lt;E&gt; &#123;<br><br>    Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator();<br><br>    SortedSet&lt;E&gt; <span class="hljs-title function_">subSet</span><span class="hljs-params">(E fromElement, E toElement)</span>;<br><br>    SortedSet&lt;E&gt; <span class="hljs-title function_">headSet</span><span class="hljs-params">(E toElement)</span>;<br><br>    SortedSet&lt;E&gt; <span class="hljs-title function_">tailSet</span><span class="hljs-params">(E fromElement)</span>;<br><br>E <span class="hljs-title function_">first</span><span class="hljs-params">()</span>;<br><br>    E <span class="hljs-title function_">last</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Spliterators</span>.IteratorSpliterator&lt;E&gt;(<br>                <span class="hljs-built_in">this</span>, Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; getComparator() &#123;<br>                <span class="hljs-keyword">return</span> SortedSet.<span class="hljs-built_in">this</span>.comparator();<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CompletableFuture＜T＞ 源码解析</title>
    <link href="/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletableFuture%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletableFuture%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletableFuture%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.concurrent.CompletableFuture＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CompletableFuture＜T＞-概述"><a href="#3-1-CompletableFuture＜T＞-概述" class="headerlink" title="3.1. CompletableFuture＜T＞ 概述"></a>3.1. CompletableFuture＜T＞ 概述</h3><p><code>CompletableFuture＜T＞</code> 是一个具体类，实现了 <code>java.util.concurren.Future＜V＞</code> 接口、<code>java.util.concurrent.CompletionStage＜T＞</code> 接口<br><img src="/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletableFuture%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletableFuture%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p>我们可以简单的理解为：一个 <code>CompletableFuture＜T＞</code> 实例就是一个 “阶段”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Future＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurren.Future＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>CompletionStage＜T＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletionStage%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CompletionStage＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletionStage%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.concurrent.CompletionStage＜T＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-CompletableFuture＜T＞-相关流程"><a href="#3-2-CompletableFuture＜T＞-相关流程" class="headerlink" title="3.2. CompletableFuture＜T＞ 相关流程"></a>3.2. CompletableFuture＜T＞ 相关流程</h3><p>以如下代码为例，线程会以非阻塞的方式快速的执行完这些 <code>Java</code> 代码。假设线程执行到 <code>cfA</code> 这一行，会根据 <code>CompletableFuture＜T＞#supplyAsync</code> 的语义去执行 <code>TaskA</code>（需要注意的是：<code>CompletableFuture＜T＞#supplyAsync</code> 是 “点火键”）</p><p>当线程执行到 <code>cfB1</code> 这一行，会根据 <code>CompletionStage＜T＞#thenApply</code> 的语义去执行 <code>TaskB1</code>。如果 “前置条件” 都已满足，可能是由当前线程执行核心动作，也可能是由当前线程将核心动作封装成一个任务，提交到线程池，由线程池中的线程执行核心动作（需要注意的是：默认提交到 <code>ForkJoinPool.commonPool()</code>）。但是如果 “前置条件” 未都满足，会将核心动作 “挂载” 到未完成的 “阶段” 上，等到最后一个 “阶段” 完成后，再来处理这个核心动作，这就是大名鼎鼎的 “异步编程回调”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br><span class="hljs-comment">//...</span><br><br>CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(TaskA);<br><br>CompletableFuture&lt;String&gt; cfB1 = cfA.thenApply(TaskB1);<br><br>CompletableFuture&lt;String&gt; cfB2 = cfA.thenApply(TaskB2);<br><br>CompletableFuture&lt;String&gt; cfC = cfA.thenApply(TaskC);<br><br>CompletableFuture&lt;String&gt; cfD = cfC.thenApply(TaskD);<br><br><span class="hljs-comment">//...</span><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在后续的代码中，只要存在 “依赖 <code>CompletableFuture&lt;T&gt;</code> 的执行结果才能继续执行” 的情况，我们一律通过回调来处理。其他的简单操作可以直接使用常规方法</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CompletionStage＜T＞ 源码解析</title>
    <link href="/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletionStage%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletionStage%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletionStage%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.concurrent.CompletionStage＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CompletionStage＜T＞-概述"><a href="#3-1-CompletionStage＜T＞-概述" class="headerlink" title="3.1. CompletionStage＜T＞ 概述"></a>3.1. CompletionStage＜T＞ 概述</h3><p><code>CompletionStage＜T＞</code> 是一个接口</p><p>我们可以简单的理解为：一个 <code>CompletionStage＜T＞</code> 接口的具体实现类实例就是一个 “阶段”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>对于 <code>CompletionStage＜T＞</code> 接口、<code>CompletableFuture＜T＞</code> 具体类，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于 <code>CompletionStage＜T＞</code> 接口，我们只需要能看懂它的方法即可，没必要对源码进行过度深究</li></ol></blockquote><hr><h2 id="4-相关方法"><a href="#4-相关方法" class="headerlink" title="4. 相关方法"></a>4. 相关方法</h2><p>在 <code>CompletionStage＜T＞</code> 接口中，方法的命名十分有规律：触发条件 + 核心动作 + 执行方式</p><ol><li>触发条件<ol><li><code>Then</code><ol><li>如果上一阶段执行成功（即正常退出），才执行核心动作</li></ol></li><li><code>Both</code><ol><li>如果上一阶段和传入的方法参数（即另一个阶段）都执行成功（即正常退出），才执行核心动作</li></ol></li><li><code>Either</code><ol><li>上一阶段和传入的方法参数（即另一个阶段）任意一个最先执行完成，并且是执行成功（即正常退出），才执行核心动作</li><li>上一阶段和传入的方法参数（即另一个阶段）任意一个最先执行完成，并且是执行失败（即异常退出、取消或停止任务），不会执行核心动作</li></ol></li><li><code>Handle</code><ol><li>上一阶段执行完成（即正常退出、异常退出、取消或停止任务），才执行核心动作</li></ol></li><li><code>WhenComplete</code><ol><li>上一阶段执行完成（即正常退出、异常退出、取消或停止任务），才执行核心动作</li></ol></li><li><code>Exceptionally</code><ol><li>上一阶段执行失败（即异常退出、取消或停止任务），才执行核心动作</li></ol></li></ol></li><li>核心动作<ol><li><code>Run</code><ol><li>不接收上一阶段的返回结果，执行一个 <code>Runnable</code> 任务，没有返回结果</li></ol></li><li><code>Apply</code><ol><li>接收上一阶段的返回结果，执行一个 <code>Function＜T, R＞</code> 类型的回调函数，返回一个类型不定的结果</li></ol></li><li><code>Accept</code><ol><li>接收上一阶段的返回结果，执行一个 <code>Consumer＜T＞</code> 类型的回调函数，没有返回结果</li></ol></li><li><code>Compose</code><ol><li>接收上一阶段的返回结果，执行一个 <code>Function＜T, CompletionStage＜R＞＞</code> 类型的回调函数，返回一个 <code>CompletionStage＜T＞</code> 类型的结果</li></ol></li><li><code>Combine</code><ol><li>接收上一阶段的返回结果和另一个 <code>CompletionStage＜T＞</code> 类型的方法参数（即另一个阶段）的执行结果，执行一个 <code>BiFunction＜T, U, R＞</code> 类型的回调函数，返回一个类型不定的结果</li></ol></li></ol></li><li>执行方式<ol><li><code>Async</code><ol><li>有 <code>Async</code><ol><li>如果上一阶段和传入的方法参数（即另一个阶段）都已经执行完毕<ol><li>由当前线程将核心动作封装成一个任务，提交到线程池，由线程池中的线程执行核心动作（默认提交到 <code>ForkJoinPool.commonPool()</code>，可以指定自定义线程池）</li></ol></li><li>如果上一阶段和传入的方法参数（即另一个阶段）有未执行完毕的<ol><li>将核心动作 “挂载” 到未完成的阶段上，并由最后一个执行某阶段完毕的那个线程将核心动作封装成一个任务，提交到线程池，由线程池中的线程执行核心动作（需要注意的是：默认提交到 <code>ForkJoinPool.commonPool()</code>，可以指定自定义线程池）</li></ol></li></ol></li><li>无 <code>Async</code><ol><li>如果上一阶段和传入的方法参数（即另一个阶段）已经执行完毕<ol><li>由当前线程执行核心动作</li></ol></li><li>如果上一阶段和传入的方法参数（即另一个阶段）有未执行完毕的<ol><li>将核心动作 “挂载” 到未完成的阶段上，并由最后一个执行某阶段完毕的那个线程执行核心动作</li></ol></li></ol></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果异常没有被捕获并处理，就会一直向后抛出</li><li>取消或停止任务，也要是核心动作执行的是 <code>Future</code> 任务才能做到</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java函数式编程</title>
    <link href="/2025/12/01/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/12/01/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><ul><li><input disabled="" type="checkbox"> Lambda 表达式问题爆破</li><li><input disabled="" type="checkbox"> Java Stream 的串行流问题爆破</li><li><input disabled="" type="checkbox"> Java Stream 的并行流问题爆破</li><li><input disabled="" type="checkbox"> Java Stream 的串行流适用场景</li></ul><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/12/01/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">http://blog.wangjia.ink/2025/12/01/笔记：Java函数式编程/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/Java-2c3974fbda5e8089b9eae3bb58c6bcce?source=copy_link">https://www.notion.so/Java-2c3974fbda5e8089b9eae3bb58c6bcce?source=copy_link</a></p></li></ol><hr><h1 id="三、回调"><a href="#三、回调" class="headerlink" title="三、回调"></a>三、回调</h1><h2 id="1-回调概述"><a href="#1-回调概述" class="headerlink" title="1. 回调概述"></a>1. 回调概述</h2><p>回调是指：线程在调用方法 <code>A</code> 时，需要将方法 <code>B</code> 作为方法参数传递进去。线程在执行方法 <code>A</code> 的过程中，会在某个特定的时机去调用方法 &#96;B<br><img src="/2025/12/01/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这个方法 <code>B</code> 我们称之为 “回调函数”</li></ol></blockquote><hr><h2 id="2-回调函数实现方式"><a href="#2-回调函数实现方式" class="headerlink" title="2. 回调函数实现方式"></a>2. 回调函数实现方式</h2><h3 id="2-1-匿名内部类"><a href="#2-1-匿名内部类" class="headerlink" title="2.1. 匿名内部类"></a>2.1. 匿名内部类</h3><p>对于 <code>Java</code> 而言，它是一门面向对象的语言，所以无法像 <code>JavaScript</code> 那样将方法直接作为方法参数进行传递，而是必须依赖类的实例进行传递。因此我们只能退而求其次：线程在调用方法 <code>A</code> 时，将某类的实例作为方法参数传递进去，而该实例能够调用方法 <code>B</code>。线程在执行方法 <code>A</code> 的过程中，会在某个特定的时机使用该实例去调用方法 <code>B</code></p><p>以如下代码为例，假设我们要将 <code>MyFunctionalInterface#myMethod</code> 作为方法参数传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyFunctionalInterface</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们就可以传递承载它的 <code>MyFunctionalInterface</code> 接口的具体实现类实例。因此，接收方需要接收一个 <code>MyFunctionalInterface</code> 类型的方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(MyFunctionalInterface myFunctionalInterface)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        myFunctionalInterface.myMethod();<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以使用匿名内部类实现回调的最终形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(MyFunctionalInterface myFunctionalInterface)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        myFunctionalInterface.myMethod();<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <br>        test.doSomething(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFunctionalInterface</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;);<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-2-Lambda-表达式"><a href="#2-2-Lambda-表达式" class="headerlink" title="2.2. Lambda 表达式"></a>2.2. Lambda 表达式</h3><h4 id="2-2-1-Lambda-表达式概述"><a href="#2-2-1-Lambda-表达式概述" class="headerlink" title="2.2.1. Lambda 表达式概述"></a>2.2.1. Lambda 表达式概述</h4><p>想象这样一个问题：我们的目的仅仅是传递一个回调方法，却被迫要创建一个的匿名内部类，然后再创建其实例，再通过其实例调用方法，显得非常笨重和繁琐</p><p>为了解决这一问题，<code>Java8</code> 引入了 <code>Lambda</code> 表达式。<code>Lambda</code> 表达式是一种语法糖，在编译阶段会被编译器自动转换为对应的函数式接口的具体实现类，最终返回该函数式接口的具体实现类实例，帮我们简化了一些步骤</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>尽管 <code>Lambda</code> 表达式功能强大，但它只能用于函数式接口，返回一个函数式接口的具体实现类实例</li><li><code>Lambda</code> 表达式使用的是 <code>invokedynamic</code> 字节码指令来创建匿名内部类和匿名内部类实例的。详见笔记：<code>JVM</code>（<code>obsidian</code> 内部链接：，<code>Hexo</code> 链接：）</li></ol></blockquote><hr><h4 id="2-2-2-Lambda-表达式编写方式"><a href="#2-2-2-Lambda-表达式编写方式" class="headerlink" title="2.2.2. Lambda 表达式编写方式"></a>2.2.2. Lambda 表达式编写方式</h4><p><code>Lambda</code> 表达式由三部分组成：</p><ol><li>参数列表<ol><li>明确指出参数类型<ol><li>(<code>int a, int b</code>)</li></ol></li><li>根据上下文自动推断参数类型<ol><li>(<code>a, b</code>)</li></ol></li><li>需要注意的是：<ol><li>不允许出现既明确指出参数类型，又根据上下文自动推断参数类型的情况（例如 (<code>int a, b</code>)）</li><li>只有在恰好只有一个参数，并且是根据上下文自动推断参数类型的情况下，<code>Lambda</code> 表达式的参数列表才可以省略<code> ()</code>。在其他所有场景（包括没有参数），<code>() </code>都必须显式写出（例如 <code>a</code> 是正确的，但是 <code>Object a</code> 是不正确的）</li></ol></li></ol></li><li><code>-&gt;</code></li><li>方法体<ol><li>如果方法体只有一行<ol><li>如果有 <code>return</code><ol><li>可以省略 <code>return</code>（例如 <code>return a + b ➔ a + b</code>）</li></ol></li><li>如果没有 <code>return</code><ol><li>直接写即可（例如 <code>System.out.println(&quot;Hello World&quot;)</code>）</li></ol></li></ol></li><li>如果方法体有多行<ol><li>必须有 <code>&#123;&#125;</code>，并且不能省略 <code>return</code>（例如 <code>&#123; int c = a + b; return c; &#125;</code>）</li></ol></li></ol></li></ol><hr><h4 id="Lambda-表达式问题爆破"><a href="#Lambda-表达式问题爆破" class="headerlink" title="Lambda 表达式问题爆破"></a>Lambda 表达式问题爆破</h4><h1 id="四、函数式接口"><a href="#四、函数式接口" class="headerlink" title="四、函数式接口"></a>四、函数式接口</h1><h2 id="1-函数式接口概述"><a href="#1-函数式接口概述" class="headerlink" title="1. 函数式接口概述"></a>1. 函数式接口概述</h2><p>函数式接口是指：只包含一个实例接口方法（普通）的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyFunctionalInterface</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">(String s)</span>;<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>标注 <code>@FunctionalInterface</code> 用于告诉编译器 “请帮我检查一下这个接口，是否只有一个实例接口方法（普通）”</li><li>虽然函数式接口只包含一个实例接口方法（普通），但是能包含多个实例接口方法（<code>default</code>）、静态接口方法（<code>default</code>）</li></ol></blockquote><hr><h2 id="2-内置的函数式接口相关分类"><a href="#2-内置的函数式接口相关分类" class="headerlink" title="2. 内置的函数式接口相关分类"></a>2. 内置的函数式接口相关分类</h2><p><code>Java8</code> 怕我们自己定义函数式接口太麻烦，提前为我们准备好了一些常用的函数式接口：</p><ol><li>四大金刚<ol><li><code>Function＜T, R＞</code> 接口</li><li><code>Consumer＜T＞</code> 接口</li><li><code>Predicate＜T＞</code> 接口</li><li><code>Supplier＜T＞</code> 接口</li></ol></li><li>扩展变体<ol><li><code>Bi</code> 系列<ol><li><code>BiFunction＜T, U, R＞</code> 接口</li><li><code>BiConsumer＜T, U＞</code> 接口</li><li><code>BiPredicate&lt;T, U&gt;</code> 接口</li></ol></li><li><code>Operator</code> 系列<ol><li><code>UnaryOperator＜T＞</code> 接口</li><li><code>BinaryOperator＜T＞</code> 接口</li><li><code>IntUnaryOperator</code> 接口</li><li><code>IntBinaryOperator</code> 接口</li><li><code>LongUnaryOperator</code> 接口</li><li><code>LongBinaryOperator</code> 接口</li><li><code>DoubleUnaryOperator</code> 接口</li><li><code>DoubleBinaryOperator</code> 接口</li></ol></li><li><code>Primitive</code> 系列<ol><li><code>Function＜T, R＞</code> 相关<ol><li><code>IntFunction＜R＞</code> 接口</li><li><code>LongFunction＜R＞</code> 接口</li><li><code>DoubleFunction＜R＞</code> 接口</li><li><code>ToIntFunction＜T＞</code> 接口</li><li><code>ToLongFunction＜T＞</code> 接口</li><li><code>ToDoubleFunction＜T＞</code> 接口</li><li><code>IntToLongFunction</code> 接口</li><li><code>IntToDoubleFunction</code> 接口</li><li><code>LongToIntFunction</code> 接口</li><li><code>LongToDoubleFunction</code> 接口</li><li><code>DoubleToIntFunction</code> 接口</li><li><code>DoubleToLongFunction</code> 接口</li><li><code>ToIntBiFunction＜T, U＞</code> 接口</li><li><code>ToLongBiFunction＜T, U＞</code> 接口</li><li><code>ToDoubleBiFunction＜T, U＞</code> 接口</li></ol></li><li><code>Consumer＜T＞</code> 相关<ol><li><code>IntConsumer</code> 接口</li><li><code>LongConsumer</code> 接口</li><li><code>DoubleConsumer</code> 接口</li><li><code>ObjIntConsumer＜T＞</code> 接口</li><li><code>ObjLongConsumer＜T＞</code> 接口</li><li><code>ObjDoubleConsumer＜T＞</code> 接口</li></ol></li><li><code>Predicate＜T＞</code> 相关<ol><li><code>IntPredicate</code> 接口</li><li><code>LongPredicate</code> 接口</li><li><code>DoublePredicate</code> 接口</li></ol></li><li><code>Supplier＜T＞</code> 相关<ol><li><code>IntSupplier</code> 接口</li><li><code>LongSupplier</code> 接口</li><li><code>DoubleSupplier</code> 接口</li><li><code>BooleanSupplier</code> 接口</li></ol></li></ol></li></ol></li></ol><h3 id="2-1-四大金刚"><a href="#2-1-四大金刚" class="headerlink" title="2.1. 四大金刚"></a>2.1. 四大金刚</h3><h4 id="2-1-1-Function＜T-R＞-接口"><a href="#2-1-1-Function＜T-R＞-接口" class="headerlink" title="2.1.1. Function＜T, R＞  接口"></a>2.1.1. Function＜T, R＞  接口</h4><p>详见源码：<code>Function＜T, R＞</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Function%EF%BC%9CT,R%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.function.Function＜T,R＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Function%EF%BC%9CT,R%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Function＜T,R＞源码解析/</a></li></ol></li></ol><hr><h4 id="2-1-2-Consumer＜T＞-接口"><a href="#2-1-2-Consumer＜T＞-接口" class="headerlink" title="2.1.2. Consumer＜T＞ 接口"></a>2.1.2. Consumer＜T＞ 接口</h4><p>详见源码：<code>Consumer＜T＞</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.function.Consumer＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Consumer＜T＞源码解析/</a></li></ol></li></ol><hr><h4 id="2-1-3-Predicate＜T＞-接口"><a href="#2-1-3-Predicate＜T＞-接口" class="headerlink" title="2.1.3. Predicate＜T＞ 接口"></a>2.1.3. Predicate＜T＞ 接口</h4><p>详见源码：<code>Predicate＜T＞</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Predicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.function.Predicate＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Predicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Predicate＜T＞源码解析/</a></li></ol></li></ol><hr><h4 id="2-1-4-Supplier＜T＞-接口"><a href="#2-1-4-Supplier＜T＞-接口" class="headerlink" title="2.1.4. Supplier＜T＞ 接口"></a>2.1.4. Supplier＜T＞ 接口</h4><p>详见源码：<code>Supplier＜T＞</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Supplier%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.function.Supplier＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Supplier%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Supplier＜T＞源码解析/</a></li></ol></li></ol><hr><h1 id="五、Java-Stream"><a href="#五、Java-Stream" class="headerlink" title="五、Java Stream"></a>五、Java Stream</h1><h2 id="1-Java-Stream-概述"><a href="#1-Java-Stream-概述" class="headerlink" title="1. Java Stream 概述"></a>1. Java Stream 概述</h2><p>我们知道 “在 <code>Java</code> 应用中，遍历某个数据结构有两种方式：基于索引遍历、基于引用遍历”。为了避免每一次想要遍历某个数据结构时，都要手动编写数据结构的遍历逻辑。所以我们通常使用迭代器封装数据结构的遍历逻辑，遍历时直接使用迭代器进行数据结构的遍历（需要注意的是：使用迭代器进行数据结构的遍历，同样需要借助循环）。可即便如此，我们还是发现：使用迭代器进行数据结构的遍历时，操作仍然显得非常繁琐</p><p>于是 <code>Java</code> 语言的设计团队提供了增强 <code>for</code> 循环语法糖来简化操作。可尽管如此，如果涉及到多个操作，操作仍然会显得太繁琐：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br><br>        <span class="hljs-comment">// 创建集合</span><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        <span class="hljs-comment">// 把所有以 “张” 开头的元素存储到新集合中</span><br>        ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : list1) &#123;<br>            <span class="hljs-keyword">if</span>(name.startsWith(<span class="hljs-string">&quot;张&quot;</span>))&#123;<br>                list2.add(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 把 “张” 开头的，长度为 3 的元素再存储到新集合中</span><br>        ArrayList&lt;String&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : list2) &#123;<br>            <span class="hljs-keyword">if</span>(name.length() == <span class="hljs-number">3</span>)&#123;<br>                list3.add(name);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 输出结果</span><br>        <span class="hljs-keyword">for</span> (String s : list3) &#123;<br>            System.out.println(s);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>Java8</code> 之后的 <code>Java Stream</code> 以一种声明式、函数式的风格，优雅的解决了这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br><br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;周芷若&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张强&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br><br>        list.stream().filter(name -&gt; name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter(name -&gt; name.length() == <span class="hljs-number">3</span>).forEach(name -&gt; System.out.println(name));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>增强 <code>for</code> 循环（<code>for-each</code> 循环）是 <code>Java</code> 提供的一种语法糖，在编译阶段会被编译器自动转换为使用迭代器进行数据结构的遍历（需要注意的是：是使用迭代器实现数据结构的遍历，而不是使用可拆分迭代器实现数据结构的遍历）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译前</span><br><span class="hljs-keyword">for</span> (T t : iterable) &#123;<br>xxxxxx<br>&#125;<br><br><br><span class="hljs-comment">// 编译后</span><br><span class="hljs-keyword">for</span> (Iterator&lt;T&gt; it = iterable.iterator(); it.hasNext(); ) &#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> it.next();<br>xxxxxx<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. 如果仅仅是为了代码看起来优雅，<code>Java</code> 语言的设计团队是不可能大动干戈引入 <code>Java Stream</code> 这一庞大的体系的。其实 <code>Java Stream</code> 被引入的真正原因是：惰性求值、并行处理<br>    1. 惰性求值<br>        1. 当执行 <code>Java Stream</code> 的中间方法时，并不会像传统的处理方法一样：执行每一步时都会创建一个新的数据结构，然后遍历某个数据结构，让数据结构中的每个元素都执行这一步，将元素被这一步处理后的结果 “增” 进这个新的数据结构中。执行完这一步，再执行下一步（即一步一步来）<br>        2. 相反，在执行 <code>Java Stream</code> 的中间方法时，只是会记录下这一步的链式逻辑，并不会立即执行。直到执行到 <code>Java Stream</code> 的结束方法时，<code>Java Stream</code> 才会按照链式逻辑遍历某个数据结构，让数据结构中的每个元素都执行完整个链式逻辑。处理完这一个元素，再处理下一个元素，从而避免了大量的中间的数据结构的创建（即一个一个来）<br>        3. 需要注意的是：<code>90%</code> 都是基于上述的流程，但是也有 <code>10%</code> 并不是这样。这是因为涉及到了排序方法，这样的话需要让 <code>Java Stream</code> 中的每个元素都执行完这一步，然后再按上述的流程继续执行<br>    2. 并行处理<br>        1. 我们知道 “在 <code>Java</code> 应用中，遍历某个数据结构有两种方式：基于索引遍历、基于引用遍历”。如果让我们自己编写数据结构的遍历逻辑，我们很可能是使用单线程进行数据结构的遍历<br>        2. 因为如果我们希望使用多线程进行数据结构的遍历，就必须提前将数据结构中的元素进行拆分，然后手动创建新的数据结构来保存每一段被拆分后的元素。当使用多线程进行数据结构的遍历后，我们还需要手动合并结果。除此之外，我们还需要处理多线程并发情况下的安全问题。这样一套整下来，操作就显得非常繁琐，不如直接使用单线程进行数据结构的遍历来的方便<br>        3. 但是 <code>Java Stream</code> 已经帮我们封装了这些复杂逻辑，使我们能更轻松地使用多线程进行数据结构的遍历（并行流）<br>3. <code>Java Stream</code> 的并行流是使用 <code>ForkJoinPool</code> 实现分而治之、迭代拆分、工作窃取的。然而，我们日常在使用 <code>ForkJoinPool</code> 时，是需要手动编写元素或数据的迭代拆分逻辑的，你可能疑惑：<code>Java Stream</code> 的并行流的迭代拆分逻辑被写到了哪里？<br>    1. 我们知道 “不管是 <code>Java Stream</code> 的串行流还是 <code>Java Stream</code> 的并行流，都要以可拆分迭代器为起点”。所以能创建 <code>Java Stream</code> 的并行流或 <code>Java Stream</code> 的串行流的数据结构，通常会包含一个实现 <code>Spliterator＜T＞</code> 接口的内部类，而并行流的迭代拆分逻辑就被写在这个内部类中<br>    2. 以上述代码为例，并行流的迭代拆分逻辑就被写在 <code>HashMap＜K, V＞.KeySpliterator＜K, V＞</code>（由于 <code>HashSet＜E＞</code> 底层是基于一个 <code>HashMap＜K, V＞</code> 实现的，所以直接使用 <code>HashMap＜K, V＞</code> 的内部类）</p></blockquote><hr><h2 id="2-Java-Stream-相关分类"><a href="#2-Java-Stream-相关分类" class="headerlink" title="2. Java Stream 相关分类"></a>2. Java Stream 相关分类</h2><ol><li>以 <code>Java Stream</code> 处理的元素的数据类型分类：<ol><li>普通流（即处理引用数据类型的元素的流）<ol><li><code>Stream＜T＞</code> 接口的具体实现类</li></ol></li><li>特化流（即处理基本数据类型的元素的流）<ol><li><code>IntStream</code> 接口的具体实现类</li><li><code>LongStream</code> 接口的具体实现类</li><li><code>DoubleStream</code> 接口的具体实现类</li></ol></li></ol></li><li>以 <code>Java Stream</code> 的执行方式分类：<ol><li>串行流</li><li>并行流</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>为什么提供了特化流？使用普通流难道解决不了我们的问题吗？<ol><li>因为普通流涉及到了 <code>Java</code> 泛型。我们知道 “一旦某个东西涉及到 <code>Java</code> 泛型，那么其在处理基本数据类型的元素时，就会出现很多问题”</li><li>我们先来回顾一下集合在涉及到 <code>Java</code> 泛型后，在处理基本数据类型的元素时出现的问题：<ol><li>内存方面的压力<ol><li>如果我们只是想存储一亿个基本数据类型的元素，但是由于集合涉及到 <code>Java</code> 泛型，所以集合中只能存储引用数据类型的元素（需要注意的是：实际存储的是引用数据类型的元素的引用）。所以基本数据类型的元素只能在自动装箱后再 “增” 进集合中</li><li>例如一个 <code>int</code> 类型的数据是 <code>4 byte</code>，但是一个 <code>Integer</code> 类型的数据在 <code>32 bit</code> 虚拟机下可能需要 <code>16 byte</code>，那么对于一亿个数据，就多消耗了 <code>1525 MB</code> 的内存（需要注意的是：由于集合中实际存储的是引用数据类型的元素的引用，这一亿个引用也占用了不小的内存）</li></ol></li><li><code>CPU</code> 方面的压力<ol><li>如果我们对集合中的元素做一次简单的计算操作（例如对每个元素执行 <code>+1</code>）时，就会触发这一亿个元素的自动拆箱 ➔ 计算 ➔ 自动装箱</li><li>除此之外，由于集合中实际存储的是引用数据类型的元素的引用，所以要访问某元素时，就要先通过其引用指向的内存地址找到该元素。这个寻址的过程本身就存在较大的开销，而且它并不像数组那样，是分配连续内存的数据结构，一次性就能加载多个元素，而是 “东一块西一块” 的，从而大大增加了寻址开销（术语是：<code>CPU</code> 缓存命中率低）</li></ol></li></ol></li><li>而普通流在涉及到 <code>Java</code> 泛型后，在处理基本数据类型的元素时会出现更多的问题：<ol><li>如果我们使用普通流遍历的的是一个数组（需要注意的是：数组是 <code>Java</code> 中唯一既能存储基本数据类型的元素，又能存储引用数据类型的元素（需要注意的是：实际存储的是引用数据类型的元素的引用）的数据结构）<ol><li>这相当于人为地降低处理效率。因为普通流涉及到 <code>Java</code> 泛型，所以只能处理引用数据类型的元素。所以即便数组中存储的是基本数据类型的元素，为了被普通流处理，也需要先对其进行自动装箱（即创建一亿个包装类实例，仅为了开始）</li><li>除此之外，还具有集合在涉及到 <code>Java</code> 泛型后，在处理基本数据类型的元素时出现的问题</li></ol></li><li>如果我们使用普通流遍历的是一个集合（需要注意的是：由于集合涉及到 <code>Java</code> 泛型，所以集合中只能存储引用数据类型的元素（实际存储的是引用数据类型的元素的引用））<ol><li>由于集合中存储的元素，已经是自动装箱后的元素了，所以不需要再对其进行自动装箱了。但是仍然具有集合在涉及到 <code>Java</code> 泛型后，在处理基本数据类型的元素时出现的问题</li></ol></li><li>除此之外，还会存在 <code>GC</code> 方面的压力：<ol><li><code>Java Stream</code> 中最初的元素，都是被所遍历的数据结构所引用的，所以不用担心它们被 <code>GC</code></li><li>但是在 <code>Java Stream</code> 的执行的过程中，如果创建了新的实例（例如我们在某一个中间方法中，要对 <code>Java Stream</code> 中的每个元素做一次简单的计算操作（例如对每个元素执行 <code>+1</code>），那么就会产生一亿个新的包装类实例）。由于这些新的实例并不是数据结构中的元素，所以如果它们在下一步被拦截了（例如拦截了 <code>100</code> 万个实例），那么这些实例就会失去引用，需要被 <code>GC</code>。我的意思是：<code>Java Stream</code> 中涉及到的元素，除了数据结构中的元素和在结束方法中被收集到某处的元素，所有的中间元素都是 “垃圾”，需要被 <code>GC</code>（需要注意的是：数据结构中的元素和在结束方法中被收集到某处的元素会不会被 <code>GC</code>，还要看强软弱虚四引用）</li><li>需要注意的是：这是整个 <code>Java Stream</code> 体系的 “通病”，而不是因为普通流在涉及到 <code>Java</code> 泛型后，在处理基本数据类型时才出现这个问题。只不过由于普通流在涉及到 <code>Java</code> 泛型后，在处理基本数据类型的元素时出现了大量的自动装箱、自动拆箱，大大加重了这个问题</li></ol></li></ol></li></ol></li><li>为什么特化流只提供了处理 <code>int</code>、<code>long</code>、<code>double</code> 类型的元素的流？<ol><li>因为处理 <code>byte</code>、<code>short</code>、<code>char</code> 类型的元素，可以直接使用处理 <code>int</code> 类型的元素的流（因为 <code>int</code> 类型的范围涵盖了它们）</li><li>而处理 <code>float</code> 类型的元素，可以直接使用处理 <code>double</code> 类型的元素的流（因为 <code>double</code> 类型的精度涵盖了它）</li><li>并且 <code>boolean</code> 类型的元素通常不需要参与计算</li></ol></li></ol></li></ol></blockquote><hr><h2 id="Java-Stream-问题爆破"><a href="#Java-Stream-问题爆破" class="headerlink" title="Java Stream 问题爆破"></a>Java Stream 问题爆破</h2><h3 id="Java-Stream-的并行流问题爆破"><a href="#Java-Stream-的并行流问题爆破" class="headerlink" title="Java Stream 的并行流问题爆破"></a>Java Stream 的并行流问题爆破</h3><p>虽然并行处理是 <code>Java Stream</code> 被引入的真正原因之一，但遗憾的是，<code>Java Stream</code> 的并行流在日常开发中并不常见，因为它有这样几个 “坑”：</p><ol><li>我们在使用 <code>Java Stream</code> 的并行流时，很容易因为它的编写风格而产生 “我在使用单线程进行数据结构的遍历” 的感觉，从而忽视了多线程并发情况下的安全问题。虽然 <code>Java Stream</code> 已经帮我们处理了很多的多线程并发情况下的安全问题，但是你像在结束方法中，将 <code>Java Stream</code> 中的元素收集到非多线程并发安全的数据结构（例如 <code>ArrayList＜E＞</code>）中的情况，需要我们自己特别注意</li><li>我们知道 “<code>Java Stream</code> 的并行流是使用 <code>ForkJoinPool</code> 实现分而治之、迭代拆分、工作窃取的”。但是 <code>Java Stream</code> 的并行流默认使用的是单个 <code>JVM</code> 中全局唯一的 <code>ForkJoinPool.commonPool()</code>。所以一个 <code>Java</code> 服务中，所有 <code>Java Stream</code> 的并行流，甚至是不相关但涉及到 <code>ForkJoinPool.commonPool()</code> 的业务（例如 <code>CompletableFuture＜T＞</code>），都会去竞争 <code>ForkJoinPool.commonPool()</code> 中的线程</li><li>由于 <code>Java Stream</code> 的并行流使用了 <code>ForkJoinPool</code>，而一旦我们的线程涉及到让其他线程去执行一些任务时，就势必会出现一个问题：<code>ThreadLocal</code> 因为无法跨线程而 “丢失”</li><li>由于 <code>Java Stream</code> 的并行流使用了 <code>ForkJoinPool</code>，而使用 <code>ForkJoinPool</code> 本身就算有成本的（例如创建任务、线程调度、上下文切换、数据的迭代拆分、工作窃取、结果合并等），如果处理的数据并不多，那么使用 <code>Java Stream</code> 的并行流反而得不偿失</li><li>我们知道 “对于底层是基于非连续内存的数据结构，不太建议使用 <code>Java Stream</code> 的并行流”。所谓的 “不太建议” 是指：需要我们自行权衡，如果对数据结构中的元素进行迭代拆分的时间 ＞ 使用 <code>Java Stream</code> 的并行流节省的时间，那么我们是肯定不能使用 <code>Java Stream</code> 的并行流</li></ol><hr><h2 id="3-Java-Stream-适用场景"><a href="#3-Java-Stream-适用场景" class="headerlink" title="3. Java Stream 适用场景"></a>3. Java Stream 适用场景</h2><h3 id="Java-Stream-的并行流适用场景"><a href="#Java-Stream-的并行流适用场景" class="headerlink" title="Java Stream 的并行流适用场景"></a>Java Stream 的并行流适用场景</h3><p>并行流适用以下场景为：</p><ol><li>离线批处理</li><li>海量数据处理</li><li>纯 <code>CPU</code> 密集型</li><li>底层是基于连续内存的数据结构</li></ol><hr><h2 id="5-Java-Stream-相关常用方法"><a href="#5-Java-Stream-相关常用方法" class="headerlink" title="5. Java Stream 相关常用方法"></a>5. Java Stream 相关常用方法</h2><p><code>Java Stream</code> 相关的常用方法主要包括：</p><ol><li>创建方法</li><li>中间方法</li><li>结束方法</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>判断一个方法是中间方法还是结束方法，只需要看该方法是否返回一个 <code>Java Stream</code></li><li><code>Java Stream</code> 相关的常用方法主要包括：<ol><li><code>java.util.stream.Stream＜T＞</code>  接口中的一些方法</li><li><code>java.util.stream.IntStream</code>  接口中的一些方法</li><li><code>java.util.stream.LongStream</code>  接口中的一些方法</li><li><code>java.util.stream.DoubleStream</code>  接口中的一些方法</li></ol></li></ol></blockquote><h3 id="5-1-创建方法"><a href="#5-1-创建方法" class="headerlink" title="5.1. 创建方法"></a>5.1. 创建方法</h3><blockquote><p>[!NOTE] 注意事项</p><ol><li>除了下面的方法外，<code>Java Stream</code> 还有很多创建方法，但掌握这些创建方法已经足够了</li></ol></blockquote><h4 id="5-1-1-根据数组创建-Java-Stream"><a href="#5-1-1-根据数组创建-Java-Stream" class="headerlink" title="5.1.1. 根据数组创建 Java Stream"></a>5.1.1. 根据数组创建 Java Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] myArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><br><span class="hljs-comment">// 串行流</span><br>Arrays.stream(myArray).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>会根据数组的类型返回对应的 <code>Java Stream</code>（即普通流、特化流）</li></ol></blockquote><hr><h4 id="5-1-2-根据集合创建-Java-Stream"><a href="#5-1-2-根据集合创建-Java-Stream" class="headerlink" title="5.1.2. 根据集合创建 Java Stream"></a>5.1.2. 根据集合创建 Java Stream</h4><h5 id="5-1-2-1-根据-Set＜E＞-创建-Java-Stream"><a href="#5-1-2-1-根据-Set＜E＞-创建-Java-Stream" class="headerlink" title="5.1.2.1. 根据 Set＜E＞ 创建 Java Stream"></a>5.1.2.1. 根据 Set＜E＞ 创建 Java Stream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-comment">// 串行流</span><br>mySet.stream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// 并行流</span><br>mySet.parallelStream().<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><hr><h5 id="5-1-2-2-根据-List＜E＞-创建-Java-Stream"><a href="#5-1-2-2-根据-List＜E＞-创建-Java-Stream" class="headerlink" title="5.1.2.2. 根据 List＜E＞ 创建 Java Stream"></a>5.1.2.2. 根据 List＜E＞ 创建 Java Stream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; myList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 串行流</span><br>myList.stream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// 并行流</span><br>myList.parallelStream().<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><hr><h5 id="5-1-2-3-根据-Map＜K-V＞-创建-Java-Stream"><a href="#5-1-2-3-根据-Map＜K-V＞-创建-Java-Stream" class="headerlink" title="5.1.2.3. 根据 Map＜K, V＞ 创建 Java Stream"></a>5.1.2.3. 根据 Map＜K, V＞ 创建 Java Stream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String,Integer&gt; myHashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Key 的串行流</span><br>myHashMap.keySet().stream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// Key 的并行流</span><br>myHashMap.keySet().parallelStream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// Value 的串行流</span><br>myHashMap.values().stream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// Value  的并行流</span><br>myHashMap.values().parallelStream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// Key-Value 的串行流</span><br>myHashMap.entrySet().stream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// Key-Value 的并行流</span><br>myHashMap.entrySet().parallelStream().<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><hr><h5 id="5-1-2-4-根据-Queue＜E＞-创建-Java-Stream"><a href="#5-1-2-4-根据-Queue＜E＞-创建-Java-Stream" class="headerlink" title="5.1.2.4. 根据 Queue＜E＞ 创建 Java Stream"></a>5.1.2.4. 根据 Queue＜E＞ 创建 Java Stream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;String&gt; myQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 串行流</span><br>myQueue.stream().<span class="hljs-keyword">var</span><br><br><span class="hljs-comment">// 并行流</span><br>myQueue.parallelStream().<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><hr><h4 id="5-1-3-合并两个-Java-Stream"><a href="#5-1-3-合并两个-Java-Stream" class="headerlink" title="5.1.3. 合并两个 Java Stream"></a>5.1.3. 合并两个 Java Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; myStreamA = Stream.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);<br><br>Stream&lt;String&gt; myStreamB = Stream.of(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br><br>Stream&lt;String&gt; resultStream = Stream.concat(myStreamA, myStreamB);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>该方法是让两个 <code>Java Stream</code> “首尾相连” 合并成一个新的 <code>Java Stream</code></li><li>参与合并的两个 <code>Java Stream</code> 中，只要有一个是 <code>Java Stream</code> 的并行流，那么合并的结果就是一个 <code>Java Stream</code> 的并行流</li><li>参与合并的两个 <code>Java Stream</code> 中，如果第一个 <code>Java Stream</code> 是一个 “无穷流”，那么第二个 <code>Java Stream</code> 中的元素可能永远不能被处理</li><li>如果有多个 <code>Java Stream</code> 要合并，不要嵌套使用 <code>Stream＜T＞#concat</code>（例如 <code>Stream.concat(Stream.concat(a, b), c)</code>）。推荐把它们 “增” 进一个集合中，然后再调用 <code>Stream＜T＞#flatMap</code>：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Stream&lt;String&gt;&gt; streams = Stream.of(s1, s2, s3, s4);<br><br>Stream&lt;String&gt; result = streams.flatMap(s -&gt; s);<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-中间方法"><a href="#5-2-中间方法" class="headerlink" title="5.2. 中间方法"></a>5.2. 中间方法</h3><h4 id="5-2-1-通用方法"><a href="#5-2-1-通用方法" class="headerlink" title="5.2.1. 通用方法"></a>5.2.1. 通用方法</h4><p>通用方法是 <code>java.util.stream.Stream＜T＞</code> 接口中的一些方法</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>除了下面的方法外，还有切片方法、映射方法、排序方法、调试方法，用到再学</li></ol></blockquote><h5 id="5-2-1-1-过滤方法"><a href="#5-2-1-1-过滤方法" class="headerlink" title="5.2.1.1. 过滤方法"></a>5.2.1.1. 过滤方法</h5><h6 id="5-2-1-1-1-Stream＜T＞-filter-Predicate＜-super-T＞-predicate"><a href="#5-2-1-1-1-Stream＜T＞-filter-Predicate＜-super-T＞-predicate" class="headerlink" title="5.2.1.1.1. Stream＜T＞  filter(Predicate＜? super T＞  predicate)"></a>5.2.1.1.1. Stream＜T＞  filter(Predicate＜? super T＞  predicate)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))...<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-2-去重方法"><a href="#5-2-1-2-去重方法" class="headerlink" title="5.2.1.2. 去重方法"></a>5.2.1.2. 去重方法</h5><h6 id="5-2-1-2-1-Stream＜T＞-distinct"><a href="#5-2-1-2-1-Stream＜T＞-distinct" class="headerlink" title="5.2.1.2.1. Stream＜T＞  distinct()"></a>5.2.1.2.1. Stream＜T＞  distinct()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().distinct()...<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>该方法是依赖 <code>HashSet＜E＞</code> 实现去重的，所以判断元素是否相同是根据 <code>Object#hashCode</code> 和 <code>Object#equals</code> 来判断的。详见笔记：<code>Java</code> 数据类型（<code>obsidian</code> 内部链接：<a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">笔记：Java数据类型</a>，<code>Hexo</code> 链接： <a href="http://blog.wangjia.ink/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">http://blog.wangjia.ink/2025/11/27/笔记：Java数据类型/</a> ）</li></ol></blockquote><hr><h5 id="5-2-1-3-映射方法"><a href="#5-2-1-3-映射方法" class="headerlink" title="5.2.1.3. 映射方法"></a>5.2.1.3. 映射方法</h5><h6 id="5-2-1-3-1-＜R＞-Stream＜R＞-map-Function＜-super-T-extends-R＞-mapper"><a href="#5-2-1-3-1-＜R＞-Stream＜R＞-map-Function＜-super-T-extends-R＞-mapper" class="headerlink" title="5.2.1.3.1. ＜R＞ Stream＜R＞ map(Function＜? super T, ? extends R＞ mapper)"></a>5.2.1.3.1. ＜R＞ Stream＜R＞ map(Function＜? super T, ? extends R＞ mapper)</h6><p>该方法用于非阻塞对 <code>Java Stream</code> 中的每个元素执行传入的方法参数 <code>mapper</code>（即一个 <code>Function＜T, R＞</code> 类型的回调函数）</p><p>该方法与 <code>Stream＜T＞#flatMap</code> 的区别在于：<code>Stream＜T＞#flatMap</code> 在处理完 <code>Java Stream</code> 中的每个元素后，必须返回一个 <code>Java Stream</code>，并最终合成一个大的 <code>Java Stream</code>。但是该方法在处理完 <code>Java Stream</code> 中的每个元素后，不能返回一个 <code>Java Stream</code>，而是返回其他引用数据类型的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().map(name -&gt; name.length())...<br></code></pre></td></tr></table></figure><hr><h6 id="5-2-1-3-2-IntStream-mapToInt-ToIntFunction＜-super-T＞-mapper"><a href="#5-2-1-3-2-IntStream-mapToInt-ToIntFunction＜-super-T＞-mapper" class="headerlink" title="5.2.1.3.2. IntStream mapToInt(ToIntFunction＜? super T＞ mapper)"></a>5.2.1.3.2. IntStream mapToInt(ToIntFunction＜? super T＞ mapper)</h6><p>该方法用于非阻塞将普通流转化成特化流</p><hr><h6 id="5-2-1-3-3-LongStream-mapToLong-ToLongFunction＜-super-T＞-mapper"><a href="#5-2-1-3-3-LongStream-mapToLong-ToLongFunction＜-super-T＞-mapper" class="headerlink" title="5.2.1.3.3. LongStream mapToLong(ToLongFunction＜? super T＞ mapper)"></a>5.2.1.3.3. LongStream mapToLong(ToLongFunction＜? super T＞ mapper)</h6><p>该方法用于非阻塞将普通流转化成特化流</p><hr><h6 id="5-2-1-3-4-DoubleStream-mapToDouble-ToDoubleFunction＜-super-T＞-mapper"><a href="#5-2-1-3-4-DoubleStream-mapToDouble-ToDoubleFunction＜-super-T＞-mapper" class="headerlink" title="5.2.1.3.4. DoubleStream mapToDouble(ToDoubleFunction＜? super T＞ mapper)"></a>5.2.1.3.4. DoubleStream mapToDouble(ToDoubleFunction＜? super T＞ mapper)</h6><p>该方法用于非阻塞将普通流转化成特化流</p><hr><h6 id="5-2-1-3-5-＜R＞-Stream＜R＞-flatMap-Function＜-super-T-extends-Stream＜-extends-R＞＞-mapper"><a href="#5-2-1-3-5-＜R＞-Stream＜R＞-flatMap-Function＜-super-T-extends-Stream＜-extends-R＞＞-mapper" class="headerlink" title="5.2.1.3.5. ＜R＞ Stream＜R＞ flatMap(Function＜? super T, ? extends Stream＜? extends R＞＞ mapper)"></a>5.2.1.3.5. ＜R＞ Stream＜R＞ flatMap(Function＜? super T, ? extends Stream＜? extends R＞＞ mapper)</h6><p>该方法用于非阻塞对 <code>Java Stream</code> 中的每个元素执行传入的方法参数 <code>mapper</code>（即一个 <code>Function＜T, R＞</code> 类型的回调函数）</p><p>该方法与 <code>Stream＜T＞#map</code> 的区别在于： 该方法在处理完 <code>Java Stream</code> 中的每个元素后，必须返回一个 <code>Java Stream</code>，并最终合成一个大的 <code>Java Stream</code>。但是 <code>Stream＜T＞#Map</code> 在处理完 <code>Java Stream</code> 中的每个元素后，不能返回一个 <code>Java Stream</code>，而是返回其他引用数据类型的实例</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Stream＜T＞#map</code> 最核心的作用就是消除嵌套（即解构）：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//针对 Array </span><br>String[][] matrix = &#123;<br>    &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 针对 Set＜E＞ </span><br>Set&lt;Set&lt;String&gt;&gt; teamTags = Set.of(<br>    Set.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Spring&quot;</span>),  <br>    Set.of(<span class="hljs-string">&quot;Spring&quot;</span>, <span class="hljs-string">&quot;MyBatis&quot;</span>) <br>);<br><br><span class="hljs-comment">// 针对 List＜E＞ </span><br>List&lt;List&lt;String&gt;&gt; school = List.of(<br>    List.of(<span class="hljs-string">&quot;学生A&quot;</span>, <span class="hljs-string">&quot;学生B&quot;</span>), <br>    List.of(<span class="hljs-string">&quot;学生C&quot;</span>, <span class="hljs-string">&quot;学生D&quot;</span>) <br>);<br><br><span class="hljs-comment">// 针对 Map＜K, V＞ </span><br>Map&lt;String, List&lt;String&gt;&gt; bookshelf = Map.of(<br>    <span class="hljs-string">&quot;科技&quot;</span>, List.of(<span class="hljs-string">&quot;深入理解Java虚拟机&quot;</span>, <span class="hljs-string">&quot;并发编程实战&quot;</span>),<br>    <span class="hljs-string">&quot;文学&quot;</span>, List.of(<span class="hljs-string">&quot;三体&quot;</span>)<br>);<br><br><span class="hljs-comment">// 针对 Queue＜E＞ </span><br>Queue&lt;List&lt;String&gt;&gt; messageQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>messageQueue.add(List.of(<span class="hljs-string">&quot;Msg1&quot;</span>, <span class="hljs-string">&quot;Msg2&quot;</span>));<br>messageQueue.add(List.of(<span class="hljs-string">&quot;Msg3&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h6 id="5-2-1-3-6-IntStream-flatMapToInt-Function＜-super-T-extends-IntStream＞-mapper"><a href="#5-2-1-3-6-IntStream-flatMapToInt-Function＜-super-T-extends-IntStream＞-mapper" class="headerlink" title="5.2.1.3.6. IntStream flatMapToInt(Function＜? super T, ? extends IntStream＞ mapper)"></a>5.2.1.3.6. IntStream flatMapToInt(Function＜? super T, ? extends IntStream＞ mapper)</h6><p>该方法用于非阻塞将普通流转化成特化流（需要注意的是：先扁平化，再转化）</p><hr><h6 id="5-2-1-3-7-LongStream-flatMapToLong-Function＜-super-T-extends-LongStream＞-mapper"><a href="#5-2-1-3-7-LongStream-flatMapToLong-Function＜-super-T-extends-LongStream＞-mapper" class="headerlink" title="5.2.1.3.7. LongStream flatMapToLong(Function＜? super T, ? extends LongStream＞ mapper)"></a>5.2.1.3.7. LongStream flatMapToLong(Function＜? super T, ? extends LongStream＞ mapper)</h6><p>该方法用于非阻塞将普通流转化成特化流（需要注意的是：先扁平化，再转化）</p><hr><h6 id="5-2-1-3-8-DoubleStream-flatMapToDouble-Function＜-super-T-extends-DoubleStream＞-mapper"><a href="#5-2-1-3-8-DoubleStream-flatMapToDouble-Function＜-super-T-extends-DoubleStream＞-mapper" class="headerlink" title="5.2.1.3.8. DoubleStream flatMapToDouble(Function＜? super T, ? extends DoubleStream＞ mapper)"></a>5.2.1.3.8. DoubleStream flatMapToDouble(Function＜? super T, ? extends DoubleStream＞ mapper)</h6><p>该方法用于非阻塞将普通流转化成特化流（需要注意的是：先扁平化，再转化）</p><hr><h4 id="5-2-2-特化流独属方法"><a href="#5-2-2-特化流独属方法" class="headerlink" title="5.2.2. 特化流独属方法"></a>5.2.2. 特化流独属方法</h4><p>特化流独属方法是 <code>java.util.stream.IntStream</code> 接口、<code>java.util.stream.LongStream</code> 接口、<code>java.util.stream.DoubleStream</code> 接口中的一些方法</p><hr><h3 id="5-3-结束方法"><a href="#5-3-结束方法" class="headerlink" title="5.3. 结束方法"></a>5.3. 结束方法</h3><h4 id="5-3-1-通用方法"><a href="#5-3-1-通用方法" class="headerlink" title="5.3.1. 通用方法"></a>5.3.1. 通用方法</h4><p>通用方法是 <code>java.util.stream.Stream＜T＞</code> 接口中的一些方法</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>除了下面的方法外，还有统计方法、匹配方法、查询方法，用到再学</li></ol></blockquote><h5 id="5-3-1-1-遍历方法"><a href="#5-3-1-1-遍历方法" class="headerlink" title="5.3.1.1. 遍历方法"></a>5.3.1.1. 遍历方法</h5><h6 id="5-3-1-1-1-void-forEach-Consumer＜-super-T＞-action"><a href="#5-3-1-1-1-void-forEach-Consumer＜-super-T＞-action" class="headerlink" title="5.3.1.1.1. void forEach(Consumer＜? super T＞  action)"></a>5.3.1.1.1. void forEach(Consumer＜? super T＞  action)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().forEach(name -&gt; System.out.println(name))<br></code></pre></td></tr></table></figure><hr><h5 id="5-3-1-2-收集方法"><a href="#5-3-1-2-收集方法" class="headerlink" title="5.3.1.2. 收集方法"></a>5.3.1.2. 收集方法</h5><h6 id="5-3-1-2-1-将元素收集到-String-中"><a href="#5-3-1-2-1-将元素收集到-String-中" class="headerlink" title="5.3.1.2.1. 将元素收集到 String 中"></a>5.3.1.2.1. 将元素收集到 String 中</h6><p><font color="#92d050">1. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector) 结合 Collectors.joining()</font><br>该方法用于非阻塞将元素拼接成一个长字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().collect(Collectors.joining()).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector)  结合 Collectors.joining(CharSequence delimiter)</font><br>该方法用于非阻塞将元素拼接成一个长字符串，并且中间用指定的符号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>)).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">3. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector)  结合 Collectors.joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</font><br>该方法用于非阻塞将元素拼接成一个长字符串，并且中间用指定的符号隔开，而且在拼接后的字符串的开头和结尾追加指定的符号（即前缀和后缀）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>)).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>结果的形式是这样的：<code>[A, ,B, C]</code></li></ol></blockquote><hr><h6 id="5-3-1-2-2-将元素收集到数组中"><a href="#5-3-1-2-2-将元素收集到数组中" class="headerlink" title="5.3.1.2.2. 将元素收集到数组中"></a>5.3.1.2.2. 将元素收集到数组中</h6><p><font color="#92d050">1. Stream＜T＞#toArray()</font><br>该方法用于非阻塞将元素收集到 <code>Object</code> 类型的 <code>Array</code> 实例中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().toArray().<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. Stream＜T＞#toArray(IntFunction＜A[]＞ generator)</font><br>该方法用于将元素收集到 “实例化工厂” 创建的 <code>Array</code> 实例中（需要注意的是：阻塞、非阻塞、限时阻塞要看回调函数的具体逻辑）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().toArray(size -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">100</span>]).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><hr><h6 id="5-3-1-2-3-将元素收集到-List＜E＞-中"><a href="#5-3-1-2-3-将元素收集到-List＜E＞-中" class="headerlink" title="5.3.1.2.3. 将元素收集到 List＜E＞ 中"></a>5.3.1.2.3. 将元素收集到 List＜E＞ 中</h6><p><font color="#92d050">1. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector) 结合 Collectors.toCollection(Supplier＜C＞ collectionFactory)</font><br>该方法用于将元素收集到 “实例化工厂” 创建的 <code>List＜E＞</code> 实例中（需要注意的是：阻塞、非阻塞、限时阻塞要看回调函数的具体逻辑）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().collect(Collectors.toCollection(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;())).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><hr><h6 id="5-3-1-2-4-将元素收集到-Set＜E＞-中"><a href="#5-3-1-2-4-将元素收集到-Set＜E＞-中" class="headerlink" title="5.3.1.2.4. 将元素收集到 Set＜E＞ 中"></a>5.3.1.2.4. 将元素收集到 Set＜E＞ 中</h6><p><font color="#92d050">1. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector) 结合 Collectors.toCollection(Supplier＜C＞ collectionFactory)</font><br>该方法用于将元素收集到 “实例化工厂” 创建的 <code>Set＜E＞</code> 实例中（需要注意的是：阻塞、非阻塞、限时阻塞要看回调函数的具体逻辑）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().collect(Collectors.toCollection(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;())).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><hr><h6 id="5-3-1-2-5-将元素收集到-Map＜K-V＞-中"><a href="#5-3-1-2-5-将元素收集到-Map＜K-V＞-中" class="headerlink" title="5.3.1.2.5. 将元素收集到 Map＜K, V＞ 中"></a>5.3.1.2.5. 将元素收集到 Map＜K, V＞ 中</h6><p><font color="#92d050">1. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector) 结合 Collectors.toMap(Function＜? super T, ? extends K＞ keyMapper, Function＜? super T, ? extends U＞ valueMapper, BinaryOperator＜U＞ mergeFunction, Supplier＜M＞ mapFactory)</font><br>该方法用于将元素收集到 “实例化工厂” 创建的 <code>Map＜K, V＞</code> 实例中（需要注意的是：阻塞、非阻塞、限时阻塞要看回调函数的具体逻辑）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.stream().collect(<br>    Collectors.toMap(<br>    <br> <span class="hljs-comment">// Key</span><br>        user -&gt; user.getId(),<br>        <br><span class="hljs-comment">// Value</span><br>        user -&gt; user,<br>        <br>    <span class="hljs-comment">// Key 重复时的冲突解决策略</span><br>        (oldV, newV) -&gt; newV,<br>        <br>        <span class="hljs-comment">// 生成 Map＜K, V＞ 实例的 “实例化工厂”</span><br>        () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;()<br>    )<br>).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector) 结合 Collectors.groupingBy(Function＜? super T, ? extends K＞ classifier, Supplier＜M＞ mapFactory, Collector＜? super T, A, D＞ downstream)</font><br>该方法用于将元素收集到 “实例化工厂” 创建的 <code>Map＜K, V＞</code> 实例中（需要注意的是：阻塞、非阻塞、限时阻塞要看回调函数的具体逻辑）</p><p>需要注意的是：该方法其实是将元素收集到 <code>Map＜K, List＜V＞＞</code> 实例中，类似于 <code>MySQL</code> 中的分组查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeMap&lt;Long, List&lt;User&gt;&gt; sortedGroupMap = myList.stream().collect(<br>    Collectors.groupingBy(<br>    <br>    <span class="hljs-comment">// 分类器（分组器）</span><br>        User::getDeptId, <br>        <br>        <span class="hljs-comment">// 创建 Map＜K, V＞ 实例的 “实例化工厂”</span><br>        TreeMap::<span class="hljs-keyword">new</span>,<br>        <br>        <span class="hljs-comment">// 将元素分组后，对每一组执行该传入的方法参数</span><br>        Collectors.toList()<br>    )<br>);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>所谓的 “将元素分组后，对每一组执行该传入的方法参数” 是指：类似于 <code>MySQL</code> 中的分组查询通常与聚合函数配合使用一样，这里就扮演 “聚合函数” 的角色（需要注意的是：通常结合 <code>Collectors</code> 提供的一些方法）</li></ol></blockquote><p><font color="#92d050">3. Stream＜T＞#collect(Collector＜? super T, A, R＞ collector) 结合 Collectors.groupingByConcurrent(Function＜? super T, ? extends K＞ classifier, Supplier＜M＞ mapFactory, Collector＜? super T, A, D＞ downstream) </font><br>该方法用于将元素收集到 “实例化工厂” 创建的 <code>Map＜K, V＞</code> 实例中（需要注意的是：阻塞、非阻塞、限时阻塞要看回调函数的具体逻辑）</p><p>该方法同样是将元素收集到 <code>Map＜K, List＜V＞＞</code> 实例中，类似于 <code>MySQL</code> 中的分组查询</p><p>该方法与上面的方法的区别在于： 我们知道 “<code>Java Stream</code> 的并行流是使用 <code>ForkJoinPool</code> 实现分而治之、迭代拆分、工作窃取的”。如果使用上面的方法，会生成多个小 <code>Map＜K, V＞</code> 实例用来存储每部分被拆分后的元素被 <code>Java Stream</code> 处理后的结果，然后再合并成一个大的 <code>Map＜K, V＞</code> 实例。而该方法是让所有执行 <code>Java Stream</code> 的并行流的线程共同向同一个多线程并发安全的 <code>Map＜K, V＞</code> 实例进行写操作，不需要创建多个小 <code>Map＜K, V＞</code> 实例和最后的合并动作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentMap&lt;Long, List&lt;User&gt;&gt; concurrentMap = myList.parallelStream().collect(<br>    Collectors.groupingByConcurrent(<br>    <br>    <span class="hljs-comment">// 分类器（分组器）</span><br>        User::getDeptId,<br>        <br>        <span class="hljs-comment">// 生成 Map＜K, V＞ 实例的 “实例化工厂”</span><br>        ConcurrentHashMap::<span class="hljs-keyword">new</span>,<br>        <br>        <span class="hljs-comment">// 将元素分组后，对每一组执行该传入的方法参数</span><br>        Collectors.toList()<br>    )<br>);<br></code></pre></td></tr></table></figure><hr><h4 id="5-3-2-特化流独属方法"><a href="#5-3-2-特化流独属方法" class="headerlink" title="5.3.2. 特化流独属方法"></a>5.3.2. 特化流独属方法</h4><p>特化流独属方法是 <code>java.util.stream.IntStream</code> 接口、<code>java.util.stream.LongStream</code> 接口、<code>java.util.stream.DoubleStream</code> 接口中的一些方法</p><hr><h1 id="六、CompletableFuture＜T＞"><a href="#六、CompletableFuture＜T＞" class="headerlink" title="六、CompletableFuture＜T＞"></a>六、CompletableFuture＜T＞</h1><p>详见源码：<code>CompletableFuture＜T＞</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletableFuture%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CompletableFuture＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CompletableFuture%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.concurrent.CompletableFuture＜T＞源码解析/</a></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 函数式编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.RandomAccess 源码解析</title>
    <link href="/2025/11/30/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.RandomAccess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/30/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.RandomAccess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/30/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.RandomAccess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/30/源码：java.util.RandomAccess源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-RandomAccess-概述"><a href="#3-1-RandomAccess-概述" class="headerlink" title="3.1. RandomAccess 概述"></a>3.1. RandomAccess 概述</h3><p><code>RandomAccess</code> 是一个接口</p><p>我们知道：在 <code>Java</code> 应用中，遍历一个集合通常有两种方式：索引遍历、迭代器遍历。而 <code>RandomAccess</code> 是一个标记接口，只要我们 <code>Implements RandomAccess</code>，他就告诉其他算法 “使用哪种遍历方式最快”（是告诉其他算法）</p><p>如果 <code>Implements RandomAccess</code>，最好使用索引遍历。如果没有 <code>Implements RandomAccess</code>，最好使用迭代器遍历</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞获取迭代器实例</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 即获取一个实现了 Iterator 接口的具体实现类实例，其内部维护了一个数据结构用来存储元素</span><br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞遍历迭代器实例维护的数据结构中的所有元素，并对每个元素执行传入的方法参数 action</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞获取可拆分迭代器实例</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 即获取一个实现了 Spliterator 接口的具体实现类实例</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Iterator＜E＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Iterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.Iterator＜E＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Iterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.util.Iterator＜E＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Consumer＜T＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.function.Consumer＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Consumer＜T＞源码解析/</a></li></ol></li></ol></li><li>增强 <code>for</code> 循环（<code>for-each</code> 循环）是 <code>Java</code> 提供的一种语法糖，在编译阶段会被编译器自动转换为等价的迭代器遍历代码</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译前</span><br><span class="hljs-keyword">for</span> (T t : iterable) &#123;<br>xxxxxx<br>&#125;<br><br><br><span class="hljs-comment">// 编译后</span><br><span class="hljs-keyword">for</span> (Iterator&lt;T&gt; it = iterable.iterator(); it.hasNext(); ) &#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> it.next();<br>xxxxxx<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>4. <code>Spliterator</code> 是 <code>Java8</code> 为了支持并行流而专门引入的一个接口。详见笔记：<code>Java</code> 函数式编程（<code>obsidian</code> 内部链接：<a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">笔记：Java函数式编程</a>，<code>Hexo</code> 链接：）</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 数据类型</title>
    <link href="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><ul><li><input disabled="" type="checkbox"> List<ul><li><input checked="" disabled="" type="checkbox"> ArrayList</li><li><input checked="" disabled="" type="checkbox"> LinkedList</li><li><input disabled="" type="checkbox"> CopyOnWriteArrayList</li></ul></li><li><input disabled="" type="checkbox"> Set 去重，去重，去重！！！！说啊<ul><li><input disabled="" type="checkbox"> TreeSet</li><li><input disabled="" type="checkbox"> HashSet</li><li><input disabled="" type="checkbox"> EnumSet</li><li><input disabled="" type="checkbox"> LinkedHashSet 最重要的就是 LRU</li><li><input disabled="" type="checkbox"> CopyOnWriteArraySet</li></ul></li><li><input disabled="" type="checkbox"> Map<ul><li><input checked="" disabled="" type="checkbox"> TreeMap</li><li><input checked="" disabled="" type="checkbox"> HashMap</li><li><input disabled="" type="checkbox"> EnumMap</li><li><input checked="" disabled="" type="checkbox"> WeakHashMap</li><li><input checked="" disabled="" type="checkbox"> LinkedHashMap</li><li><input checked="" disabled="" type="checkbox"> ConcurrentHashMap</li><li><input disabled="" type="checkbox"> ConcurrentSkipListMap</li></ul></li><li><input disabled="" type="checkbox"> Queue<ul><li><input checked="" disabled="" type="checkbox"> LinkedList</li><li><input disabled="" type="checkbox"> ArrayBlockingQueue</li><li><input disabled="" type="checkbox"> LinkedBlockingQueue</li><li><input disabled="" type="checkbox"> PriorityBlockingQueue</li><li><input disabled="" type="checkbox"> DelayQueue</li><li><input disabled="" type="checkbox"> SynchronousQueue</li><li><input disabled="" type="checkbox"> LinkedTransferQueue</li><li><input disabled="" type="checkbox"> PriorityQueue</li><li><input disabled="" type="checkbox"> ConcurrentLinkedQueue</li><li><input disabled="" type="checkbox"> ScheduledThreadPoolExecutor.DelayedWorkQueue</li><li><input disabled="" type="checkbox"> ForkJoinPool.WorkQueue</li><li><input disabled="" type="checkbox"> ArrayDeque</li><li><input disabled="" type="checkbox"> LinkedBlockingDeque</li><li><input disabled="" type="checkbox"> ConcurrentLinkedDeque</li></ul></li><li><input disabled="" type="checkbox"> instanceof 的原理</li><li><input disabled="" type="checkbox"> 为什么 Java 要设计成 “伪泛型”</li><li><input disabled="" type="checkbox"> 为什么无法使用 instanceof 检查泛型类型（泛型类型是指什么）</li><li><input disabled="" type="checkbox"> 内部类之后，继续回到 Java 函数式编程从lambda 表达式继续开始</li></ul><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">http://blog.wangjia.ink/2025/11/27/笔记：Java数据类型/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/Java-2b7974fbda5e80849377f2d49f812c50?source=copy_link">https://www.notion.so/Java-2b7974fbda5e80849377f2d49f812c50?source=copy_link</a></p></li></ol><hr><h1 id="四、引用数据类型"><a href="#四、引用数据类型" class="headerlink" title="四、引用数据类型"></a>四、引用数据类型</h1><h2 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h2><h3 id="1-1-具体类"><a href="#1-1-具体类" class="headerlink" title="1.1. 具体类"></a>1.1. 具体类</h3><h4 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h4><h5 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h5><p>详见源码：<code>String</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9AString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：String源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/25/%E6%BA%90%E7%A0%81%EF%BC%9AString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/25/源码：String源码解析/</a></li></ol></li></ol><hr><h4 id="1-1-1-内部类"><a href="#1-1-1-内部类" class="headerlink" title="1.1.1. 内部类"></a>1.1.1. 内部类</h4><ol><li>实例内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li><li><code>Lambda</code> 表达式</li></ol><table><thead><tr><th>特性</th><th><strong>实例内部类</strong></th><th><strong>静态内部类</strong></th><th><strong>局部内部类</strong></th><th><strong>匿名内部类</strong></th><th>Lambda 表达式</th></tr></thead><tbody><tr><td><strong>位置</strong></td><td>类内部，但是在方法外部</td><td>类内部，但是在方法外部</td><td>方法内部</td><td>1. 类内部，但是在方法外部（赋值）<br>2. 方法参数<br>3. 方法内部</td><td>1. 类内部，但是在方法外部（赋值）<br>2. 方法参数<br>3. 方法内部</td></tr><tr><td><strong>对象的实例化方式</strong></td><td>先创建上层类实例，再通过上层类实例创建内部类实例</td><td>直接创建内部类实例</td><td>直接创建内部类实例（只能在创建局部内部类的方法内部创建内部类实例）</td><td>创建内部类的同时，会自动创建内部类实例</td><td>创建 <code>Lambda</code> 表达式的同时，会自动创建内部类实例</td></tr><tr><td><strong>this 指向的位置</strong></td><td>内部类实例本身</td><td>内部类实例本身</td><td>内部类实例本身</td><td>内部类实例本身</td><td>1. 如果 <code>Lambda</code> 表达式被创建在类的内部，但是在方法外：上层类实例<br>2. 如果 <code>Lambda</code> 表达式被创建在实例方法的方法参数或方法内部：调用这个实例方法的实例<br>3. 如果 <code>Lambda</code> 表达式被创建在静态方法的方法参数或方法内部：没有 <code>this</code>，不能使用 <code>this</code></td></tr><tr><td><strong>是否持有上层类的引用</strong></td><td>✅（<code>this$0</code>）</td><td>❌</td><td>1. 如果局部内部类被创建在实例方法的内部：✅<br>2. 如果局部内部类被创建在静态方法的内部：❌</td><td>1. 如果不涉及到静态：✅<br>2. 如果涉及到静态：❌（例如匿名内部类实例被赋值给静态变量或静态常量，又或者匿名内部类被创建在静态方法的方法参数或方法内部）</td><td>1. 如果 <code>Lambda</code> 表达式的方法体中涉及到上层类的非静态变量、常量、方法、内部类：✅<br>2. 如果 <code>Lambda</code> 表达式的方法体中没有涉及到上层类的非静态变量、常量、方法、内部类：❌</td></tr><tr><td><strong>支持的访问修饰符</strong></td><td>所有</td><td>所有</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td><strong>支持的类级别的非访问修饰符</strong></td><td><code>final</code>、<code>strictfp</code>、<code>abstract</code>、<code>sealed</code>、<code>non-sealed</code></td><td><code>final</code>、<code>static</code>、<code>strictfp</code>、<code>abstract</code>、<code>sealed</code>、<code>non-sealed</code></td><td><code>final</code>、<code>strictfp</code>、<code>asbtract</code></td><td>不支持</td><td>不支持</td></tr><tr><td><strong>支持的属性级别的非访问修饰符</strong></td><td><code>final</code>、<code>volatile</code>、<code>transient</code></td><td><code>final</code>、<code>static</code>、<code>volatile</code>、<code>tr</code>abstract<code>、</code>sealed<code>、</code>non-sealed<code>ansient</code>（在 <code>Java16</code> 之后，允许在内部类中使用 <code>static</code> 非访问修饰符）</td><td><code>final</code>、<code>static</code>、<code>volatile</code>、<code>transient</code>（在 <code>Java16</code> 之后，允许在内部类中使用 <code>static</code> 非访问修饰符）</td><td><code>final</code>、<code>static</code>、<code>volatile</code>、<code>transient</code>（在 <code>Java16</code> 之后，允许在内部类中使用 <code>static</code> 非访问修饰符）</td><td><code>final</code>（<code>Lambda</code> 表达式和其他四种内部类终究是不同。创建四种内部类是真的在创建一个类，属性是正儿八经的属性。但是我们创建 <code>Lambda</code> 表达式，其方法体本质上对某函数式接口的接口方法（普通）的实现，所以属性其实是局部变量。而局部变量只支持 <code>final</code> 非访问修饰符</td></tr><tr><td><strong>支持的方法级别的非访问修饰符</strong></td><td><code>final</code>、<code>native</code>、<code>strictfp</code>、<code>synchronized</code></td><td><code>final</code>、<code>static</code>、<code>native</code>、<code>strictfp</code>、<code>synchronized</code>（在 <code>Java16</code> 之后，允许在内部类中使用 <code>static</code> 非访问修饰符）</td><td><code>final</code>、<code>static</code>、<code>native</code>、<code>strictfp</code>、<code>synchronized</code>（在 <code>Java16</code> 之后，允许在内部类中使用 <code>static</code> 非访问修饰符）</td><td><code>final</code>、<code>static</code>、<code>native</code>、<code>strictfp</code>、<code>synchronized</code>（在 <code>Java16</code> 之后，允许在内部类中使用 <code>static</code> 非访问修饰符）</td><td>不支持</td></tr><tr><td><strong>是否能直接访问上层类中的非静态的变量、常量、方法、内部类</strong></td><td>✅</td><td>❌</td><td>1. 如果局部内部类被创建在实例方法的内部：✅<br>2. 如果局部内部类被创建在静态方法的内部：❌</td><td>1. 如果不涉及到静态：✅<br>2. 如果涉及到静态：❌</td><td>1. 如果 <code>Lambda</code> 表达式的方法体中涉及到上层类的非静态变量、常量、方法、内部类：✅<br>2. 如果 <code>Lambda</code> 表达式的方法体中没有涉及到上层类的非静态变量、常量、方法、内部类：❌</td></tr><tr><td><strong>.class 文件的文件名</strong></td><td><code>Outer$Inner.class</code></td><td><code>Outer$Inner.class</code></td><td><code>Outer$1Inner.class</code>（有数字编号）</td><td><code>Outer$1.class</code>（纯数字编号）</td><td>无 <code>.class</code> 文件</td></tr></tbody></table><blockquote><p>[!NOTE] 注意事项</p><ol><li>局部内部类中的变量、常量并不是局部变量，因为它是一个正儿八经的类，只不过被创建在某方法的内部。而方法中的变量才是真正的局部变量</li><li>匿名内部类和 <code>Lambda</code> 表达式不像其他内部类一样，需要先创建类然后再创建其实例，而是我们在创建匿名内部类和 <code>Lambda</code> 表达式的时候，就自动创建了其实例并返回。所以我们说 “匿名内部类和 <code>Lambda</code> 表达式可以创建在类内部，但是在方法外部”，其实就是将其返回的实例赋值给类的变量或常量：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">memberLambda</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;...&quot;</span>);<br>    <br><span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] Title<br>3. 静态内部类与上层类在地位上是一样的，因为静态内部类除了在上层类的内部，其他的和上层类一点关系没有，所以不会持有上层类的引用<br>4. 所谓的 “持有上层类的引用” 是指：在编译阶段，编译器会自动为内部类添加一个实例变量，用于记录上层类的引用（需要注意的是：只会记录上层类的引用，并不会记录上层类的上层类的引用。如果确实需要访问上层类的上层类，需要借助上层类持有的引用来访问）<br>5. 如果内部类能直接访问上层类中的非静态的变量、常量、方法、内部类，那么即便是使用 <code>private</code> 访问修饰符修饰，也能访问<br>6. 局部内部类、匿名内部类、<code>Lambda</code> 表达式如果需要访问局部变量，只能访问 <code>final</code> 修饰的局部变量或 <code>Effectively Final</code> 的局部变量（在编译阶段，编译器会自动判断出哪些变量在初始化后就没有再被修改过，那么这些变量就算 <code>Effectively Final</code> 的变量）<br>7. 局部变量也只能是 <code>final</code> 修饰的局部变量或 <code>Effectively Final</code> 的局部变量，否则在编译阶段，编译器会报错<br>8. 个人推荐规范一些语法：<br>    1. 访问本方法中的成员时：<br>        1. 变量、常量<br>            1. 局部变量<br>                1. 使用 <code>secret</code><br>        2. 内部类<br>            1. 局部内部类<br>                1. 创建实例时使用 <code>new Inner()</code><br>    2. 访问本类实例中的成员时：<br>        1. 变量、常量<br>            1. 普通常量、实例变量<br>                1. 使用 <code>this.secret</code><br>            2. 静态常量、静态变量<br>                1. 使用  <code>类名.secret</code><br>        2. 方法<br>            1. 实例方法<br>                1. 使用 <code>this.run()</code><br>            2. 静态方法<br>                1. 使用 <code>类名.run()</code><br>        3. 内部类<br>            1. 实例内部类<br>                1. 创建实例时使用 <code>this.new Inner()</code><br>            2. 静态内部类<br>                1. 创建实例时使用 <code>new 类名.Inner()</code><br>    3. 访问上层类实例中的成员时：<br>        1. 变量、常量<br>            1. 普通常量、实例变量<br>                1. 使用 <code>Outer.this.secret</code><br>            2. 静态常量、静态变量<br>                1. 使用  <code>类名.secret</code><br>        2. 方法<br>            1. 实例方法<br>                1. 使用 <code>Outer.this.run()</code><br>            2. 静态方法<br>                1. 使用 <code>类名.run()</code><br>        3. 内部类<br>            1. 实例内部类<br>                1. 创建实例时使用 <code>Outer.this.new Inner()</code><br>            2. 静态内部类<br>                1. 创建实例时使用 <code>new 类名.Inner()</code><br>        4. 需要注意的是：访问上层类实例中的成员，需要内部类实例持有上层类的引用<br>    4. 访问其他类实例中的成员时：<br>        1. 变量、常量<br>            1. 普通常量、实例变量<br>                1. 使用 <code>new Outer() </code>和 <code>outer.secret</code><br>            2. 静态常量、静态变量<br>                1. 使用  <code>类名.secret</code><br>        2. 方法<br>            1. 实例方法<br>                1. 使用 <code>new Outer() </code>和 <code>outer.run()</code><br>            2. 静态方法<br>                1. 使用 <code>类名.run()</code><br>        3. 内部类<br>            1. 实例内部类<br>                1. 创建实例时使用 <code>new Outer() </code>和 <code>outer.new Inner()</code><br>            2. 静态内部类<br>                1. 创建实例时使用 <code>new 类名.Inner()</code></p></blockquote><hr><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h2><h3 id="2-1-Set＜E＞"><a href="#2-1-Set＜E＞" class="headerlink" title="2.1. Set＜E＞"></a>2.1. Set＜E＞</h3><h4 id="2-1-1-Set＜E＞-基础体系"><a href="#2-1-1-Set＜E＞-基础体系" class="headerlink" title="2.1.1. Set＜E＞ 基础体系"></a>2.1.1. Set＜E＞ 基础体系</h4><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3.png"></p><ol><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Cloneable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Cloneable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.lang.Cloneable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Iterable＜E＞</code><ol><li><code>obsidian</code> 内部链接：<br> 1. <a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Iterable＜T＞源码解析</a></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.lang.Iterable＜T＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Collection＜E＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Collection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.Collection＜E＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Collection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.util.Collection＜E＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Set＜E＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Set%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.Set＜E＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Set%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.util.Set＜E＞源码解析/</a></li></ol></li></ol></li></ol><hr><h4 id="2-1-2-Set＜E＞-相关分类"><a href="#2-1-2-Set＜E＞-相关分类" class="headerlink" title="2.1.2. Set＜E＞ 相关分类"></a>2.1.2. Set＜E＞ 相关分类</h4><ol><li><code>TreeSet＜E＞</code></li><li><code>HashSet＜E＞</code></li><li><code>EnumSet＜E＞</code></li><li><code>LinkedHashSet＜E＞</code></li><li><code>CopyOnWriteArraySet＜E＞</code></li><li><code>ConcurrentSkipListSet＜E＞</code></li><li><code>ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt;</code></li></ol><h4 id="2-1-3-TreeSet＜E＞"><a href="#2-1-3-TreeSet＜E＞" class="headerlink" title="2.1.3. TreeSet＜E＞"></a>2.1.3. TreeSet＜E＞</h4><h5 id="2-1-3-1-TreeSet＜E＞-体系结构"><a href="#2-1-3-1-TreeSet＜E＞-体系结构" class="headerlink" title="2.1.3.1. TreeSet＜E＞ 体系结构"></a>2.1.3.1. TreeSet＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5.png"></p><hr><h5 id="2-1-3-2-TreeSet＜E＞-底层实现"><a href="#2-1-3-2-TreeSet＜E＞-底层实现" class="headerlink" title="2.1.3.2. TreeSet＜E＞ 底层实现"></a>2.1.3.2. TreeSet＜E＞ 底层实现</h5><p><code>TreeSet＜E＞</code> 底层是基于一个 <code>TreeMap＜K, V＞</code> 实现的</p><p><code>TreeSet＜E＞</code> 是通过 <code>TreeSet＜E＞➔m</code> 存储数据的，而它又是 <code>NavigableMap＜K, V＞</code> 类型（实际初始化时就是一个 <code>TreeMap＜K, V＞</code>）</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然说 <code>TreeSet＜E＞</code> 底层是基于 <code>TreeMap＜K, V＞</code> 实现的，但是只使用了 <code>TreeMap＜K, V＞</code> 的 <code>Key</code> 来存储数据</li><li>由于 <code>TreeSet＜E＞</code> 底层是基于 <code>TreeMap＜K, V＞</code> 实现的，所以 <code>TreeSet＜E＞</code> 能够自动对元素进行排序（自然排序、定制排序）</li></ol></blockquote><hr><h5 id="2-1-3-3-TreeSet＜E＞-问题爆破"><a href="#2-1-3-3-TreeSet＜E＞-问题爆破" class="headerlink" title="2.1.3.3. TreeSet＜E＞ 问题爆破"></a>2.1.3.3. TreeSet＜E＞ 问题爆破</h5><p>由于<code>TreeSet＜E＞</code> 底层是基于一个 <code>TreeMap＜K, V＞</code> 实现的，所以 <code>TreeMap＜K, V＞</code> 拥有的问题，<code>TreeSet＜E＞</code> 一般都有。详见下文：<code>TreeMap＜K, V＞</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然说 <code>TreeSet＜E＞</code> 底层是基于 <code>TreeMap＜K, V＞</code> 实现的，但是只使用了 <code>TreeMap＜K, V＞</code> 的 <code>Key</code> 来存储数据。所以我们着重看 <code>TreeMap＜K, V＞</code> 的 <code>Key</code></li><li>为了解决 <code>TreeSet＜E＞</code> 多线程并发安全性问题，我们通常为其加锁或者使用另外一种数据结构：<code>ConcurrentSkipListSet＜E＞</code></li></ol></blockquote><hr><h4 id="2-1-4-HashSet＜E＞"><a href="#2-1-4-HashSet＜E＞" class="headerlink" title="2.1.4. HashSet＜E＞"></a>2.1.4. HashSet＜E＞</h4><h5 id="2-1-4-1-HashSet＜E＞-体系结构"><a href="#2-1-4-1-HashSet＜E＞-体系结构" class="headerlink" title="2.1.4.1. HashSet＜E＞ 体系结构"></a>2.1.4.1. HashSet＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6.png"></p><hr><h5 id="2-1-4-2-HashSet＜E＞-底层实现"><a href="#2-1-4-2-HashSet＜E＞-底层实现" class="headerlink" title="2.1.4.2. HashSet＜E＞ 底层实现"></a>2.1.4.2. HashSet＜E＞ 底层实现</h5><p><code>HashSet＜E＞</code> 底层是基于一个 <code>HashMap＜K, V＞</code> 实现的</p><p><code>HashSet＜E＞</code> 是通过 <code>HashSet＜E＞➔map</code> 存储数据的，而它又是 <code>HashMap＜K, V＞</code> 类型</p><hr><h5 id="2-1-4-3-HashSet＜E＞-问题爆破"><a href="#2-1-4-3-HashSet＜E＞-问题爆破" class="headerlink" title="2.1.4.3. HashSet＜E＞ 问题爆破"></a>2.1.4.3. HashSet＜E＞ 问题爆破</h5><p>由于<code>HashSet＜E＞</code> 底层是基于一个 <code>HashMap＜K, V＞</code> 实现的，所以 <code>HashMap＜K, V＞</code> 拥有的问题，<code>HashSet＜E＞</code> 一般都有。详见下文：<code>HashMap＜K, V＞</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然说 <code>HashSet＜E＞</code> 底层是基于 <code>HashMap＜K, V＞</code> 实现的，但是只使用了 <code>HashMap＜K, V＞</code> 的 <code>Key</code> 来存储数据。所以我们着重看 <code>HashMap＜K, V＞</code> 的 <code>Key</code></li><li>为了解决 <code>HashSet＜E＞</code> 多线程并发安全性问题，我们通常为其加锁或者使用另外一种数据结构：<code>ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt;</code></li></ol></blockquote><hr><h4 id="2-1-5-LinkedHashSet＜E＞"><a href="#2-1-5-LinkedHashSet＜E＞" class="headerlink" title="2.1.5. LinkedHashSet＜E＞"></a>2.1.5. LinkedHashSet＜E＞</h4><h5 id="2-1-5-1-LinkedHashSet＜E＞-体系结构"><a href="#2-1-5-1-LinkedHashSet＜E＞-体系结构" class="headerlink" title="2.1.5.1. LinkedHashSet＜E＞ 体系结构"></a>2.1.5.1. LinkedHashSet＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-27.png"></p><hr><h5 id="2-1-5-2-LinkedHashSet＜E＞-底层实现"><a href="#2-1-5-2-LinkedHashSet＜E＞-底层实现" class="headerlink" title="2.1.5.2. LinkedHashSet＜E＞ 底层实现"></a>2.1.5.2. LinkedHashSet＜E＞ 底层实现</h5><p><code>LinkedHashSet＜E＞</code> 底层是基于一个 <code>LinkedHashMap＜K, V＞</code> 实现的</p><p><code>LinkedHashSet＜E＞</code> 是通过父类的 <code>HashSet＜E＞-&gt;map</code> 来存储数据的，而它又是 <code>HashMap＜K, V＞</code> 类型（实际初始化时就是一个 <code>LinkedHashMap＜K, V＞</code>）</p><hr><h5 id="2-1-5-3-LinkedHashSet＜E＞-问题爆破"><a href="#2-1-5-3-LinkedHashSet＜E＞-问题爆破" class="headerlink" title="2.1.5.3. LinkedHashSet＜E＞ 问题爆破"></a>2.1.5.3. LinkedHashSet＜E＞ 问题爆破</h5><p>由于<code>LinkedHashSet＜E＞</code> 底层是基于一个 <code>LinkedHashMap＜K, V＞</code> 实现的，所以 <code>LinkedHashMap＜K, V＞</code> 拥有的问题，<code>LinkedHashSet＜E＞</code> 一般都有。详见下文：<code>LinkedHashMap＜K, V＞</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然说 <code>LinkedHashSet＜E＞</code> 底层是基于 <code>LinkedHashMap＜K, V＞</code> 实现的，但是只使用了 <code>LinkedHashMap＜K, V＞</code> 的 <code>Key</code> 来存储数据。所以我们着重看 <code>LinkedHashMap＜K, V＞</code> 的 <code>Key</code></li><li>为了解决 <code>LinkedHashSet＜E＞</code> 多线程并发安全性问题，我们通常为其加锁</li></ol></blockquote><hr><h4 id="2-1-6-CopyOnWriteArraySet＜E＞"><a href="#2-1-6-CopyOnWriteArraySet＜E＞" class="headerlink" title="2.1.6. CopyOnWriteArraySet＜E＞"></a>2.1.6. CopyOnWriteArraySet＜E＞</h4><h5 id="2-1-6-1-CopyOnWriteArraySet＜E＞-体系结构"><a href="#2-1-6-1-CopyOnWriteArraySet＜E＞-体系结构" class="headerlink" title="2.1.6.1. CopyOnWriteArraySet＜E＞ 体系结构"></a>2.1.6.1. CopyOnWriteArraySet＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7.png"></p><hr><h5 id="2-1-6-2-CopyOnWriteArraySet＜E＞-底层实现"><a href="#2-1-6-2-CopyOnWriteArraySet＜E＞-底层实现" class="headerlink" title="2.1.6.2. CopyOnWriteArraySet＜E＞ 底层实现"></a>2.1.6.2. CopyOnWriteArraySet＜E＞ 底层实现</h5><p><code>CopyOnWriteArraySet＜E＞</code> 底层是基于一个 <code>CopyOnWriteArrayList＜E＞</code> 实现的</p><p><code>CopyOnWriteArraySet＜E＞</code> 是通过 <code>CopyOnWriteArraySet＜E＞➔al</code> 存储数据的，而它又是 <code>CopyOnWriteArrayList＜E＞</code> 类型</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>CopyOnWriteArraySet＜E＞</code> 本质上就是 <code>CopyOnWriteArrayList＜E＞</code> 的一个装饰器，它所有的操作最终都是委托给  <code>CopyOnWriteArrayList＜E＞</code> 去执行的，只不过在 “增” 操作的时候多做了一个 “去重” 操作。即在 “增” 操作时，会先遍历整个数组，发现该元素不存在后，再创建一个新数组，并在这个新数组上执行 “写” 操作</li></ol></blockquote><hr><h5 id="2-1-6-3-CopyOnWriteArraySet＜E＞-问题爆破"><a href="#2-1-6-3-CopyOnWriteArraySet＜E＞-问题爆破" class="headerlink" title="2.1.6.3. CopyOnWriteArraySet＜E＞ 问题爆破"></a>2.1.6.3. CopyOnWriteArraySet＜E＞ 问题爆破</h5><p>由于<code>CopyOnWriteArraySet＜E＞</code> 底层是基于一个 <code>CopyOnWriteArrayList＜K, V＞</code> 实现的，所以 <code>CopyOnWriteArrayList＜K, V＞</code> 拥有的问题，<code>CopyOnWriteArraySet＜E＞</code> 一般都有。详见上文：<code>CopyOnWriteArrayList＜K, V＞</code></p><hr><h4 id="2-1-7-ConcurrentSkipListSet＜E＞"><a href="#2-1-7-ConcurrentSkipListSet＜E＞" class="headerlink" title="2.1.7. ConcurrentSkipListSet＜E＞"></a>2.1.7. ConcurrentSkipListSet＜E＞</h4><h5 id="2-1-7-1-ConcurrentSkipListSet＜E＞-体系结构"><a href="#2-1-7-1-ConcurrentSkipListSet＜E＞-体系结构" class="headerlink" title="2.1.7.1. ConcurrentSkipListSet＜E＞ 体系结构"></a>2.1.7.1. ConcurrentSkipListSet＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-28.png"></p><hr><h5 id="2-1-7-2-ConcurrentSkipListSet＜E＞-底层实现"><a href="#2-1-7-2-ConcurrentSkipListSet＜E＞-底层实现" class="headerlink" title="2.1.7.2. ConcurrentSkipListSet＜E＞ 底层实现"></a>2.1.7.2. ConcurrentSkipListSet＜E＞ 底层实现</h5><p><code>ConcurrentSkipListSet＜E＞</code> 底层是基于一个 <code>ConcurrentSkipListMap＜K, V＞</code> 实现的</p><p><code>ConcurrentSkipListSet＜E＞</code> 是通过 <code>ConcurrentSkipListSet＜E＞➔m</code> 存储数据的，而它又是 <code>ConcurrentNavigableMap＜K, V＞</code> 类型（实际初始化时就是一个 <code>ConcurrentSkipListMap＜K, V＞</code>）</p><hr><h5 id="2-1-7-3-ConcurrentSkipListSet＜E＞-问题爆破"><a href="#2-1-7-3-ConcurrentSkipListSet＜E＞-问题爆破" class="headerlink" title="2.1.7.3. ConcurrentSkipListSet＜E＞ 问题爆破"></a>2.1.7.3. ConcurrentSkipListSet＜E＞ 问题爆破</h5><p>由于<code>ConcurrentSkipListSet＜E＞</code> 底层是基于一个 <code>ConcurrentSkipListMap＜K, V＞</code> 实现的，所以 <code>ConcurrentSkipListMap＜K, V＞</code> 拥有的问题，<code>ConcurrentSkipListSet＜E＞</code> 一般都有。详见下文：<code>ConcurrentSkipListMap＜K, V＞</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然说 <code>ConcurrentSkipListSet＜E＞</code> 底层是基于 <code>ConcurrentSkipListMap＜K, V＞</code> 实现的，但是只使用了 <code>ConcurrentSkipListMap＜K, V＞</code> 的 <code>Key</code> 来存储数据。所以我们着重看 <code>ConcurrentSkipListMap＜K, V＞</code> 的 <code>Key</code></li></ol></blockquote><hr><h4 id="2-1-8-ConcurrentHashMap＜K-V＞-KeySetView"><a href="#2-1-8-ConcurrentHashMap＜K-V＞-KeySetView" class="headerlink" title="2.1.8. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt;"></a>2.1.8. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt;</h4><h5 id="2-1-8-1-ConcurrentHashMap＜K-V＞-KeySetView-体系结构"><a href="#2-1-8-1-ConcurrentHashMap＜K-V＞-KeySetView-体系结构" class="headerlink" title="2.1.8.1. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt; 体系结构"></a>2.1.8.1. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt; 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-29.png"></p><hr><h5 id="2-1-8-2-ConcurrentHashMap＜K-V＞-KeySetView-底层实现"><a href="#2-1-8-2-ConcurrentHashMap＜K-V＞-KeySetView-底层实现" class="headerlink" title="2.1.8.2. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt; 底层实现"></a>2.1.8.2. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt; 底层实现</h5><p><code>ConcurrentHashMap＜K, V＞.KeySetView＜K, V＞</code> 底层是基于一个 <code>ConcurrentHashMap＜K, V＞</code> 实现的</p><p><code>ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt;</code> 是通过父类的 <code>CollectionView＜K, V, E＞-&gt;map</code> 来存储数据的，而它又是 <code>ConcurrentHashMap＜K, V＞</code> 类型</p><hr><h5 id="2-1-8-3-ConcurrentHashMap＜K-V＞-KeySetView-问题爆破"><a href="#2-1-8-3-ConcurrentHashMap＜K-V＞-KeySetView-问题爆破" class="headerlink" title="2.1.8.3. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt; 问题爆破"></a>2.1.8.3. ConcurrentHashMap＜K, V＞.KeySetView&lt;K,V&gt; 问题爆破</h5><p>由于 <code>ConcurrentHashMap＜K, V＞.KeySetView＜K, V＞</code> 底层是基于一个 <code>ConcurrentHashMap＜K, V＞</code> 实现的，所以 <code>ConcurrentHashMap＜K, V＞</code> 拥有的问题，<code>ConcurrentHashMap＜K, V＞.KeySetView＜K, V＞</code> 一般都有。详见下文：<code>ConcurrentHashMap＜K, V＞</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然说 <code>ConcurrentHashMap＜K, V＞.KeySetView＜K, V＞</code> 底层是基于 <code>ConcurrentHashMap＜K, V＞</code> 实现的，但是只使用了 <code>ConcurrentHashMap＜K, V＞</code> 的 <code>Key</code> 来存储数据。所以我们着重看 <code>ConcurrentHashMap＜K, V＞</code> 的 <code>Key</code></li></ol></blockquote><hr><h3 id="2-2-List＜E＞"><a href="#2-2-List＜E＞" class="headerlink" title="2.2. List＜E＞"></a>2.2. List＜E＞</h3><h4 id="2-2-1-List＜E＞-基础体系"><a href="#2-2-1-List＜E＞-基础体系" class="headerlink" title="2.2.1. List＜E＞ 基础体系"></a>2.2.1. List＜E＞ 基础体系</h4><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4.png"></p><ol><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Cloneable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Cloneable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.lang.Cloneable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>RandomAccess</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.RandomAccess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.RandomAccess源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/30/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.RandomAccess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/30/源码：java.util.RandomAccess源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Iterable＜E＞</code><ol><li><code>obsidian</code> 内部链接：<br> 1. <a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Iterable＜T＞源码解析</a></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.lang.Iterable＜T＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Collection＜E＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Collection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.Collection＜E＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Collection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.util.Collection＜E＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>List＜E＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.List%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.List＜E＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/12/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/12/01/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li></ol><hr><h4 id="2-2-2-List＜E＞-相关分类"><a href="#2-2-2-List＜E＞-相关分类" class="headerlink" title="2.2.2. List＜E＞ 相关分类"></a>2.2.2. List＜E＞ 相关分类</h4><ol><li><code>ArrayList＜E＞</code></li><li><code>LinkedList＜E＞</code></li><li><code>CopyOnWriteArrayList＜E＞</code></li></ol><table><thead><tr><th>特性</th><th>ArrayList＜E＞</th><th>LinkedList＜E＞</th><th>CopyOnWriteArrayList＜E＞</th></tr></thead><tbody><tr><td><strong>顺序性</strong></td><td>✅（<code>FIFO</code> 顺序，可手动排序）</td><td>✅（<code>FIFO</code> 顺序、<code>LIFO</code> 顺序，可手动排序）</td><td>✅（<code>FIFO </code>顺序、可手动排序）</td></tr><tr><td><strong>有界性</strong></td><td>❌（需要扩容）</td><td>—</td><td>❌（需要扩容）</td></tr><tr><td><strong>支持扩容</strong></td><td>✅</td><td>—</td><td>✅</td></tr><tr><td><strong>底层实现</strong></td><td>一个数组</td><td>一条双向链表</td><td>1. <code>Java11</code> 之前：一个数组 + 一个 <code>ReentrantLock</code>（无条件队列）<br>2. <code>Java11</code> 之后：一个数组 + <code>synchronized</code></td></tr><tr><td><strong>允许元素重复</strong></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>允许元素为 null</strong></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>多线程并发安全性</strong></td><td>❌</td><td>❌</td><td>✅</td></tr></tbody></table><hr><h4 id="2-2-3-ArrayList＜E＞"><a href="#2-2-3-ArrayList＜E＞" class="headerlink" title="2.2.3. ArrayList＜E＞"></a>2.2.3. ArrayList＜E＞</h4><h5 id="2-2-3-1-ArrayList＜E＞-体系结构"><a href="#2-2-3-1-ArrayList＜E＞-体系结构" class="headerlink" title="2.2.3.1. ArrayList＜E＞ 体系结构"></a>2.2.3.1. ArrayList＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><hr><h5 id="2-2-3-2-ArrayList＜E＞-底层实现"><a href="#2-2-3-2-ArrayList＜E＞-底层实现" class="headerlink" title="2.2.3.2. ArrayList＜E＞ 底层实现"></a>2.2.3.2. ArrayList＜E＞ 底层实现</h5><p><code>ArrayList＜E＞</code> 底层是基于一个数组实现的</p><p><code>ArrayList＜E＞</code> 是通过 <code>ArrayList＜E＞-&gt;elementData</code> 存储数据的，而它又是一个由 <code>Object</code> 构建的数组</p><hr><h5 id="2-2-3-3-ArrayList＜E＞-扩容机制"><a href="#2-2-3-3-ArrayList＜E＞-扩容机制" class="headerlink" title="2.2.3.3. ArrayList＜E＞ 扩容机制"></a>2.2.3.3. ArrayList＜E＞ 扩容机制</h5><p>在 <code>Java8</code> 之后，<code>ArrayList＜E＞</code> 采用了懒加载策略。如果我们使用无参构造方法创建 <code>ArrayList＜E＞</code> 实例，底层数组其实是一个空数组，只有在第一次执行 “增” 操作时才会真正分配内存空间</p><p>当数组已满时就会触发扩容（数组已满后，在下一次 “增” 操作时先扩容再 “增” 元素）。<code>ArrayList＜E＞</code> 扩容时会创建一个容量为原来 <code>1.5</code> 倍的新数组，并调用 <code>Arrays#copyOf</code> 将旧数组中的元素拷贝到新数组中（这里并不是遍历，而是调用了 <code>native</code> 方法，实现整个内存块的拷贝）</p><hr><h5 id="2-2-3-4-ArrayList＜E＞-问题爆破"><a href="#2-2-3-4-ArrayList＜E＞-问题爆破" class="headerlink" title="2.2.3.4. ArrayList＜E＞ 问题爆破"></a>2.2.3.4. ArrayList＜E＞ 问题爆破</h5><h6 id="2-2-3-4-1-元素类型问题"><a href="#2-2-3-4-1-元素类型问题" class="headerlink" title="2.2.3.4.1. 元素类型问题"></a>2.2.3.4.1. 元素类型问题</h6><p>由于<code>ArrayList＜E＞</code> 是通过 <code>ArrayList＜E＞-&gt;elementData</code> 存储数据的，而它又是一个由 <code>Object</code> 构建的数组。所以 <code>ArrayList＜E＞</code> 只能存储 <code>Object</code> 类型的元素</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>不是说  <code>ArrayList＜E＞</code> 只能存储 <code>Object</code> 类型的元素吗？为什么我们还可以执行例如 <code>ArrayList＜E＞.add(10)</code> 的操作？<ol><li>其实这和 <code>ArrayList＜E＞</code> 没多大关系，而是涉及到 <code>Java</code> 应用中一个通用的机制，即装箱机制：在编译阶段，如果编译器发现你传入的是基本数据类型的方法参数，但是方法参数要求的类型是引用数据类型，就会触发装箱机制（例如将这个 <code>int</code> 装箱为 <code>Integer</code>）</li><li>需要注意的是：装箱机制仅适用于基本数据类型</li></ol></li><li><code>Java</code> 泛型是如何工作的？<ol><li><code>Java</code> 泛型的工作机制涉及到编译阶段的数据类型检查以及类型擦除</li><li>编译阶段的数据类型检查：<ol><li>如果我们正常使用编译阶段的数据类型检查（例如 <code>List&lt;String&gt; myList = new ArrayList&lt;&gt;()</code>，使用 <code>Java</code> 泛型约束数据类型）<ol><li>在编译阶段会进行数据类型检查，如果数据类型检查未通过会导致编译失败（需要注意的是：对于基本数据类型，会先对其进行装箱，然后再对其进行数据类型检查）</li><li>如果我们想绕过编译阶段的数据类型检查，我们可以通过反射机制或 “走后门” 的方式，强行将与预期不符的类型的元素 “增” 进去。这些方法并不会导致编译失败，但是可能会因为类型擦除而导致的数据类型转换，在调用这些方法时抛出 <code>ClassCastException</code> 非受检异常</li><li>所谓的 “走后门” 是指：你原本 <code>List&lt;String&gt; myList = new ArrayList&lt;&gt;()</code> 的 <code>myList</code> 正常进行类型检查的。但是如果你再  <code>List rawList = myList</code> 的 <code>rawList</code> 是放弃类型检查的。但是 <code>rawList</code> 和 <code>myList</code> 实际上指向同一块内存地址，所以我们可以通过 <code>rawList</code>  “增” 一些与预期不符的类型的元素（这是一个历史包袱）</li></ol></li><li>如果我们放弃使用编译阶段的数据类型检查（例如 <code>List myList = new ArrayList&lt;&gt;()</code>，虽然它提供了 <code>Java</code> 泛型，但是我们并没有指定数据类型）<ol><li>在编译阶段并不会进行数据类型检查</li></ol></li></ol></li><li>类型擦除：<ol><li>我们可以简单理解为：在编译之后，数据类型会被擦除为泛型参数的数据类型的上界数据类型（例如 <code>E</code> 的上界数据类型是 <code>Object</code>、<code>? extends MyClass</code> 的上界数据类型是 <code>MyClass</code>）。以 <code>ArrayList&lt;E&gt;#add(E e)</code> 为例，本来我们写的是：<code>List&lt;String&gt; myList = new ArrayList&lt;&gt;()</code>。按照语义，它应该是 <code>myList#add(String E)</code>，但是在编译之后，实际应该是 <code>myList#add(Object E)</code></li><li>那么这就有一个问题：<code>ArrayList＜E＞#get</code> 按照语义应该返回 <code>String</code> 类型的数据，但是在编译后，实际应该返回 <code>Object</code> 类型的数据。但是我们的方法的具体逻辑本身是按照返回 <code>String</code> 类型的数据所写的，是返回一个 <code>String</code> 类型的结果，而这和返回一个 <code>Object</code> 类型的数据不符。所以编译器会在返回值处自动插入一个数据类型转换（例如  <code>String str = (String) myList.get(0)</code>）。所以在调用这些方法时，就有可能因为数据类型转换而抛出 <code>ClassCastException</code> 非受检异常（需要注意的是：对于基本数据类型，会先对其进行装箱，然后再对其进行数据类型转换）</li></ol></li></ol></li><li>站在技术角度，不类型擦除绝对比类型擦除好，那么 <code>Java</code> 泛型为什么还要进行类型擦除？<ol><li>历史包袱，没有办法</li></ol></li><li>为什么 <code>Java</code> 泛型不能约束数据类型为基本数据类型，导致我们处理基本数据类型时，要先对其进行装箱？<ol><li>因为在类型擦除后，会被擦除为引用数据类型</li></ol></li><li><code>Java</code> 泛型为什么会导致频繁的自动装箱、自动拆箱？<ol><li>我们知道：由于 <code>Java</code> 泛型不能约束数据类型为基本数据类型，导致我们处理基本数据类型时，要先对其进行装箱</li><li>但是在运算时，包装类本身并不能直接参与计算。所以要先对其进行拆箱，完成计算后再装箱</li></ol></li></ol></li></ol></blockquote><hr><h6 id="2-2-3-4-2-多线程并发安全问题"><a href="#2-2-3-4-2-多线程并发安全问题" class="headerlink" title="2.2.3.4.2. 多线程并发安全问题"></a>2.2.3.4.2. 多线程并发安全问题</h6><p>为了解决这一问题，我们通常为其加锁或者使用另外一种数据结构：<code>CopyOnWriteArrayList＜E＞</code></p><hr><h6 id="2-2-3-4-3-迭代器的-“增”、“删”-异常问题"><a href="#2-2-3-4-3-迭代器的-“增”、“删”-异常问题" class="headerlink" title="2.2.3.4.3. 迭代器的 “增”、“删” 异常问题"></a>2.2.3.4.3. 迭代器的 “增”、“删” 异常问题</h6><p>因为 <code>ArrayList＜E＞</code> 的迭代器本质上是按照数组索引进行遍历的（例如 <code>0 ➔ 1 ➔ 2 ➔ …</code>）。如果在遍历过程中进行了 “增” 或 “删” 操作，会导致数组中后续元素发生位置变化，但是迭代器仍会按照原先的数组索引往后走。这两个动作叠加，就可能造成漏读或重复读的问题</p><p>例如 <code>ArrayList＜E＞</code> 有 <code>A</code>、<code>B</code>、<code>C</code> 三个元素，迭代器按照数组索引进行遍历。如果我们让迭代器走到 <code>A</code> 时执行 “删” 操作，让后面的元素整体左移。此时 <code>B</code> 元素的数组索引为 <code>0</code>，<code>C</code> 元素的数组索引为 <code>1</code>。迭代器会按照原先的数组索引往后走，于是就走到数组索引 <code>1</code> 对应的位置（即 <code>C</code>），这就出现了漏读的问题</p><p>在例如 <code>ArrayList＜E＞</code> 有 <code>A</code> 一个元素，迭代器按照数组索引进行遍历。如果我们让迭代器遍历到 <code>A</code> 元素时，就在 <code>A</code> 元素的数组位置 “增” 一个新元素（例如 <code>temp</code>），让 <code>A</code> 元素右移动。此时 <code>temp</code> 元素的数组索引为 <code>0</code>，<code>A</code> 元素的数组索引为 <code>1</code>。迭代器会按照原先的数组索引往后走，于是就走到数组索引 <code>1</code> 对应的位置（即 <code>A</code>），就又 “增” 了一个新元素（<code>temp</code>），于是就出现 <code>temp</code>、<code>temp</code>、<code>temp</code>、<code>...</code>、<code>A</code> 的情况，这就出现了重复读的问题</p><p>为了解决这一问题，<code>ArrayList＜E＞</code> 采取了快速失败（<code>Fail-fast</code>）策略。当 <code>ArrayList＜E＞</code> 开始遍历时，会记下一个版本号（即 <code>Itr-&gt;expectedModCount</code>），当 <code>ArrayList＜E＞</code> 调用 <code>Iterator＜E＞#next</code> 后，会先检查这个版本号。如果版本号对不上，说明在遍历过程中进行了 “增” 或 “删” 操作，会抛出 <code>ConcurrentModificationException</code> 非受检异常</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>对于 <code>Fail-fast</code> 策略，我们是不能调用 <code>ArrayList＜E＞</code> 的相关方法进行 “增” 或 “删” 操作的。如果我们真的有这方面的需求，可以调用 <code>Iterator＜E＞</code> 的相关方法或 <code>ListIterator＜E＞</code> 的相关方法</li><li><code>Iterator＜E＞</code> 是 <code>List＜E＞</code>、<code>Set＜E＞</code>、<code>Map＜K, V＞</code>、<code>Queue＜E＞</code> 通用的迭代器，而 <code>ListIterator＜E＞</code> 是专门为 <code>List＜E＞</code> 提供的迭代器，提供了更多的方法</li></ol></blockquote><hr><h6 id="2-2-3-4-4-频繁扩容导致的性能抖动问题"><a href="#2-2-3-4-4-频繁扩容导致的性能抖动问题" class="headerlink" title="2.2.3.4.4. 频繁扩容导致的性能抖动问题"></a>2.2.3.4.4. 频繁扩容导致的性能抖动问题</h6><p>为了解决这一问题，我们在已知要存储大量数据的情况下，可以在创建 <code>ArrayList＜E＞</code> 实例的时候，指定一个较大的初始容量，避免频繁扩容</p><hr><h4 id="2-2-4-LinkedList＜E＞"><a href="#2-2-4-LinkedList＜E＞" class="headerlink" title="2.2.4. LinkedList＜E＞"></a>2.2.4. LinkedList＜E＞</h4><h5 id="2-2-4-1-LinkedList＜E＞-体系结构"><a href="#2-2-4-1-LinkedList＜E＞-体系结构" class="headerlink" title="2.2.4.1. LinkedList＜E＞ 体系结构"></a>2.2.4.1. LinkedList＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1.png"></p><hr><h5 id="2-2-4-2-LinkedList-底层实现"><a href="#2-2-4-2-LinkedList-底层实现" class="headerlink" title="2.2.4.2. LinkedList 底层实现"></a>2.2.4.2. LinkedList 底层实现</h5><p><code>LinkedList＜E＞</code> 底层是基于一条双向链表实现的</p><p><code>LinkedList＜E＞</code> 是通过一条由 <code>LinkedList＜E＞.Node＜E＞</code> 构建的双向链表存储数据的，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br><br>E item;<br><br>Node&lt;E&gt; next;<br><br>Node&lt;E&gt; prev;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2-2-4-3-LinkedList＜E＞-问题爆破"><a href="#2-2-4-3-LinkedList＜E＞-问题爆破" class="headerlink" title="2.2.4.3. LinkedList＜E＞ 问题爆破"></a>2.2.4.3. LinkedList＜E＞ 问题爆破</h5><h6 id="2-2-4-3-1-元素类型问题"><a href="#2-2-4-3-1-元素类型问题" class="headerlink" title="2.2.4.3.1. 元素类型问题"></a>2.2.4.3.1. 元素类型问题</h6><p>由于 <code>LinkedList＜E＞</code> 是通过一条由 <code>LinkedList＜E＞.Node＜E＞</code> 构建的双向链表存储数据的，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br><br>E item;<br><br>Node&lt;E&gt; next;<br><br>Node&lt;E&gt; prev;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>E</code> 本质上是一个对象引用，所以 <code>LinkedList＜E＞</code> 只能存储 <code>Object</code> 类型的元素。</p><hr><h6 id="2-2-4-3-2-多线程并发安全问题"><a href="#2-2-4-3-2-多线程并发安全问题" class="headerlink" title="2.2.4.3.2. 多线程并发安全问题"></a>2.2.4.3.2. 多线程并发安全问题</h6><p>为了解决这一问题，我们通常为其加锁</p><hr><h6 id="2-2-4-3-3-迭代器的-“增”、“删”-异常问题"><a href="#2-2-4-3-3-迭代器的-“增”、“删”-异常问题" class="headerlink" title="2.2.4.3.3. 迭代器的 “增”、“删” 异常问题"></a>2.2.4.3.3. 迭代器的 “增”、“删” 异常问题</h6><p>为了解决这一问题，<code>LinkedList＜E＞</code> 采取了快速失败（<code>Fail-fast</code>）策略。</p><hr><h4 id="2-2-5-CopyOnWriteArrayList"><a href="#2-2-5-CopyOnWriteArrayList" class="headerlink" title="2.2.5. CopyOnWriteArrayList"></a>2.2.5. CopyOnWriteArrayList</h4><h5 id="2-2-5-1-CopyOnWriteArrayList-体系结构"><a href="#2-2-5-1-CopyOnWriteArrayList-体系结构" class="headerlink" title="2.2.5.1. CopyOnWriteArrayList 体系结构"></a>2.2.5.1. CopyOnWriteArrayList 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2.png"></p><hr><h5 id="2-2-5-2-CopyOnWriteArrayList＜E＞-底层实现"><a href="#2-2-5-2-CopyOnWriteArrayList＜E＞-底层实现" class="headerlink" title="2.2.5.2. CopyOnWriteArrayList＜E＞ 底层实现"></a>2.2.5.2. CopyOnWriteArrayList＜E＞ 底层实现</h5><p>在 <code>Java11</code> 之前，<code>CopyOnWriteArrayList＜E＞</code> 底层是基于一个数组 + 一个 <code>ReentrantLock</code>（无条件队列）实现的。在 <code>Jav11</code> 之后，<code>CopyOnWriteArrayList＜E＞</code> 底层是基于一个数组 +<code>synchronized</code> 实现的</p><p><code>CopyOnWriteArrayList＜E＞</code> 是通过 <code>CopyOnWriteArrayList＜E＞-&gt;array</code> 存储数据的，而它又是一个由 <code>Object</code> 构建的数组</p><hr><h5 id="2-2-5-3-CopyOnWriteArrayList＜E＞-相关流程"><a href="#2-2-5-3-CopyOnWriteArrayList＜E＞-相关流程" class="headerlink" title="2.2.5.3. CopyOnWriteArrayList＜E＞ 相关流程"></a>2.2.5.3. CopyOnWriteArrayList＜E＞ 相关流程</h5><h6 id="2-2-5-3-1-读操作相关流程"><a href="#2-2-5-3-1-读操作相关流程" class="headerlink" title="2.2.5.3.1. 读操作相关流程"></a>2.2.5.3.1. 读操作相关流程</h6><p>虽然 <code>CopyOnWriteArrayList＜E＞</code> 是一个多线程并发安全的数据结构，但是读操作完全不加锁</p><hr><h6 id="2-2-5-3-2-写操作相关流程"><a href="#2-2-5-3-2-写操作相关流程" class="headerlink" title="2.2.5.3.2. 写操作相关流程"></a>2.2.5.3.2. 写操作相关流程</h6><p>但是 <code>CopyOnWriteArrayList＜E＞</code> 的写操作会加锁。在 <code>Java11</code> 之前，<code>CopyOnWriteArrayList＜E＞</code> 是使用 <code>ReentrantLock</code>。在 <code>Java11</code> 之后，<code>CopyOnWriteArrayList＜E＞</code> 是使用 <code>synchronized</code></p><p>当执行 <code>CopyOnWriteArrayList＜E＞</code> 的写操作的线程竞争到锁后，会创建一个新数组，并调用 <code>Arrays#copyOf</code> 将旧数组中的元素拷贝到新数组中（这里并不是遍历，而是调用了 <code>native</code> 方法，实现整个内存块的拷贝）。然后线程就会在这个新数组上执行写操作。当线程执行完写操作后，就会将旧数组的引用替换成新数组的引用</p><hr><h5 id="2-2-5-4-CopyOnWriteArrayList-问题爆破"><a href="#2-2-5-4-CopyOnWriteArrayList-问题爆破" class="headerlink" title="2.2.5.4. CopyOnWriteArrayList 问题爆破"></a>2.2.5.4. CopyOnWriteArrayList 问题爆破</h5><h6 id="2-2-5-4-1-元素类型问题"><a href="#2-2-5-4-1-元素类型问题" class="headerlink" title="2.2.5.4.1. 元素类型问题"></a>2.2.5.4.1. 元素类型问题</h6><p>由于<code>CopyOnWriteArrayList＜E＞</code> 是通过 <code>CopyOnWriteArrayList＜E＞-&gt;array</code> 存储数据的，而它又是一个由 <code>Object</code> 构建的数组。所以 <code>ArrayList＜E＞</code> 只能存储 <code>Object</code> 类型的元素</p><hr><h6 id="2-2-5-4-2-迭代器的-“增”、“删”-异常问题"><a href="#2-2-5-4-2-迭代器的-“增”、“删”-异常问题" class="headerlink" title="2.2.5.4.2. 迭代器的 “增”、“删” 异常问题"></a>2.2.5.4.2. 迭代器的 “增”、“删” 异常问题</h6><p>为了解决这一问题，<code>CopyOnWriteArrayList＜E＞</code> 采取了安全失败（<code>Fail-safe</code>）策略。我们知道 “线程会在创建的新数组上执行写操作，当线程执行完写操作后，就会将旧数组的引用替换成新数组的引用”。所以 <code>CopyOnWriteArrayList＜E＞</code> 遍历的永远是那个旧数组，不受后续 “增”、“删” 操作的影响（即便主内存中的数组已经被写好几轮了，但是迭代器看到的仍然是最初的那一个旧数组）</p><hr><h3 id="2-3-Map＜K-V＞"><a href="#2-3-Map＜K-V＞" class="headerlink" title="2.3. Map＜K, V＞"></a>2.3. Map＜K, V＞</h3><h4 id="2-3-1-Map＜K-V＞-基础体系"><a href="#2-3-1-Map＜K-V＞-基础体系" class="headerlink" title="2.3.1. Map＜K, V＞ 基础体系"></a>2.3.1. Map＜K, V＞ 基础体系</h4><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-26.png"></p><hr><h4 id="2-3-2-Map＜K-V＞-相关分类"><a href="#2-3-2-Map＜K-V＞-相关分类" class="headerlink" title="2.3.2. Map＜K, V＞ 相关分类"></a>2.3.2. Map＜K, V＞ 相关分类</h4><ol><li><code>TreeMap＜K, V＞</code></li><li><code>HashMap＜K, V＞</code></li><li><code>EnumMap＜K, V＞</code></li><li><code>WeakHashMap＜K, V＞</code></li><li><code>LinkedHashMap＜K, V＞</code></li><li><code>ConcurrentHashMap＜K, V＞</code></li><li><code>ConcurrentSkipListMap＜K, V＞</code></li></ol><hr><h4 id="2-3-3-TreeMap＜K-V＞"><a href="#2-3-3-TreeMap＜K-V＞" class="headerlink" title="2.3.3. TreeMap＜K, V＞"></a>2.3.3. TreeMap＜K, V＞</h4><h5 id="2-3-3-1-TreeMap＜K-V＞-体系结构"><a href="#2-3-3-1-TreeMap＜K-V＞-体系结构" class="headerlink" title="2.3.3.1. TreeMap＜K, V＞ 体系结构"></a>2.3.3.1. TreeMap＜K, V＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8.png"></p><hr><h5 id="2-3-3-2-TreeMap＜K-V＞-底层实现"><a href="#2-3-3-2-TreeMap＜K-V＞-底层实现" class="headerlink" title="2.3.3.2. TreeMap＜K, V＞ 底层实现"></a>2.3.3.2. TreeMap＜K, V＞ 底层实现</h5><p><code>TreeMap＜K, V＞</code> 底层是基于一个红黑树实现的</p><p><code>TreeMap＜K, V＞</code> 是通过一个由 <code>TreeMap＜K, V＞.Entry＜K, V＞</code> 构建的红黑树存储数据的，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br><br>K key;<br><br>V value;<br><br>Entry&lt;K,V&gt; left;<br><br>Entry&lt;K,V&gt; right;<br><br>Entry&lt;K,V&gt; parent;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> BLACK;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>由于 <code>TreeMap＜K, V＞</code> 底层是基于红黑树实现的，而红黑树本质上是一个自平衡的二叉查找树，所以 <code>TreeMap＜K, V＞</code> 能够自动对元素进行排序（自然排序、定制排序）</li><li>默认情况下，<code>TreeMap＜K, V＞</code> 采用自然排序。即根据 <code>Key</code> 实例所属类实现的 <code>Comparable＜T＞#compareTo</code> 对元素进行排序。详见源码：<code>Comparable&lt;T&gt;</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Comparable＜T＞源码解析</a>，<code>Hexo</code> 链接： <a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.lang.Comparable＜T＞源码解析/</a> ）</li><li>除此之外，我们也可以采用定制排序。即在创建 <code>TreeMap＜K, V＞</code> 实例时，传入一个 <code>Comparator＜T＞</code> 接口的具体实现类实例，然后 <code>TreeMap＜K, V＞</code> 会根据 <code>Comparator＜T＞#compare</code> 对元素进行排序。详见源码：<code>Comparator&lt;T&gt;</code>（<code>obsidian</code> 内部链接：，<code>Hexo</code> 链接：）</li></ol></blockquote><hr><h5 id="2-3-3-3-TreeMap＜K-V＞-问题爆破"><a href="#2-3-3-3-TreeMap＜K-V＞-问题爆破" class="headerlink" title="2.3.3.3. TreeMap＜K, V＞ 问题爆破"></a>2.3.3.3. TreeMap＜K, V＞ 问题爆破</h5><h6 id="2-3-3-3-1-Key-类型问题"><a href="#2-3-3-3-1-Key-类型问题" class="headerlink" title="2.3.3.3.1. Key 类型问题"></a>2.3.3.3.1. Key 类型问题</h6><p>由于 <code>TreeMap＜K, V＞</code> 是通过一个由 <code>TreeMap＜K, V＞.Entry＜K, V＞</code> 构建的红黑树存储数据的，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br><br>K key;<br><br>V value;<br><br>Entry&lt;K,V&gt; left;<br><br>Entry&lt;K,V&gt; right;<br><br>Entry&lt;K,V&gt; parent;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> BLACK;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>K</code> 本质上是一个对象引用，所以 <code>TreeMap＜K, V＞</code> 只能存储 <code>Key</code> 为 <code>Object</code> 类型的元素</p><p>除此之外，<code>TreeMap＜K, V＞</code> 在自然排序下是通过 <code>Comparable＜T＞#compareTo</code> 来判断元素的 <code>Key</code> 是否重复的，所以元素的 <code>Key</code> 必须是 <code>Comparable</code> 类型的</p><hr><h6 id="2-3-3-3-2-多线程并发安全性问题"><a href="#2-3-3-3-2-多线程并发安全性问题" class="headerlink" title="2.3.3.3.2. 多线程并发安全性问题"></a>2.3.3.3.2. 多线程并发安全性问题</h6><p>为了解决这一问题，我们通常为其加锁或者使用另外一种数据结构：<code>ConcurrentSkipListMap＜K, V＞</code></p><hr><h6 id="2-3-3-3-3-迭代器的-“增”、“删”-异常问题"><a href="#2-3-3-3-3-迭代器的-“增”、“删”-异常问题" class="headerlink" title="2.3.3.3.3. 迭代器的 “增”、“删” 异常问题"></a>2.3.3.3.3. 迭代器的 “增”、“删” 异常问题</h6><p>为了解决这一问题，<code>TreeMap＜K, V＞</code> 采取了快速失败（<code>Fail-fast</code>）策略。</p><hr><h6 id="2-3-3-3-4-Key-Value-重复问题"><a href="#2-3-3-3-4-Key-Value-重复问题" class="headerlink" title="2.3.3.3.4. Key-Value 重复问题"></a>2.3.3.3.4. Key-Value 重复问题</h6><p><code>TreeMap＜K, V＞</code> 严禁元素的 <code>Key</code> 重复，它是通过 <code>Comparable＜T＞#compareTo</code> 或 <code>Comparator＜T＞#compare</code> 来判断元素的 <code>Key</code> 是否重复的</p><p><code>TreeMap＜K, V＞</code> 允许元素的 <code>Value</code> 重复</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>由于 <code>TreeMap＜K, V＞</code> 是通过 <code>Comparable＜T＞#compareTo</code> 或 <code>Comparator＜T＞#compare</code> 来判断元素的 <code>Key</code> 是否重复的。如果两个实例的 <code>Object#equals</code> 为 <code>false</code>（即逻辑上不相等），但是 <code>TreeMap＜K, V＞</code> 也有可能认为它们相等，从而产生覆盖</li><li>为了解决这一问题，我们需要在定义 <code>Key</code> 的保证：当且仅当 <code>Object#euqals</code> 返回 <code>true</code> 时，<code>Comparable＜T＞#compareTo</code> 或 <code>Comparator＜T＞#compare</code> 才返回 <code>0</code></li></ol></blockquote><hr><h6 id="2-3-3-3-5-Key-Value-为-null-问题"><a href="#2-3-3-3-5-Key-Value-为-null-问题" class="headerlink" title="2.3.3.3.5. Key-Value 为 null 问题"></a>2.3.3.3.5. Key-Value 为 null 问题</h6><p>如果采用的是自然排序，<code>TreeMap＜K, V＞</code> 不允许元素的 <code>Key</code> 为 <code>null</code>，因为调用 <code>Comparable＜T＞#compareTo</code> 时就直接抛出 <code>NullPointerException</code> 非受检异常了</p><p>但是如果采用的是定制排序，<code>TreeMap＜K, V＞</code> 允不允许元素的 <code>Key</code> 为 <code>null</code>，就要看我们传入的 <code>Comparator＜T＞</code> 接口的具体实现类实例。如果 <code>Comparator＜T＞#compare</code> 处理了元素的 <code>Key</code> 为 <code>null</code> 的情况，那么 <code>TreeMap＜K, V＞</code> 是允许元素的 <code>Key</code> 为 <code>null</code> 的</p><p><code>TreeMap＜K, V＞</code> 允许元素的 <code>Value</code> 为 <code>null</code>，并且数量不限制</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>由于 <code>TreeMap＜K, V＞</code> 在自然排序下不允许元素的 <code>Key</code> 为 <code>null</code>，所以在对 <code>TreeMap＜K, V＞</code> 进行 “增” 操作之前要进行非空判断</li></ol></blockquote><hr><h6 id="2-3-3-3-6-红黑树读操作失效问题"><a href="#2-3-3-3-6-红黑树读操作失效问题" class="headerlink" title="2.3.3.3.6. 红黑树读操作失效问题"></a>2.3.3.3.6. 红黑树读操作失效问题</h6><p>这是红黑树一个非常典型的问题：当你把一个元素 “增” 到 <code>TreeMap＜K, V＞</code> 中，它会被 TreeMap＜K, V＞ 调整到红黑树的某个位置。如果你在 “增” 之后，“改” 了元素的 <code>Key</code>，影响到了 <code>Comparable＜T＞#compareTo</code> 或 <code>Comparator＜T＞#compare</code>，<code>TreeMap＜K, V＞</code> 并不会再调整它的位置了。</p><p>所以当你去读该元素时，<code>TreeMap＜K, V＞</code> 会根据元素的新 <code>Key</code> 对应的红黑树路径去读数据。但是该元素仍然在元素的旧 <code>Key</code> 对应的红黑树路径，所以根本无法被正确读到。除此之外，这也造成了一个内存泄漏问题</p><p>为了解决这一问题，我们元素的 <code>Key</code> 必须是不可变的（即不可变类）</p><hr><h4 id="2-3-4-HashMap＜K-V＞"><a href="#2-3-4-HashMap＜K-V＞" class="headerlink" title="2.3.4. HashMap＜K, V＞"></a>2.3.4. HashMap＜K, V＞</h4><h5 id="2-3-4-1-HashMap＜K-V＞-体系结构"><a href="#2-3-4-1-HashMap＜K-V＞-体系结构" class="headerlink" title="2.3.4.1. HashMap＜K, V＞ 体系结构"></a>2.3.4.1. HashMap＜K, V＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-11.png"></p><hr><h5 id="2-3-4-2-HashMap＜K-V＞-底层实现"><a href="#2-3-4-2-HashMap＜K-V＞-底层实现" class="headerlink" title="2.3.4.2. HashMap＜K, V＞ 底层实现"></a>2.3.4.2. HashMap＜K, V＞ 底层实现</h5><p>在 <code>Java8</code> 之前，<code>HashMap＜K, V＞</code> 底层是基于一个数组 + 多条单向链表实现的。在 <code>Java8</code> 之后，<code>HashMap＜K, V＞</code> 底层是基于一个数组 + 多条单向链表 + 多个红黑树实现的</p><p><code>HashMap＜K, V＞</code> 是通过 <code>HashMap＜K, V＞➔table</code> 存储数据的，而它又是一个由 <code>HashMap＜K, V＞.Node＜K, V＞</code> 构建的数组，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br><br><span class="hljs-keyword">final</span> K key;<br><br>V value;<br><br>Node&lt;K,V&gt; next;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，每一个 <code>HashMap＜K, V＞.Node＜K, V＞</code> 还维护了一条由 <code>HashMap＜K, V＞.Node＜K, V＞</code> 构建的单向链表</p><hr><h5 id="2-3-4-3-HashMap＜K-V＞-相关流程"><a href="#2-3-4-3-HashMap＜K-V＞-相关流程" class="headerlink" title="2.3.4.3. HashMap＜K, V＞ 相关流程"></a>2.3.4.3. HashMap＜K, V＞ 相关流程</h5><p>由于 <code>HashMap＜K, V＞</code> 底层基于一个数组 + 多条单向链表或者一个数组 + 多条单向链表 + 多个红黑树。所以我们要了解 <code>HashMap＜K, V＞</code>，就必须要先了解一下哈希表：</p><ol><li>写操作相关流程<ol><li>当我们向数组中 “增” 元素（例如 <code>apple:1</code>）时，<code>HashMap＜K, V＞</code> 首先会根据元素的 <code>Key</code> 通过哈希函数（即 <code>Object#hashCode</code>）计算出哈希值（即 <code>Hash</code>），并将其转换成数组索引（使用 <code>Hash &amp; (Capacity - 1)</code>），然后定位到数组索引对应的位置，并将该元素 “增” 到该位置</li></ol></li><li>读操作相关流程<ol><li>当我们向数组读某元素（例如 <code>Key = apple</code>）时，<code>HashMap＜K, V＞</code> 同样会根据元素的 <code>Key</code> 通过哈希函数（即 <code>Object#hashCode</code>）计算出哈希值（即 <code>Hash</code>），并将其转换成数组索引（使用 <code>Hash &amp; (Capacity - 1)</code>），然后定位到数组索引对应的位置，并将该元素读出</li></ol></li></ol><p>理想状态下，无论 <code>HashMap＜K, V＞</code> 中有多少元素（<code>10</code> 个或 <code>1000</code> 万个），我们 “查” 操作的平均时间复杂度都是 $O(1)$</p><p>但是如果发生哈希冲突（例如 <code>banana:555</code> 也被写到数组索引 <code>5</code> 对应的位置）时，那么数组索引 <code>5</code> 对应的位置不仅仅要存放 <code>apple</code>，还要存放 <code>banana</code>，我们通常是使用链表来解决这个问题</p><p>但是这也带来一个问题：我们需要遍历这个链表，直到找到我们需要的值。如果哈希冲突非常严重，即同一个索引位置的链表变得非常长，我们遍历的时间也会变的非常长</p><p>我们在 <code>MySQL</code> 中也接触过，一个链表如果非常长，我们可以通过红黑树来优化这个问题，于是 <code>Java8</code> 引入了一个重大优化：当同一个索引位置的链表长度达到一定阈值（默认为 <code>8</code>），并且整个哈希表的大小（即数组长度）也达到一定阈值（默认为 <code>64</code>）时，这个链表会自动转换成一棵红黑树</p><hr><h5 id="2-3-4-4-HashMap＜K-V＞-扩容机制"><a href="#2-3-4-4-HashMap＜K-V＞-扩容机制" class="headerlink" title="2.3.4.4. HashMap＜K, V＞ 扩容机制"></a>2.3.4.4. HashMap＜K, V＞ 扩容机制</h5><p>当数组中的元素的数量达到 “数组容量 * 负载因子” 时就会触发扩容。例如默认的数组容量是 <code>16</code>，默认的负载因子是 <code>0.75</code>，那么元素数量达到 <code>12</code> 时便会开始扩容</p><p>在 <code>Java8</code> 之前，<code>HashMap＜K, V＞</code> 扩容时会创建一个容量为原来 <code>2</code> 倍的新数组。<code>HashMap＜K, V＞</code> 会遍历旧数组，如果某数组位置上有元素（例如是链表），<code>HashMap＜K, V＞</code> 会遍历链表，并将每个元素的哈希值重新转换成新数组的数组索引，然后定位到数组索引对应的新数组位置，并将元素拷贝到该位置（并不是调用 <code>Arrays#copyOf</code>）。但是由于遍历的顺序是 <code>A ➔ B ➔ C</code>（<code>C</code> 先 “增” 进来的），所以在新数组位置上它们的顺序可能就变成了 <code>C ➔ B ➔ A</code>（<code>A</code> 先 “增” 进来的），这就是大名鼎鼎的 “头插法”（）</p><p>在 <code>Java8</code> 之后，<code>HashMap＜K, V＞</code> 扩容时同样会创建一个容量为原来 <code>2</code> 倍的新数组。<code>HashMap＜K, V＞</code> 同样会遍历旧数组，如果某数组位置上有元素（例如是链表），<code>HashMap＜K, V＞</code> 会遍历链表，但是并不会将每个元素的哈希值重新转换成新数组的数组索引，而是利用了一种基于位运算的优化</p><p>这个位运算的优化是指：由于数组的长度始终是 <code>2</code> 的幂（例如从 <code>16</code>（<code>10000</code>） 扩到 <code>32</code>（<code>100000</code>）），新长度相比旧长度仅多出一位高位。<code>HashMap＜K, V＞</code> 只需要检查元素的哈希值在这一新增高位上的值（使用 <code>Hash &amp; OldCapacity</code>，而不是 <code>Hash &amp; (OldCapacity - 1)</code>）：</p><ol><li>如果该位为 <code>0</code><ol><li>该元素在新数组中的数组索引保持不变</li></ol></li><li>如果该位为 <code>1</code><ol><li>该元素在新数组中的数组索引 &#x3D; 元素在旧数组上的数组索引 + 旧数组的数组长度</li></ol></li></ol><p>除此之外，为了解决 “头插法” 在多线程并发情况下出现的严重问题，<code>HashMap＜K, V＞</code> 还引入了两条链表，这里简称为 “低位链表”、“高位链表”。当 <code>HashMap＜K, V＞</code> 检查元素的哈希值在这一新增高位上的值为 <code>0</code> 时，就会把元素链接到低位链表。如果为 <code>1</code> 时，就会把元素链接到高位链表。然后当我们遍历完这个链表后，就把低位链表和高位链表放到新数组对应的位置。由于遍历的顺序是 <code>A ➔ B ➔ C</code>，而在低位链表或高位链表中可能仍然是 <code>A ➔ B ➔ C</code>，这就是大名鼎鼎的 “尾插法”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>所谓的 “可能” 是指：它们未必还会在同一个数组位置上</li><li>哈希冲突是指：可能是 <code>Key</code> 不同，也可能是计算出的哈希值不同，但是转换成的数组索引是相同的</li></ol></blockquote><hr><h5 id="2-3-4-5-HashMap-问题爆破"><a href="#2-3-4-5-HashMap-问题爆破" class="headerlink" title="2.3.4.5. HashMap 问题爆破"></a>2.3.4.5. HashMap 问题爆破</h5><h6 id="2-3-4-5-1-多线程并发安全性问题"><a href="#2-3-4-5-1-多线程并发安全性问题" class="headerlink" title="2.3.4.5.1. 多线程并发安全性问题"></a>2.3.4.5.1. 多线程并发安全性问题</h6><p>为了解决这一问题，我们通常为其加锁或者使用另外一种数据结构：<code>ConcurrentHashMap＜K, V＞</code></p><hr><h6 id="2-3-4-5-2-迭代器的-“增”、“删”-异常问题"><a href="#2-3-4-5-2-迭代器的-“增”、“删”-异常问题" class="headerlink" title="2.3.4.5.2. 迭代器的 “增”、“删” 异常问题"></a>2.3.4.5.2. 迭代器的 “增”、“删” 异常问题</h6><p>为了解决这一问题，<code>HashMap＜K, V＞</code> 采取了快速失败（<code>Fail-fast</code>）策略。</p><hr><h6 id="2-3-4-5-3-Key-Value-重复问题"><a href="#2-3-4-5-3-Key-Value-重复问题" class="headerlink" title="2.3.4.5.3. Key-Value 重复问题"></a>2.3.4.5.3. Key-Value 重复问题</h6><p><code>HashMap＜K, V＞</code> 严禁元素的 <code>Key</code> 重复，它是通过 <code>（元素的 Key 的 Hash 相等） &amp;&amp; （元素的 Key 相等）</code>来判断元素的 <code>Key</code> 是否重复的</p><p><code>HashMap＜K, V＞</code> 允许元素的 <code>Value</code> 重复</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>要判断两个元素的 <code>Key</code> 的 <code>Hash</code> 是否相等，前提是我们必须能计算出 <code>Key</code> 的 <code>Hash</code>。因此我们的 <code>Key</code> 必须重写 <code>Object#hashCode</code>（<code>Object#hashCode</code> 默认基于实例的内存地址计算）</li><li>同样的，要判断两个元素的 <code>Key</code> 是否相等，我们的 <code>Key</code> 必须重写 <code>Object#equals</code>（<code>Object#equals</code> 默认比较的是实例的内存地址）</li></ol></blockquote><hr><h6 id="2-3-4-5-4-Key-Value-为-null-问题"><a href="#2-3-4-5-4-Key-Value-为-null-问题" class="headerlink" title="2.3.4.5.4. Key-Value 为 null 问题"></a>2.3.4.5.4. Key-Value 为 null 问题</h6><p><code>HashMap＜K, V＞</code> 允许元素的 <code>Key</code> 为 <code>null</code>，但是由于元素的 <code>Key</code> 不可重复，所以 <code>HashMap＜K, V＞</code> 中最多只能有一个元素的 <code>Key</code> 为 <code>null</code>。如果某元素的元素的 <code>Key</code> 为 <code>null</code>，<code>HashMap＜K, V＞</code> 并不会计算它的 <code>Key</code> 的哈希值，而是强制将其哈希值视为 <code>0</code>。因此，<code>Key</code> 为 <code>null</code> 的元素的数组索引总是为 <code>0</code></p><p><code>HashMap＜K, V＞</code> 允许元素的 <code>Value</code> 为 <code>null</code>，并且数量不限制</p><hr><h6 id="2-3-4-5-5-频繁扩容导致的性能抖动问题"><a href="#2-3-4-5-5-频繁扩容导致的性能抖动问题" class="headerlink" title="2.3.4.5.5. 频繁扩容导致的性能抖动问题"></a>2.3.4.5.5. 频繁扩容导致的性能抖动问题</h6><p>为了解决这一问题，我们在已知要存储大量数据的情况下，可以在创建 <code>HashMap＜K, V＞</code> 实例的时候，指定一个较大的初始容量，避免频繁扩容</p><hr><h6 id="2-3-4-5-6-哈希表读操作失效问题"><a href="#2-3-4-5-6-哈希表读操作失效问题" class="headerlink" title="2.3.4.5.6. 哈希表读操作失效问题"></a>2.3.4.5.6. 哈希表读操作失效问题</h6><p>这是哈希表一个非常典型的问题：当你把一个元素 “增” 到了 <code>HashMap＜K, V＞</code> 中，它会被 <code>HashMap＜K, V＞</code> “增” 到数组的某个位置。如果你在 “增” 之后，“改” 了元素的 <code>Key</code>，影响到了哈希值的计算，但是 <code>HashMap＜K, V＞</code> 并不会再调整它的位置了</p><p>所以当你去读该元素时，<code>HashMap＜K, V＞</code> 会根据元素的新 <code>Key</code> 通过哈希函数计算出哈希值，并将其转换成数组索引，然后定位到数组索引对应的位置。但是该元素仍然在元素的旧 <code>Key</code> 对应的数组位置，所以根本无法被正确读到。除此之外，这也造成了一个内存泄漏问题</p><p>为了解决这一问题，我们元素的 <code>Key</code> 必须是不可变的（即不可变类）</p><hr><h4 id="2-3-5-WeakHashMap＜K-V＞"><a href="#2-3-5-WeakHashMap＜K-V＞" class="headerlink" title="2.3.5. WeakHashMap＜K, V＞"></a>2.3.5. WeakHashMap＜K, V＞</h4><h5 id="2-3-5-1-WeakHashMap＜K-V＞-体系结构"><a href="#2-3-5-1-WeakHashMap＜K-V＞-体系结构" class="headerlink" title="2.3.5.1. WeakHashMap＜K, V＞ 体系结构"></a>2.3.5.1. WeakHashMap＜K, V＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-9.png"></p><hr><h5 id="2-3-5-2-WeakHashMap＜K-V＞-底层实现"><a href="#2-3-5-2-WeakHashMap＜K-V＞-底层实现" class="headerlink" title="2.3.5.2. WeakHashMap＜K, V＞ 底层实现"></a>2.3.5.2. WeakHashMap＜K, V＞ 底层实现</h5><p><code>WeakHashMap＜K, V＞</code> 底层是基于一个数组 + 多条单向链表实现的（类似于 <code>Java8</code> 之前的 <code>HashMap＜K, V＞</code> 的底层实现，没有红黑树）</p><p><code>WeakHashMap＜K, V＞</code> 是通过 <code>HashMap＜K, V＞➔table</code> 存储数据的，而它又是一个由 <code>WeakHashMap＜K, V＞.Entry＜K, V＞</code> 构建的数组，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br><br>V value;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br><br>Entry&lt;K,V&gt; next;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，每一个 <code>WeakHashMap＜K, V＞.Entry＜K, V＞</code> 还维护了一条由 <code>WeakHashMap＜K, V＞.Entry＜K, V＞</code> 构建的单向链表</p><hr><h5 id="2-3-5-3-WeakHashMap＜K-V＞-扩容机制"><a href="#2-3-5-3-WeakHashMap＜K-V＞-扩容机制" class="headerlink" title="2.3.5.3. WeakHashMap＜K, V＞ 扩容机制"></a>2.3.5.3. WeakHashMap＜K, V＞ 扩容机制</h5><p><code>WeakHashMap＜K, V＞</code> 的扩容机制和 <code>Java8</code> 之前的 <code>HashMap＜K, V＞</code> 的扩容机制相似，只不过在扩容前会进行一次清理。如果清理后发现又不超过 ”数组容量 * 负载因子“ 了，则不会再进行扩容。详见上文：<code>HashMap＜K, V＞</code></p><hr><h5 id="2-3-5-4-WeakHashMap＜K-V＞-问题爆破"><a href="#2-3-5-4-WeakHashMap＜K-V＞-问题爆破" class="headerlink" title="2.3.5.4. WeakHashMap＜K, V＞ 问题爆破"></a>2.3.5.4. WeakHashMap＜K, V＞ 问题爆破</h5><p>由于 <code>WeakHashMap＜K, V＞</code> 底层实现类似于 <code>Java8</code> 之前的 <code>HashMap＜K, V＞</code> 的底层实现，所以 <code>HashMap＜K, V＞</code> 拥有的问题，<code>WeakHashMap＜K, V＞</code> 一般都有。详见上文：<code>HashMap＜K, V＞</code></p><hr><h4 id="2-3-6-LinkedHashMap＜K-V＞"><a href="#2-3-6-LinkedHashMap＜K-V＞" class="headerlink" title="2.3.6. LinkedHashMap＜K, V＞"></a>2.3.6. LinkedHashMap＜K, V＞</h4><h5 id="2-3-6-1-LinkedHashMap＜K-V＞-概述"><a href="#2-3-6-1-LinkedHashMap＜K-V＞-概述" class="headerlink" title="2.3.6.1. LinkedHashMap＜K, V＞ 概述"></a>2.3.6.1. LinkedHashMap＜K, V＞ 概述</h5><p>想象这样几个问题：</p><ol><li>如果我们用 <code>HashMap＜K, V＞</code> 来实现“购物车”，用户按顺序加入了 <code>A</code>、<code>B</code>、<code>C</code>，但由于 <code>HashMap＜K, V＞</code> 本身是无序结构，遍历时可能得到 <code>B</code>、<code>C</code>、<code>A</code>。更糟糕的是，一旦 <code>HashMap＜K, V＞</code> 发生扩容，遍历的顺序还可能再次变化（简单来说就是 <code>HashMap＜K, V＞</code> 不支持 <code>FIFO</code> 顺序）</li><li>由于 <code>HashMap＜K, V＞</code> 底层使用了数组，这意味着它不可避免地具有数组的典型问题：数组的容量为 <code>10000</code>，但实际只存储了 <code>3</code> 个元素（你不知道究竟存储了多少元素），而且这 <code>3</code> 个元素存储在哪里你不知道。所以在遍历的时候（注意是遍历的时候）只能把 <code>10000</code> 个位置遍历一遍</li></ol><p>为了解决这些问题，<code>LinkedHashMap＜K, V＞</code> 在 <code>HashMap＜K, V＞</code> 的基础上，还维护了一条由 <code>LinkedHashMap＜K, V＞.Entry＜K, V＞</code> 构建的双向链表</p><p>在执行 ”增删改“ 操作时，会同时操作 <code>HashMap＜K, V＞</code> 和双向链表。常规的 ”查“ 操作仍然依赖 <code>HashMap＜K, V＞</code> 来获得高性能，但是只要涉及到遍历，我们就会使用双向链表</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>LinkedHashMap＜K, V＞</code> 除了支持插入顺序外，还支持最近访问顺序，天然符合 <code>LRU</code> 内存淘汰策略</li></ol></blockquote><hr><h5 id="2-3-6-2-LinkedHashMap＜K-V＞-体系结构"><a href="#2-3-6-2-LinkedHashMap＜K-V＞-体系结构" class="headerlink" title="2.3.6.2. LinkedHashMap＜K, V＞ 体系结构"></a>2.3.6.2. LinkedHashMap＜K, V＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-12.png"></p><hr><h5 id="2-3-6-3-LinkedHashMap＜K-V＞-底层实现"><a href="#2-3-6-3-LinkedHashMap＜K-V＞-底层实现" class="headerlink" title="2.3.6.3. LinkedHashMap＜K, V＞ 底层实现"></a>2.3.6.3. LinkedHashMap＜K, V＞ 底层实现</h5><p><code>LinkedHashMap＜K, V＞</code> 底层是基于一个 <code>HashMap＜K, V＞</code> + 一条双向链表实现的</p><p><code>LinkedHashMap＜K, V＞</code> 是通过以下方式存储数据的：</p><ol><li><code>HashMap＜K, V＞-&gt;table</code>，而它又是一个由 <code>HashMap＜K, V＞.Node＜K, V＞</code> 构建的数组</li><li>一条由 <code>LinkedHashMap＜K, V＞.Entry＜K, V＞</code> 构建的双向链表</li></ol><p>它们的基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashMap＜K, V＞-&gt;Node＜K, V＞</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br><br><span class="hljs-keyword">final</span> K key;<br><br>V value;<br><br>Node&lt;K,V&gt; next;<br><br>&#125;<br><br><span class="hljs-comment">// LinkedHashMap＜K, V＞.Entry＜K, V＞</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;<br><br>Entry&lt;K,V&gt; before, after;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-6-4-LinkedHashMap-问题爆破"><a href="#2-3-6-4-LinkedHashMap-问题爆破" class="headerlink" title="2.3.6.4. LinkedHashMap 问题爆破"></a>2.3.6.4. LinkedHashMap 问题爆破</h5><p>由于<code>LinkedHashMap＜K, V＞</code> 底层是基于 <code>HashMap＜K, V＞</code> 实现的，所以 <code>HashMap＜K, V＞</code> 拥有的问题，<code>LinkedHashMap＜K, V＞</code> 一般都有。详见上文：<code>HashMap＜K, V＞</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>为了解决 <code>LinkedHashMap＜K, V＞</code> 多线程并发安全性问题，我们通常为其加锁</li><li><code>LinkedHashMap＜K, V＞</code> 比较奇怪，其 ”查“ 操作也会导致迭代器的 “增”、“删” 异常问题</li></ol></blockquote><hr><h4 id="2-3-7-ConcurrentHashMap＜K-V＞"><a href="#2-3-7-ConcurrentHashMap＜K-V＞" class="headerlink" title="2.3.7. ConcurrentHashMap＜K, V＞"></a>2.3.7. ConcurrentHashMap＜K, V＞</h4><h5 id="2-3-7-1-ConcurrentHashMap＜K-V＞-体系结构"><a href="#2-3-7-1-ConcurrentHashMap＜K-V＞-体系结构" class="headerlink" title="2.3.7.1. ConcurrentHashMap＜K, V＞ 体系结构"></a>2.3.7.1. ConcurrentHashMap＜K, V＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-24.png"></p><hr><h5 id="2-3-7-2-ConcurrentHashMap＜K-V＞-底层实现"><a href="#2-3-7-2-ConcurrentHashMap＜K-V＞-底层实现" class="headerlink" title="2.3.7.2. ConcurrentHashMap＜K, V＞ 底层实现"></a>2.3.7.2. ConcurrentHashMap＜K, V＞ 底层实现</h5><h6 id="2-3-7-2-1-Java8-之前"><a href="#2-3-7-2-1-Java8-之前" class="headerlink" title="2.3.7.2.1. Java8 之前"></a>2.3.7.2.1. Java8 之前</h6><p>在 <code>Java8</code> 之前，<code>ConcurrentHashMap＜K, V＞</code> 底层是基于多个数组 + 多条单向链表 + 多个 <code>ReentrantLock</code> （无条件队列）实现的</p><p><code>ConcurrentHashMap＜K, V＞</code> 是通过 <code>ConcurrentHashMap＜K, V＞-&gt;segments</code> 存储数据的，而它又是一个由 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 构建的数组，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<br><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> threshold;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>每一个 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 还维护了一个由 <code>ConcurrentHashMap＜K, V＞.HashEntry＜K, V＞</code> 构建的数组，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt; &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br><br>    <span class="hljs-keyword">final</span> K key;<br><br>    <span class="hljs-keyword">volatile</span> V value;<br><br>    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，每一个 <code>ConcurrentHashMap＜K, V＞.HashEntry＜K, V＞</code> 还维护了一条由 <code>ConcurrentHashMap＜K, V＞.HashEntry＜K, V＞</code> 构建的单向链表</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>数据的存储实际上是由 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 维护的数组进行的</li></ol></blockquote><hr><h6 id="2-3-7-2-2-Java8-之后"><a href="#2-3-7-2-2-Java8-之后" class="headerlink" title="2.3.7.2.2. Java8 之后"></a>2.3.7.2.2. Java8 之后</h6><p>在 <code>Java8</code> 之后，<code>ConcurrentHashMap＜K, V＞</code> 底层是基于一个数组 + 多条单向链表 + 多个红黑树 + <code>CAS</code> + <code>synchronized</code> 实现的（类似于 <code>Java8</code> 之后的 <code>HashMap＜K, V＞</code> 的底层实现）</p><p><code>ConcurrentHashMap＜K, V＞</code> 是通过 <code>ConcurrentHashMap＜K, V＞➔table</code> 存储数据的，而它又是一个由 <code>ConcurrentHashMap＜K, V＞.Node＜K, V＞</code> 构建的数组，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br><br><span class="hljs-keyword">final</span> K key;<br><br><span class="hljs-keyword">volatile</span> V val;<br><br><span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，每一个 <code>ConcurrentHashMap＜K, V＞.Node＜K, V＞</code> 还维护了一条由 <code>ConcurrentHashMap＜K, V＞.Node＜K, V＞</code> 构建的单向链表</p><hr><h5 id="2-3-7-3-ConcurrentHashMap＜K-V＞-扩容机制"><a href="#2-3-7-3-ConcurrentHashMap＜K-V＞-扩容机制" class="headerlink" title="2.3.7.3. ConcurrentHashMap＜K, V＞ 扩容机制"></a>2.3.7.3. ConcurrentHashMap＜K, V＞ 扩容机制</h5><p><code>ConcurrentHashMap＜K, V＞</code> 的扩容机制和 <code>HashMap＜K, V＞</code> 的扩容机制相似，只不过在 <code>Java8</code> 之前的 <code>ConcurrentHashMap＜K, V＞</code> 在扩容时，并不是所有的 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 维护的数组都扩容，而是某个 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 维护的数组在需要扩容时才扩容。详见上文：<code>HashMap＜K, V＞</code></p><hr><h5 id="2-3-7-4-ConcurrentHashMap＜K-V＞-相关流程"><a href="#2-3-7-4-ConcurrentHashMap＜K-V＞-相关流程" class="headerlink" title="2.3.7.4. ConcurrentHashMap＜K, V＞ 相关流程"></a>2.3.7.4. ConcurrentHashMap＜K, V＞ 相关流程</h5><h6 id="2-3-7-4-1-Java8-之前"><a href="#2-3-7-4-1-Java8-之前" class="headerlink" title="2.3.7.4.1. Java8 之前"></a>2.3.7.4.1. Java8 之前</h6><p><font color="#92d050">1. 读操作相关流程</font><br><code>ConcurrentHashMap＜K, V＞</code> 的读操作全程不加锁</p><p><font color="#92d050">2. 写操作相关流程</font><br>在 <code>Java8</code> 之前，<code>ConcurrentHashMap＜K, V＞</code> 的读操作的核心理念是 “分段锁”</p><p>当线程执行写操作时，会先根据元素的 <code>Key</code> 通过哈希函数计算出哈希值，并将其转换成数组索引，然后定位的数组索引对应的 <code>ConcurrentHashMap＜K, V＞-&gt;segments</code> 位置（某个 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code>）</p><p>接着线程会竞争该 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 的 <code>Lock</code> 锁。当线程持有锁后，会再将 <code>Key</code> 的哈希值转换成 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 的数组索引，然后定位到数组索引对应的位置，并对其进行写操作</p><hr><h6 id="2-3-7-4-2-Java8-之后"><a href="#2-3-7-4-2-Java8-之后" class="headerlink" title="2.3.7.4.2. Java8 之后"></a>2.3.7.4.2. Java8 之后</h6><p><font color="#92d050">1. 读操作相关流程</font><br><code>ConcurrentHashMap＜K, V＞</code> 的读操作全程不加锁</p><p><font color="#92d050">2. 写操作相关流程</font><br>在 <code>Java8</code> 之前，我们要竞争一个 <code>ConcurrentHashMap＜K, V＞.Segment＜K, V＞</code> 的 <code>Lock</code> 锁，锁的范围非常大。在 <code>Java8</code> 之后，当线程执行写操作时，会先根据元素的 <code>Key</code> 通过哈希函数计算出哈希值，并将其转换成数组索引，然后定位到数组索引对应的位置。如果该数组位置上没有元素，就使用 <code>CAS</code> 对其进行写操作。如果该数组位置上已有元素，就对该数组位置的首个元素加 <code>synchronized</code> 锁，然后再进行写操作</p><hr><h5 id="2-3-7-5-ConcurrentHashMap＜K-V＞-问题爆破"><a href="#2-3-7-5-ConcurrentHashMap＜K-V＞-问题爆破" class="headerlink" title="2.3.7.5. ConcurrentHashMap＜K, V＞ 问题爆破"></a>2.3.7.5. ConcurrentHashMap＜K, V＞ 问题爆破</h5><h6 id="2-3-7-5-1-迭代器的-“增”、“删”-异常问题"><a href="#2-3-7-5-1-迭代器的-“增”、“删”-异常问题" class="headerlink" title="2.3.7.5.1. 迭代器的 “增”、“删” 异常问题"></a>2.3.7.5.1. 迭代器的 “增”、“删” 异常问题</h6><p>为了解决这一问题，<code>ConcurrentHashMap＜K, V＞</code> 采取了弱一致性（<code>Weakly Consistent</code>）策略。在遍历过程中进行了 “增” 或 “删” 操作，不会抛出任何异常，而是继续向下遍历</p><hr><h4 id="2-3-8-ConcurrentSkipListMap＜K-V＞"><a href="#2-3-8-ConcurrentSkipListMap＜K-V＞" class="headerlink" title="2.3.8. ConcurrentSkipListMap＜K, V＞"></a>2.3.8. ConcurrentSkipListMap＜K, V＞</h4><h5 id="2-3-8-1-ConcurrentSkipListMap＜K-V＞-体系结构"><a href="#2-3-8-1-ConcurrentSkipListMap＜K-V＞-体系结构" class="headerlink" title="2.3.8.1. ConcurrentSkipListMap＜K, V＞ 体系结构"></a>2.3.8.1. ConcurrentSkipListMap＜K, V＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-25.png"></p><hr><h5 id="2-3-8-2-ConcurrentSkipListMap＜K-V＞-底层实现"><a href="#2-3-8-2-ConcurrentSkipListMap＜K-V＞-底层实现" class="headerlink" title="2.3.8.2. ConcurrentSkipListMap＜K, V＞ 底层实现"></a>2.3.8.2. ConcurrentSkipListMap＜K, V＞ 底层实现</h5><p><code>ConcurrentSkipListMap＜K, V＞</code> 底层是基于一个跳表 + <code>CAS</code> 实现的</p><p><code>ConcurrentSkipListMap＜K, V＞</code> 是通过一个由 <code>ConcurrentSkipListMap＜K, V＞.Node＜K, V＞</code> 构建的，基于单向链表的跳表存储数据的，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br><br><span class="hljs-keyword">final</span> K key; <br><br>V val;<br><br>Node&lt;K,V&gt; next;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2-3-8-3-ConcurrentSkipListMap＜K-V＞-问题爆破"><a href="#2-3-8-3-ConcurrentSkipListMap＜K-V＞-问题爆破" class="headerlink" title="2.3.8.3. ConcurrentSkipListMap＜K, V＞ 问题爆破"></a>2.3.8.3. ConcurrentSkipListMap＜K, V＞ 问题爆破</h5><h6 id="2-3-8-3-1-迭代器的-“增”、“删”-异常问题"><a href="#2-3-8-3-1-迭代器的-“增”、“删”-异常问题" class="headerlink" title="2.3.8.3.1. 迭代器的 “增”、“删” 异常问题"></a>2.3.8.3.1. 迭代器的 “增”、“删” 异常问题</h6><p>为了解决这一问题，<code>ConcurrentSkipListMap＜K, V＞</code> 采取了弱一致性（<code>Weakly Consistent</code>）策略。在遍历过程中进行了 “增” 或 “删” 操作，不会抛出任何异常，而是继续向下遍历</p><hr><h3 id="2-4-Queue＜E＞"><a href="#2-4-Queue＜E＞" class="headerlink" title="2.4. Queue＜E＞"></a>2.4. Queue＜E＞</h3><h4 id="2-4-1-Queue＜E＞-基础体系"><a href="#2-4-1-Queue＜E＞-基础体系" class="headerlink" title="2.4.1. Queue＜E＞ 基础体系"></a>2.4.1. Queue＜E＞ 基础体系</h4><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-10.png"></p><ol><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Cloneable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Cloneable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Comparable&lt;T&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Comparable＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Delayed</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Delayed源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li><li>详见源码：<code>Iterable＜E＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Iterable＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li></li></ol></li></ol></li></ol><hr><h4 id="2-4-2-Queue＜E＞-相关分类"><a href="#2-4-2-Queue＜E＞-相关分类" class="headerlink" title="2.4.2. Queue＜E＞ 相关分类"></a>2.4.2. Queue＜E＞ 相关分类</h4><ol><li><code>LinkedList＜E＞</code></li><li><code>DelayQueue＜E＞</code></li><li><code>PriorityQueue＜E＞</code></li><li><code>SynchronousQueue＜E＞</code></li><li><code>ArrayBlockingQueue＜E＞</code></li><li><code>LinkedTransferQueue＜E＞</code></li><li><code>LinkedBlockingQueue＜E＞</code></li><li><code>PriorityBlockingQueue＜E＞</code></li><li><code>ConcurrentLinkedQueue＜E＞</code></li><li><code>ForkJoinPool.WorkQueue＜E＞</code></li><li><code>ScheduledThreadPoolExecutor.DelayedWorkQueue＜E＞</code></li><li><code>ArrayDeque＜E＞</code></li><li><code>LinkedBlockingDeque＜E＞</code></li><li><code>ConcurrentLinkedDeque＜E＞</code></li></ol><table><thead><tr><th>特性</th><th>LinkedList＜E＞</th><th>DelayQueue＜E＞</th><th>PriorityQueue＜E＞</th></tr></thead><tbody><tr><td><strong>顺序性</strong></td><td>✅（<code>FIFO</code> 顺序、<code>LIFO</code> 顺序）</td><td>✅（<code>TTL</code> 顺序）</td><td>✅（优先级顺序）</td></tr><tr><td><strong>有界性</strong></td><td>—</td><td>❌</td><td>❌（需要扩容）</td></tr><tr><td><strong>支持扩容</strong></td><td>—</td><td>✅</td><td>✅</td></tr><tr><td><strong>支持双端</strong></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><strong>支持延迟</strong></td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td><strong>支持优先级</strong></td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><strong>底层实现</strong></td><td>一条双向链表</td><td>一个 <code>PriorityQueue</code> + 一个 <code>ReentrantLock</code>（一个条件队列）</td><td>一个二叉堆</td></tr><tr><td><strong>允许元素重复</strong></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>允许元素为 null</strong></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><strong>多线程并发安全性</strong></td><td>❌</td><td>✅</td><td>❌</td></tr></tbody></table><table><thead><tr><th>特性</th><th>synchronousQueue＜E＞</th><th>ArrayBlockingQueue＜E＞</th><th>LinkedTransferQueue＜E＞</th></tr></thead><tbody><tr><td><strong>顺序性</strong></td><td>—</td><td>✅（<code>FIFO</code> 顺序）</td><td>✅（<code>FIFO</code> 顺序）</td></tr><tr><td><strong>有界性</strong></td><td>—</td><td>✅</td><td>—</td></tr><tr><td><strong>支持扩容</strong></td><td>—</td><td>❌</td><td>—</td></tr><tr><td><strong>支持双端</strong></td><td>—</td><td>❌</td><td>❌</td></tr><tr><td><strong>支持延迟</strong></td><td>—</td><td>❌</td><td>❌</td></tr><tr><td><strong>支持优先级</strong></td><td>—</td><td>❌</td><td>❌</td></tr><tr><td><strong>底层实现</strong></td><td>—</td><td>一个数组 + 一个 <code>ReentrantLock</code>（两个条件队列）</td><td>一条单向链表 + <code>CAS</code></td></tr><tr><td><strong>允许元素重复</strong></td><td>—</td><td>✅</td><td>✅</td></tr><tr><td><strong>允许元素为 null</strong></td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td><strong>多线程并发安全性</strong></td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><table><thead><tr><th>特性</th><th>LinkedBlockingQueue＜E＞</th><th>PriorityBlockingQueue＜E＞</th><th>ConcurrentLinkedQueue＜E＞</th></tr></thead><tbody><tr><td><strong>顺序性</strong></td><td>✅（<code>FIFO</code> 顺序）</td><td>✅（优先级顺序）</td><td>✅（<code>FIFO</code> 顺序）</td></tr><tr><td><strong>有界性</strong></td><td>✅（人为限制）</td><td>❌（需要扩容）</td><td>—</td></tr><tr><td><strong>支持扩容</strong></td><td>—</td><td>✅</td><td>—</td></tr><tr><td><strong>支持双端</strong></td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td><strong>支持延迟</strong></td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td><strong>支持优先级</strong></td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td><strong>底层实现</strong></td><td>一条单向链表 + 两个 <code>ReentrantLock</code>（各一个条件队列）</td><td>一个二叉堆 + 一个 <code>ReentrantLock</code>（一个条件队列）</td><td>一条单向链表 + <code>CAS</code></td></tr><tr><td><strong>允许元素重复</strong></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>允许元素为 null</strong></td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td><strong>多线程并发安全性</strong></td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><table><thead><tr><th>特性</th><th>ForkJoinPool.WorkQueue＜E＞</th><th>ScheduledThreadPoolExecutor.DelayedWorkQueue＜E＞</th><th>ArrayDeque＜E＞</th></tr></thead><tbody><tr><td><strong>顺序性</strong></td><td></td><td></td><td>✅（<code>FIFO</code> 顺序、<code>LIFO</code> 顺序）</td></tr><tr><td><strong>有界性</strong></td><td></td><td></td><td>❌（需要扩容）</td></tr><tr><td><strong>支持扩容</strong></td><td></td><td></td><td>✅</td></tr><tr><td><strong>支持双端</strong></td><td></td><td></td><td>✅</td></tr><tr><td><strong>支持延迟</strong></td><td></td><td></td><td>❌</td></tr><tr><td><strong>支持优先级</strong></td><td></td><td></td><td>❌</td></tr><tr><td><strong>底层实现</strong></td><td></td><td></td><td>一个数组</td></tr><tr><td><strong>允许元素重复</strong></td><td></td><td></td><td>✅</td></tr><tr><td><strong>允许元素为 null</strong></td><td></td><td></td><td>❌</td></tr><tr><td><strong>多线程并发安全性</strong></td><td></td><td></td><td>❌</td></tr></tbody></table><table><thead><tr><th>特性</th><th>LinkedBlockingDeque＜E＞</th><th>ConcurrentLinkedDeque＜E＞</th></tr></thead><tbody><tr><td><strong>顺序性</strong></td><td>✅（<code>FIFO</code> 顺序、<code>LIFO</code> 顺序）</td><td>✅（<code>FIFO</code> 顺序、<code>LIFO</code> 顺序）</td></tr><tr><td><strong>有界性</strong></td><td>✅（人为限制）</td><td>—</td></tr><tr><td><strong>支持扩容</strong></td><td>—</td><td>—</td></tr><tr><td><strong>支持双端</strong></td><td>✅</td><td>✅</td></tr><tr><td><strong>支持延迟</strong></td><td>❌</td><td>❌</td></tr><tr><td><strong>支持优先级</strong></td><td>❌</td><td>❌</td></tr><tr><td><strong>底层实现</strong></td><td>一条双向链表 + 一个 <code>ReentrantLock</code>（两个条件队列）</td><td>一条双向链表 + <code>CAS</code></td></tr><tr><td><strong>允许元素重复</strong></td><td>✅</td><td>✅</td></tr><tr><td><strong>允许元素为 null</strong></td><td>❌</td><td>❌</td></tr><tr><td><strong>多线程并发安全性</strong></td><td>✅</td><td>✅</td></tr></tbody></table><hr><h4 id="2-4-2-1-LinkedList＜E＞"><a href="#2-4-2-1-LinkedList＜E＞" class="headerlink" title="2.4.2.1. LinkedList＜E＞"></a>2.4.2.1. LinkedList＜E＞</h4><p>详见上文：<code>LinkedList＜E＞</code></p><hr><h4 id="2-4-3-DelayQueue＜E＞"><a href="#2-4-3-DelayQueue＜E＞" class="headerlink" title="2.4.3. DelayQueue＜E＞"></a>2.4.3. DelayQueue＜E＞</h4><h5 id="2-4-3-1-DelayQueue＜E＞-体系结构"><a href="#2-4-3-1-DelayQueue＜E＞-体系结构" class="headerlink" title="2.4.3.1. DelayQueue＜E＞ 体系结构"></a>2.4.3.1. DelayQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-13.png"></p><hr><h4 id="2-4-4-PriorityQueue＜E＞"><a href="#2-4-4-PriorityQueue＜E＞" class="headerlink" title="2.4.4. PriorityQueue＜E＞"></a>2.4.4. PriorityQueue＜E＞</h4><h5 id="2-4-4-1-PriorityQueue＜E＞-体系结构"><a href="#2-4-4-1-PriorityQueue＜E＞-体系结构" class="headerlink" title="2.4.4.1. PriorityQueue＜E＞ 体系结构"></a>2.4.4.1. PriorityQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-14.png"></p><hr><h4 id="2-4-5-SynchronousQueue＜E＞"><a href="#2-4-5-SynchronousQueue＜E＞" class="headerlink" title="2.4.5. SynchronousQueue＜E＞"></a>2.4.5. SynchronousQueue＜E＞</h4><h5 id="2-4-5-1-SynchronousQueue＜E＞-体系结构"><a href="#2-4-5-1-SynchronousQueue＜E＞-体系结构" class="headerlink" title="2.4.5.1. SynchronousQueue＜E＞ 体系结构"></a>2.4.5.1. SynchronousQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-15.png"></p><hr><h4 id="2-4-6-ArrayBlockingQueue＜E＞"><a href="#2-4-6-ArrayBlockingQueue＜E＞" class="headerlink" title="2.4.6. ArrayBlockingQueue＜E＞"></a>2.4.6. ArrayBlockingQueue＜E＞</h4><h5 id="2-4-6-1-ArrayBlockingQueue＜E＞-体系结构"><a href="#2-4-6-1-ArrayBlockingQueue＜E＞-体系结构" class="headerlink" title="2.4.6.1. ArrayBlockingQueue＜E＞ 体系结构"></a>2.4.6.1. ArrayBlockingQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-16.png"></p><hr><h4 id="2-4-7-LinkedTransferQueue＜E＞"><a href="#2-4-7-LinkedTransferQueue＜E＞" class="headerlink" title="2.4.7. LinkedTransferQueue＜E＞"></a>2.4.7. LinkedTransferQueue＜E＞</h4><h5 id="2-4-7-1-LinkedTransferQueue＜E＞-体系结构"><a href="#2-4-7-1-LinkedTransferQueue＜E＞-体系结构" class="headerlink" title="2.4.7.1. LinkedTransferQueue＜E＞ 体系结构"></a>2.4.7.1. LinkedTransferQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-17.png"></p><hr><h4 id="2-4-8-LinkedBlockingQueue＜E＞"><a href="#2-4-8-LinkedBlockingQueue＜E＞" class="headerlink" title="2.4.8. LinkedBlockingQueue＜E＞"></a>2.4.8. LinkedBlockingQueue＜E＞</h4><h5 id="2-4-8-1-LinkedBlockingQueue＜E＞-体系结构"><a href="#2-4-8-1-LinkedBlockingQueue＜E＞-体系结构" class="headerlink" title="2.4.8.1. LinkedBlockingQueue＜E＞ 体系结构"></a>2.4.8.1. LinkedBlockingQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-18.png"></p><hr><h4 id="2-4-9-PriorityBlockingQueue＜E＞"><a href="#2-4-9-PriorityBlockingQueue＜E＞" class="headerlink" title="2.4.9. PriorityBlockingQueue＜E＞"></a>2.4.9. PriorityBlockingQueue＜E＞</h4><h5 id="2-4-9-1-PriorityBlockingQueue＜E＞-体系结构"><a href="#2-4-9-1-PriorityBlockingQueue＜E＞-体系结构" class="headerlink" title="2.4.9.1. PriorityBlockingQueue＜E＞ 体系结构"></a>2.4.9.1. PriorityBlockingQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-19.png"></p><hr><h4 id="2-4-10-ConcurrentLinkedQueue＜E＞"><a href="#2-4-10-ConcurrentLinkedQueue＜E＞" class="headerlink" title="2.4.10. ConcurrentLinkedQueue＜E＞"></a>2.4.10. ConcurrentLinkedQueue＜E＞</h4><h5 id="2-4-10-1-ConcurrentLinkedQueue＜E＞-体系结构"><a href="#2-4-10-1-ConcurrentLinkedQueue＜E＞-体系结构" class="headerlink" title="2.4.10.1. ConcurrentLinkedQueue＜E＞ 体系结构"></a>2.4.10.1. ConcurrentLinkedQueue＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-20.png"></p><hr><h4 id="2-4-11-ArrayDeque＜E＞"><a href="#2-4-11-ArrayDeque＜E＞" class="headerlink" title="2.4.11. ArrayDeque＜E＞"></a>2.4.11. ArrayDeque＜E＞</h4><h5 id="2-4-11-1-ArrayDeque＜E＞-体系结构"><a href="#2-4-11-1-ArrayDeque＜E＞-体系结构" class="headerlink" title="2.4.11.1. ArrayDeque＜E＞ 体系结构"></a>2.4.11.1. ArrayDeque＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-21.png"></p><hr><h4 id="2-4-12-LinkedBlockingDeque＜E＞"><a href="#2-4-12-LinkedBlockingDeque＜E＞" class="headerlink" title="2.4.12. LinkedBlockingDeque＜E＞"></a>2.4.12. LinkedBlockingDeque＜E＞</h4><h5 id="2-4-12-1-LinkedBlockingDeque＜E＞-体系结构"><a href="#2-4-12-1-LinkedBlockingDeque＜E＞-体系结构" class="headerlink" title="2.4.12.1. LinkedBlockingDeque＜E＞ 体系结构"></a>2.4.12.1. LinkedBlockingDeque＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-22.png"></p><hr><h4 id="2-4-13-ConcurrentLinkedDeque＜E＞"><a href="#2-4-13-ConcurrentLinkedDeque＜E＞" class="headerlink" title="2.4.13. ConcurrentLinkedDeque＜E＞"></a>2.4.13. ConcurrentLinkedDeque＜E＞</h4><h5 id="2-4-13-1-ConcurrentLinkedDeque＜E＞-体系结构"><a href="#2-4-13-1-ConcurrentLinkedDeque＜E＞-体系结构" class="headerlink" title="2.4.13.1. ConcurrentLinkedDeque＜E＞ 体系结构"></a>2.4.13.1. ConcurrentLinkedDeque＜E＞ 体系结构</h5><p><img src="/2025/11/27/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-23.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 数据类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java日志框架</title>
    <link href="/2025/11/24/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
    <url>/2025/11/24/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/24/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6.eddx"></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/Java-2b5974fbda5e806899f7fa6b19c61c04?source=copy_link">https://www.notion.so/Java-2b5974fbda5e806899f7fa6b19c61c04?source=copy_link</a></p></li></ol><hr><h1 id="三、Java-日志框架前置基础"><a href="#三、Java-日志框架前置基础" class="headerlink" title="三、Java 日志框架前置基础"></a>三、Java 日志框架前置基础</h1><h2 id="1-Java-日志框架的发展史"><a href="#1-Java-日志框架的发展史" class="headerlink" title="1. Java 日志框架的发展史"></a>1. Java 日志框架的发展史</h2><p><img src="/2025/11/24/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6.png"></p><hr><h1 id="四、JUL"><a href="#四、JUL" class="headerlink" title="四、JUL"></a>四、JUL</h1><h2 id="1-JUL-概述"><a href="#1-JUL-概述" class="headerlink" title="1. JUL 概述"></a>1. JUL 概述</h2><p><code>JUL</code>（<code>Java Util Logging</code>），是 <code>JDK</code> 内置的日志记录框架，使用时无需额外引入第三方库，使用相对简单。</p><p><code>JUL</code> 虽然能满足一般应用的日志需求，但相比 <code>Log4j</code>、<code>SLF4J</code> 等第三方框架，其扩展性和高级特性较为有限。</p><hr><h2 id="2-JUL-核心组件"><a href="#2-JUL-核心组件" class="headerlink" title="2. JUL 核心组件"></a>2. JUL 核心组件</h2><p><img src="/2025/11/24/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6-1.png"></p><ol><li><code>Logger</code><ol><li><code>Logger</code>（记录器）是日志框架的入口，我们可以通过调用 <code>Logger.getLogger(String name)</code> 获取 <code>Logger</code> 实例，并调用其方法记录日志信息。</li><li>需要注意的是：<ol><li><code>Logger</code> 会根据我们设置的 <code>Logger</code> 日志级别来记录需要的日志，对于低于我们设定级别的日志，即使我们调用了日志的记录方法（如 <code>logger.config(xxx)</code>），这些日志也不会被 <code>Logger</code> 记录（可以理解为：日志的第一层过滤）</li><li><code>Logger</code> 通常搭配 <code>Level</code> 和 <code>Filter</code> 使用</li></ol></li></ol></li><li><code>Filter</code><ol><li><code>Filter</code>（过滤器） 用于在日志记录被发送到 <code>Handler</code> 之前进行筛选，可以进行定制，决定哪些日志信息应该被接受，哪些应被过滤掉（可以理解为：日志的第二层过滤）</li></ol></li><li><code>Handler</code><ol><li><code>Handler</code>（处理器），负责接收 <code>Logger</code> 记录的日志，并将日志消息输出到指定目标</li><li><code>Handler</code> 分别有：<ol><li><code>ConsoleHandler</code><ol><li>日志输出到控制台</li></ol></li><li><code>FileHandler</code><ol><li>日志输出到文件</li></ol></li><li><code>SocketHandler</code><ol><li>日志输出到网络端点</li></ol></li><li><code>MemoryHandler</code><ol><li>日志暂存于内存，满足条件时批量输出</li></ol></li></ol></li><li>需要注意的是：<ol><li>一个 <code>Logger</code> 可以关联多个 <code>Handler</code>，以便将日志消息输出到不同的目标。</li><li><code>Handler</code> 会根据我们设置的 <code>Handler</code> 日志级别来输出需要的日志，对于低于设定级别的日志，即使 <code>Logger</code> 将其传递过来，这些日志也不会被输出（可以理解为：日志的第三层过滤）</li><li><code>Handler</code> 通常搭配 <code>Level</code> 和 <code>Formatter</code> 使用</li></ol></li></ol></li><li><code>Formatter</code><ol><li><code>Formatter</code>（格式化组件） 定义了日志消息的输出格式。</li><li><code>Formatter</code> 分别有：<ol><li><code>SimpleFormatter</code><ol><li>简单、易读的文本格式</li></ol></li><li><code>XMLFormatter</code><ol><li>以 <code>XML</code> 格式输出日志</li></ol></li><li>需要注意的是：<ol><li>原生 <code>Java</code> 并没有提供 <code>JSON</code> 格式的格式化组件</li><li>但是们可以通过自定义 <code>Formatter</code> 类来自定义输出格式</li></ol></li></ol></li></ol></li><li><code>Level</code><ol><li><code>Level</code>（验证级别）定义了日志级别</li><li><code>Level</code> 的级别顺序为：<ol><li><code>OFF</code><ol><li>禁止捕获所有级别的日志信息</li></ol></li><li><code>SEVERE</code><ol><li>错误信息，表示严重错误或异常情况，应用可能无法继续运行</li></ol></li><li><code>WARNING</code><ol><li>警告信息，提示潜在的问题，但应用仍然可以继续运行</li></ol></li><li><code>INFO</code><ol><li>输出常规运行信息，提供系统运行状态</li></ol></li><li><code>CONFIG</code><ol><li>输出配置项信息</li></ol></li><li><code>FINE</code><ol><li>调试信息（少），详细调试时使用</li></ol></li><li><code>FINER</code><ol><li>调试信息（中），详细调试时使用</li></ol></li><li><code>FINEST</code><ol><li>调试信息（多），详细调试时使用</li></ol></li><li><code>ALL</code><ol><li>捕获所有级别的日志信息</li></ol></li></ol></li></ol></li></ol><hr><h2 id="3-JUL-核心特性"><a href="#3-JUL-核心特性" class="headerlink" title="3. JUL 核心特性"></a>3. JUL 核心特性</h2><p><code>JUL</code> 是一个具备层次结构的日志记录器，采用父子关系进行组织。例如 <code>com</code> 是 <code>com.example</code> 的父级，而 <code>com.example</code> 又是 <code>com.example.test</code> 的父级，而最顶层的 <code>com</code> 则以根日志（ <code>RootLogger</code>） 作为其父级。</p><p>而 <code>JUL</code> 包含以下核心特性：</p><ol><li>继承的特性<ol><li>如果我们没有为子级 <code>Logger</code> 手动设置日志级别，它会默认继承父级 <code>Logger</code> 的日志级别</li></ol></li><li>日志向上传递的特性<ol><li>每当子级 <code>Logger</code>（例如 <code>com.example</code>）记录一条日志时，首先会通过自身配置的 <code>Handler</code> 输出</li><li>随后，这条日志会向上传递至父级 <code>Logger</code>，并通过父级的 <code>Handler</code> 输出（在父级同样会进行过滤）</li><li>这个向上传递过程会逐级进行，最终到达最顶层的 <code>RootLogger</code>，并通过其 <code>Handler</code> 输出</li><li>我们可以禁用这种向上传递行为（通过 <code>setUseParentHandlers(false)</code>）</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>由于日志是逐条向上传递的，而不是等到底层 <code>Handler</code> 整体输出后再整体向上传递，因此可能会看到类似以下的日志输出：</li></ol></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>严重: severe 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>严重: severe 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>严重: severe 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>警告: warning 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>警告: warning 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>警告: warning 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>信息: info 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>信息: info 信息<br><span class="hljs-number">3</span>月 <span class="hljs-number">12</span>, <span class="hljs-number">2025</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37</span> 上午 com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.Main</span> <span class="hljs-selector-tag">main</span><br>信息: info 信息<br></code></pre></td></tr></table></figure><hr><h2 id="4-JUL-使用方式"><a href="#4-JUL-使用方式" class="headerlink" title="4. JUL 使用方式"></a>4. JUL 使用方式</h2><h3 id="4-1-进行-JUL-相关配置"><a href="#4-1-进行-JUL-相关配置" class="headerlink" title="4.1. 进行 JUL 相关配置"></a>4.1. 进行 JUL 相关配置</h3><h4 id="4-1-1-文件配置"><a href="#4-1-1-文件配置" class="headerlink" title="4.1.1. 文件配置"></a>4.1.1. 文件配置</h4><h5 id="4-1-1-1-JAVA-HOME-conf-logging-properties"><a href="#4-1-1-1-JAVA-HOME-conf-logging-properties" class="headerlink" title="4.1.1.1. ${JAVA_HOME}&#x2F;conf&#x2F;logging.properties"></a>4.1.1.1. ${JAVA_HOME}&#x2F;conf&#x2F;logging.properties</h5><h6 id="4-1-1-1-1-配置概述"><a href="#4-1-1-1-1-配置概述" class="headerlink" title="4.1.1.1.1. 配置概述"></a>4.1.1.1.1. 配置概述</h6><p>该配置用于配置根日志管道</p><hr><h6 id="4-1-1-1-2-Logger-配置"><a href="#4-1-1-1-2-Logger-配置" class="headerlink" title="4.1.1.1.2. Logger 配置"></a>4.1.1.1.2. Logger 配置</h6><p><font color="#92d050">1. 配置 Logger 的日志级别</font></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">.level</span> = <span class="hljs-string">INFO  </span><br></code></pre></td></tr></table></figure><hr><h6 id="4-1-1-1-3-Handler-配置"><a href="#4-1-1-1-3-Handler-配置" class="headerlink" title="4.1.1.1.3. Handler 配置"></a>4.1.1.1.3. Handler 配置</h6><p><font color="#92d050">1. 配置 RootLogger 使用哪些 Handler</font></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">handlers</span> = <span class="hljs-string">java.util.logging.ConsoleHandler, java.util.logging.FileHandler</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. ConsoleHandler 的详细配置</font></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 1. ConsoleHandler 的日志级别</span><br><span class="hljs-attr">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">INFO</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 2. ConsoleHandler 的日志输出格式</span><br><span class="hljs-attr">java.util.logging.ConsoleHandler.formatter</span> = <span class="hljs-string">java.util.logging.SimpleFormatter</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">3. FileHandler 的详细配置</font></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 1. FileHandler 的日志级别</span><br><span class="hljs-attr">java.util.logging.FileHandler.level</span> = <span class="hljs-string">ALL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 2. FileHandler 输出到的日志文件的存放位置</span><br><span class="hljs-attr">java.util.logging.FileHandler.pattern</span> = <span class="hljs-string">D:\\EnglishDeployment\\logs\\JUL.%g.log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 3. 单个日志文件最大字节数量（10485760 字节 为 10MB）</span><br><span class="hljs-attr">java.util.logging.FileHandler.limit</span> = <span class="hljs-string">10485760</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 4. 日志文件最大总数量</span><br><span class="hljs-attr">java.util.logging.FileHandler.count</span> = <span class="hljs-string">5 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 5. FileHandler 输出日志是否以追加模式（true 为追加模式，false 为覆盖模式）</span><br>    <span class="hljs-attr">1.</span> <span class="hljs-string">true</span><br>        <span class="hljs-attr">1.</span> <span class="hljs-string">追加模式</span><br>        <span class="hljs-attr">2.</span> <span class="hljs-string">如果日志文件已经存在，新日志会接在旧日志后面继续写</span><br>    <span class="hljs-attr">2.</span> <span class="hljs-string">false</span><br>        <span class="hljs-attr">1.</span> <span class="hljs-string">覆盖模式</span><br>        <span class="hljs-attr">2.</span> <span class="hljs-string">每次应用启动时，如果日志文件已存在，会先清空，从头写新的内容</span><br><span class="hljs-attr">java.util.logging.FileHandler.append</span> = <span class="hljs-string">true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 6. FileHandler 的日志输出格式（默认是 XML 方式）</span><br><span class="hljs-attr">java.util.logging.FileHandler.formatter</span> = <span class="hljs-string">java.util.logging.SimpleFormatter</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果需要将日志写入文件（即使用 <code>FileHandler</code>），需要注意以下三点：<ol><li><code>JUL</code> 只创建文件而不会自动生成文件所在的目录，因此必须手动创建 <code>logs</code> 目录，并确保程序具有相应的读写权限。</li><li>文件路径的格式应使用 <code>\\</code> 而非 <code>\</code></li><li><code>JUL</code> 中的日志轮换机制流程如下：<ol><li><code>JUL</code> 先将日志记录在 <code>JUL.0.log</code> 文件中。</li><li>当 <code>JUL.0.log</code> 文件写满时，它会被重命名为 <code>JUL.1.log</code>，同时创建一个新的 <code>JUL.0.log</code> 继续记录。</li><li>随着 <code>JUL.0.log</code> 日志再次写满，<code>JUL.1.log</code> 会被重命名为 <code>JUL.2.log</code>，而 <code>JUL.0.log</code> 则再次重命名为 <code>JUL.1.log</code>，这样依次进行。</li><li>当文件数量达到最大限制时，最早的日志文件（如 <code>JUL.4.log</code>）将被删除，以腾出空间</li></ol></li></ol></li></ol></blockquote><hr><h4 id="4-1-2-配置包日志管道"><a href="#4-1-2-配置包日志管道" class="headerlink" title="4.1.2. 配置包日志管道"></a>4.1.2. 配置包日志管道</h4><p>对于某些包下的代码，如果我们不希望完全沿用<code> RootLogger</code> 的配置，可以在代码中手动为这些包单独配置</p><p>在下面的示例中，我们为 <code>com.example.Main</code> 包单独配置了日志管道（有入口，有出口，不如直接叫做日志管道），并且禁用了日志向上传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 1. 创建 ConsoleHandler（日志处理器）</span><br>        <span class="hljs-type">ConsoleHandler</span> <span class="hljs-variable">consoleHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleHandler</span>();<br><br>        <span class="hljs-comment">// 2. 创建 SimpleFormatter（格式化组件）</span><br>        <span class="hljs-type">SimpleFormatter</span> <span class="hljs-variable">simpleFormatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFormatter</span>();<br><br>        <span class="hljs-comment">// 3. 将格式化组件设置到日志处理器中</span><br>        consoleHandler.setFormatter(simpleFormatter);<br><br>        <span class="hljs-comment">// 4. 获取 com.example.Main 层的 Logger</span><br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;com.example.Main&quot;</span>);<br><br>        <span class="hljs-comment">// 5. 配置 com.example.Main 层的 Logger</span><br>        <span class="hljs-comment">// Logger 的日志级别</span><br>        logger.setLevel(Level.INFO); <br>        <br>        <span class="hljs-comment">// 禁用日志向上传递</span><br>        logger.setUseParentHandlers(<span class="hljs-literal">false</span>); <br>        <br>        <span class="hljs-comment">// Logger 输出到的 Handler</span><br>        logger.addHandler(consoleHandler); <br><br>        <span class="hljs-comment">// 6. 调用我们配置好的包日志管道记录日志（记录时是使用 logger 进行记录，因为 logger 是日志的入口）</span><br>        logger.severe(<span class="hljs-string">&quot;severe 信息&quot;</span>);<br>        logger.warning(<span class="hljs-string">&quot;warning 信息&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;info 信息&quot;</span>);<br>        logger.config(<span class="hljs-string">&quot;config 信息&quot;</span>);<br>        logger.fine(<span class="hljs-string">&quot;fine 信息&quot;</span>);<br>        logger.finer(<span class="hljs-string">&quot;finer 信息&quot;</span>);<br>        logger.finest(<span class="hljs-string">&quot;finest 信息&quot;</span>);<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果我们为每个类都单独写一堆日志配置，使用起来就会显得非常繁琐。更好的做法是写一个 <code>LogUtil</code> 工具类，在里面一次性为 <code>com.example</code> 包配置好日志管道，这样后续各个类只需要直接获取 Logger 就能记录日志了。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogUtil</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;com.example&quot;</span>);<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">ConsoleHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleHandler</span>();<br>        handler.setFormatter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFormatter</span>());<br>        handler.setLevel(Level.ALL);<br>        logger.addHandler(handler);<br>        logger.setUseParentHandlers(<span class="hljs-literal">false</span>);<br>        logger.setLevel(Level.ALL);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-使用-JUL-记录日志"><a href="#4-2-使用-JUL-记录日志" class="headerlink" title="4.2. 使用 JUL 记录日志"></a>4.2. 使用 JUL 记录日志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-comment">// 获取 com.example.Main 层的 Logger</span><br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;com.example.Main&quot;</span>);<br><br>        logger.severe(<span class="hljs-string">&quot;severe 信息&quot;</span>);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>JUL</code> 的 <code>Logger</code> 是按名字单例的，都会保存在全局的 <code>LogManager</code> 中。<ol><li>如果你之前已经运行过配置好的 <code>com.example.Main</code> 层的 <code>Logger</code>，那么在其它地方获取同名的 <code>Logger</code>，拿到的就是这个已经配置过的实例。</li><li>但是如果你之前没有运行过，那么在获取时， <code>LogManager</code> 会为 <code>com.example.Main</code> 新建一个 <code>Logger</code>，并使用默认配置（继承父级 <code>Logger</code>），再在其它地方获取同名的 <code>Logger</code>，拿到的就是这个已经配置过的实例（即便再运行配置好的 <code>com.example.Main</code> 层的 <code>Logger</code>）</li></ol></li><li><code>JUL</code> 还提供一种方便的日志记录方式，允许我们动态传递参数，从而代替拼接字符串：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Ba Tian&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>logger.log(Level.INFO,<span class="hljs-string">&quot;学生的姓名为：&#123;0&#125;，年龄为：&#123;1&#125;&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;name,age&#125;);<br></code></pre></td></tr></table></figure><hr><h1 id="五、SLF4J"><a href="#五、SLF4J" class="headerlink" title="五、SLF4J"></a>五、SLF4J</h1><h2 id="1-SLF4J-概述"><a href="#1-SLF4J-概述" class="headerlink" title="1. SLF4J 概述"></a>1. SLF4J 概述</h2><p><code>SLF4J</code>（<code>Simple Logging Facade for Java</code>）是一种日志门面框架，为各种日志框架提供统一的抽象接口（<code>API</code>），让开发者在应用中只需依赖于这一套 <code>API</code>，而无需针对不同的日志实现学习各自的专有 <code>API</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>SLF4J</code> 只是个日志门面，自身不提供任何配置功能</li><li>如果需要配置日志，例如设置日志级别等，仍需按照具体日志实现（如 <code>Log4J2</code>、<code>JUL</code> 等）的配置方式，进行相关配置</li></ol></blockquote><hr><h2 id="2-SLF4J-支持的日志级别"><a href="#2-SLF4J-支持的日志级别" class="headerlink" title="2. SLF4J 支持的日志级别"></a>2. SLF4J 支持的日志级别</h2><p><code>SLF4J</code> 支持的日志级别顺序为：</p><ol><li><code>ERROR</code><ol><li>输出错误信息，表示严重错误或异常情况，应用可能无法继续进行</li></ol></li><li><code>WARN</code>（最推荐）<ol><li>输出警告信息，提示潜在的问题</li></ol></li><li><code>INFO</code><ol><li>输出常规运行信息，提供系统运行状态</li></ol></li><li><code>DEBUF</code><ol><li>输出调试信息，比如详细的配置解析过程</li></ol></li><li><code>TRACE</code><ol><li>输出最详细的信息，几乎是逐行解释发生了什么</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>SLF4J</code> 本身只是个日志门面，因此他没有默认的日志级别，其取决于我们使用的底层日志实现：<ol><li><code>JUL</code><ol><li>默认日志级别是 <code>INFO</code></li></ol></li><li><code>Log4J</code><ol><li>默认日志级别是 <code>ERROR</code></li></ol></li><li><code>Log4J2</code><ol><li>默认日志级别是 <code>ERROR</code></li></ol></li></ol></li></ol></blockquote><hr><h2 id="3-SLF4J-使用方式"><a href="#3-SLF4J-使用方式" class="headerlink" title="3. SLF4J 使用方式"></a>3. SLF4J 使用方式</h2><h3 id="3-1-添加相关依赖"><a href="#3-1-添加相关依赖" class="headerlink" title="3.1. 添加相关依赖"></a>3.1. 添加相关依赖</h3><ol><li>创建后<ol><li><code>slf4j-api</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.slf4j/slf4j-api">https://mvnrepository.com/artifact/org.slf4j/slf4j-api</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li><li><code>log4j-slf4j2-impl</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j2-impl">https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j2-impl</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0-beta2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里引入的 <code>log4j-slf4j2-impl</code> 依赖是一个适配器。</li><li>因为 <code>SLF4J</code> 诞生之前的日志框架，并未遵循 <code>SLF4J</code> 标准，因此无法在引入 <code>SLF4J</code> 依赖后，立即投入使用，需要额外引入适配器</li><li>而 <code>SLF4J</code> 之后的日志框架，如果已遵循 <code>SLF4J</code> 规范，则只需直接引入相关依赖即可正常使用。但如果日志框架未遵循 <code>SLF4J</code> 标准（例如 <code>Log4J2</code>），仍然需要引入适配器才能使用</li></ol></blockquote><hr><h3 id="3-2-使用-SLF4J-记录日志"><a href="#3-2-使用-SLF4J-记录日志" class="headerlink" title="3.2. 使用 SLF4J 记录日志"></a>3.2. 使用 SLF4J 记录日志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;com.example.Main&quot;</span>);<br>        logger.trace(<span class="hljs-string">&quot;trace 信息&quot;</span>);  <br>        logger.debug(<span class="hljs-string">&quot;debug 信息&quot;</span>);  <br>        logger.info(<span class="hljs-string">&quot;info 信息&quot;</span>);  <br>        logger.warn(<span class="hljs-string">&quot;warn 信息&quot;</span>);  <br>        logger.error(<span class="hljs-string">&quot;error 信息&quot;</span>);  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>SLF4J</code> 同样提供另外一种记录方式，允许我们动态传递参数，从而代替拼接字符串：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Ba Tian&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>logger.log(Level.INFO,<span class="hljs-string">&quot;学生的姓名为：&#123;&#125;，年龄为：&#123;&#125;&quot;</span>,name,age);<br></code></pre></td></tr></table></figure><hr><h1 id="六、SLF4J-Log4J2"><a href="#六、SLF4J-Log4J2" class="headerlink" title="六、SLF4J + Log4J2"></a>六、SLF4J + Log4J2</h1><h2 id="1-SLF4J-Log4J2-概述"><a href="#1-SLF4J-Log4J2-概述" class="headerlink" title="1. SLF4J + Log4J2 概述"></a>1. SLF4J + Log4J2 概述</h2><p>使用 <code>SLF4J</code> 作为日志门面框架，搭配 <code>Log4j2</code> 的日志实现框架，绝对是当前市场上最强大、最灵活的日志功能实现方式</p><hr><h2 id="2-Log4J2-相关组件"><a href="#2-Log4J2-相关组件" class="headerlink" title="2. Log4J2 相关组件"></a>2. Log4J2 相关组件</h2><p><code>Log4j2</code> 主要由日志记录器（<code>Loggers</code>）、输出控制器（<code>Appenders</code>）和日志格式化器（<code>Layout</code>）组成</p><ol><li><code>Loggers</code><ol><li><code>Loggers</code>（日志记录器），负责记录日志，并控制日志的输出级别</li><li>需要注意的是，与 <code>JUL</code> 不同，<code>Log4j2</code> 中的日志信息在 <code>Logger</code> 中确定输出级别后，不会再经过 <code>Handler</code> 的再次过滤，这意味着 <code>Logger</code> 配置的输出级别直接决定最终的日志输出级别</li></ol></li><li><code>Appenders</code><ol><li><code>Appenders</code>（输出控制器），负责把日志输出到指定位置</li><li><code>Appenders</code> 分别有：<ol><li><code>ConsoleAppender</code><ol><li>将日志输出到控制台</li></ol></li><li><code>FileAppender</code><ol><li>将日志写入到单一文件中</li></ol></li><li><code>RollingFileAppender</code><ol><li>将日志写入到文件中，支持按大小和时间滚动</li></ol></li><li><code>JDBCAppender</code><ol><li>将日志存储到关系型数据库中</li></ol></li></ol></li></ol></li><li><code>Layout</code><ol><li><code>Layout</code>（日志格式化器），决定了日志的格式化方式，即日志输出的具体格式</li><li>常用的 <code>Layout</code> 包括：<ol><li><code>HTMLLayout</code><ol><li>输出为 <code>HTML</code> 表格的格式</li></ol></li><li><code>JSONLayout</code><ol><li>输出为 <code>JSON</code> 格式</li></ol></li><li><code>XMLLayout</code><ol><li>输出为 <code>XML</code> 格式</li></ol></li><li><code>SimpleLayout</code><ol><li>简单的日志输出格式</li></ol></li><li><code>PatternLayout</code>（默认）<ol><li>最强大的格式化组件，可以根据自定义日志输出格式</li></ol></li></ol></li></ol></li></ol><hr><h2 id="3-Log4J2-支持的日志级别"><a href="#3-Log4J2-支持的日志级别" class="headerlink" title="3. Log4J2 支持的日志级别"></a>3. Log4J2 支持的日志级别</h2><p><code>Log4J2</code> 支持的级别顺序为：</p><ol><li><code>OFF</code><ol><li>禁止捕获所有级别的日志信息</li></ol></li><li><code>FATAL</code><ol><li>输出严重错误信息，应用可能无法继续运行</li></ol></li><li><code>ERROR</code><ol><li>输出错误信息，表示严重错误或异常情况，但应用仍然可以继续运行</li></ol></li><li><code>WARN</code><ol><li>输出警告信息，提示潜在的问题</li></ol></li><li><code>INFO</code><ol><li>输出常规运行信息，提供系统运行状态</li></ol></li><li><code>DEBUG</code><ol><li>输出调试信息，比如详细的配置解析过程</li></ol></li><li><code>TRACE</code><ol><li>输出最详细的信息，几乎是逐行解释发生了什么</li></ol></li><li><code>ALL</code><ol><li>捕获所有级别的日志信息</li></ol></li></ol><p>需要注意的是，无需担心 <code>SLF4J</code> 日志门面框架只有五个标准级别的限制，这是因为适配器在 <code>SLF4J</code> 和 <code>Log4j2</code> 之间建立了一套完整的映射关系：<br><img src="/2025/11/24/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6-2.png"></p><hr><h2 id="4-SLF4J-Log4J2-使用方式"><a href="#4-SLF4J-Log4J2-使用方式" class="headerlink" title="4. SLF4J + Log4J2 使用方式"></a>4. SLF4J + Log4J2 使用方式</h2><h3 id="4-1-添加相关依赖"><a href="#4-1-添加相关依赖" class="headerlink" title="4.1. 添加相关依赖"></a>4.1. 添加相关依赖</h3><ol><li>创建时<ol><li><code>Web</code><ol><li><code>Spring Web</code></li></ol></li></ol></li><li>创建后<ol><li><code>slf4j-api </code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.slf4j/slf4j-api">https://mvnrepository.com/artifact/org.slf4j/slf4j-api</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li><li><code>log4j-api</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api">https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li><li><code>log4j-core</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core">https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core</a></li></ol></li><li><code>Gradle</code></li></ol></li><li><code>disruptor</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/com.lmax/disruptor">https://mvnrepository.com/artifact/com.lmax/disruptor</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li><li><code>log4j-slf4j2-impl</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j2-impl">https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j2-impl</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.24.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.24.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.24.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>log4j-api</code> 是 <code>Log4j</code> 的日志门面，为什么在已有 <code>SLF4J</code> 门面的情况下仍需要引入？<ol><li>虽然 <code>SLF4J</code> 是一个通用日志门面，但在使用 <code>Log4j2</code> 作为日志实现时，<code>SLF4J</code> 实际上会访问调用 <code>log4j-api</code>，再由它对接 <code>Log4j2</code> 的具体实现</li></ol></li><li>为什么引入的是 <code>Log4j2</code> 依赖，看起来却像是在引入 <code>Log4j</code> 依赖？<ol><li>如果依赖的版本号是 <code>2.x.x</code>，说明引入的确实是 <code>Log4j2</code></li></ol></li></ol></blockquote><hr><h3 id="4-2-进行-Log4J2-相关配置"><a href="#4-2-进行-Log4J2-相关配置" class="headerlink" title="4.2. 进行 Log4J2 相关配置"></a>4.2. 进行 Log4J2 相关配置</h3><h4 id="4-2-1-Xml-配置"><a href="#4-2-1-Xml-配置" class="headerlink" title="4.2.1. Xml 配置"></a>4.2.1. Xml 配置</h4><h5 id="4-2-1-1-resources-log4j2-xml"><a href="#4-2-1-1-resources-log4j2-xml" class="headerlink" title="4.2.1.1. resources&#x2F;log4j2.xml"></a>4.2.1.1. resources&#x2F;log4j2.xml</h5><h6 id="4-2-1-1-1-配置概述"><a href="#4-2-1-1-1-配置概述" class="headerlink" title="4.2.1.1.1. 配置概述"></a>4.2.1.1.1. 配置概述</h6><p>该配置用于配置 <code>Loggers</code>、<code>Appenders</code>、<code>Layout</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>文件名必须固定，并且 <code>Log4J2</code> 默认会按照一定顺序在类路径下查找配置文件：<ol><li><code>log4j2.xml</code></li><li><code>log4j2.json</code>（<code>log4j2.jsn</code>）</li><li><code>log4j2.yaml</code>（<code>log4j2.yml</code>）</li><li><code>log4j2.properties</code></li></ol></li></ol></blockquote><hr><h6 id="4-2-1-1-2-Tiny-配置"><a href="#4-2-1-1-2-Tiny-配置" class="headerlink" title="4.2.1.1.2. Tiny 配置"></a>4.2.1.1.2. Tiny 配置</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 定义全局属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 自定义日志输出格式（Layout） --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATTERN&quot;</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 自定义日志文件的保存路径 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATH&quot;</span>&gt;</span>D:\\EnglishDeployment\\logs<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 自定义文件的保存路径 --&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置 Appenders（日志输出器） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置 Loggers（日志记录器） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h6 id="4-2-1-1-3-配置-Appenders"><a href="#4-2-1-1-3-配置-Appenders" class="headerlink" title="4.2.1.1.3. 配置 Appenders"></a>4.2.1.1.3. 配置 Appenders</h6><p><font color="#92d050">1. 配置 ConsoleAppender</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConsoleAppender&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>target</code><ol><li>输出的位置</li><li>可选参数包括：<ol><li><code>SYSTEM_OUT</code><ol><li>输出到标准输出流（<code>System.out</code>）</li></ol></li><li><code>SYSTEM_ERR</code><ol><li>输出到标准错误流（<code>System.err</code>）</li></ol></li></ol></li></ol></li></ol><p><font color="#92d050">2. 配置 FileAppender</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FileAppender&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_PATH&#125;/app.log&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 配置 RollingFileAppender</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileAppender&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_PATH&#125;/rolling.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATH&#125;/rolling-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 文件达到 10MB 时滚动一次 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;10MB&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 每天滚动一次 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 最多保留 7 个历史文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;7&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">4. JDBCAppender</font></p><hr><h6 id="4-2-1-1-4-配置-Loggers"><a href="#4-2-1-1-4-配置-Loggers" class="headerlink" title="4.2.1.1.4. 配置 Loggers"></a>4.2.1.1.4. 配置 Loggers</h6><p><font color="#92d050">1. 根 Logger 配置</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用 ConsoleAppender（这里 ref 引用的，是我们上面配置 Appenders 时的 name） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ConsoleAppender&quot;</span>/&gt;</span>  <br><br><span class="hljs-comment">&lt;!-- 使用 RollingFileAppender --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileAppender&quot;</span>/&gt;</span>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 包 Logger 配置</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.example.service&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用 FileAppender --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FileAppender&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>additivity</code><ol><li>日志是否向上传递</li></ol></li></ol><p><font color="#92d050">3. 混合异步日志配置</font><br>混合异步日志是指：在保持根日志管道为同步模式的前提下，为特定包的日志管道单独配置为异步模式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">AsyncLogger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.example.async&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">includeLocation</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ConsoleAppender&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AsyncLogger</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>includeLocation</code><ol><li>日志中是否包含行号信息</li><li>由于获取行号信息会影响日志记录性能，建议将其设置为 <code>false</code> 以提升效率</li></ol></li></ol><hr><h5 id="4-2-1-2-resources-log4j2-component-properties"><a href="#4-2-1-2-resources-log4j2-component-properties" class="headerlink" title="4.2.1.2. resources&#x2F;log4j2.component.properties"></a>4.2.1.2. resources&#x2F;log4j2.component.properties</h5><h6 id="4-2-1-2-1-配置概述"><a href="#4-2-1-2-1-配置概述" class="headerlink" title="4.2.1.2.1. 配置概述"></a>4.2.1.2.1. 配置概述</h6><p>全局异步日志是指：所有日志记录的操作统一设置为异步模式</p><p>而该配置用于配置异步模式</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>文件名必须固定</li></ol></blockquote><hr><h6 id="4-2-1-2-2-具体配置"><a href="#4-2-1-2-2-具体配置" class="headerlink" title="4.2.1.2.2. 具体配置"></a>4.2.1.2.2. 具体配置</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Log4jContextSelector</span>=<span class="hljs-string">org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-3-使用-Log4J2-记录日志"><a href="#4-3-使用-Log4J2-记录日志" class="headerlink" title="4.3. 使用 Log4J2 记录日志"></a>4.3. 使用 Log4J2 记录日志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;com.example.Main&quot;</span>);<br>        logger.trace(<span class="hljs-string">&quot;trace 信息&quot;</span>);  <br>        logger.debug(<span class="hljs-string">&quot;debug 信息&quot;</span>);  <br>        logger.info(<span class="hljs-string">&quot;info 信息&quot;</span>);  <br>        logger.warn(<span class="hljs-string">&quot;warn 信息&quot;</span>);  <br>        logger.error(<span class="hljs-string">&quot;error 信息&quot;</span>);  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="七、Spring-Boot-Starter-Log4J2"><a href="#七、Spring-Boot-Starter-Log4J2" class="headerlink" title="七、Spring Boot Starter Log4J2"></a>七、Spring Boot Starter Log4J2</h1><h2 id="1-快速上手"><a href="#1-快速上手" class="headerlink" title="1. 快速上手"></a>1. 快速上手</h2><h3 id="1-1-添加相关依赖"><a href="#1-1-添加相关依赖" class="headerlink" title="1.1. 添加相关依赖"></a>1.1. 添加相关依赖</h3><ol><li>创建时<ol><li><code>Web</code><ol><li><code>Spring Web</code></li></ol></li></ol></li><li>创建后<ol><li><code>spring-boot-starter-log4j2</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-log4j2">https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-log4j2</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li><li><code>lombok</code><ol><li><code>Maven</code><ol><li><a href="https://mvnrepository.com/artifact/org.projectlombok/lombok">https://mvnrepository.com/artifact/org.projectlombok/lombok</a></li></ol></li><li><code>Gradle</code><ol><li></li></ol></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在添加 <code>spring-boot-starter-web</code> 依赖时，需要排除 <code>spring-boot-starter-logging</code>。因为 <code>Spring Web</code> 默认使用 <code>SLF4J + Logback</code></li><li><code>lombok</code> 提供了 <code>@Slf4j</code>，我们一般要添加该依赖</li></ol></blockquote><hr><h3 id="1-2-进行-Log4J2-相关配置"><a href="#1-2-进行-Log4J2-相关配置" class="headerlink" title="1.2. 进行 Log4J2 相关配置"></a>1.2. 进行 Log4J2 相关配置</h3><hr><h3 id="1-3-使用-SLF4J-记录日志"><a href="#1-3-使用-SLF4J-记录日志" class="headerlink" title="1.3. 使用 SLF4J 记录日志"></a>1.3. 使用 SLF4J 记录日志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;com.example.Main&quot;</span>);<br>        logger.trace(<span class="hljs-string">&quot;trace 信息&quot;</span>);  <br>        logger.debug(<span class="hljs-string">&quot;debug 信息&quot;</span>);  <br>        logger.info(<span class="hljs-string">&quot;info 信息&quot;</span>);  <br>        logger.warn(<span class="hljs-string">&quot;warn 信息&quot;</span>);  <br>        logger.error(<span class="hljs-string">&quot;error 信息&quot;</span>);  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>以上述代码为例，<code>@Slf4j</code> 会在编译阶段自动添加 <code>private static final Logger log = LoggerFactory.getLogger(MyService.class)</code></li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 日志框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Hexo + Obsidian + GitHub Pages</title>
    <link href="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/"/>
    <url>/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><hr><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><ol><li><code>Git</code></li><li><code>Node.js</code></li><li><code>PowerShell</code></li></ol><hr><h2 id="4-创建-Hexo-项目"><a href="#4-创建-Hexo-项目" class="headerlink" title="4. 创建 Hexo 项目"></a>4. 创建 Hexo 项目</h2><h3 id="4-1-初始化-Hexo-项目"><a href="#4-1-初始化-Hexo-项目" class="headerlink" title="4.1. 初始化 Hexo 项目"></a>4.1. 初始化 Hexo 项目</h3><p><font color="#92d050">1. 创建文件夹</font><br>这里我命名为 <code>myNote</code>（名称可自定义）<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages.png"></p><p><font color="#92d050">2. 使用 PowerShell 打开文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-1.png"></p><p><font color="#92d050">3. 全局安装 hexo</font></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">4. 初始化 Hexo 项目</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">5. 安装相关依赖</font></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-2-配置-Hexo-元数据"><a href="#4-2-配置-Hexo-元数据" class="headerlink" title="4.2. 配置 Hexo 元数据"></a>4.2. 配置 Hexo 元数据</h3><p><font color="#92d050">1. 使用 VS Code 打开 myNote 文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-2.png"></p><p><font color="#92d050">2. 配置 Hexo 元数据</font><br>在系统 <code>myNote/_config.yml</code> 文件中配置元数据：<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-3.png"></p><hr><h3 id="4-3-启动-Hexo，查看效果"><a href="#4-3-启动-Hexo，查看效果" class="headerlink" title="4.3. 启动 Hexo，查看效果"></a>4.3. 启动 Hexo，查看效果</h3><p><font color="#92d050">1. 使用 PowerShell 打开文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-4.png"></p><p><font color="#92d050">2. 依次执行命令</font></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. 清除现存的 Hexo 的静态文件</span><br><span class="hljs-attribute">hexo</span> clean<br><br><br><span class="hljs-comment"># 2. 生成新的 Hexo 静态文件</span><br>hexo g<br><br><br><span class="hljs-comment"># 3. 启动本地服务器，预览生成的网页效果，便于本地调试</span><br>hexo s<br></code></pre></td></tr></table></figure><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-5.png"></p><p><font color="#92d050">3. 查看 Hexo 效果</font><br>查看： <a href="http://localhost:4000/">http://localhost:4000/</a></p><hr><h3 id="4-4-配置-Hexo-主题"><a href="#4-4-配置-Hexo-主题" class="headerlink" title="4.4. 配置 Hexo 主题"></a>4.4. 配置 Hexo 主题</h3><p>上面展示的 Hexo 默认样式较为简陋，视觉效果不佳。你可以在 <a href="https://hexo.io/themes/">Hexo主题库</a> 中挑选一个自己喜欢的主题，这里我选择 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> 作为我的主题。</p><p><font color="#92d050">1. 下载 fluid 安装包</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-6.png"></p><p><font color="#92d050">2. 解压缩到 myNote&#x2F;theme 目录下，并将其重命名为 fluid</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-7.png"></p><p><font color="#92d050">3. 配置使用 fluid 主题</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-8.png"></p><p><font color="#92d050">4. 使用 PowerShell 打开文件夹</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-9.png"></p><p><font color="#92d050">5. 添加 about 页面</font></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> page about<br></code></pre></td></tr></table></figure><p><font color="#92d050">6. 设置 about&#x2F;index.md 的头部属性</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-10.png"></p><p><font color="#92d050">7. 进行 Hexo 主题配置</font><br>根据需要在主题的 <code>myNote/themes/fluid/config.yml</code> 文件中进行相应的配置，具体怎么配，看你自己喜欢就行。</p><p><font color="#92d050">8. 启动 Hexo，查看效果</font></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. 清除现存的 Hexo 的静态文件</span><br><span class="hljs-attribute">hexo</span> clean<br><br><br><span class="hljs-comment"># 2. 生成新的 Hexo 静态文件</span><br>hexo g<br><br><br><span class="hljs-comment"># 3. 启动本地服务器，预览生成的网页效果，便于本地调试</span><br>hexo s<br></code></pre></td></tr></table></figure><hr><h2 id="5-集成-GitHub-Pages"><a href="#5-集成-GitHub-Pages" class="headerlink" title="5. 集成 GitHub Pages"></a>5. 集成 GitHub Pages</h2><h3 id="5-1-进行-Git-代理配置"><a href="#5-1-进行-Git-代理配置" class="headerlink" title="5.1. 进行 Git 代理配置"></a>5.1. 进行 Git 代理配置</h3><p>由于需要将静态页面部署到 <code>GitHub Pages</code>，并将整个 <code>Obsidian</code> 仓库推送到 <code>MyNote</code> 仓库，我们先设置 <code>Git</code> 代理，以提升网络传输速度</p><p><font color="#92d050">1. 检查是否配置过 Git 代理</font></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global http.proxy</span><br><br><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global https.proxy</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 如果存在代理，进行代理取消</font></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> http<span class="hljs-selector-class">.proxy</span><br><br><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> https.proxy<br></code></pre></td></tr></table></figure><p><font color="#92d050">3. 重新配置 Git 代理</font></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global https.proxy 127.0.0.1:7890</span><br><br><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global http.proxy 127.0.0.1:7890</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>此处的端口号需根据你本地 <code>Clash</code> 的配置进行调整，填写你实际使用的代理端口。</li></ol></blockquote><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-11.png"></p><hr><h3 id="5-2-创建-GitHub-Pages"><a href="#5-2-创建-GitHub-Pages" class="headerlink" title="5.2. 创建 GitHub Pages"></a>5.2. 创建 GitHub Pages</h3><p>首先，登录 <code>GitHub</code> 并创建一个名为 <code>&lt;your_id&gt;.github.io</code> 的仓库，并确保将其设置为 <code>Public</code>（公开）<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-12.png"></p><hr><h3 id="5-3-Hexo-项目关联到-GitHub-Pages"><a href="#5-3-Hexo-项目关联到-GitHub-Pages" class="headerlink" title="5.3. Hexo 项目关联到 GitHub Pages"></a>5.3. Hexo 项目关联到 GitHub Pages</h3><p><font color="#92d050">1. 安装 deploy 插件</font></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p><font color="#92d050">2. 进行 myNote&#x2F;config.yml 配置</font></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/wangjia5289/wangjia5289.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><hr><h3 id="5-4-Hexo-项目推送到-GitHub-Pages"><a href="#5-4-Hexo-项目推送到-GitHub-Pages" class="headerlink" title="5.4. Hexo 项目推送到 GitHub Pages"></a>5.4. Hexo 项目推送到 GitHub Pages</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 1. 清除现存的Hexo的静态文件</span><br><span class="hljs-attribute">hexo</span> clean<br><br><br><span class="hljs-comment"># 2. 生成新的 Hexo 静态文件</span><br>hexo g<br><br><br><span class="hljs-comment"># 3. 启动本地服务器，预览生成的网页效果，便于本地调试</span><br>hexo s<br><br><br><span class="hljs-comment"># 4. 将 Hexo 项目推送到 GitHub Pages</span><br>hexo d<br></code></pre></td></tr></table></figure><hr><h3 id="5-5-查看-GitHub-Pages-效果"><a href="#5-5-查看-GitHub-Pages-效果" class="headerlink" title="5.5. 查看 GitHub Pages 效果"></a>5.5. 查看 GitHub Pages 效果</h3><p>查看： <a href="https://github.com/wangjia5289/wangjia5289.github.io.git">https://github.com/wangjia5289/wangjia5289.github.io.git</a></p><hr><h2 id="6-集成-GitHub-Repository"><a href="#6-集成-GitHub-Repository" class="headerlink" title="6. 集成 GitHub Repository"></a>6. 集成 GitHub Repository</h2><p><font color="#92d050">1. 创建 GitHub Repository</font><br>我们额外创建一个名为 <code>myNote</code>（名称可自定义）的仓库，并确保将其设置为 <code>Private</code>（私有）用于备份所有文件，以防数据丢失<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-13.png"></p><p><font color="#92d050">2. 依次运行命令</font></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 1. 初始化本地 Git 仓库</span><br>git <span class="hljs-keyword">init</span><br><br><br><span class="hljs-meta"># 2. 创建 README 文档</span><br>echo <span class="hljs-string">&quot;随便写点东西好了&quot;</span> &gt; README.md<br><br><br><span class="hljs-meta"># 3. 将 README 稳定添加到缓冲取</span><br>git <span class="hljs-keyword">add</span> README.md<br><br><br><span class="hljs-meta"># 4. 进行第一次推送（务必进行，相当于点火器）</span><br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><br><br><span class="hljs-meta"># 5. 将当前分支强制重命名为 main</span><br>git branch -M main<br><br><br><span class="hljs-meta"># 6. 本地仓库与远程仓库进行关联。</span><br>git remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/wangjia5289/xxxxxx.git</span><br><br><br><span class="hljs-meta"># 7. 进行分支关联（使用 -u 选项，将本地 main 分支与远程 main 分支关联，之后可以直接使用 git push 和 git pull，而无需每次指定远程仓库和分支。）</span><br>git push -u origin main<br><br><br><span class="hljs-meta"># 8. 后续推送</span><br>我们可以通过命令行或使用 GitHub Desktop 等工具来推送代码。<br></code></pre></td></tr></table></figure><hr><h2 id="7-集成-Obsidian"><a href="#7-集成-Obsidian" class="headerlink" title="7. 集成 Obsidian"></a>7. 集成 Obsidian</h2><h3 id="7-1-创建模版"><a href="#7-1-创建模版" class="headerlink" title="7.1. 创建模版"></a>7.1. 创建模版</h3><p>在 <code>Hexo</code> 中，为确保每篇文章都能以预设格式和样式展示，通常需要在文章头部设置特定的属性。然而，手动设置这些属性对于每一次撰写新文章来说可能显得繁琐。为简化这一过程，可以创建一个模板。这样，每次撰写新文章时，只需导入该模板，即可自动包含所需的默认属性设置。</p><p><font color="#92d050">1. 创建模版</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-14.png"></p><p><font color="#92d050">2. 设置模版</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-15.png"></p><blockquote><p>[!NOTE] 注意事项：Hexo 页面加锁</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 1. 安装 hexo-blog-encrypt</span><br>npm <span class="hljs-keyword">install </span>--save hexo-<span class="hljs-keyword">blog-encrypt</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment">## 2. 在文章头部添加 password</span><br><span class="hljs-symbol">password:</span> xxxxxx<br></code></pre></td></tr></table></figure><hr><h3 id="7-2-忽略没用文件"><a href="#7-2-忽略没用文件" class="headerlink" title="7.2. 忽略没用文件"></a>7.2. 忽略没用文件</h3><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-27.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果安装了 <code>Omnisearch</code> 插件，需要开启这个选项：</li></ol></blockquote><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-28.png"></p><hr><h3 id="7-3-Custom-Attachment-Location-插件"><a href="#7-3-Custom-Attachment-Location-插件" class="headerlink" title="7.3. Custom Attachment Location 插件"></a>7.3. Custom Attachment Location 插件</h3><p><font color="#92d050">1. 修改 Obsidian 配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-16.png"></p><p><font color="#92d050">2. 安装 Custom Attachment Location 插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-17.png"></p><p><font color="#92d050">3. 进行插件配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-18.png"></p><p><font color="#92d050">4. 进行 myNote&#x2F;config.yml 配置</font></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 1. 将 post_asset_foler 设置为 true</span><br><span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br><br><br><span class="hljs-comment"># 2. 添加下述内容</span><br><span class="hljs-params">marked:</span> <br>  <span class="hljs-params">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h3 id="7-4-File-Explorer-插件"><a href="#7-4-File-Explorer-插件" class="headerlink" title="7.4. File Explorer++ 插件"></a>7.4. File Explorer++ 插件</h3><p><font color="#92d050">1. 安装 File Explorer++ 插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-19.png"></p><p><font color="#92d050">2. 进行插件配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-20.png"></p><hr><h3 id="7-5-Git-插件"><a href="#7-5-Git-插件" class="headerlink" title="7.5. Git 插件"></a>7.5. Git 插件</h3><p><font color="#92d050">1. 安装 Git 插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-21.png"></p><p><font color="#92d050">2. 配置插件</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-22.png"></p><p><font color="#92d050">3. 手动实现推送到 Repository</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-23.png"></p><hr><h2 id="8-Page-与域名绑定（可选）"><a href="#8-Page-与域名绑定（可选）" class="headerlink" title="8. Page 与域名绑定（可选）"></a>8. Page 与域名绑定（可选）</h2><p><font color="#92d050">1. 登录 GitHub，在您的 id.github.io 项目中，通过 Settings选项进行域名配置</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-24.png"></p><p><font color="#92d050">2. 在 public 文件夹下创建一个名为 CNAME 的文件，并在其中保存您希望绑定的域名</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-25.png"></p><p><font color="#92d050">3. 为域名添加 CNAME 记录并指向 id.github.io</font><br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages/%E7%AC%94%E8%AE%B0%EF%BC%9AHexo+Obsidian+GitHubPages-26.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：JUC</title>
    <link href="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/"/>
    <url>/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/">http://blog.wangjia.ink/2025/11/23/笔记：JUC/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/JUC-2b2974fbda5e8012975ef0197d6e8237">https://www.notion.so/JUC-2b2974fbda5e8012975ef0197d6e8237</a></p></li></ol><hr><h1 id="三、JUC-前置基础"><a href="#三、JUC-前置基础" class="headerlink" title="三、JUC 前置基础"></a>三、JUC 前置基础</h1><h2 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h2><h3 id="1-1-操作系统层-🌈"><a href="#1-1-操作系统层-🌈" class="headerlink" title="1.1. 操作系统层 🌈"></a>1.1. 操作系统层 🌈</h3><p>操作系统层的线程状态是指：操作系统内核调度本地线程的实际反映<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.png"></p><hr><h3 id="1-2-Java-应用层"><a href="#1-2-Java-应用层" class="headerlink" title="1.2. Java 应用层"></a>1.2. Java 应用层</h3><p><code>Java</code> 应用层的线程状态是指： <code>JVM</code> 对线程生命周期的抽象和管理，主要反映线程在 <code>Java</code> 内存模型中的行为<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-1.png"></p><ol><li><code>NEW</code><ol><li>在 <code>Java</code> 应用层，<code>Thread</code> 实例已创建，但尚未调用 <code>Thread#start</code>，处于未启动状态</li><li>需要注意的是，我们只是创建了线程实例，但是该实例尚未与操作系统层面的线程建立关联</li></ol></li><li><code>RUNNABLE</code><ol><li>可运行状态<ol><li>当我们调用 <code>Thread#start</code> 后，<code>JVM</code> 会在操作系统层面请求创建一个本地线程</li><li>一旦操作系统创建了这个本地线程，并将其与 <code>Thread</code> 实例 “绑定”，<code>Thread</code> 实例就会进入可运行状态</li><li>可运行状态表示 <code>Thread</code> 实例已经准备好运行了，然而，能否真正运行还要取决于操作系统的调度</li><li>本地线启动时JVM 会为该本地线程分配虚拟机栈和程序计数器（？？），</li></ol></li><li>运行状态<ol><li>本地线程被分配到 <code>CPU</code> 时间片后，开始执行 <code>Java</code> 代码</li></ol></li><li>阻塞状态<ol><li>阻塞状态其实就是本地线程进入 <code>IO</code> 阻塞</li><li>需要注意的是：<ol><li>在 <code>Java</code> 应用层的 <code>IO</code> 阻塞、<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>，在操作系统层都属于阻塞状态，<code>CPU</code> 不再调用这个线程</li><li><code>IO</code> 阻塞严格来说是操作系统层的阻塞，但是我们没必要划分的那么清晰，知道它是什么东西即可</li></ol></li></ol></li></ol></li><li><code>TERMINATED</code><ol><li>当线程执行完任务后，线程实例就会进入<code>TERMINATED</code> 状态</li><li>在 <code>Java</code> 层面上，线程是一个线程对象，当这个线程对象不再被引用时，会在下一次 GC 时被垃圾回收。</li></ol></li></ol><hr><h2 id="2-线程相关分类"><a href="#2-线程相关分类" class="headerlink" title="2. 线程相关分类"></a>2. 线程相关分类</h2><p>在 <code>Java</code> 应用层，线程分为：</p><ol><li>用户线程</li><li>守护线程</li></ol><p>我们平时创建的 <code>Thread</code> 实例默认都是用户线程，<code>main</code> 方法的主线程也是一个用户线程。很多人误以为：只要主线程结束后，<code>JVM</code> 进程就会结束。事实上，这种理解是错误的，只要仍有用户线程在运行，<code>JVM</code> 进程就会继续存活。</p><p>但是守护线程的行为则非如此，当所有用户线程都执行完毕后，<code>JVM</code> 进程将自动退出，而不管是否还有守护线程在运行。此时守护线程会被强制终止，其 <code>finally</code> 块中的代码也不保证一定执行。因此守护线程常用于后台服务，例如垃圾回收、心跳监控、日志清理等任务</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>从 <code>GC</code> 的角度来看，线程可以分为两类:<ol><li>用户线程<ol><li>即应用程序自身创建和管理的线程</li><li>常见的主线程、工作线程、守护线程都属于用户线程</li></ol></li><li><code>VM</code> 线程<ol><li>由 <code>JVM</code> 内部维护，用于支撑虚拟机运行的必要线程，例如 <code>GC</code> 线程、<code>JIT</code> 编译线程、信号分发线程等</li><li><code>VM</code> 线程不同于守护线程，守护线程是 <code>Java</code> 程序可见、可控的，而 <code>VM</code> 线程则完全对 <code>Java</code> 代码不可见</li></ol></li></ol></li></ol></blockquote><hr><h2 id="3-线程阻塞相关分类"><a href="#3-线程阻塞相关分类" class="headerlink" title="3. 线程阻塞相关分类"></a>3. 线程阻塞相关分类</h2><ol><li><code>IO</code> 阻塞<ol><li><code>Java</code> 程序在与操作系统交互时，由操作系统层代我们执行的阻塞，让我们的本地线程进入阻塞状态</li><li>虽然 <code>IO</code> 阻塞在操作系统层面也属于阻塞状态，但对 <code>Java</code> 应用层来说，它并不能直接感知本地线程是否正处于 <code>IO</code> 阻塞，因此 <code>Thread</code> 实例的状态仍为 <code>RUNNABLE</code>。简单来说就是：因为感知不到，所以认为还在运行</li></ol></li><li><code>BLOCKED</code> 阻塞、<code>WAITING</code> 阻塞、<code>TIMED_WAITING</code> 阻塞<ol><li><code>Java</code> 应用层还提供了多种 <code>API</code> 让本地线程主动进入阻塞状态，<code>Thread</code> 实例进入 <code>BWTW</code> 状态</li><li>因为调用了 <code>Java</code> 应用层提供的 <code>API</code>，所以 <code>Java</code> 应用层能知道线程进入了阻塞状态，并且还知道线程进入阻塞状态的 “原因”，所以 <code>Thread</code> 实例能进入对应的 <code>BLOCKED</code>、<code>WAITING</code> 或 <code>TIMED_WAITING</code> 状态</li><li><code>Java</code> 应用层提供的相关 <code>API</code> 主要包括：<ol><li><code>Thread.sleep</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，等待被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li><li>基于 <code>Monitor</code> 的阻塞<ol><li>竞争 <code>Monitor</code> 锁失败<ol><li><code>synchronized</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>BLOCKED</code> 状态，并被投递到 <code>Monitor</code> 的 <code>EntryList</code> 队列（竞争队列），等待被唤醒（<code>Monitor</code> 锁被释放时，由 <code>JVM</code> 唤醒）</li></ol></li></ol></li><li><code>Object#wait</code><ol><li><code>Object#wait()</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，并被投递到 <code>Monitor</code> 的 <code>WaitSet</code> 队列（等待队列），等待被唤醒（<code>Object#notify</code>）、被中断</li></ol></li><li><code>Object#wait(long timeoutMillis)</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，并被投递到 <code>Monitor</code> 的 <code>WaitSet</code> 队列（等待队列），等待被唤醒（<code>Object#notify</code>）、被中断、阻塞超时</li></ol></li></ol></li><li><code>Thread#join</code><ol><li><code>Thread#join()</code><ol><li>没什么好说的，因为其本质是基于 <code>Object#wait</code> 实现的阻塞</li></ol></li><li><code>Thread#join(final long millis)</code></li><li><code>Thread#join(long millis, int nanos)</code></li></ol></li><li>需要注意的是：<ol><li><code>Object#wait</code> 和 <code>Thread#join</code> 都会使 <code>Thread</code> 实例进入 <code>Monitor</code> 的等待队列。那么为什么要进入等待队列，而不是进入竞争队列呢？</li><li>进入等待队列是因为 <code>Thread</code> 实例在竞争到 <code>Monitor</code> 锁后，发现某个条件尚未满足，为了不影响其他线程继续获取 <code>Monitor</code> 锁，所以会主动释放锁，并进入等待队列中等待条件被满足</li><li>所以 <code>Object#wait</code> 和 <code>Thread#join</code> 的前置条件是：竞争到 <code>Monitor</code> 锁。只有先竞争到 <code>Monitor</code> 锁，才知道某个条件尚未满足</li><li>我的意思是：<code>Object#wait</code>、<code>Thread#join</code> 和 <code>synchronized</code> 是绑定的，它们必须出现在 <code>synchronized</code> 代码块中，否则会抛出异常。而 <code>Thread.sleep</code>、基于 <code>Park</code> 的阻塞没有这种限制，可以在任何地方使用</li><li>需要注意的是：如果竞争到 <code>Monitor</code> 锁，但是使用了 <code>Thread.sleep</code>、基于 <code>Park</code> 的阻塞的情况下，<code>Monitor</code> 锁是不会被释放的</li></ol></li></ol></li><li>基于 <code>Park</code> 的阻塞<ol><li><code>LockSupport.park</code><ol><li><code>LockSupport.park()</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）</li></ol></li><li><code>LockSupport.parkNanos(long nanos)</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li><li><code>LockSupport.parkUntil(long deadline)</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li><li>需要注意的是，具体的过程比上述描述稍微复杂一点，详见源码：<code>LockSupport</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.LockSupport源码解析</a>，<code>Hexo</code> 链接： <a href="http://blog.wangjia.ink/2025/11/13/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/13/源码：java.util.concurrent.locks.LockSupport源码解析/</a> ）</li></ol></li></ol></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>IO</code> 阻塞、<code>Threa.sleep</code> 都依赖于操作系统层的队列</li><li>基于 <code>Monitor</code> 的阻塞依赖于 <code>Java</code> 应用层的 <code>Monitor</code> 中的 <code>EntryList</code>、<code>WaitSet</code> 队列</li><li>而基于 <code>Park</code> 的阻塞，原则上是不依赖于任何数据结构，不过在实际中，几乎所有基于 <code>Park</code> 阻塞的产品，都会维护一个数据结构（可能是队列，也可能是其他数据结构）。因为如果没有这个数据结构，就无法记录哪些线程被阻塞、以及应当唤醒哪些线程</li></ol></blockquote><hr><h2 id="4-线程之间的执行关系"><a href="#4-线程之间的执行关系" class="headerlink" title="4. 线程之间的执行关系"></a>4. 线程之间的执行关系</h2><p><font color="#92d050">1. 串行</font><br>串行是指任务按顺序一个接一个地执行，只有当前一个任务执行完成，后一个任务才会开始执行，严格遵循任务提交的先后顺序。即便系统拥有多个 <code>CPU</code> 核心，在串行模式下，任意时刻也只会有一个线程在运行。</p><p><font color="#92d050">2. 并发</font><br>并发是指多个线程看起来像是在同时运行，其是通过时间片轮转机制实现，通过快速切换线程，让每个线程都获得运行机会，因此并发特性在单核环境中体现得尤为明显。</p><p>而在多核 <code>CPU</code> 上，线程有可能被分配到不同的核心上并行执行，但当线程数量多于核心数量时，<code>CPU</code> 仍需通过时间片轮转进行调度，以确保所有线程都能获得执行机会。</p><p><font color="#92d050">3. 并行</font><br>并行是指多个线程在真正意义上同时运行，分别占用不同的 <code>CPU</code> 核心，在同一时刻执行各自的任务，体现出真正的同时处理能力。</p><hr><h2 id="5-线程的活跃性"><a href="#5-线程的活跃性" class="headerlink" title="5. 线程的活跃性"></a>5. 线程的活跃性</h2><h3 id="5-1-死锁"><a href="#5-1-死锁" class="headerlink" title="5.1. 死锁"></a>5.1. 死锁</h3><h4 id="5-1-1-死锁概述"><a href="#5-1-1-死锁概述" class="headerlink" title="5.1.1. 死锁概述"></a>5.1.1. 死锁概述</h4><p>死锁是指：两个或两个以上的线程在执行过程中，因互相持有对方所需的资源而造成的一种互相等待的现象。如果没有外力干涉，这些线程都将无法推进下去，永远处于阻塞状态</p><p>例如线程 $T_1$ 已经持有了锁 <code>A</code>，现在想去竞争锁 <code>B</code>。线程 $T_2$ 已经持有了锁 <code>B</code>，现在想去竞争锁 <code>A</code>，这便形成了死锁</p><p>需要注意的是：在 <code>JUC</code> 中，所谓的 “资源” 是指：锁</p><hr><h4 id="5-1-2-死锁的必要条件"><a href="#5-1-2-死锁的必要条件" class="headerlink" title="5.1.2. 死锁的必要条件"></a>5.1.2. 死锁的必要条件</h4><ol><li>互斥条件<ol><li>资源是独占的，同一时刻只能被一个线程持有</li></ol></li><li>不剥夺条件<ol><li>线程已持有的资源，在末使用完之前，不能被其他线程强行剥夺，只能由线程自己主动释放</li></ol></li><li>循环等待条件<ol><li>若干线程之间形成一种头尾相接的循环等待资源的关系（例如 <code>A</code> 等 <code>B</code>，<code>B</code> 等 <code>A</code>）</li></ol></li><li>请求与保持条件<ol><li>线程在等待新资源时，对已经持有的资源保持不放（吃着碗里的，看着锅里的）</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>解决死锁的核心思路，就是破坏上述四个条件的任意一个。由于 “互斥条件” 是锁的基本特性，通常我们无法破坏，因此主要针对后三个条件进行破坏</li></ol></blockquote><hr><h4 id="5-1-3-死锁的解决方案"><a href="#5-1-3-死锁的解决方案" class="headerlink" title="5.1.3. 死锁的解决方案"></a>5.1.3. 死锁的解决方案</h4><h5 id="5-1-3-1-破坏不剥夺条件"><a href="#5-1-3-1-破坏不剥夺条件" class="headerlink" title="5.1.3.1. 破坏不剥夺条件"></a>5.1.3.1. 破坏不剥夺条件</h5><p>破坏不剥夺条件是指：线程等待资源超过一段时间，就放弃等待，并释放已持有的资源</p><hr><h5 id="5-1-3-2-破坏循环等待条件（最常用）"><a href="#5-1-3-2-破坏循环等待条件（最常用）" class="headerlink" title="5.1.3.2. 破坏循环等待条件（最常用）"></a>5.1.3.2. 破坏循环等待条件（最常用）</h5><p>破坏循环等待条件是指：规定所有线程必须按照相同的顺序获取资源。例如规定所有线程必须先获取锁 <code>A</code>，再获取锁 <code>B</code>，再获取锁 <code>C</code></p><hr><h5 id="5-1-3-3-破坏请求与保持条件"><a href="#5-1-3-3-破坏请求与保持条件" class="headerlink" title="5.1.3.3. 破坏请求与保持条件"></a>5.1.3.3. 破坏请求与保持条件</h5><p>破坏请求与保持条件是指：采用 “预先申请” 的方式，让所有线程必须一次性申请它所需要的所有资源。如果能申请到所有资源，线程继续向下执行。如果不能申请到所有资源，则释放已持有的资源</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>破坏请求与保持条件，通常和破坏不剥夺条件结合使用</li></ol></blockquote><hr><h3 id="5-2-活锁"><a href="#5-2-活锁" class="headerlink" title="5.2. 活锁"></a>5.2. 活锁</h3><h4 id="5-2-1-活锁概述"><a href="#5-2-1-活锁概述" class="headerlink" title="5.2.1. 活锁概述"></a>5.2.1. 活锁概述</h4><p>活锁是指：两个或两个以上的线程在执行过程种，因为不断互相改变对方的终止条件，导致所有线程都无法继续向下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">double</span> seconds)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep((<span class="hljs-type">long</span>) (seconds * <span class="hljs-number">1000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count--;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望加到 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count++;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>活锁本质上是 ”重试“ 导致的冲突</li></ol></blockquote><hr><h4 id="5-2-2-活锁的解决方案"><a href="#5-2-2-活锁的解决方案" class="headerlink" title="5.2.2. 活锁的解决方案"></a>5.2.2. 活锁的解决方案</h4><h5 id="5-2-2-1-加锁"><a href="#5-2-2-1-加锁" class="headerlink" title="5.2.2.1. 加锁"></a>5.2.2.1. 加锁</h5><p>活锁本质上并不是 “锁” 本身，但解决活锁时，却是可以使用 ”加锁“ 来解决</p><hr><h5 id="5-2-2-2-随机避让（最常用）"><a href="#5-2-2-2-随机避让（最常用）" class="headerlink" title="5.2.2.2. 随机避让（最常用）"></a>5.2.2.2. 随机避让（最常用）</h5><p>随即避让是指：当多个 ”请求“ 同时争抢资源失败时，不要立即重试，也不要使用固定的休眠时间。更合理的做法是采用 ”指数退避 + 随机抖动“ 的策略，降低竞争冲突</p><p>这里同样能使用随即避让能避免这个问题，不过场景不再是 “争抢资源”，而是 “重试” 导致的冲突。我们可以在重试时加入随机避让，减少重试之间的同步碰撞</p><hr><h5 id="5-2-2-3-限制重试次数"><a href="#5-2-2-3-限制重试次数" class="headerlink" title="5.2.2.3. 限制重试次数"></a>5.2.2.3. 限制重试次数</h5><hr><h3 id="5-3-饥饿"><a href="#5-3-饥饿" class="headerlink" title="5.3. 饥饿"></a>5.3. 饥饿</h3><h4 id="5-3-1-饥饿概述"><a href="#5-3-1-饥饿概述" class="headerlink" title="5.3.1. 饥饿概述"></a>5.3.1. 饥饿概述</h4><p>饥饿是指：某个线程虽然长期处于可运行状态，但是却一直无法获取所需要的资源（例如 <code>CPU</code> 时间片、锁、资源池资源等），导致线程无法继续执行</p><hr><h4 id="5-3-2-饥饿的解决方案"><a href="#5-3-2-饥饿的解决方案" class="headerlink" title="5.3.2. 饥饿的解决方案"></a>5.3.2. 饥饿的解决方案</h4><p>无论是线程饥饿、流量控制，还是 <code>IO</code> 阻塞，这些问题的本质都是相同的：因无法获取所需要的资源，导致无法继续执行。</p><p>针对这种 ”资源匮乏“ 的问题，通常有五种解决方案：</p><ol><li>强制排队</li><li>资源预留</li><li>及时止损<ol><li>异步处理</li><li>降级处理</li><li>启动告警</li></ol></li><li>随机避让</li><li>调整优先级</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>流量控制主要包括并发控制和速率限制</li></ol></blockquote><h5 id="5-3-2-1-强制排队"><a href="#5-3-2-1-强制排队" class="headerlink" title="5.3.2.1. 强制排队"></a>5.3.2.1. 强制排队</h5><p>强制排队是指：放弃 “自由竞争”，严格遵循 “先来后到” 原则，保证每个 ”请求“ 最终都能得到处理</p><p>以锁资源为例，我们可以使用公平锁，而不是非公平锁</p><hr><h5 id="5-3-2-2-资源预留"><a href="#5-3-2-2-资源预留" class="headerlink" title="5.3.2.2. 资源预留"></a>5.3.2.2. 资源预留</h5><p>资源预留是指：提前划分好资源配额，实行资源隔离，做到 ”专款专用“，防止某单一 ”请求“ 耗尽所有资源</p><p>以线程资源为例，我们可以为每个业务分配一个独立的线程池，而不是共用一个大的线程池</p><hr><h5 id="5-3-2-3-及时止损"><a href="#5-3-2-3-及时止损" class="headerlink" title="5.3.2.3. 及时止损"></a>5.3.2.3. 及时止损</h5><p>及时止损是指：当通过限时阻塞（超时未获取）或非阻塞（尝试一次未获取）确定拿不到资源的时候，不再继续等待，而是采取以下策略：</p><ol><li>异步处理<ol><li>异步编程或借助 <code>MQ</code> 实现 “削峰填谷”</li></ol></li><li>降级处理</li><li>启动告警</li><li>异步编程回调</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>可能是限时阻塞，也可能是非阻塞，还可能是直接使用异步编程回调（连非阻塞也不用，直接使用异步编程回调）</li></ol></blockquote><hr><h5 id="5-3-2-4-随机避让"><a href="#5-3-2-4-随机避让" class="headerlink" title="5.3.2.4. 随机避让"></a>5.3.2.4. 随机避让</h5><p>随即避让是指：当多个 ”请求“ 同时争抢资源失败时，不要立即重试，也不要使用固定的休眠时间。更合理的做法是采用 ”指数退避 + 随机抖动“ 的策略，降低竞争冲突</p><hr><h5 id="5-3-2-5-调整优先级"><a href="#5-3-2-5-调整优先级" class="headerlink" title="5.3.2.5. 调整优先级"></a>5.3.2.5. 调整优先级</h5><p>调整优先级是指：调整竞争权重，让核心的 ”请求“ 拥有更高的优先级</p><p>以 <code>CPU</code> 时间片资源为例，我们动态调整线程的优先级</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>虽然 <code>Java</code> 提供了 <code>Thread#setPriority</code>，但这通常不是一个靠谱的解决方案，更多时候我们要反其道而行之：尽量不要修改线程的优先级，让所有线程的优先级保持同等水平</li></ol></blockquote><hr><h2 id="8-线程相关常用方法"><a href="#8-线程相关常用方法" class="headerlink" title="8. 线程相关常用方法"></a>8. 线程相关常用方法</h2><p>线程相关的常用方法主要包括：</p><ol><li><code>Thread</code> 中的一些的方法</li><li><code>TimeUnit</code> 中的一些方法<ol><li><code>TimeUnit#sleep</code></li><li><code>TimeUnit#timedJoin</code></li><li><code>TimeUnit#timedWait</code></li></ol></li><li><code>Object</code> 中的一些方法<ol><li><code>Object#wait</code></li><li><code>Object#notify</code></li></ol></li><li><code>LockSupport</code> 中的一些方法</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Thread</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Thread源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/12/源码：java.lang.Thread源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Object</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Object源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/24/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/24/源码：java.lang.Object源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>LockSupport</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.LockSupport源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/13/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/13/源码：java.util.concurrent.locks.LockSupport源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h1 id="四、ThreadLocal"><a href="#四、ThreadLocal" class="headerlink" title="四、ThreadLocal"></a>四、ThreadLocal</h1><p><code>ThreadLocal</code> 是指：<code>Thread-&gt;threadLocals</code>，用于记录该 <code>Thread</code> 实例独属的一些信息。而 <code>Thread-&gt;threadLocals</code> 又是 <code>ThreadLocal.ThreadLocalMap</code> 类型，详见源码：<code>ThreadLocal&lt;T&gt;.ThreadLocalMap</code>（<code>obsidian</code> 内部连接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.ThreadLocal＜T＞.ThreadLocalMap源码解析</a>，<code>Hexo</code> 链接： <a href="http://blog.wangjia.ink/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/16/源码：java.lang.ThreadLocal＜T＞.ThreadLocalMap源码解析/</a> ）</p><hr><h1 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h1><h2 id="1-锁基础体系"><a href="#1-锁基础体系" class="headerlink" title="1. 锁基础体系"></a>1. 锁基础体系</h2><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-2.png"></p><ol><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Lock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Lock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/07/源码：java.util.concurrent.locks.Lock源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ReadWriteLock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReadWriteLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/07/源码：java.util.concurrent.locks.ReadWriteLock源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Condition</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Condition源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.Condition源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>AbstractOwnableSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/01/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedLongSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedLongSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/19/源码：java.util.concurrent.locks.AbstractQueuedLongSynchronizer源码解析/</a></li></ol></li></ol></li></ol><hr><h2 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2. synchronized"></a>2. synchronized</h2><h3 id="2-1-synchronized-前置基础"><a href="#2-1-synchronized-前置基础" class="headerlink" title="2.1. synchronized 前置基础"></a>2.1. synchronized 前置基础</h3><h4 id="2-1-1-Java-对象头"><a href="#2-1-1-Java-对象头" class="headerlink" title="2.1.1. Java 对象头"></a>2.1.1. Java 对象头</h4><p>通常我们的一个 <code>Java</code> 实例，他在堆内存中由三部分组成：</p><ol><li><code>Java</code> 对象头（<code>Object Header</code>）</li><li>实例数据（<code>Instance Data</code>）</li><li>对齐填充（<code>Padding</code>）</li></ol><p>以 <code>32</code> 位虚拟机为例：<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-3.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>这里的 <code>Klass Word</code> 应该叫做 <code>Klass Pointer</code></li></ol></blockquote><hr><h3 id="2-2-synchronized-概述"><a href="#2-2-synchronized-概述" class="headerlink" title="2.2. synchronized 概述"></a>2.2. synchronized 概述</h3><p><code>synchronized</code> 是一种可重入、悲观、非公平、互斥的锁</p><hr><h3 id="2-3-synchronized-使用方式"><a href="#2-3-synchronized-使用方式" class="headerlink" title="2.3. synchronized 使用方式"></a>2.3. synchronized 使用方式</h3><p>以如下代码为例，如果 <code>Room#increment</code> 竞争到了锁，那么 <code>Room#decrement</code>、<code>Room#getCounter</code> 都无法再竞争到锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        counter++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        counter--;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCounter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>当我们为静态具体方法加上 <code>synchronized</code> 修饰符，锁的是类对象（即 <code>Class</code> 对象）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>counter++;<br>&#125;<br><br><br><span class="hljs-comment">// 等价写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (Room.Class) &#123;<br>counter++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. 当我们为实例普通方法加上 <code>synchronized</code> 修饰符，锁的是仅是当前对象（即 <code>this</code>）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>counter++;<br>&#125;<br><br><br><span class="hljs-comment">// 等价写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>counter++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>3. 普通实例方法并不必然只能锁当前对象 (<code>this</code>)，静态方法也并非只能锁类对象（<code>Class</code> 对象）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>counter++;<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (Room.class) &#123;<br>counter++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>4. 以如下代码为例，虽然 <code>Room#sleep</code> 和 <code>Room#study</code> 本身没有逻辑上的交集，我们可以通过引入多把锁来进行优化：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-comment">// 引入多把锁进行优化</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>5. 即便一个方法中，只涉及到了共享变量的读操作，我们仍然要为其加锁。这主要是为了其可见性、原子性。可见性可以通过多种方式来保证，因此并不一定需要加锁。但原子性必须依赖锁来确保，避免 <code>B</code> 线程在进行读操作时，<code>A</code> 线程进行写操作，从根本上杜绝脏读、不可重复读、幻读等问题<br>6. 对于 <code>synchronized</code> 的本质，我们可以简单的理解为：通过为某对象或某类对象的加锁，从而控制多线程对共享资源的读写操作</p></blockquote><hr><h3 id="2-4-synchrnoized-锁升级"><a href="#2-4-synchrnoized-锁升级" class="headerlink" title="2.4. synchrnoized 锁升级"></a>2.4. synchrnoized 锁升级</h3><p>锁升级的流程为：<code>偏向锁 ➔ 轻量级锁 ➔ 重量级锁</code></p><h4 id="2-4-1-偏向锁"><a href="#2-4-1-偏向锁" class="headerlink" title="2.4.1. 偏向锁"></a>2.4.1. 偏向锁</h4><p>偏向锁的设计初衷，是在无竞争场景下进一步降低竞争锁的开销，从而提升锁操作的性能</p><p>当某线程（例如 $T_1$） 要去执行临界区代码，<code>JVM</code> 会通过 <code>CAS</code> 尝试将 $T_1$ 的 <code>Thread ID</code> 写入被加锁对象或被加锁类对象的对象头中的 <code>Mark Word</code> 中。</p><p>如果写入成功， $T_1$ 顺利执行临界区代码。如果 $T_1$ 后续再次执行临界区代码，只需检查 <code>Mark Word</code> 中的 <code>Thread ID</code> 是否与自身一致（由于偏向锁在释放时并不会主动重置对象头，因此在无竞争场景下，<code>Mark Word</code> 中依旧保留着 $T_1$ 的 <code>Thread ID</code>，所以能直接执行）</p><p>如果写入失败，则是其他线程（例如 $T_2$）正在持有偏向锁（无论 $T_2$ 是否在执行临界区代码），而这就发生了竞争，偏向锁模式就会宣告失败。此时 <code>JVM</code> 会将偏向锁升级为轻量级锁</p><p>我们可以简单的理解为：一旦某个线程持有了偏向锁，它就 “偏向” 这个线程，从头到尾都只认它，无论该线程是否在执行临界区代码。但是一旦出现第二个线程尝试竞争锁，偏向锁就会被撤销并升级为轻量级锁</p><p>然而，随着硬件性能提升和虚拟机其他优化手段的发展，偏向锁带来的性能收益已逐渐减弱，同时其实现的复杂性也成为阻碍 <code>JVM</code> 进一步优化的负担。除此之外，在高并发场景中，偏向锁撤销的开销往往大于其带来的收益。因此，<code>Oracle</code> 在 <code>Java15</code> 之后将偏向锁标记为废弃，并在 <code>Java17</code> 中将其彻底移除。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果使用的是 <code>Java8</code>，偏向锁默认是开启的，我们可以通过 <code>JVM</code> 启动参数来关闭偏向锁</li></ol></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:-UseBiasedLocking</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>2. 由于 <code>Mark Word</code> 的空间是有限的，存储了 <code>HashCode</code> 就没地方存 <code>Thread ID</code> 了。因此，如果在无锁状态计算了 <code>HashCode</code>，就无法再使用偏向锁，而是直接使用轻量级锁。如果在持有偏向锁时计算了 <code>HashCode</code>，偏向锁会被立即撤销，并直接升级为重量级锁（因为重量级锁的 <code>Monitor</code> 中可以存储 <code>HashCode</code>）</p></blockquote><hr><h4 id="2-4-2-轻量级锁"><a href="#2-4-2-轻量级锁" class="headerlink" title="2.4.2. 轻量级锁"></a>2.4.2. 轻量级锁</h4><p>轻量级锁的设计初衷，是在轻量竞争场景下进一步降低竞争锁的开销，从而提升锁操作的性能</p><p>当某线程（例如 $T_1$）要去执行临界区代码，<code>JVM</code> 会在 $T_1$ 的虚拟机栈的栈帧中创建一个锁记录（<code>Lock Record</code>）<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-4.png"></p><p>然后 <code>JVM</code> 将 <code>Lock Record</code> 的 <code>Object reference</code> 指向被加锁对象或被加锁类对象，并且通过 <code>CAS</code> 尝试将 <code>Lock Record</code> 的 <code>lock record</code> 地址 <code>00</code> 与被加锁对象或被加锁类对象的 <code>MarkWord</code>（即 <code>Hashcode Age Bias 01</code>）进行交换</p><p>如果交换成功， $T_1$ 顺利执行临界区代码。如果在 $T_1$ 执行临界区代码时发生了重入，同样会添加新的 <code>Lock Record</code>。$T_1$ 的虚拟机栈的栈帧中有多少个 <code>Lock Record</code>，说明发生了多少次重入<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-5.png"></p><p>当 $T_1$ 执行完临界区的代码，<code>JVM</code> 会将两者再交换回来<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-6.png"></p><p>如果交换失败，则是其他线程（例如 $T_2$）持有轻量级锁，那么 $T_1$ 会进行多次自旋。如果多次自旋仍热未成功，<code>JVM</code> 会将轻量级锁升级为重量级锁<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-7.png"></p><hr><h4 id="2-4-3-重量级锁"><a href="#2-4-3-重量级锁" class="headerlink" title="2.4.3. 重量级锁"></a>2.4.3. 重量级锁</h4><p>监视器（<code>Monitor</code>、管程）是 <code>JVM</code> 内部专门用于实现重量级锁的结构。当升级为重量级锁时，<code>JVM</code> 会为被加锁对象或被加锁类对象创建一个 <code>Monitor</code> 对象<br><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-8.png"></p><p>当 $T_1$ 执行完临界区代码后，会根据线程中保存的指向被加锁对象或被加锁类对象的地址，找到该对象或类对象，然后再根据该对象的对象头的 <code>Mark Word</code> 找到 <code>Monitor</code>，将其 <code>Owner</code> 设置为 <code>null</code>，并唤醒 <code>Monitor</code> 中 <code>EntryList</code> 中所有等待的线程，这些线程随后开始竞争重量级锁（ <code>Monitor</code> 的 <code>Owner</code>）</p><hr><h2 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h2><p>详见源码：<code>ReentrantLock</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.ReentrantLock源码解析/</a></li></ol></li></ol><hr><h2 id="4-ReentrantReadWriteLock"><a href="#4-ReentrantReadWriteLock" class="headerlink" title="4. ReentrantReadWriteLock"></a>4. ReentrantReadWriteLock</h2><p>详见源码：<code>ReentrantReadWriteLock</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantReadWriteLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/09/源码：java.util.concurrent.locks.ReentrantReadWriteLock源码解析/</a></li></ol></li></ol><hr><h2 id="5-CAS"><a href="#5-CAS" class="headerlink" title="5. CAS"></a>5. CAS</h2><h3 id="5-1-CAS-概述"><a href="#5-1-CAS-概述" class="headerlink" title="5.1. CAS 概述"></a>5.1. CAS 概述</h3><p><code>CAS</code> 是一种思想，其核心思想是：当前线程在进行写操作时，当 <code>V = E</code> 时，修改为 <code>N</code>。当 <code>V ≠ E</code> 时，不进行任何操作。其中 <code>V</code>、<code>E</code>、<code>N</code> 是指：</p><ol><li><code>V</code>（<code>Current Value</code>）<ol><li>当前线程在进行写操作时，共享变量在主内存中的实际值</li></ol></li><li><code>E</code>（<code>Expected Value</code>）<ol><li>当前线程在进行写操作时，期望共享变量在主内存中的实际值</li><li>简单来说就是：$t_1$ 时从主内存拿到的共享变量，我们期望 $t_2$ 时主内存中的共享变量仍然是这个值</li></ol></li><li><code>N</code>（<code>New Value</code>）<ol><li>当前线程在进行写操作时，要把共享变量修改为该值</li></ol></li></ol><p>为了实现 <code>CAS</code> 思想，不同的 <code>CPU</code> 厂商提供了不同的原子性的机器码指令（例如 <code>x86</code> 是 <code>CMPXCHG</code>，<code>ARM</code> 是 <code>LDXR/STXR</code> 组合），我们一般把这些机器码指令称之为 “<code>CAS</code> 指令”</p><p>在日常交流中，我们常把把 <code>CAS</code> 和 <code>CAS</code> 指令混为一谈。在 <code>Java</code> 中，说到 “使用 <code>CAS</code>”，其实就是通过 <code>Unsafe</code> 调用了 <code>CAS</code> 指令</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>CAS</code> 本质上并不是一种锁，而是一种更新机制</li><li>虽然 <code>V</code> 说是 ”当前线程在进行写操作时，共享变量在主内存中的实际值“，但是由于 <code>JMM</code> 的存在，我们可能仍从工作内存读 <code>V</code>，所以有可见性问题。除此之外，还有有序性问题。因此即便使用 <code>CAS</code>，通常结合 <code>volatile</code> 修饰符使用，<code>CAS</code> 保证原子性，<code>volatile</code> 保证可见性、顺序性</li><li>当我们使用 <code>CAS</code> 时，目标肯定是希望写操作成功。所以我们通常会循环执行 <code>CAS</code>，直到写操作成功</li></ol></blockquote><hr><h3 id="5-2-CAS-问题爆破"><a href="#5-2-CAS-问题爆破" class="headerlink" title="5.2. CAS 问题爆破"></a>5.2. CAS 问题爆破</h3><h4 id="5-2-1-ABA-问题"><a href="#5-2-1-ABA-问题" class="headerlink" title="5.2.1. ABA 问题"></a>5.2.1. ABA 问题</h4><h5 id="5-2-1-1-ABA-问题概述"><a href="#5-2-1-1-ABA-问题概述" class="headerlink" title="5.2.1.1. ABA 问题概述"></a>5.2.1.1. ABA 问题概述</h5><p><code>ABA</code> 问题是指：当 <code>V = E</code> 时，尽管 <code>CAS</code> 操作成功了，但实际上该位置的数据可能曾经发生过变化。例如我们桌子上有一杯水（<code>A</code>），你离开了一会儿。期间别人把你杯子里的水喝了（变成 <code>B</code>），然后又重新倒满水（变回 <code>A</code>）。等你回来时，看到水还是满的，你以为没人动过，但实际上里面的水已经变了</p><p>很多时候 <code>ABA</code> 问题可能无伤大雅。但是在一些业务逻辑时，这个问题可能是致命的</p><hr><h5 id="5-2-1-2-ABA-问题解决方案"><a href="#5-2-1-2-ABA-问题解决方案" class="headerlink" title="5.2.1.2. ABA 问题解决方案"></a>5.2.1.2. ABA 问题解决方案</h5><h6 id="5-2-1-2-1-版本号"><a href="#5-2-1-2-1-版本号" class="headerlink" title="5.2.1.2.1. 版本号"></a>5.2.1.2.1. 版本号</h6><p>版本号是指：不仅比较值（即 <code>V = E</code>），还要比较版本号。即 $CAS(E, N)➔CAS(E + Version_E, B + Version_B)$，当线程在进行写操作时，不仅要 <code>V = E</code>，还要 $Version_V&#x3D;Version_E$</p><p>而 <code>AtomicStampedReference</code> 就采用了这种方式解决了 <code>ABA</code> 问题。</p><p>除此之外，<code>AtomicMarkableReference</code> 可以看作是 <code>AtomicStampedReference</code> 的简化版，但是它并没有严格使用版本号。<code>AtomicMarkableReference</code> 是为了解决 “很多时候我们并不需要知道它被修改了多少次，而是只需要知道它是否被修改过” 的问题</p><hr><h3 id="5-3-Atomic-原子类"><a href="#5-3-Atomic-原子类" class="headerlink" title="5.3. Atomic* 原子类"></a>5.3. Atomic* 原子类</h3><h4 id="5-3-1-Atomic-原子类概述"><a href="#5-3-1-Atomic-原子类概述" class="headerlink" title="5.3.1. Atomic* 原子类概述"></a>5.3.1. Atomic* 原子类概述</h4><p><code>Atomic*</code> 原子类是使用 <code>CAS</code> 实现多线程并发安全的一些类</p><hr><h4 id="5-3-2-Atomic-原子类相关分类"><a href="#5-3-2-Atomic-原子类相关分类" class="headerlink" title="5.3.2. Atomic* 原子类相关分类"></a>5.3.2. Atomic* 原子类相关分类</h4><ol><li><code>AtomicBoolean</code></li><li><code>AtomicInteger</code></li><li><code>AtomicIntegerArray</code></li><li><code>AtomicIntegerFieldUpdater</code></li><li><code>AtomicIntegerFieldUpdaterImpl</code></li><li><code>AtomicLong</code></li><li><code>AtomicLongArray</code></li><li><code>AtomicLongFieldUpdater</code></li><li><code>AtomicReference</code></li><li><code>AtomicReferenceArray</code></li><li><code>AtomicReferenceFieldUpdater</code></li><li><code>AtomicReferenceFieldUpdaterImpl</code></li><li><code>AtomicMarkableReference</code></li><li><code>AtomicStampedReference</code></li><li><code>LongAdder</code></li><li><code>DoubleAdder</code></li></ol><hr><h1 id="六、并发工具"><a href="#六、并发工具" class="headerlink" title="六、并发工具"></a>六、并发工具</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h2><p>详见源码：<code>CountDownLatch</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CountDownLatch源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/16/源码：java.util.concurrent.CountDownLatch源码解析/</a></li></ol></li></ol><hr><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p>详见源码：<code>CyclicBarrier</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CyclicBarrier源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/19/源码：java.util.concurrent.CyclicBarrier源码解析/</a></li></ol></li></ol><hr><h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h2><p>详见源码：<code>Semaphore</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Semaphore源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/19/源码：java.util.concurrent.Semaphore源码解析/</a></li></ol></li></ol><hr><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1-线程池基础体系"><a href="#1-线程池基础体系" class="headerlink" title="1. 线程池基础体系"></a>1. 线程池基础体系</h2><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-9.png"></p><ol><li>详见源码：<code>Executor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Executor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.Executor源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/03/源码：java.util.concurrent.ExecutorService源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>AbstractExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.AbstractExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.AbstractExecutorService源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ScheduledExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.ScheduledExecutorService源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ThreadPoolExecutor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ThreadPoolExecutor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/03/源码：java.util.concurrent.ThreadPoolExecutor源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ScheduledThreadPoolExecutor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledThreadPoolExecutor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/04/源码：java.util.concurrent.ScheduledThreadPoolExecutor源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ForkJoinPool</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/14/源码：java.util.concurrent.ForkJoinPool源码解析/</a></li></ol></li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>线程池的三架马车：<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>ForkJoinPool</code></li></ol></blockquote><hr><h1 id="八、异步编程"><a href="#八、异步编程" class="headerlink" title="八、异步编程"></a>八、异步编程</h1><h2 id="1-异步编程基础体系"><a href="#1-异步编程基础体系" class="headerlink" title="1. 异步编程基础体系"></a>1. 异步编程基础体系</h2><p><img src="/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC-10.png"></p><ol><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Comparable&lt;T&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Comparable＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.lang.Comparable＜T＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Callable&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Callable＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.Callable＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.Runnable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Delayed</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Delayed源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.util.concurrent.Delayed源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Future＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurren.Future＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>RunnableFuture&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.RunnableFuture＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/04/源码：java.util.concurrent.ScheduledFuture＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ForkJoinTask&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ForkJoinTask＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>FutureTask&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.FutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.FutureTask＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>RunnableScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/05/05/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/05/05/源码：java.util.concurrent.RunnableScheduledFuture＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ScheduledFutureTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>RecursiveAction</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RecursiveAction源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.RecursiveAction源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>RecursiveTask&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RecursiveTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.RecursiveTask＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>CountedCompleter&lt;T&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.CountedCompleter＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.CountedCompleter＜T＞源码解析/</a></li></ol></li></ol></li></ol><hr><h2 id="2-异步编程的实现方式"><a href="#2-异步编程的实现方式" class="headerlink" title="2. 异步编程的实现方式"></a>2. 异步编程的实现方式</h2><h3 id="2-1-伪异步"><a href="#2-1-伪异步" class="headerlink" title="2.1. 伪异步"></a>2.1. 伪异步</h3><p>伪异步是指：当前线程将我们执行的 <code>Java</code> 代码中，一些耗时的操作交给其他线程（通常使用专门的线程池）去执行，当前线程可以直接继续向下执行</p><hr><h3 id="2-2-伪异步-异步编程等待"><a href="#2-2-伪异步-异步编程等待" class="headerlink" title="2.2. 伪异步 + 异步编程等待"></a>2.2. 伪异步 + 异步编程等待</h3><p> 伪异步 + 异步编程等待是指：虽然当前线程将我们执行的 <code>Java</code> 代码中，一些耗时的操作交给其他线程（通常使用专门的线程池）去执行，但当前线程仍然需要该任务的返回结果，所以当前线程必须在后续某个时刻获取该任务的返回结果</p><p>通常的做法是：提交任务后返回一个凭证（即 <code>Future</code>，常见具体实现类主要包括 <code>FutureTask</code>、<code>ScheduledFutureTask</code>、<code>ForkJoinTask</code>），然后根据这个凭证在需要结果时获取结果，然后再继续向下执行</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>异步编程等待既可能是阻塞的也可能是限时阻塞的</li></ol></blockquote><hr><h3 id="2-3-伪异步-异步编程回调"><a href="#2-3-伪异步-异步编程回调" class="headerlink" title="2.3. 伪异步 + 异步编程回调"></a>2.3. 伪异步 + 异步编程回调</h3><p>这部分内容涉及到了 <code>CompletableFuture</code>，详见笔记：<code>Java</code> 函数式编程（<code>obsidian</code> 内部链接：<a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">笔记：Java函数式编程</a>，<code>Hexo</code> 链接：）</p><hr><h3 id="伪异步-异步流式回调（响应式）"><a href="#伪异步-异步流式回调（响应式）" class="headerlink" title="伪异步 + 异步流式回调（响应式）"></a>伪异步 + 异步流式回调（响应式）</h3><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CyclicBarrier 源码解析</title>
    <link href="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CyclicBarrier%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/19/源码：java.util.concurrent.CyclicBarrier源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CyclicBarrier-概述"><a href="#3-1-CyclicBarrier-概述" class="headerlink" title="3.1. CyclicBarrier 概述"></a>3.1. CyclicBarrier 概述</h3><p><code>CyclicBarrier</code> 是一个具体类</p><p>循环栅栏（<code>CyclicBarrier</code>）可以简单的理解为 <code>CountDownLatch</code> 的一个变种。我们使用 <code>CountDownLatch</code> 实现汇总模式（主线程等待、子线程减数）、发令枪模式（子线程等待，主线程减数）时，会发现它们总是需要另一方来触发减数，像是缺少一个 “点火” 键</p><p>而 <code>CyclicBarrier</code> 是参与线程既减数，也等待。假设需要 <code>10</code> 个线程到达同步点，前 <code>9</code> 个线程在到达同步点后，都会减数然后等待，此时计数从 <code>10 ➔ 1</code>。当最后一个线程到达同步点时，也会减数然后等待，此时计数从 <code>1 ➔ 0</code>，所有线程同时继续向下执行。整个过程不需要额外的 “点火” 键，实现了 “线程互相等待”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>CountDownLatch</code> 是使用 <code>AQS</code> 实现的，而 <code>CyclicBarrier</code> 是使用 <code>ReentrantLock</code> 实现的</li><li><code>CountDownLatch</code> 是一次性的，而 <code>CyclicBarrier</code> 是可重复使用的</li><li>简单理解 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>：<ol><li><code>CountDownLatch</code> 是门闩开启才能继续执行</li><li><code>CyclicBarrier</code> 是 “互相等待” 都准备好才能继续执行</li><li><code>Semaphore</code> 是拿到 “许可证” 才能继续执行</li></ol></li></ol></blockquote><hr><h3 id="3-2-CyclicBarrier-应用场景"><a href="#3-2-CyclicBarrier-应用场景" class="headerlink" title="3.2. CyclicBarrier 应用场景"></a>3.2. CyclicBarrier 应用场景</h3><h4 id="3-2-1-并发压力测试"><a href="#3-2-1-并发压力测试" class="headerlink" title="3.2.1. 并发压力测试"></a>3.2.1. 并发压力测试</h4><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Semaphore 源码解析</title>
    <link href="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Semaphore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/19/源码：java.util.concurrent.Semaphore源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Semaphore-概述"><a href="#3-1-Semaphore-概述" class="headerlink" title="3.1. Semaphore 概述"></a>3.1. Semaphore 概述</h3><p><code>Semaphore</code> 是一个具体类</p><p>信号量（<code>Semaphore</code>）是使用 <code>AQS</code> 实现的共享模式的同步器。<code>State</code> 和共享资源分别表示以下含义：</p><ol><li><code>State</code> 表示剩余的 “许可证” 的数量</li><li>共享资源表示持有 “许可证” 期间被允许执行的操作</li></ol><p>我们可以将 <code>Semaphore</code> 简单的理解为：可重复的、既能做减法也能做加法的计数器，计的数就是 “许可证”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>简单理解 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>：<ol><li><code>CountDownLatch</code> 是门闩开启才能继续执行</li><li><code>CyclicBarrier</code> 是 “互相等待” 都准备好才能继续执行</li><li><code>Semaphore</code> 是拿到 “许可证” 才能继续执行</li></ol></li></ol></blockquote><hr><h3 id="3-2-Semaphore-应用场景"><a href="#3-2-Semaphore-应用场景" class="headerlink" title="3.2. Semaphore 应用场景"></a>3.2. Semaphore 应用场景</h3><h4 id="3-2-1-并发控制"><a href="#3-2-1-并发控制" class="headerlink" title="3.2.1. 并发控制"></a>3.2.1. 并发控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFlowControl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">mySemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mySemaphore.acquire(); <br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mySemaphore.release();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>流量控制主要包括并发控制和速率限制</li></ol></blockquote><hr><h4 id="3-2-2-资源池管理"><a href="#3-2-2-资源池管理" class="headerlink" title="3.2.2. 资源池管理"></a>3.2.2. 资源池管理</h4><p>常见的资源池包括连接池、线程池、对象池</p><p>以连接池为例，可以将连接池中的连接的数量与 <code>Semaphore</code> 的 ”许可证“ 的数量关联起来。在获取连接之前先获取 ”许可证“，在归还连接之后再归还 ”许可证“</p><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Sync"><a href="#4-1-Sync" class="headerlink" title="4.1. Sync"></a>4.1. Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br>Sync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br>setState(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPermits</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br><span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>compareAndSetState(available, remaining))<br><span class="hljs-keyword">return</span> remaining;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br><span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br><span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reducePermits</span><span class="hljs-params">(<span class="hljs-type">int</span> reductions)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current - reductions;<br><span class="hljs-keyword">if</span> (next &gt; current) <span class="hljs-comment">// underflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Permit count underflow&quot;</span>);<br><span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">drainPermits</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (current == <span class="hljs-number">0</span> || compareAndSetState(current, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> current;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-FairSync"><a href="#4-2-FairSync" class="headerlink" title="4.2. FairSync"></a>4.2. FairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>FairSync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br><span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>compareAndSetState(available, remaining))<br><span class="hljs-keyword">return</span> remaining;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-NonfairSync"><a href="#4-3-NonfairSync" class="headerlink" title="4.3. NonfairSync"></a>4.3. NonfairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>NonfairSync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-Semaphore-int-permits"><a href="#5-1-Semaphore-int-permits" class="headerlink" title="5.1. Semaphore(int permits)"></a>5.1. Semaphore(int permits)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br><br>sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-Semaphore-int-permits-boolean-fair"><a href="#5-2-Semaphore-int-permits-boolean-fair" class="headerlink" title="5.2. Semaphore(int permits, boolean fair)"></a>5.2. Semaphore(int permits, boolean fair)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br><br>sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedLongSynchronizer 源码解析</title>
    <link href="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/19/源码：java.util.concurrent.locks.AbstractQueuedLongSynchronizer源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedLongSynchronizer-概述"><a href="#3-1-AbstractQueuedLongSynchronizer-概述" class="headerlink" title="3.1. AbstractQueuedLongSynchronizer 概述"></a>3.1. AbstractQueuedLongSynchronizer 概述</h3><p><code>AbstractQueuedLongSynchronizer</code> 是一个抽象类，继承了 <code>java.util.concurrent.locks.AbstractOwnableSynchronizer</code>，实现了 <code>java.io.Serializable</code><br><img src="/2025/11/19/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedLongSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>AbstractQueuedLongSynchronizer</code> 和 <code>AbstractQueuedSynchronizer</code> 是一样的，只不过 <code>State</code> 从 <code>32 bit ➔ 64 bit</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractOwnableSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.function.Consumer＜T＞ 源码解析</title>
    <link href="/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Consumer＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Consumer＜T＞-概述"><a href="#3-1-Consumer＜T＞-概述" class="headerlink" title="3.1. Consumer＜T＞ 概述"></a>3.1. Consumer＜T＞ 概述</h3><p><code>Consumer＜T＞</code> 是一个接口</p><p><code>Consumer＜T＞</code> 是一个具有 “消费” 功能的内置函数式接口，表示 “给你一个方法参数 <code>T</code>，处理掉它，没有返回结果”</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 用于定义当前回调函数的具体逻辑，并执行当前回调函数（需要注意的是：阻塞、非阻塞、限时阻塞看回调函数的具体逻辑）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br><br><span class="hljs-comment">// 用于非阻塞组合两个回调函数为一个回调函数，该回调函数的具体逻辑为：先执行当前回调函数，传入的方法参数 after（即一个 Consumer＜T＞ 类型的回调函数）</span><br>    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.function.Function＜T,R＞ 源码解析</title>
    <link href="/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Function%EF%BC%9CT,R%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Function%EF%BC%9CT,R%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Function%EF%BC%9CT,R%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Function＜T,R＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="Function＜T-R＞-概述"><a href="#Function＜T-R＞-概述" class="headerlink" title="Function＜T, R＞ 概述"></a>Function＜T, R＞ 概述</h3><p><code>Function＜T, R＞</code> 是一个接口</p><p><code>Function＜T, R＞</code> 是一个具有 “转换” 或 “计算” 功能的内置函数式接口，表示 “给你一个方法参数 <code>T</code>，转换或计算它，返回一个 <code>R</code> 类型的结果”</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt; &#123;<br><br><span class="hljs-comment">// 用于定义当前回调函数的具体逻辑，并执行当前回调函数（需要注意的是：阻塞、非阻塞、限时阻塞看回调函数的具体逻辑）</span><br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;<br><br><span class="hljs-comment">// 用于非阻塞组合两个回调函数为一个回调函数，该回调函数的具体逻辑为：先执行传入的方法参数 before（即一个 Function＜T, R＞ 类型的回调函数），再执行当前回调函数</span><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="hljs-title function_">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> V, ? extends T&gt; before)</span> &#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞组合两个回调函数为一个回调函数，该回调函数的具体逻辑为：先执行当前回调函数，传入的方法参数 after（即一个 Function＜T, R＞ 类型的回调函数）</span><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> R, ? extends V&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞原样返回当前回调函数的方法参数</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="hljs-title function_">identity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.function.Predicate＜T＞ 源码解析</title>
    <link href="/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Predicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Predicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Predicate%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Predicate＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="Predicate＜T＞-概述"><a href="#Predicate＜T＞-概述" class="headerlink" title="Predicate＜T＞ 概述"></a>Predicate＜T＞ 概述</h3><p><code>Predicate＜T＞</code> 是一个接口</p><p><code>Predicate＜T＞</code> 是一个具有 “判断” 功能的内置函数式接口，表示 “给你一个方法参数 <code>T</code>，判断它是否满足条件，返回一个 <code>boolean</code> 类型的结果”</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 用于定义当前回调函数的具体逻辑，并执行当前回调函数（需要注意的是：阻塞、非阻塞、限时阻塞看回调函数的具体逻辑）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br><br><span class="hljs-comment">// 用于非阻塞组合两个回调函数为一个回调函数，该回调函数的具体逻辑为：先执行当前回调函数，如果回调函数的执行结果为 true，再执行传入的方法参数 other（即一个 Predicate＜T＞ 类型的回调函数）</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞组合两个回调函数为一个回调函数，该回调函数的具体逻辑为：先执行当前回调函数，如果回调函数的执行结果为 false，再执行传入的方法参数 other（一个 Predicate＜T＞ 类型的回调函数）</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 用于非阻塞执行当前回调函数，并对回调函数的执行结果取反</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 即如果回调函数的执行结果为 true，那么该方法就返回 false</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">negate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">isEqual</span><span class="hljs-params">(Object targetRef)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span> == targetRef)<br>                ? Objects::isNull<br>                : object -&gt; targetRef.equals(object);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">not</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; target)</span> &#123;<br>        Objects.requireNonNull(target);<br>        <span class="hljs-keyword">return</span> (Predicate&lt;T&gt;)target.negate();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.function.Supplier＜T＞ 源码解析</title>
    <link href="/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Supplier%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Supplier%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Supplier%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Supplier＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><p><code>Supplier＜T＞</code> 是一个接口</p><p><code>Supplier＜T＞</code> 是一个具有 “生产” 功能的内置函数式接口，表示 “不给你任何方法参数，返回一个 <code>T</code> 类型的结果”</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">//用于定义当前回调函数的具体逻辑，并执行当前回调函数（需要注意的是：阻塞、非阻塞、限时阻塞看回调函数的具体逻辑）</span><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.ThreadLocal＜T＞.ThreadLocalMap 源码解析</title>
    <link href="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/16/源码：java.lang.ThreadLocal＜T＞.ThreadLocalMap源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ThreadLocal-ThreadLocalMap-述"><a href="#3-1-ThreadLocal-ThreadLocalMap-述" class="headerlink" title="3.1. ThreadLocal.ThreadLocalMap 述"></a>3.1. ThreadLocal.ThreadLocalMap 述</h3><p><code>ThreadLocal.ThreadLocalMap</code> 是一个具体类，是 <code>ThreadLocal</code> 的静态内部类</p><p><code>ThreadLocal.ThreadLocalMap</code> 是通过 <code>ThreadLocal.ThreadLocalMap-&gt;table</code> 存储数据的，而它又是一个由 <code>Entry</code> 构建的数组，其基本属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br><br>Object value;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>Entry</code> 的 <code>key</code> 必须是 <code>ThreadLocal</code> 类型，而 <code>value</code> 是 <code>Object</code> 类型。因此，我们可以把它简单理解为：<br><img src="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.ThreadLocal%EF%BC%9CT%EF%BC%9E.ThreadLocalMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>为什么 <code>ThreadLocal.ThreadLocalMap</code> 要使用 <code>ThreadLocal</code> 实例作为 <code>Key</code>？能不能使用其他类的实例？<ol><li>在一个复杂的 <code>Java</code> 应用中，会引入大量第三方依赖，它们内部可能都会使用 <code>ThreadLocal</code> 存储上下文数据</li><li>如果 <code>Key</code> 使用字符串（例如 “<code>myName</code>”），不同依赖可能恰好用到同名的 <code>Key</code>，最终导致数据被覆盖</li><li>而使用 <code>ThreadLocal</code> 实例作为 <code>Key</code> 依赖于它的对象地址，因为你即便创建了同名的 <code>ThreadLocal</code> 实例，它们的对象地址仍然是不同的</li><li>那么到底能不能使用其他类的实例呢？从实现的角度来看，只要是实例，就都能当 <code>Key</code>，当然不限制必须是 <code>ThreadLocal</code> 实例。但是 Entry 的构造方法被设计的就是使用 <code>ThreadLocal</code> 实例，所以我们就使用这个好了</li></ol></li><li>为什么 <code>Thread</code> 不直接使用其他的 <code>Map</code>，而是使用 <code>ThreadLocal.ThreadLocalMap</code>？<ol><li>这主要是为了尽量避免内存泄漏，虽然没有彻底杜绝，但是比其他的 <code>Map</code> 要好得多</li><li>因为其他的 <code>Map</code> 的 <code>Key</code> 是强引用，只要线程存活，那么 <code>ThreadLocal</code> 实例就永远无法被回收</li><li>而 <code>ThreadLocal.ThreadLocalMap</code> 的 <code>Key</code> 是弱引用，可以在 <code>ThreadLocal</code> 实例不再被使用时被回收</li><li>虽然 <code>ThreadLocal#set</code>、<code>ThreadLocal#get</code> 能在 <code>Key</code> 为 <code>null</code> 时清理 <code>Value</code>，但是这是 “被动清理”，并不可靠</li></ol></li><li><code>ThreadLocal.ThreadLocalMap</code> 有没有位置冲突？它是如何解决位置冲突的？<ol><li>有，它是采取 “线性探测” 的方式解决位置冲突的。即 如果 <code>i</code> 已经被占用，就尝试 <code>i + 1</code>，以此类推…</li><li>在调用 <code>ThreadLocal#set</code> 或 <code>ThreadLocal#get</code> 后，如果发生了线性探测，那么在探测的过程中遇到某位置的 <code>Key</code> 为 <code>null</code> 时，会顺手把这个位置的 <code>Value</code> 清理了</li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-ThreadLocal-ThreadLocalMap-使用方式"><a href="#3-2-ThreadLocal-ThreadLocalMap-使用方式" class="headerlink" title="3.2. ThreadLocal.ThreadLocalMap 使用方式"></a>3.2. ThreadLocal.ThreadLocalMap 使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个 ThreadLocal 实例，通常由 static final 修饰</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; userContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 存数据</span><br>            userContext.set(<span class="hljs-string">&quot;用户A的数据&quot;</span>);<br>            <span class="hljs-comment">// 取数据</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取: &quot;</span> + userContext.get());<br>            <span class="hljs-comment">// 删数据</span><br>            userContext.remove();<br>        &#125;, <span class="hljs-string">&quot;Thread-A&quot;</span>).start();<br><br>        <span class="hljs-comment">// 模拟线程 B</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            userContext.set(<span class="hljs-string">&quot;用户B的数据&quot;</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取: &quot;</span> + userContext.get());<br>            userContext.remove();<br>        &#125;, <span class="hljs-string">&quot;Thread-B&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>在上述代码中，看起来像是在对 <code>ThreadLocal</code> 实例本身进行读写，但真正的逻辑是：通过当前线程找到它所持有的 <code>ThreadLocal.ThreadLocalMap</code>，然后在这个 <code>Map</code> 的 <code>Entry[]</code> 中，以当前 <code>ThreadLocal</code> 实例为 <code>Key</code> 进行读写。</li><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code><ol><li>为什么 <code>ThreadLocal</code> 实例通常由 <code>static final</code> 修饰？<ol><li>这主要是为了减少内存占用，因为即便多个 <code>ThreadLocal.ThreadLocalMap</code> 使用同一个 <code>ThreadLocal</code> 实例当 <code>Key</code>，但是它们互不影响。所以没必要专门为每一个 <code>ThreadLocal.ThreadLocalMap</code> 创建一个 <code>ThreadLocal</code> 实例</li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-3-ThreadLocal-ThreadLocalMap-问题爆破"><a href="#3-3-ThreadLocal-ThreadLocalMap-问题爆破" class="headerlink" title="3.3. ThreadLocal.ThreadLocalMap 问题爆破"></a>3.3. ThreadLocal.ThreadLocalMap 问题爆破</h3><h4 id="3-3-1-数据-“脏读”"><a href="#3-3-1-数据-“脏读”" class="headerlink" title="3.3.1. 数据 “脏读”"></a>3.3.1. 数据 “脏读”</h4><p>某线程在处理上一个任务时，向 <code>ThreadLocal</code> 写入了数据，但是任务结束后没有清理数据。当该线程去处理下一个任务的时候，调用 <code>ThreadLocal#get</code> 会读到上一个任务遗留下来的数据</p><p>为了解决这一问题，我们需要任务结束后调用 <code>Thread#remove</code> 删除数据</p><hr><h4 id="3-3-2-内存泄漏"><a href="#3-3-2-内存泄漏" class="headerlink" title="3.3.2. 内存泄漏"></a>3.3.2. 内存泄漏</h4><p>由于 <code>ThreadLocal.ThreadLocalMap</code> 的 <code>Key</code> 是弱引用，而 <code>Value</code> 是强引用。所以当 <code>ThreadLocal</code> 实例被回收后，<code>Key</code> 会变成 <code>null</code>，但是对应的 <code>Value</code> 仍然存在，无法被回收</p><p>为了解决这一问题，我们需要任务结束后调用 <code>Thread#remove</code> 删除数据</p><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Entry"><a href="#4-1-Entry" class="headerlink" title="4.1. Entry"></a>4.1. Entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br><br>Object value;<br><br>Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br><span class="hljs-built_in">super</span>(k);<br>value = v;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br><span class="hljs-keyword">private</span> Entry[] table;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CountDownLatch 源码解析</title>
    <link href="/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/16/源码：java.util.concurrent.CountDownLatch源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CountDownLatch-概述"><a href="#3-1-CountDownLatch-概述" class="headerlink" title="3.1. CountDownLatch 概述"></a>3.1. CountDownLatch 概述</h3><p><code>CountDownLatch</code> 是一个具体类</p><p>倒计时门闩（<code>CountDownLatch</code>）是使用 <code>AQS</code> 实现的共享模式的同步器。<code>State</code> 和共享资源分别表示以下含义：</p><ol><li><code>State</code> 表示门闩是否开启<ol><li><code>0</code><ol><li>门闩开启</li></ol></li><li><code>n</code>（<code>n &gt; 0</code>）<ol><li>门闩关闭</li></ol></li></ol></li><li>共享资源表示门闩开启后，被允许执行的操作</li></ol><p>我们可以将 <code>CountDownLatch</code> 简单的理解为：一次性的、只做减法的计数器。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>简单理解 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>：<ol><li><code>CountDownLatch</code> 是门闩开启才能继续执行</li><li><code>CyclicBarrier</code> 是 “互相等待” 都准备好才能继续执行</li><li><code>Semaphore</code> 是拿到 “许可证” 才能继续执行</li></ol></li></ol></blockquote><hr><h3 id="3-2-CountDownLatch-应用场景"><a href="#3-2-CountDownLatch-应用场景" class="headerlink" title="3.2. CountDownLatch 应用场景"></a>3.2. CountDownLatch 应用场景</h3><h4 id="3-2-1-汇总模式"><a href="#3-2-1-汇总模式" class="headerlink" title="3.2.1. 汇总模式"></a>3.2.1. 汇总模式</h4><p>汇总模式是指：主线程等待多个子线程准备好后，才能继续执行</p><p>我们可以简单的理解为：主线程等待，子线程减数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">myCountDownlatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(finalI);<br>                <br>                <span class="hljs-comment">// 调用 CountDownLatch#countDown</span><br>                myCountDownlatch.countDown();<br>            &#125;).start();<br>        &#125;<br><br><span class="hljs-comment">// 调用 CountDownLatch#await</span><br>        myCountDownlatch.await();<br>        <br>        System.out.println(<span class="hljs-string">&quot;天下贤才尽数会于麾下！&quot;</span>);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-发令枪模式"><a href="#3-2-2-发令枪模式" class="headerlink" title="3.2.2. 发令枪模式"></a>3.2.2. 发令枪模式</h4><p>发令枪模式是指：多个子线程准备好后，等待主线程 “发枪”，才能继续执行</p><p>我们可以简单的理解为：子线程等待，主线程减数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">myCountDownlatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                <br>                <span class="hljs-comment">// 调用 CountDownLatch#await</span><br>                    myCountDownlatch.await();<br>                    System.out.println(finalI);<br>                    myCountDownlatch.countDown();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;天下贤才尽数听令而动！&quot;</span>);<br><br><span class="hljs-comment">// 调用 CountDownLatch#countDown</span><br>        myCountDownlatch.countDown();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <br>        Sync(<span class="hljs-type">int</span> count) &#123;<br>            setState(count);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>        <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.getCount();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + <span class="hljs-string">&quot;[Count = &quot;</span> + sync.getCount() + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.CountedCompleter＜T＞ 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.CountedCompleter＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-CountedCompleter-概述"><a href="#3-1-CountedCompleter-概述" class="headerlink" title="3.1. CountedCompleter 概述"></a>3.1. CountedCompleter 概述</h3><p><code>CountedCompleter</code> 是一个抽象类，继承了 <code>java.util.concurrent.ForkJoinTask＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.CountedCompleter%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>CountedCompleter</code> 是一个 ”天书“ 级别的类，它设计的初衷是：解决 ”当一组任务完成后触发一个回调“ 的问题，但是它用起来非常的反直觉，并且极易出错</p><p>而 <code>CompletableFuture</code> 就是 <code>CountedCompleter</code> 的 ”现代易用版“，我们可以直接使用 <code>CompletableFuture</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ForkJoinTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ForkJoinTask＜V＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ForkJoinTask＜V＞ 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ForkJoinTask＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ForkJoinTask-概述"><a href="#3-1-ForkJoinTask-概述" class="headerlink" title="3.1. ForkJoinTask 概述"></a>3.1. ForkJoinTask 概述</h3><p><code>ForkJoinTask</code> 是一个抽象类，实现了 <code>java.util.concurren.Future＜V＞</code>、<code>java.io.Serializable</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Future＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurren.Future＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Serializable源码解析</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究。详见源码：<code>ForkJoinPool</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a>，<code>Hexo</code> 链接： <a href="http://blog.wangjia.ink/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/14/源码：java.util.concurrent.ForkJoinPool源码解析/</a> ）</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RecursiveTask＜V＞ 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.RecursiveTask＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="RecursiveTask-概述"><a href="#RecursiveTask-概述" class="headerlink" title="RecursiveTask 概述"></a>RecursiveTask 概述</h3><p><code>RecursiveTask</code> 是一个抽象类，继承了 <code>java.util.concurrent.ForkJoinTask＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ForkJoinTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ForkJoinTask＜V＞源码解析/</a></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究。详见源码：<code>ForkJoinPool</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a>，<code>Hexo</code> 链接：）</li></ol></blockquote><hr><h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">5232453952276485270L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecursiveTask</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span><br>    V result;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span> &#123;<br>        result = value;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        result = compute();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RecursiveAction 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.RecursiveAction源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-RecursiveAction-概述"><a href="#3-1-RecursiveAction-概述" class="headerlink" title="3.1. RecursiveAction 概述"></a>3.1. RecursiveAction 概述</h3><p><code>RecursiveAction</code> 是一个抽象类，继承了 <code>java.util.concurrent.ForkJoinTask＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RecursiveAction%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ForkJoinTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ForkJoinTask＜V＞源码解析/</a></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究。详见源码：<code>ForkJoinPool</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ForkJoinPool源码解析</a>，<code>Hexo</code> 链接： <a href="http://blog.wangjia.ink/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/14/源码：java.util.concurrent.ForkJoinPool源码解析/</a> ）</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">5232453952276485070L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecursiveAction</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void mustBeNull)</span> &#123; &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        compute();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞ 源码解析</title>
    <link href="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledThreadPoolExecutor-ScheduledFutureTask-概述"><a href="#3-1-ScheduledThreadPoolExecutor-ScheduledFutureTask-概述" class="headerlink" title="3.1. ScheduledThreadPoolExecutor.ScheduledFutureTask 概述"></a>3.1. ScheduledThreadPoolExecutor.ScheduledFutureTask 概述</h3><p><code>ScheduledThreadPoolExecutor.ScheduledFutureTask</code> 是一个具体类，是 <code>java.util.concurrent.ScheduledThreadPoolExecutor</code> 的普通内部类，继承了 <code>java.util.concurrent.FutureTask＜V＞</code>、<code>java.util.concurrent.RunnableScheduledFuture＜V＞</code><br><img src="/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>FutureTask＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.FutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.FutureTask＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>RunnableScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/05/05/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/05/05/源码：java.util.concurrent.RunnableScheduledFuture＜V＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示任务执行点</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 哪些需要排序的 Java 数据类型就是以任务执行点进行排序的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> time;<br><br><span class="hljs-comment">// 表示任务序号</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果多个 FutureTask 的任务执行点相同，任务序号小的任务会排在前面</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequenceNumber;<br><br><span class="hljs-comment">// 表示任务是否是周期性任务，以及如何进行周期性</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 可选参数包括：</span><br><span class="hljs-comment">//     1. 0</span><br><span class="hljs-comment">//         1. “一次性” 任务</span><br><span class="hljs-comment">//     2. n（n &gt; 0）</span><br><span class="hljs-comment">//         1. 以 period 的固定速率，周期性执行任务</span><br><span class="hljs-comment">//     2. n（n &lt; 0）</span><br><span class="hljs-comment">//         1. 以 period 的固定延迟，周期性执行任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<br><br><span class="hljs-comment">// 表示任务对应的二叉堆索引</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 堆索引是为了实现快速 Future#cancel 操作的重大优化</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 因为 DelayQueue 使用了 PriorityQueue,而 PriorityQueue 底层基于二叉堆，而二叉堆底层又基于数组</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果没有 heapIndex 并调用 Future#cancel，就需要遍历数组去找到这个任务，然后再进行删除</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果拥有 heapIndex，当任务在 DelayQueue 变化位置时，会自动更新这个 heapIndex，那么 heapIndex 是直指这个任务的。所以调用 Future#cancel 的时候，就可以直接根据 heapIndex 找到这个任务，然后再进行删除</span><br><span class="hljs-type">int</span> heapIndex;<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-ScheduledFutureTask-Callable＜V＞-callable-long-triggerTime-long-sequenceNumber"><a href="#5-1-ScheduledFutureTask-Callable＜V＞-callable-long-triggerTime-long-sequenceNumber" class="headerlink" title="5.1. ScheduledFutureTask(Callable＜V＞ callable, long triggerTime, long sequenceNumber)"></a>5.1. ScheduledFutureTask(Callable＜V＞ callable, long triggerTime, long sequenceNumber)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> triggerTime,<br><span class="hljs-type">long</span> sequenceNumber) &#123;<br><span class="hljs-built_in">super</span>(callable);<br><span class="hljs-built_in">this</span>.time = triggerTime;<br><span class="hljs-built_in">this</span>.period = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">this</span>.sequenceNumber = sequenceNumber;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-sequenceNumber"><a href="#5-2-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-sequenceNumber" class="headerlink" title="5.2. ScheduledFutureTask(Runnable r, V result, long triggerTime, long sequenceNumber)"></a>5.2. ScheduledFutureTask(Runnable r, V result, long triggerTime, long sequenceNumber)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> triggerTime,<br><span class="hljs-type">long</span> sequenceNumber) &#123;<br><span class="hljs-built_in">super</span>(r, result);<br><span class="hljs-built_in">this</span>.time = triggerTime;<br><span class="hljs-built_in">this</span>.period = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">this</span>.sequenceNumber = sequenceNumber;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-3-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-period-long-sequenceNumber"><a href="#5-3-ScheduledFutureTask-Runnable-r-V-result-long-triggerTime-long-period-long-sequenceNumber" class="headerlink" title="5.3. ScheduledFutureTask(Runnable r, V result, long triggerTime, long period, long sequenceNumber)"></a>5.3. ScheduledFutureTask(Runnable r, V result, long triggerTime, long period, long sequenceNumber)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> triggerTime,<br><span class="hljs-type">long</span> period, <span class="hljs-type">long</span> sequenceNumber) &#123;<br><span class="hljs-built_in">super</span>(r, result);<br><span class="hljs-built_in">this</span>.time = triggerTime;<br><span class="hljs-built_in">this</span>.period = period;<br><span class="hljs-built_in">this</span>.sequenceNumber = sequenceNumber;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h2><h3 id="6-1-实例具体方法"><a href="#6-1-实例具体方法" class="headerlink" title="6.1. 实例具体方法"></a>6.1. 实例具体方法</h3><h4 id="6-1-1-具体方法（普通）"><a href="#6-1-1-具体方法（普通）" class="headerlink" title="6.1.1. 具体方法（普通）"></a>6.1.1. 具体方法（普通）</h4><h5 id="6-1-1-1-void-setNextRunTime"><a href="#6-1-1-1-void-setNextRunTime" class="headerlink" title="6.1.1.1. void setNextRunTime()"></a>6.1.1.1. void setNextRunTime()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br><span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>time += p;<br><span class="hljs-keyword">else</span><br>time = triggerTime(-p);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="6-1-2-具体方法（实现）"><a href="#6-1-2-具体方法（实现）" class="headerlink" title="6.1.2. 具体方法（实现）"></a>6.1.2. 具体方法（实现）</h4><h5 id="6-1-2-1-Comparable＜T＞-中接口方法的实现"><a href="#6-1-2-1-Comparable＜T＞-中接口方法的实现" class="headerlink" title="6.1.2.1. Comparable＜T＞ 中接口方法的实现"></a>6.1.2.1. Comparable＜T＞ 中接口方法的实现</h5><h6 id="6-1-2-1-1-int-compareTo-Delayed-other"><a href="#6-1-2-1-1-int-compareTo-Delayed-other" class="headerlink" title="6.1.2.1.1. int compareTo(Delayed other)"></a>6.1.2.1.1. int compareTo(Delayed other)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br><span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-comment">// compare zero if same object</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br><span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;<br><span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);<br><span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-2-Runnable-中接口方法的实现"><a href="#6-1-2-2-Runnable-中接口方法的实现" class="headerlink" title="6.1.2.2. Runnable 中接口方法的实现"></a>6.1.2.2. Runnable 中接口方法的实现</h5><h6 id="6-1-2-2-1-void-run"><a href="#6-1-2-2-1-void-run" class="headerlink" title="6.1.2.2.1. void run()"></a>6.1.2.2.1. void run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!canRunInCurrentRunState(<span class="hljs-built_in">this</span>))<br>cancel(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isPeriodic())<br><span class="hljs-built_in">super</span>.run();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>setNextRunTime();<br>reExecutePeriodic(outerTask);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-3-Delayed-中接口方法的实现"><a href="#6-1-2-3-Delayed-中接口方法的实现" class="headerlink" title="6.1.2.3. Delayed 中接口方法的实现"></a>6.1.2.3. Delayed 中接口方法的实现</h5><h6 id="6-1-2-3-1-long-getDelay-TimeUnit-unit"><a href="#6-1-2-3-1-long-getDelay-TimeUnit-unit" class="headerlink" title="6.1.2.3.1. long getDelay(TimeUnit unit)"></a>6.1.2.3.1. long getDelay(TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br><span class="hljs-keyword">return</span> unit.convert(time - System.nanoTime(), NANOSECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-4-Future＜V＞-中接口方法的实现"><a href="#6-1-2-4-Future＜V＞-中接口方法的实现" class="headerlink" title="6.1.2.4. Future＜V＞ 中接口方法的实现"></a>6.1.2.4. Future＜V＞ 中接口方法的实现</h5><h6 id="6-1-2-4-1-boolean-cancel-boolean-mayInterruptIfRunning"><a href="#6-1-2-4-1-boolean-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="6.1.2.4.1. boolean cancel(boolean mayInterruptIfRunning)"></a>6.1.2.4.1. boolean cancel(boolean mayInterruptIfRunning)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br><span class="hljs-comment">// The racy read of heapIndex below is benign:</span><br><span class="hljs-comment">// if heapIndex &lt; 0, then OOTA guarantees that we have surely</span><br><span class="hljs-comment">// been removed; else we recheck under lock in remove()</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.cancel(mayInterruptIfRunning);<br><span class="hljs-keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="hljs-number">0</span>)<br>remove(<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">return</span> cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-2-5-RunnableScheduledFuture＜V＞-中接口方法的实现"><a href="#6-1-2-5-RunnableScheduledFuture＜V＞-中接口方法的实现" class="headerlink" title="6.1.2.5. RunnableScheduledFuture＜V＞ 中接口方法的实现"></a>6.1.2.5. RunnableScheduledFuture＜V＞ 中接口方法的实现</h5><h6 id="6-1-2-5-1-boolean-isPeriodic"><a href="#6-1-2-5-1-boolean-isPeriodic" class="headerlink" title="6.1.2.5.1. boolean isPeriodic()"></a>6.1.2.5.1. boolean isPeriodic()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPeriodic</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> period != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ForkJoinPool 源码解析</title>
    <link href="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><ul><li><input disabled="" type="checkbox"> 使用场景和严禁 XXXX</li><li><input disabled="" type="checkbox"> ForkJoinPool.commonPool()</li><li><input disabled="" type="checkbox"> 数据的迭代拆分</li></ul><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/14/源码：java.util.concurrent.ForkJoinPool源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ForkJoinPool-概述"><a href="#3-1-ForkJoinPool-概述" class="headerlink" title="3.1. ForkJoinPool 概述"></a>3.1. ForkJoinPool 概述</h3><p><code>ForkJoinPool</code> 是一个具体类，继承了 <code>java.util.concurrent.AbstractExecutorService</code></p><p><code>ForkJoinPool</code> 被设计用于高效执行那些可以被 ”迭代拆分“ 的任务，其核心特性是：</p><ol><li>分而治之</li><li>迭代拆分</li><li>工作窃取</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.AbstractExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.AbstractExecutorService源码解析/</a></li></ol></li></ol></li><li>对于 <code>ForkJoinPool</code>、<code>ForkJoinTask&lt;V&gt;</code>、<code>RecursiveAction</code>、<code>RecursiveTask&lt;V&gt;</code>，可以说是整个 <code>JUC</code> 中最复杂的一部分，<code>Doug Lea</code> 当初为它们投入了大量心血。对于我们而言，只需要掌握它们的使用方式即可，没必要对源码进行过度深究</li></ol></blockquote><hr><h3 id="3-2-ForkJoinPool-相关流程"><a href="#3-2-ForkJoinPool-相关流程" class="headerlink" title="3.2. ForkJoinPool 相关流程"></a>3.2. ForkJoinPool 相关流程</h3><p>我们知道：<code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 的线程执行流程大致为：<code>本地线程 ➔ Thread#run ➔ Worker#run</code></p><p>而 <code>ForkJoinPool</code> 并没有使用 <code>Worker</code>，甚至没有使用原生的 <code>Thread</code>，而是直接使用了 <code>ForkJoinWorkerThread</code>（<code>ForkJoinWorkerThread</code> 继承了 <code>Thread</code>）</p><p>你可能会疑惑：为什么要让 <code>ForkJoinWorkerThread</code> 继承 <code>Thread</code>，而不是继续使用 <code>Worker</code> 或者在 <code>Worker</code> 的基础上 “魔改” 呢？原因很简单，因为我们要为每个线程单独维护一个任务队列</p><p>每个线程都会维护一个 <code>ForkJoinPool.WorkQueue</code>，这是一个双端队列。并且这些队列都会被注册到 <code>ForkJoinPool-&gt;queues</code> 中<br><img src="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p>当线程去执行一个大任务 <code>A</code> 时，可以把 <code>A</code> 拆分成多个子任务（例如 <code>B</code>、<code>C</code>、<code>D</code>），这些子任务会被投递到该本地线程维护的任务队列中。然后你是不是认为 “线程需要阻塞等待 <code>B</code>、<code>C</code>、<code>D</code> 的完成呢？”</p><p>接下来的一部分，是 <code>ForkJoinPool</code> 设计最精妙的地方：</p><ol><li>当一个任务 <code>A</code> 被拆分成子任务 <code>B</code>、<code>C</code>、<code>D</code>，并被投递到任务队列后，按理说当前线程应该阻塞并等待 <code>B</code>、<code>C</code>、<code>D</code> 的完成。然而并非如此：当前线程确实在等待，但并没有阻塞。相反，它会继续执行当前线程维护的任务队列中的其他任务</li><li>假如执行到了 <code>B</code>，在执行 <code>B</code> 的过程中，<code>B</code> 又可以进一步拆分成更小的子任务 <code>E</code>、<code>F</code>、<code>G</code>，并被投递到任务队列后，同样在等待子任务的结果的同时，当前线程并不会立即阻塞，而是会继续执行当前线程维护的任务队列中的其他任务。以此类推…直到任务被拆分到足够小</li><li>当子任务完成后，它的结果会返回给父任务。父任务在收到所有子任务结果后，再将汇总结果返回给自己的父任务。以此类推…直到最初的大任务最终得到完整的计算结果</li><li>需要注意的是：<ol><li>如果当前线程维护的任务队列中没有其他任务了，它会根据 <code>ForkJoinPool-&gt;queues</code> 随机选择一个其他线程维护的任务队列，从队尾 “窃取” 一个任务来执行</li><li>如果当前线程维护的任务队列中没有其他任务了，也 “窃取” 不到任务了，就会有以下两种情况：<ol><li>如果当前线程还在等待任务<ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，并被投递到（XXXXX，肯定是 ForkJOinPoolTask 的队列啊） <code>Task</code> 的某队列，等待被唤醒（<code>LockSupport.unpark</code>）、被中断</li><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态后，能响应中断。线程被唤醒，重新获得 <code>CPU</code> 时间片后，会抛出 <code>InterruptedException</code> 异常，并清除 <code>Thread</code> 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）。不过我们无需对此过多关注，因为相关逻辑已由 <code>ForkJoinPool</code> 处理好了。一旦发生中断，为了不污染我们的代码，<code>ForkJoinPool</code> 会抛出 <code>CancellationException</code> 非受检异常</li></ol></li><li>如果当前线程未在等待任务（“空闲”）<ol><li>如果线程池中的线程的数量 ≤ <code>corePoolSize</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态，并被投递到 ForkJoinPool 的某队列，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）</li><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>WAITING</code> 状态后，能响应中断。线程被唤醒，重新获得 <code>CPU</code> 时间片后，会抛出 <code>InterruptedException</code> 异常，并清除 <code>Thread</code> 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）。不过我们无需对此过多关注，因为相关逻辑已由 <code>ForkJoinPool</code> 处理好了。一旦发生中断，我们不会感知到任何异常</li></ol></li><li>如果线程池中的线程的数量 ＞<code>corePoolSize</code><ol><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态，并被投递到 <code>ForkJoinPool</code> 的某队列，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时<ol><li>如果超时，<code>ForkJoinPool</code> 会销毁该线程</li></ol></li><li>本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>TIMED_WAITING</code> 状态后，能响应中断。线程被唤醒，重新获得 <code>CPU</code> 时间片后，会抛出 <code>InterruptedException</code> 异常，并清除 <code>Thread</code> 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）。不过我们无需对此过多关注，因为相关逻辑已由 <code>ForkJoinPool</code> 处理好了。一旦发生中断，我们不会感知到任何异常</li></ol></li></ol></li></ol></li></ol></li></ol><p>我们以 <code>1</code> 累加到 <code>10000</code> 为例，来看一看究竟是怎么执行的：<br><img src="/2025/11/14/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ForkJoinPool%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>为什么我们不能采取 <code>ForkJoinPool</code> 的 “一个任务尚未完成，但是可以去执行其他任务” 思想，用于同步阻塞 <code>IO</code> 工作模式下的服务端，从而避免 “伪异步 + 异步编程回调”？</li><li>为什么不 “魔改” <code>Worker</code>，在 <code>Worker</code> 中添加任务队列呢？</li><li>为什么当前线程维护的任务队列中没有其他任务了，也 “窃取” 不到任务了，就要阻塞？<ol><li>防止 CPU 空转</li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h2><h3 id="4-1-public-ForkJoinPool-int-parallelism-ForkJoinWorkerThreadFactory-factory-UncaughtExceptionHandler-handler-boolean-asyncMode-int-corePoolSize-int-maximumPoolSize-int-minimumRunnable-Predicate＜-super-ForkJoinPool＞-saturate-long-keepAliveTime-TimeUnit-unit"><a href="#4-1-public-ForkJoinPool-int-parallelism-ForkJoinWorkerThreadFactory-factory-UncaughtExceptionHandler-handler-boolean-asyncMode-int-corePoolSize-int-maximumPoolSize-int-minimumRunnable-Predicate＜-super-ForkJoinPool＞-saturate-long-keepAliveTime-TimeUnit-unit" class="headerlink" title="4.1. public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode, int corePoolSize, int maximumPoolSize, int minimumRunnable, Predicate＜? super ForkJoinPool＞ saturate, long keepAliveTime,TimeUnit unit)"></a>4.1. public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode, int corePoolSize, int maximumPoolSize, int minimumRunnable, Predicate＜? super ForkJoinPool＞ saturate, long keepAliveTime,TimeUnit unit)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：</span><br><span class="hljs-comment"> * public ForkJoinPool(int parallelism,</span><br><span class="hljs-comment"> *         ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-comment"> *         UncaughtExceptionHandler handler,</span><br><span class="hljs-comment"> *         boolean asyncMode,</span><br><span class="hljs-comment"> *         int corePoolSize,</span><br><span class="hljs-comment"> *         int maximumPoolSize,</span><br><span class="hljs-comment"> *         int minimumRunnable,</span><br><span class="hljs-comment"> *         Predicate&lt;? super ForkJoinPool&gt; saturate,</span><br><span class="hljs-comment"> *         long keepAliveTime,</span><br><span class="hljs-comment"> *         TimeUnit unit)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. int parallelism</span><br><span class="hljs-comment"> *          1. 指定我们期望线程池中 ”活跃“ 线程的线程数量</span><br><span class="hljs-comment"> *          2. 所谓的 “活跃” 是指：正在执行任务或正在 ”窃取“ 任务的线程的线程数量</span><br><span class="hljs-comment"> *          3. ForkJoinPool 会尽力维持这个数量，但不能保证</span><br><span class="hljs-comment"> *      2. ForkJoinWorkerThreadFactory factory</span><br><span class="hljs-comment"> *          1. 指定创建 ForkJoinWorkerThread 实例的线程工厂</span><br><span class="hljs-comment"> *      3. UncaughtExceptionHandler handler</span><br><span class="hljs-comment"> *          1. 指定未捕获异常的处理器</span><br><span class="hljs-comment"> *          2. 当一个本地线程在执行任务时因未捕获的异常而终止（异常退出）时，会调用未捕获异常的处理器</span><br><span class="hljs-comment"> *      4. boolean asyncMode</span><br><span class="hljs-comment"> *          1. 指定本地线程从其维护的任务队列获取任务的顺序</span><br><span class="hljs-comment"> *          2. 可选参数包括：</span><br><span class="hljs-comment"> *              1. true</span><br><span class="hljs-comment"> *                  1. FIFO</span><br><span class="hljs-comment"> *              2. false</span><br><span class="hljs-comment"> *                  1. LIFO</span><br><span class="hljs-comment"> *      5. int corePoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中 “存活” 的线程被允许的最小数量</span><br><span class="hljs-comment"> *          2. 当某本地线程 “空闲” 的时间超过 keepAliveTime unit，会在销毁前检查该参数，然后再决定是否销毁</span><br><span class="hljs-comment"> *          3. 需要注意的是：该参数可以为 0</span><br><span class="hljs-comment"> *      6. int maximumPoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中的线程被允许的最大数量</span><br><span class="hljs-comment"> *      7. int minimumRunnable</span><br><span class="hljs-comment"> *          1. 指定线程池中没有调用 ForkJoinTask#join 的线程被允许的最小数量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          1. 指定可运行的工作线程被允许的最小数量</span><br><span class="hljs-comment"> *          2. 如果低于，将创建新的工作线程，直到达到 maximumPoolSize</span><br><span class="hljs-comment"> *      8. Predicate&lt;? super ForkJoinPool&gt; saturate</span><br><span class="hljs-comment"> *          1. 指定饱和策略</span><br><span class="hljs-comment"> *          2. 当没有调用 ForkJoinTask#join 的线程低于 minimumRunnable，但是也达到了 maximumPoolSize 时，会调用饱和策略</span><br><span class="hljs-comment"> *      9. long keepAliveTime</span><br><span class="hljs-comment"> *          1. 指定线程 “空闲”被允许的最长时间为：keepAliveTime unit</span><br><span class="hljs-comment"> *          2. 所谓的 “空闲” 是指：某本地线程维护的任务队列没有任务了，并且也 “窃取” 不到任务了</span><br><span class="hljs-comment"> *          3. 当某本地线程 “空闲” 的时间超过 keepAliveTime unit，</span><br><span class="hljs-comment"> *      10. TimeUnit unit</span><br><span class="hljs-comment"> *          1. 指定线程 “空闲”被允许的最长时间为：keepAliveTime unit</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 构造示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">UncaughtExceptionHandler handler,</span><br><span class="hljs-params"><span class="hljs-type">boolean</span> asyncMode,</span><br><span class="hljs-params"><span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params"><span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params"><span class="hljs-type">int</span> minimumRunnable,</span><br><span class="hljs-params">Predicate&lt;? <span class="hljs-built_in">super</span> ForkJoinPool&gt; saturate,</span><br><span class="hljs-params"><span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">TimeUnit unit)</span> &#123;<br><br>checkPermission();<br><span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> parallelism;<br><span class="hljs-keyword">if</span> (p &lt;= <span class="hljs-number">0</span> || p &gt; MAX_CAP || p &gt; maximumPoolSize || keepAliveTime &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-built_in">this</span>.factory = factory;<br><span class="hljs-built_in">this</span>.ueh = handler;<br><span class="hljs-built_in">this</span>.saturate = saturate;<br><span class="hljs-built_in">this</span>.keepAlive = Math.max(unit.toMillis(keepAliveTime), TIMEOUT_SLOP);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">33</span> - Integer.numberOfLeadingZeros(p - <span class="hljs-number">1</span>));<br><span class="hljs-type">int</span> <span class="hljs-variable">corep</span> <span class="hljs-operator">=</span> Math.min(Math.max(corePoolSize, p), MAX_CAP);<br><span class="hljs-type">int</span> <span class="hljs-variable">maxSpares</span> <span class="hljs-operator">=</span> Math.min(maximumPoolSize, MAX_CAP) - p;<br><span class="hljs-type">int</span> <span class="hljs-variable">minAvail</span> <span class="hljs-operator">=</span> Math.min(Math.max(minimumRunnable, <span class="hljs-number">0</span>), MAX_CAP);<br><span class="hljs-built_in">this</span>.bounds = ((minAvail - p) &amp; SMASK) | (maxSpares &lt;&lt; SWIDTH);<br><span class="hljs-built_in">this</span>.mode = p | (asyncMode ? FIFO : <span class="hljs-number">0</span>);<br><span class="hljs-built_in">this</span>.ctl = ((((<span class="hljs-type">long</span>)(-corep) &lt;&lt; TC_SHIFT) &amp; TC_MASK) |<br>(((<span class="hljs-type">long</span>)(-p)     &lt;&lt; RC_SHIFT) &amp; RC_MASK));<br><span class="hljs-built_in">this</span>.registrationLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-built_in">this</span>.queues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkQueue</span>[size];<br><span class="hljs-type">String</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> Integer.toString(getAndAddPoolIds(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">this</span>.workerNamePrefix = <span class="hljs-string">&quot;ForkJoinPool-&quot;</span> + pid + <span class="hljs-string">&quot;-worker-&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.LockSupport 源码解析</title>
    <link href="/2025/11/13/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/13/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/13/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/13/源码：java.util.concurrent.locks.LockSupport源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-LockSupport-概述"><a href="#3-1-LockSupport-概述" class="headerlink" title="3.1. LockSupport 概述"></a>3.1. LockSupport 概述</h3><p>想象这样几个问题：</p><ol><li><code>Object#wait</code>、<code>Object#notify</code> 和 <code>synchronized</code> 是绑定的，它们必须出现在 <code>synchronized</code> 代码块中。也就是说：为了实现一次 “等待” 或 “通知”，线程必须先去竞争到 <code>Monitor</code> 锁。而在高并发场景下，这种对 <code>Monitor</code> 锁的竞争是重量级的</li><li><code>Object#notify()</code> 是唤醒 <code>Monitor</code> 的 <code>WaitSet</code> 中的 “任意” 一个 <code>Thread</code> 实例。而 <code>Object#notifyAll()</code> 是唤醒 <code>Monitor</code> 的 <code>WaitSet</code> 中的所有 <code>Thread</code> 实例，导致 “惊群效应”。它们都没有办法精确唤醒我们指定要唤醒的线程</li><li>除此之外，还有一个经典的竞态条件：如果本地线程 <code>B</code> 调用 <code>Object#notify</code> 先于本地线程 <code>A</code> 调用 <code>Object#wait</code>，那么这个 <code>Object#notify</code> 就永久消失了，本地线程 <code>A</code> 将 ”无限期“ 地等待一个永远不会再来的 <code>Object#notify</code>。而我们往常解决的方法是：在使用 <code>Object#wait</code>、<code>Object#notify</code> 前，要先用 <code>while(condition)</code> 循环来检查状态，非常的繁琐</li></ol><p>为了解决这一问题，<code>Doug Lea</code> 就封装了 <code>LockSupport</code>，我们在 <code>AQS</code> 中实现的阻塞、唤醒都是基于 <code>LockSupport</code></p><p>在 <code>LockSupport</code> 体系下，我们可以把每个本地线程想象成一个需要持有 “许可证” 才能继续运行的人。这个许可证不是计数器，不会累加，只有两种状态：<code>1</code> 和 <code>0</code></p><p>当我们调用 <code>LockSupport.unpark</code> 唤醒某本地线程时，无论该本地线程是阻塞还是运行，都会为它发放一个 “许可证”</p><p>而当我们调用 <code>LockSupport.park</code> 时，本地线程会先检查自己是否持有许可证：</p><ol><li>如果持有许可证<ol><li>消耗许可证（许可证从 <code>1 ➔ 0</code>），继续向下执行</li></ol></li><li>如果未持有许可证<ol><li>让本地线程进入阻塞状态，<code>Thread</code> 实例进入 <code>BWTW</code> 状态，等待被唤醒（<code>LockSupport.unpark</code>）、被中断（<code>Thread#interrupt</code>）、阻塞超时</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>LockSupport.unpark</code> 可以先于 <code>LockSupport.park</code> 执行，而不会 ”条件消失“，这是 <code>Doug Lea</code> 封装它的核心原因</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LockSupport</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-comment">// 用于非阻塞设置某本地线程进入阻塞状态，Thread 实例进入 BWTW 状态的原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该原因会被设置到 Thread-&gt;parkBlocker</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlocker</span><span class="hljs-params">(Thread t, Object arg)</span> &#123;<br>        U.putReferenceOpaque(t, PARKBLOCKER, arg);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞设置本地线程进入阻塞状态，Thread 实例进入 BWTW 状态的原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该原因会被设置到 Thread-&gt;parkBlocker</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentBlocker</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        U.putReferenceOpaque(Thread.currentThread(), PARKBLOCKER, blocker);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞唤醒某本地线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            U.unpark(thread);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时，并设置原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 受检异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时，并设置原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 受检异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            setBlocker(t, blocker);<br>            U.park(<span class="hljs-literal">false</span>, nanos);<br>            setBlocker(t, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时，并设置原因</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 受检异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-literal">true</span>, deadline);<br>        setBlocker(t, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <br><span class="hljs-comment">// 用于非阻塞获取某本地线程进入阻塞状态，Thread 实例进入 BWTW 状态的原因</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBlocker</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> U.getReferenceOpaque(t, PARKBLOCKER);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 受检异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>        U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 受检异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>)<br>            U.park(<span class="hljs-literal">false</span>, nanos);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到使用了 LockSupport 的具体产品维护的数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 受检异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span> &#123;<br>        U.park(<span class="hljs-literal">true</span>, deadline);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getThreadId</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">return</span> U.getLong(thread, TID);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">U</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">PARKBLOCKER</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(Thread.class, <span class="hljs-string">&quot;parkBlocker&quot;</span>);<br>        <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">TID</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(Thread.class, <span class="hljs-string">&quot;tid&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Thread 源码解析</title>
    <link href="/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/12/源码：java.lang.Thread源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Thread-概述"><a href="#3-1-Thread-概述" class="headerlink" title="3.1. Thread 概述"></a>3.1. Thread 概述</h3><p><code>Thread</code> 是一个具体类，实现了 <code>java.util.concurrent.Runnable</code><br><img src="/2025/11/12/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>Thread</code> 实例是一个 <code>Runnable</code> 任务，当我们调用 <code>Thread#start</code> 后，<code>JVM</code> 会在操作系统层面请求创建一个本地线程。一旦操作系统创建了这个本地线程，并将其与 <code>Thread</code> 实例 “绑定”，<code>Thread</code> 实例就会进入可运行状态。当本地线程被分配到 <code>CPU</code> 时间片后，开始执行 <code>Java</code> 代码，执行的就是 <code>Thread#run</code> </p><p>然而，由于 <code>Thread#run</code> 的源码又是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>target.run();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以线程执行的流程大致为：<code>本地线程 ➔ Thread#run ➔ target#run</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></li></ol></li></ol></li><li>虽然线程执行的流程大致为：<code>本地线程 ➔ Thread#run ➔ target#run</code>。但是在某些场景下，我们不希望在创建 <code>Thread</code> 实例时传入一个 <code>Runnable</code> 实例，因为我们已经明确知道该线程要执行的具体逻辑。此时，常见的做法是直接继承 <code>Thread</code> 具体类，并重写 <code>Thread#run</code>，我们直接使用这个 <code>Thread</code> 具体类的子类。这样线程执行的流程大致为：<code>本地线程 ➔ Thread#run</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// ...</span><br>    &#125;  <br>    <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        myThread.start();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-2-创建-Thread-实例常见方式"><a href="#3-2-创建-Thread-实例常见方式" class="headerlink" title="3.2. 创建 Thread 实例常见方式"></a>3.2. 创建 Thread 实例常见方式</h3><h4 id="3-2-1-继承-Thread-具体类，重写-Thread-run，创建-Thread-具体类的子类实例"><a href="#3-2-1-继承-Thread-具体类，重写-Thread-run，创建-Thread-具体类的子类实例" class="headerlink" title="3.2.1. 继承 Thread 具体类，重写 Thread#run，创建 Thread 具体类的子类实例"></a>3.2.1. 继承 Thread 具体类，重写 Thread#run，创建 Thread 具体类的子类实例</h4><p>正如我们上面讨论的，直接继承 <code>Thread</code> 类，重写 <code>Thread#run</code>，创建 <code>Thread</code> 具体类的子类实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// ...</span><br>    &#125;  <br>    <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        myThread.start();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>我们可以使用匿名内部类继承 <code>Thread</code> 具体类：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;myThread&quot;</span>) &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-comment">// ...</span><br>            &#125;  <br>        &#125;;  <br>        myThread.start();  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-2-2-创建-Runnable-实例，创建-Thread-实例，并将-Runnable-实例作为-Thread-实例的构造方法参数传递进去"><a href="#3-2-2-创建-Runnable-实例，创建-Thread-实例，并将-Runnable-实例作为-Thread-实例的构造方法参数传递进去" class="headerlink" title="3.2.2. 创建 Runnable 实例，创建 Thread 实例，并将 Runnable 实例作为 Thread 实例的构造方法参数传递进去"></a>3.2.2. 创建 Runnable 实例，创建 Thread 实例，并将 Runnable 实例作为 Thread 实例的构造方法参数传递进去</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br>&#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;myThread&quot;</span>);<br>        myThread.start();  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-2-3-使用线程池"><a href="#3-2-3-使用线程池" class="headerlink" title="3.2.3. 使用线程池"></a>3.2.3. 使用线程池</h4><p>详见笔记：<code>JUC</code></p><ol><li><code>obsidian</code> 内部链接<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJUC.md">笔记：JUC</a></li></ol></li><li><code>Hexo</code> 链接<ol><li><a href="http://blog.wangjia.ink/2025/11/23/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/">http://blog.wangjia.ink/2025/11/23/笔记：JUC/</a></li></ol></li></ol><hr><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h2><h3 id="4-1-Thread-String-name"><a href="#4-1-Thread-String-name" class="headerlink" title="4.1. Thread(String name)"></a>4.1. Thread(String name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(String name)</span> &#123;<br><br><span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, name, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-Thread-Runnable-target"><a href="#4-2-Thread-Runnable-target" class="headerlink" title="4.2. Thread(Runnable target)"></a>4.2. Thread(Runnable target)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br><br><span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-Thread-Runnable-target-String-name"><a href="#4-3-Thread-Runnable-target-String-name" class="headerlink" title="4.3. Thread(Runnable target, String name)"></a>4.3. Thread(Runnable target, String name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target, String name)</span> &#123;<br><br><span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, target, name, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-Thread-ThreadGroup-group-Runnable-target-String-name-long-stackSize"><a href="#4-4-Thread-ThreadGroup-group-Runnable-target-String-name-long-stackSize" class="headerlink" title="4.4. Thread(ThreadGroup group, Runnable target, String name, long stackSize)"></a>4.4. Thread(ThreadGroup group, Runnable target, String name, long stackSize)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(ThreadGroup group, Runnable target, String name,</span><br><span class="hljs-params">  <span class="hljs-type">long</span> stackSize)</span> &#123;<br><br><span class="hljs-built_in">this</span>(group, target, name, stackSize, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>ThreadGroup</code> 是一个非常古老且很少被正确使用的功能，在现代开发中几乎永远不会碰它</li></ol></blockquote><hr><h2 id="5-实例方法"><a href="#5-实例方法" class="headerlink" title="5. 实例方法"></a>5. 实例方法</h2><h3 id="5-1-实例具体方法"><a href="#5-1-实例具体方法" class="headerlink" title="5.1. 实例具体方法"></a>5.1. 实例具体方法</h3><h4 id="5-1-1-具体方法（普通）"><a href="#5-1-1-具体方法（普通）" class="headerlink" title="5.1.1. 具体方法（普通）"></a>5.1.1. 具体方法（普通）</h4><h5 id="5-1-1-1-void-start"><a href="#5-1-1-1-void-start" class="headerlink" title="5.1.1.1. void start()"></a>5.1.1.1. void start()</h5><p>该方法用于非阻塞启动一个 <code>Thread</code> 实例</p><p>当我们调用 <code>Thread#start</code> 后，<code>JVM</code> 会在操作系统层面请求创建一个本地线程。一旦操作系统创建了这个本地线程，并将其与 <code>Thread</code> 实例 “绑定”，<code>Thread</code> 实例就会进入可运行状态</p><p>当本地线程被分配到 <code>CPU</code> 时间片后，开始执行 <code>Java</code> 代码，执行的就是 <code>Thread#run</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 实例具体方法（普通）：</span><br><span class="hljs-comment"> * public synchronized void start()</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. synchronized</span><br><span class="hljs-comment"> *          1. 方法加 synchronized 锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. IllegalThreadStateException</span><br><span class="hljs-comment"> *          1. 如果 Thread 实例已启动，但是又被启动，就会抛出 IllegalThreadStateException 异常</span><br><span class="hljs-comment"> *          2. 简单来说就是：一个 Thread 实例只能调用一次 Thread#start</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> * Thread myThread = new Thread(&quot;myThread&quot;) &#123;</span><br><span class="hljs-comment"> *     <span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment"> *     public void run() &#123;</span><br><span class="hljs-comment"> *         // ...</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * myThread.start();</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>group.add(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br>start0();<br>started = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!started) &#123;<br>group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-2-void-interrupt"><a href="#5-1-1-2-void-interrupt" class="headerlink" title="5.1.1.2. void interrupt()"></a>5.1.1.2. void interrupt()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞中断线程</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 该方法会为被中断的 Thread 实例设置中断状态</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 如果被中断的 Thread 实例处于 RUNNABLE 状态，就只会设置 Thread 实例的中断状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果被中断的 Thread 实例处于 BLOCKED、WAITING、TIMED_WAITING 状态，可能有以下几种情况：</span><br><span class="hljs-comment">//     1. 本地线程进入阻塞状态，Thread 实例进入 BWTW 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//     2. 本地线程进入阻塞状态，Thread 实例进入 BWTW 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，不会抛出 InterruptedException 受检异常，但会保留 Thread 实例的中断状态，继续向下执行（正常退出（未发生异常））</span><br><span class="hljs-comment">//     3. 本地线程进入阻塞状态，Thread 实例进入 BWTW 状态后，不能能响应中断。线程会继续阻塞，并会保留 Thread 示例的中断状态。当线程被唤醒后，会继续向下执行（正常退出（未发生异常））</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread()) &#123;<br>checkAccess();<br><br><span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br><span class="hljs-type">Interruptible</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> blocker;<br><span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>interrupt0();<br>b.interrupt(<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br>interrupted = <span class="hljs-literal">true</span>;<br>interrupt0();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-3-void-setPriority-int-newPriority"><a href="#5-1-1-3-void-setPriority-int-newPriority" class="headerlink" title="5.1.1.3. void setPriority(int newPriority)"></a>5.1.1.3. void setPriority(int newPriority)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞设置本地线程的优先级</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// JVM 规定本地线程的优先级为 1 - 10 之间的整数，优先级越高，本地线程被 CPU 调度的可能性越大</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 这里的优先级仅是建议性提示，是否生效取决于具体的调度策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPriority</span><span class="hljs-params">(<span class="hljs-type">int</span> newPriority)</span> &#123;<br><br>ThreadGroup g;<br>checkAccess();<br><span class="hljs-keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>&#125;<br><span class="hljs-keyword">if</span>((g = getThreadGroup()) != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;<br>newPriority = g.getMaxPriority();<br>&#125;<br>setPriority0(priority = newPriority);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-4-int-getPriority"><a href="#5-1-1-4-int-getPriority" class="headerlink" title="5.1.1.4. int getPriority()"></a>5.1.1.4. int getPriority()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞获取本地线程的优先级</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPriority</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> priority;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-5-void-join"><a href="#5-1-1-5-void-join" class="headerlink" title="5.1.1.5. void join()"></a>5.1.1.5. void join()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 Monitor 中的 WaitSet 队列，等待被唤醒（Obect#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>join(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-6-void-join-final-long-millis"><a href="#5-1-1-6-void-join-final-long-millis" class="headerlink" title="5.1.1.6. void join(final long millis)"></a>5.1.1.6. void join(final long millis)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 中的 WaitSet 队列，等待被唤醒（Obect#notify）、被中断、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> millis)</span><br><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (millis &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (isAlive()) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis;<br><span class="hljs-keyword">do</span> &#123;<br>wait(delay);<br>&#125; <span class="hljs-keyword">while</span> (isAlive() &amp;&amp; (delay = millis -<br>TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; <span class="hljs-number">0</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">while</span> (isAlive()) &#123;<br>wait(<span class="hljs-number">0</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>推荐使用 <code>TimeUnit#timedJoin</code> 替代该方法，因为其可读性更好</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeUnit.MINUTES.timedJoin(worker, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="void-join-long-millis-int-nanos"><a href="#void-join-long-millis-int-nanos" class="headerlink" title="void join(long millis, int nanos)"></a>void join(long millis, int nanos)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 中的 WaitSet 队列，等待被唤醒（Obect#notify）、被中断、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br><span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span> || nanos &gt; <span class="hljs-number">999999</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br><span class="hljs-string">&quot;nanosecond timeout value out of range&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span> &amp;&amp; millis &lt; Long.MAX_VALUE) &#123;<br>millis++;<br>&#125;<br><br>join(millis);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-7-void-setDaemon-boolean-on"><a href="#5-1-1-7-void-setDaemon-boolean-on" class="headerlink" title="5.1.1.7. void setDaemon(boolean on)"></a>5.1.1.7. void setDaemon(boolean on)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞设置 Thread 实例为守护线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDaemon</span><span class="hljs-params">(<span class="hljs-type">boolean</span> on)</span> &#123;<br><br>checkAccess();<br><span class="hljs-keyword">if</span> (isAlive()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>&#125;<br>daemon = on;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-1-1-8-boolean-isInterrupted"><a href="#5-1-1-8-boolean-isInterrupted" class="headerlink" title="5.1.1.8. boolean isInterrupted()"></a>5.1.1.8. boolean isInterrupted()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞查看 Thread 实例的中断状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 true，说明 Thread 实例被中断过</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 false，说明 Thread 实例没有被中断过</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> interrupted;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Thread.interrupted</code> 与 <code>Thread#isInterrupted</code> 的区别在于：<code>Thread.interrupted</code> 会清除 <code>Thread</code> 实例的中断状态，而 <code>Thread#isInterrupted</code> 不会</li></ol></blockquote><hr><h5 id="5-1-1-9-boolean-isAlive"><a href="#5-1-1-9-boolean-isAlive" class="headerlink" title="5.1.1.9. boolean isAlive()"></a>5.1.1.9. boolean isAlive()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞查看本地线程是否存活</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlive</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> eetop != <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="5-1-2-具体方法（实现）"><a href="#5-1-2-具体方法（实现）" class="headerlink" title="5.1.2. 具体方法（实现）"></a>5.1.2. 具体方法（实现）</h4><h5 id="5-1-2-1-Runnable-中接口方法的实现"><a href="#5-1-2-1-Runnable-中接口方法的实现" class="headerlink" title="5.1.2.1. Runnable 中接口方法的实现"></a>5.1.2.1. Runnable 中接口方法的实现</h5><h6 id="5-1-2-1-1-void-run"><a href="#5-1-2-1-1-void-run" class="headerlink" title="5.1.2.1.1. void run()"></a>5.1.2.1.1. void run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>target.run();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-静态方法"><a href="#6-静态方法" class="headerlink" title="6. 静态方法"></a>6. 静态方法</h2><h3 id="6-1-静态具体方法"><a href="#6-1-静态具体方法" class="headerlink" title="6.1. 静态具体方法"></a>6.1. 静态具体方法</h3><h4 id="6-1-1-具体方法（普通）"><a href="#6-1-1-具体方法（普通）" class="headerlink" title="6.1.1. 具体方法（普通）"></a>6.1.1. 具体方法（普通）</h4><h5 id="6-1-1-1-void-sleep-long-millis"><a href="#6-1-1-1-void-sleep-long-millis" class="headerlink" title="6.1.1.1. void sleep(long millis)"></a>6.1.1.1. void sleep(long millis)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入阻塞（TIMED_WAITING）状态，等待被中断、阻塞超时</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入阻塞（TIMED_WAITING）状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>推荐使用 <code>TimeUnit#sleep</code> 替代该方法，因为其可读性更好</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TimeUnit.HOURS.sleep(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-2-void-yield"><a href="#6-1-1-2-void-yield" class="headerlink" title="6.1.1.2. void yield()"></a>6.1.1.2. void yield()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞提示线程调度器让出当前本地线程的 CPU 时间片</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 让出 CPU 时间片后，Thread 实例的状态会从 运行状态 ➔ 可运行状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 所谓的 “提示” 是指：仅是建议性提示，是否生效取决于具体的调度策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>本地线程让出 <code>CPU</code> 时间片后，由于是可运行状态，可能会立即被其他 <code>CPU</code> 核重新调度。因此，在多核处理器或系统负载较低的情况下，该方法的效果可能并不明显。但是在单核环境或系统负载较高时，其调度行为会比较明显</li></ol></blockquote><hr><h5 id="6-1-1-3-Thread-currentThread"><a href="#6-1-1-3-Thread-currentThread" class="headerlink" title="6.1.1.3. Thread currentThread()"></a>6.1.1.3. Thread currentThread()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞获取执行当前 Java 代码的本地线程对应的 Thread 实例</span><br><span class="hljs-meta">@IntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Thread <span class="hljs-title function_">currentThread</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-4-boolean-interrupted"><a href="#6-1-1-4-boolean-interrupted" class="headerlink" title="6.1.1.4. boolean interrupted()"></a>6.1.1.4. boolean interrupted()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于非阻塞查看 Thread 实例的中断状态</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 true，说明 Thread 实例被中断过</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果为 false，说明 Thread 实例没有被中断过</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> currentThread();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> t.interrupted;<br><span class="hljs-keyword">if</span> (interrupted) &#123;<br><span class="hljs-comment">// 清除 Thread 实例中的中断状态</span><br>t.interrupted = <span class="hljs-literal">false</span>;<br>clearInterruptEvent();<br>&#125;<br><span class="hljs-keyword">return</span> interrupted;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Thread.interrupted</code> 与 <code>Thread#isInterrupted</code> 的区别在于：<code>Thread.interrupted</code> 会清除 <code>Thread</code> 实例的中断状态，而 <code>Thread#isInterrupted</code> 不会</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RunnableScheduledFuture＜V＞ 源码解析</title>
    <link href="/2025/11/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/05/05/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/05/05/源码：java.util.concurrent.RunnableScheduledFuture＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-RunnableScheduledFuture＜V＞-概述"><a href="#3-1-RunnableScheduledFuture＜V＞-概述" class="headerlink" title="3.1. RunnableScheduledFuture＜V＞ 概述"></a>3.1. RunnableScheduledFuture＜V＞ 概述</h3><p><code>RunnableScheduledFuture＜V＞</code> 是一个接口，继承了<code> java.util.concurrent.RunnableFuture＜V＞</code>、<code>java.util.concurrent.ScheduledFuture＜V＞</code></p><p><code>RunnableScheduledFuture＜V＞</code> 在 <code>RunnableFuture＜V＞</code> 的基础上，提供了以下方法：</p><ol><li>查看任务是否是周期性任务</li></ol><p>如果某实现类实现了 <code>RunnableScheduledFuture＜V＞</code> 接口，就实现了以下接口：<br><img src="/2025/11/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>RunnableFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.RunnableFuture＜V＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ScheduledFuture＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/04/源码：java.util.concurrent.ScheduledFuture＜V＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt;, ScheduledFuture&lt;V&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞查看任务是否是周期性任务</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPeriodic</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReentrantReadWriteLock 源码解析</title>
    <link href="/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/09/源码：java.util.concurrent.locks.ReentrantReadWriteLock源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReentrantReadWriteLock-概述"><a href="#3-1-ReentrantReadWriteLock-概述" class="headerlink" title="3.1. ReentrantReadWriteLock 概述"></a>3.1. ReentrantReadWriteLock 概述</h3><p><code>ReentrantReadWriteLock</code> 是一个具体类，实现了 <code>java.util.concurrent.locks.ReadWriteLock</code>、<code>java.io.Serializable</code><br><img src="/2025/11/09/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ReentrantReadWriteLock</code> 是一种可重入、悲观、公平或非公平、互斥或共享的锁，并且是使用 <code>AQS</code> 实现的混合模式的同步器。<code>State</code> 和共享资源分别表示以下含义：</p><ol><li><code>State</code> 表示写锁或读锁的重入次数<ol><li><code>State</code> 被 <code>ReentrantReadWriteLock</code> 拆分为两部分，分别表示写锁和读锁的重入次数<ol><li>低 <code>16</code> 位表示写锁的重入次数</li><li>高 <code>16</code> 位表示读锁的重入次数</li></ol></li><li>需要注意的是：如果为 <code>0</code>，表示锁空闲，既没有写锁，也没有读锁</li></ol></li><li>共享资源表示加锁期间的操作</li></ol><p>我们可以简单的理解为：<code>ReentrantReadWriteLock</code> 为我们准备了两把锁，一把是读锁，一把是写锁，我们就是依赖这两把锁进行协调，这两把锁遵循这样的规律：</p><ol><li>写写互斥<ol><li>当一个线程持有写锁后，其他线程如果要竞争写锁，必须等待该线程释放写锁</li></ol></li><li>读写互斥<ol><li>当一个线程持有写锁后，其他线程如果要竞争读锁，必须等待该线程释放写锁</li><li>当一个线程持有读锁后，其他线程如果要竞争写锁，必须等待该线程释放读锁</li></ol></li><li>读读共享<ol><li>当一个线程持有读锁后，其他线程如果要竞争读锁，可以直接持有读锁</li><li>也就是说：一个读锁可以被多个线程共享</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ReadWriteLock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReadWriteLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/07/源码：java.util.concurrent.locks.ReadWriteLock源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-ReentrantReadWriteLock-锁降级"><a href="#3-2-ReentrantReadWriteLock-锁降级" class="headerlink" title="3.2. ReentrantReadWriteLock 锁降级"></a>3.2. ReentrantReadWriteLock 锁降级</h3><p><code>ReentrantLock</code> 允许一个线程在持有写锁的情况下竞争读锁，竞争到读锁后再释放写锁。</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code><ol><li>为什么不先释放写锁，再竞争读锁？<ol><li>如果线程 <code>A</code> 写数据后，需要立刻读数据</li><li>如果先释放写锁，再竞争读锁，那么线程 <code>A</code> 释放写锁后，线程 <code>B</code> 可能立即竞争到了写锁</li><li>如果线程 <code>B</code> 也写了数据，则当线程 <code>A</code> 再竞争到读锁的时候，读到的数据就不是刚刚写的数据了</li></ol></li><li>为什么不干脆 “不释放写锁”，直到读完数据？<ol><li>可以这样做，但是性能差，而我们的目标是：在保证数据一致性的前提下，尽可能地提升并发度</li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-3-ReentrantReadWriteLock-适用场景"><a href="#3-3-ReentrantReadWriteLock-适用场景" class="headerlink" title="3.3. ReentrantReadWriteLock 适用场景"></a>3.3. ReentrantReadWriteLock 适用场景</h3><h4 id="3-3-1-读多写少"><a href="#3-3-1-读多写少" class="headerlink" title="3.3.1. 读多写少"></a>3.3.1. 读多写少</h4><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Sync"><a href="#4-1-Sync" class="headerlink" title="4.1. Sync"></a>4.1. Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><hr><h3 id="4-2-FairSync"><a href="#4-2-FairSync" class="headerlink" title="4.2. FairSync"></a>4.2. FairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2274990926593161451L</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-NonfairSync"><a href="#4-3-NonfairSync" class="headerlink" title="4.3. NonfairSync"></a>4.3. NonfairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-ReadLock"><a href="#4-4-ReadLock" class="headerlink" title="4.4. ReadLock"></a>4.4. ReadLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">ReadLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>sync = lock.sync;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.tryReadLock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sync.getReadLockCount();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() +<br><span class="hljs-string">&quot;[Read locks = &quot;</span> + r + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-5-WriteLock"><a href="#4-5-WriteLock" class="headerlink" title="4.5. WriteLock"></a>4.5. WriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">WriteLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;<br>sync = lock.sync;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.tryWriteLock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.newCondition();<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> sync.getOwner();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + ((o == <span class="hljs-literal">null</span>) ?<br>   <span class="hljs-string">&quot;[Unlocked]&quot;</span> :<br>   <span class="hljs-string">&quot;[Locked by thread &quot;</span> + o.getName() + <span class="hljs-string">&quot;]&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldByCurrentThread</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.isHeldExclusively();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHoldCount</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sync.getWriteHoldCount();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-实例方法"><a href="#5-实例方法" class="headerlink" title="5. 实例方法"></a>5. 实例方法</h2><h3 id="5-1-实例具体方法"><a href="#5-1-实例具体方法" class="headerlink" title="5.1. 实例具体方法"></a>5.1. 实例具体方法</h3><h4 id="5-1-1-具体方法（实现）"><a href="#5-1-1-具体方法（实现）" class="headerlink" title="5.1.1. 具体方法（实现）"></a>5.1.1. 具体方法（实现）</h4><h5 id="5-1-1-1-ReadWriteLock-中接口方法的实现"><a href="#5-1-1-1-ReadWriteLock-中接口方法的实现" class="headerlink" title="5.1.1.1. ReadWriteLock 中接口方法的实现"></a>5.1.1.1. ReadWriteLock 中接口方法的实现</h5><h6 id="5-1-1-1-1-WriteLock-writeLock"><a href="#5-1-1-1-1-WriteLock-writeLock" class="headerlink" title="5.1.1.1.1. WriteLock writeLock()"></a>5.1.1.1.1. WriteLock writeLock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span> &#123; <br><br><span class="hljs-keyword">return</span> writerLock; <br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="5-1-1-1-2-ReadLock-readLock"><a href="#5-1-1-1-2-ReadLock-readLock" class="headerlink" title="5.1.1.1.2. ReadLock  readLock()"></a>5.1.1.1.2. ReadLock  readLock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReentrantReadWriteLock.ReadLock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span> &#123; <br><br><span class="hljs-keyword">return</span> readerLock; <br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.Lock 源码解析</title>
    <link href="/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/07/源码：java.util.concurrent.locks.Lock源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Lock-概述"><a href="#3-1-Lock-概述" class="headerlink" title="3.1. Lock 概述"></a>3.1. Lock 概述</h3><p><code>Lock</code> 是一个接口</p><p><code>Lock</code> 为我们提供了以下方法</p><ol><li>竞争锁（阻塞、非阻塞、限时阻塞）</li><li>释放锁（非阻塞）</li><li>创建条件队列（非阻塞）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Monitor</code> 中有竞争队列、等待队列，<code>AQS</code> 中有同步队列、条件队列</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <br>    <span class="hljs-comment">// 用于阻塞竞争锁</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果锁被其他线程持有，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 AQS 的同步队列，等待被唤醒（LockSupport.unpark）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，不能能响应中断。线程会继续阻塞，并会保留 Thread 示例的中断状态。当线程被唤醒后，会继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">// 用于阻塞竞争锁</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果锁被其他线程持有，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 AQS 的同步队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">// 用于非阻塞竞争锁</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果成功，返回 true</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果失败，返回 false</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 所谓的 “非阻塞” 是指：尝试一下，行就行，不行就不行，不要让当前线程进入阻塞（BWTW）状态</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于限时阻塞竞争锁</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：time unit</span><br><span class="hljs-comment">//    1. 如果超时，将返回 false</span><br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果锁被其他线程持有，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 AQS 的同步队列，等待被唤醒（LockSupport.unpark）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果成功，返回 true</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 如果失败，返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于非阻塞释放当前线程持有的锁</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果不持有锁的线程释放锁，抛出 IllegalMonitorStateException 非受检异常</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞创建条件队列</span><br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReadWriteLock 源码解析</title>
    <link href="/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/07/源码：java.util.concurrent.locks.ReadWriteLock源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReadWriteLock-概述"><a href="#3-1-ReadWriteLock-概述" class="headerlink" title="3.1. ReadWriteLock 概述"></a>3.1. ReadWriteLock 概述</h3><p><code>ReadWriteLock</code> 是一个接口</p><p><code>ReadWriteLock</code> 为我们提供了以下方法：</p><ol><li>获取 <code>ReadLock</code>（非阻塞）</li><li>获取 <code>WriteLock</code>（非阻塞）</li></ol><hr><h1 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br><br>    <span class="hljs-comment">// 用于非阻塞获取 ReadLock</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：该方法并不是直接竞争读锁，而是我们获取 ReadLock 后，还需要调用 ReadLock 的方法竞争读锁</span><br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 用于非阻塞获取 WriteLock</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：该方法并不是直接竞争读锁，而是我们获取 WriteLock 后，还需要调用 WriteLock 的方法竞争写锁</span><br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Cloneable 源码解析</title>
    <link href="/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Cloneable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.lang.Cloneable源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Cloneable-概述"><a href="#3-1-Cloneable-概述" class="headerlink" title="3.1. Cloneable 概述"></a>3.1. Cloneable 概述</h3><p><code>Cloneable</code> 是一个接口</p><p><code>Cloneable</code> 是一个标记接口，只要我们 <code>Implements Cloneable</code>，他就告诉 <code>JVM</code> 这个类的对象可以克隆</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cloneable</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Comparable＜T＞ 源码解析</title>
    <link href="/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.lang.Comparable＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Comparable＜T＞-概述"><a href="#3-1-Comparable＜T＞-概述" class="headerlink" title="3.1. Comparable＜T＞ 概述"></a>3.1. Comparable＜T＞ 概述</h3><p><code>Comparable＜T＞</code> 是一个接口</p><p><code>Comparable＜T＞</code> 为我们提供了以下方法：</p><ol><li>配置自然排序的规则</li></ol><p>一些需要排序的 <code>Java</code> 数据类型（例如 <code>TreeSet＜E＞</code>、<code>TreeMap＜K, V＞</code>、<code>ConcurrentSkipListMap＜K, V＞</code>、<code>PriorityQueue＜E＞</code>、<code>PriorityBlockingQueue＜E＞</code>、<code>DelayQueue＜E＞</code>、<code>ScheduledThreadPoolExecutor.DelayedWorkQueue＜E＞</code>），默认会使用 <code>Comparable＜T＞#compareTo</code> 进行比较，从而进行自然排序</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 用于配置自然排序的规则</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Delayed 源码解析</title>
    <link href="/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.util.concurrent.Delayed源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Delayed-概述"><a href="#3-1-Delayed-概述" class="headerlink" title="3.1. Delayed 概述"></a>3.1. Delayed 概述</h3><p><code>Delayed</code> 是一个接口，继承了<code> java.lang.Comparable＜T＞</code><br><img src="/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>Delayed</code> 在 <code>Comparable＜T＞</code> 的基础上，提供了以下方法：</p><ol><li>获取剩余延迟的时间（非阻塞）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Comparable＜T＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.lang.Comparable＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Comparable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.lang.Comparable＜T＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞获取剩余延迟的时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledFuture＜V＞ 源码解析</title>
    <link href="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/04/源码：java.util.concurrent.ScheduledFuture＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledFuture＜V＞-概述"><a href="#3-1-ScheduledFuture＜V＞-概述" class="headerlink" title="3.1. ScheduledFuture＜V＞ 概述"></a>3.1. ScheduledFuture＜V＞ 概述</h3><p><code>ScheduledFuture</code> 是一个接口，继承了<code> java.util.concurrent.Delayed</code>、<code>java.util.concurren.Future＜V＞</code><br><img src="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Delayed</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Delayed源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/06/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Delayed%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/06/源码：java.util.concurrent.Delayed源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Future＜V＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurren.Future＜V＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>, Future&lt;V&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledThreadPoolExecutor 源码解析</title>
    <link href="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/04/源码：java.util.concurrent.ScheduledThreadPoolExecutor源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledThreadPoolExecutor-概述"><a href="#3-1-ScheduledThreadPoolExecutor-概述" class="headerlink" title="3.1. ScheduledThreadPoolExecutor 概述"></a>3.1. ScheduledThreadPoolExecutor 概述</h3><p><code>ScheduledThreadPoolExecutor</code> 是一个具体类，继承了 <code>java.util.concurrent.ThreadPoolExecutor</code>，实现了 <code>java.util.concurrent.ScheduledExecutorService</code></p><p><code>ScheduledThreadPoolExecutor</code> 在 <code>ThreadPoolExecutor</code> 的基础上，只做了三件事：</p><ol><li>使用 <code>ScheduledThreadPoolExecutor.DelayedWorkQueue</code> 作为任务队列</li><li>使用 <code>ScheduledThreadPoolExecutor.ScheduledFutureTask</code> 而不是 <code>FutureTask</code></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ThreadPoolExecutor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ThreadPoolExecutor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/03/源码：java.util.concurrent.ThreadPoolExecutor源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>ScheduledExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.ScheduledExecutorService源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-DelayedWorkQueue"><a href="#4-1-DelayedWorkQueue" class="headerlink" title="4.1. DelayedWorkQueue"></a>4.1. DelayedWorkQueue</h3><p>详见笔记：<code>Java 数据类型</code></p><ol><li><code>obsidian</code> 内部链接<ol><li><a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">笔记：Java数据类型</a></li></ol></li><li><code>Hexo</code> 链接<ol><li></li></ol></li></ol><hr><h3 id="4-2-ScheduledFutureTask"><a href="#4-2-ScheduledFutureTask" class="headerlink" title="4.2. ScheduledFutureTask"></a>4.2. ScheduledFutureTask</h3><p>详见源码：<code>ScheduledFutureTask＜V＞</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/15/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/15/源码：java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask＜V＞源码解析/</a></li></ol></li></ol><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-ScheduledThreadPoolExecutor-int-corePoolSize-ThreadFactory-threadFactory-RejectedExecutionHandler-handler"><a href="#5-1-ScheduledThreadPoolExecutor-int-corePoolSize-ThreadFactory-threadFactory-RejectedExecutionHandler-handler" class="headerlink" title="5.1. ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)"></a>5.1. ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">   ThreadFactory threadFactory,</span><br><span class="hljs-params">   RejectedExecutionHandler handler)</span> &#123;<br><span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE,<br>  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>DEFAULT_KEEPALIVE_MILLIS</code> 是 <code>ScheduledThreadPoolExecutor::DEFAULT_KEEPALIVE_MILLIS</code> ，值为：<code>10L</code></li></ol></blockquote><hr><h2 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h2><h3 id="6-1-实例具体方法"><a href="#6-1-实例具体方法" class="headerlink" title="6.1. 实例具体方法"></a>6.1. 实例具体方法</h3><h4 id="6-1-1-具体方法（实现）"><a href="#6-1-1-具体方法（实现）" class="headerlink" title="6.1.1. 具体方法（实现）"></a>6.1.1. 具体方法（实现）</h4><h5 id="6-1-1-1-Executor-中接口方法的实现"><a href="#6-1-1-1-Executor-中接口方法的实现" class="headerlink" title="6.1.1.1. Executor 中接口方法的实现"></a>6.1.1.1. Executor 中接口方法的实现</h5><h6 id="6-1-1-1-1-void-execute-Runnable-command"><a href="#6-1-1-1-1-void-execute-Runnable-command" class="headerlink" title="6.1.1.1.1. void execute(Runnable command)"></a>6.1.1.1.1. void execute(Runnable command)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><br>schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-2-ExecutorService-中接口方法的实现"><a href="#6-1-1-2-ExecutorService-中接口方法的实现" class="headerlink" title="6.1.1.2. ExecutorService 中接口方法的实现"></a>6.1.1.2. ExecutorService 中接口方法的实现</h5><h6 id="6-1-1-2-1-Future＜-＞-submit-Runnable-task"><a href="#6-1-1-2-1-Future＜-＞-submit-Runnable-task" class="headerlink" title="6.1.1.2.1. Future＜?＞ submit(Runnable task)"></a>6.1.1.2.1. Future＜?＞ submit(Runnable task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br><br><span class="hljs-keyword">return</span> schedule(task, <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-2-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result"><a href="#6-1-1-2-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result" class="headerlink" title="6.1.1.2.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)"></a>6.1.1.2.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br><br><span class="hljs-keyword">return</span> schedule(Executors.callable(task, result), <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-2-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task"><a href="#6-1-1-2-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task" class="headerlink" title="6.1.1.2.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)"></a>6.1.1.2.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br><br><span class="hljs-keyword">return</span> schedule(task, <span class="hljs-number">0</span>, NANOSECONDS);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="6-1-1-3-ScheduledExecutorService-中接口方法的实现"><a href="#6-1-1-3-ScheduledExecutorService-中接口方法的实现" class="headerlink" title="6.1.1.3. ScheduledExecutorService 中接口方法的实现"></a>6.1.1.3. ScheduledExecutorService 中接口方法的实现</h5><h6 id="6-1-1-3-1-ScheduledFuture＜-＞-schedule-Runnable-comm-long-delay-TimeUnit-unit"><a href="#6-1-1-3-1-ScheduledFuture＜-＞-schedule-Runnable-comm-long-delay-TimeUnit-unit" class="headerlink" title="6.1.1.3.1. ScheduledFuture＜?＞ schedule(Runnable comm, long delay, TimeUnit unit)"></a>6.1.1.3.1. ScheduledFuture＜?＞ schedule(Runnable comm, long delay, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>   <span class="hljs-type">long</span> delay,<br>   TimeUnit unit) &#123;<br><br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,<br>  triggerTime(delay, unit),<br>  sequencer.getAndIncrement()));<br>  <br>delayedExecute(t);<br><br><span class="hljs-keyword">return</span> t;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-3-2-＜V＞-ScheduledFuture＜V＞-schedule-Callable＜V＞-callable-long-delay-TimeUnit-unit"><a href="#6-1-1-3-2-＜V＞-ScheduledFuture＜V＞-schedule-Callable＜V＞-callable-long-delay-TimeUnit-unit" class="headerlink" title="6.1.1.3.2. ＜V＞ ScheduledFuture＜V＞ schedule(Callable＜V＞ callable, long delay, TimeUnit unit)"></a>6.1.1.3.2. ＜V＞ ScheduledFuture＜V＞ schedule(Callable＜V＞ callable, long delay, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">   <span class="hljs-type">long</span> delay,</span><br><span class="hljs-params">   TimeUnit unit)</span> &#123;<br><span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;V&gt;(callable,<br>   triggerTime(delay, unit),<br>   sequencer.getAndIncrement()));<br>delayedExecute(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-3-3-ScheduledFuture＜-＞-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit"><a href="#6-1-1-3-3-ScheduledFuture＜-＞-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit" class="headerlink" title="6.1.1.3.3. ScheduledFuture＜?＞ scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)"></a>6.1.1.3.3. ScheduledFuture＜?＞ scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>  <span class="hljs-type">long</span> initialDelay,<br>  <span class="hljs-type">long</span> period,<br>  TimeUnit unit) &#123;<br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>ScheduledFutureTask&lt;Void&gt; sft =<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>  <span class="hljs-literal">null</span>,<br>  triggerTime(initialDelay, unit),<br>  unit.toNanos(period),<br>  sequencer.getAndIncrement());<br>RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br>sft.outerTask = t;<br>delayedExecute(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-3-4-ScheduledFuture＜-＞-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit"><a href="#6-1-1-3-4-ScheduledFuture＜-＞-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit" class="headerlink" title="6.1.1.3.4. ScheduledFuture＜?＞ scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)"></a>6.1.1.3.4. ScheduledFuture＜?＞ scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br> <span class="hljs-type">long</span> initialDelay,<br> <span class="hljs-type">long</span> delay,<br> TimeUnit unit) &#123;<br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>ScheduledFutureTask&lt;Void&gt; sft =<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>  <span class="hljs-literal">null</span>,<br>  triggerTime(initialDelay, unit),<br>  -unit.toNanos(delay),<br>  sequencer.getAndIncrement());<br>RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br>sft.outerTask = t;<br>delayedExecute(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ThreadPoolExecutor.Worker 源码解析</title>
    <link href="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/04/源码：java.util.concurrent.ThreadPoolExecutor.Worker源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ThreadPoolExecutor-Worker-概述"><a href="#3-1-ThreadPoolExecutor-Worker-概述" class="headerlink" title="3.1. ThreadPoolExecutor.Worker 概述"></a>3.1. ThreadPoolExecutor.Worker 概述</h3><p>想象这样一个问题：我们的 <code>Thread</code> 是用来执行一个 <code>Runnable</code> 类型的任务，任务执行完毕后，<code>Thread</code> 就会进入 “死亡” 状态。可是在线程池中，我们希望的是能够复用线程，让它们持续地从任务队列中获取并执行任务</p><p>为了解决这一问题，<code>Doug Lea</code> 引入了 <code>Worker</code> 的概念。<code>Worker</code> 本身实现了 <code>Runnable</code> 接口，因此它也是一个 <code>Runnable</code> 类型的任务。我们让 <code>Thread</code> 执行这个 <code>Worker</code>，而在 <code>Worker</code> 的 <code>run</code> 中，使用一个循环不断地从任务队列中获取任务并执行。这样，就 “另辟蹊径” 的实现了 “复用线程”<br><img src="/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>Worker</code> 是一个具体类，是 <code>java.util.concurrent.ThreadPoolExecutor</code> 的成员内部类，继承了 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>，实现了<code> java.lang.Runnable</code></p><p><code>Worker</code> 是使用 <code>AQS</code> 实现的状态机，<code>State</code> 表示以下含义：</p><ol><li><code>-1</code><ol><li><code>Worker</code> 正在被实例化</li></ol></li><li><code>0</code><ol><li><code>Worker</code> 并没有 “执行” 任务（正在从任务队列中获取任务）</li></ol></li><li><code>1</code><ol><li><code>Worker</code> 正在 “执行” 任务</li></ol></li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br><span class="hljs-comment">// 表示 Worker 封装的 Thread 实例</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该 Thread 实例负责执行 Worker#run，并且是在 Worker 被实例化的时候被实例化的</span><br><span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="hljs-keyword">final</span> Thread thread;<br><br><span class="hljs-comment">// 表示 Worker 的 “启动任务”</span><br><span class="hljs-meta">@SuppressWarnings(&quot;serial&quot;)</span> <br>Runnable firstTask;<br><br><span class="hljs-comment">// 表示 Worker 已完成任务的任务数量</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>Worker(Runnable firstTask) &#123;<br>setState(-<span class="hljs-number">1</span>); <br><span class="hljs-built_in">this</span>.firstTask = firstTask;<br><span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 调用 ThreadPoolExecutor#runWorker，并把 this 作为方法参数传递进去</span><br>runWorker(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>setState(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <br>acquire(<span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; <br>release(<span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">return</span> isHeldExclusively(); <br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>Thread t;<br><span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.interrupt();<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.AbstractExecutorService 源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.AbstractExecutorService源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractExecutorService-概述"><a href="#3-1-AbstractExecutorService-概述" class="headerlink" title="3.1. AbstractExecutorService 概述"></a>3.1. AbstractExecutorService 概述</h3><p><code>AbstractExecutorService</code> 是一个抽象类，实现了 <code>java.util.concurrent.ExecutorService</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>AbstractExecutorService</code> 为 <code>ExecutorService</code> 中的部分通用逻辑提供了实现</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/03/源码：java.util.concurrent.ExecutorService源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-实例方法"><a href="#4-实例方法" class="headerlink" title="4. 实例方法"></a>4. 实例方法</h2><h3 id="4-1-实例具体方法"><a href="#4-1-实例具体方法" class="headerlink" title="4.1. 实例具体方法"></a>4.1. 实例具体方法</h3><h4 id="4-1-1-具体方法（普通）"><a href="#4-1-1-具体方法（普通）" class="headerlink" title="4.1.1. 具体方法（普通）"></a>4.1.1. 具体方法（普通）</h4><h5 id="4-1-1-1-＜T＞-RunnableFuture＜T＞-newTaskFor-Callable＜T＞-callable"><a href="#4-1-1-1-＜T＞-RunnableFuture＜T＞-newTaskFor-Callable＜T＞-callable" class="headerlink" title="4.1.1.1. ＜T＞ RunnableFuture＜T＞ newTaskFor(Callable＜T＞ callable)"></a>4.1.1.1. ＜T＞ RunnableFuture＜T＞ newTaskFor(Callable＜T＞ callable)</h5><p>该方法用于非阻塞将 <code>Callable</code> 任务封装成 <code>RunnableFuture</code> 类型（实则是封装成 <code>FutureTask</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="4-1-1-2-＜T＞-RunnableFuture＜T＞-newTaskFor-Runnable-runnable-T-value"><a href="#4-1-1-2-＜T＞-RunnableFuture＜T＞-newTaskFor-Runnable-runnable-T-value" class="headerlink" title="4.1.1.2. ＜T＞ RunnableFuture＜T＞ newTaskFor(Runnable runnable, T value)"></a>4.1.1.2. ＜T＞ RunnableFuture＜T＞ newTaskFor(Runnable runnable, T value)</h5><p>该方法用于非阻塞将 <code>Runnable</code> 任务封装成 <code>RunnableFuture</code> 类型（实则是封装成 <code>FutureTask</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-2-具体方法（实现）"><a href="#4-1-2-具体方法（实现）" class="headerlink" title="4.1.2. 具体方法（实现）"></a>4.1.2. 具体方法（实现）</h4><h5 id="4-1-2-1-ExecutorService-中接口方法的实现"><a href="#4-1-2-1-ExecutorService-中接口方法的实现" class="headerlink" title="4.1.2.1. ExecutorService 中接口方法的实现"></a>4.1.2.1. ExecutorService 中接口方法的实现</h5><h6 id="4-1-2-1-1-Future＜-＞-submit-Runnable-task"><a href="#4-1-2-1-1-Future＜-＞-submit-Runnable-task" class="headerlink" title="4.1.2.1.1. Future＜?＞ submit(Runnable task)"></a>4.1.2.1.1. Future＜?＞ submit(Runnable task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 实例具体方法（ExecutorService 接口方法 实现）：</span><br><span class="hljs-comment"> * public Future&lt;?&gt; submit(Runnable task)</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. Runnable task</span><br><span class="hljs-comment"> *          1. 提交的 Runnable 任务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. Runnable 任务封装成的 FutureTask 实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. NullPointerException</span><br><span class="hljs-comment"> *          1. 传入的 Runnable 任务为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br><br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-comment">// 调用 AbstractExecutorService#newTaskFor，将 Runnable 任务封装成一种 RunnableFuture（实则是封装成 FutureTask）</span><br>RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 调用 Executor#execute，提交一个 Runnable 任务</span><br>execute(ftask);<br><br><span class="hljs-comment">// 返回 Runnable 任务封装成的 FutureTask</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 之所以返回该 FutureTask 实例，是因为我们可能需要通过该 FutureTask 实例，调用 Future&lt;V&gt; 相关的方法，去对该任务进行一系才足以</span><br><span class="hljs-keyword">return</span> ftask;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="4-1-2-1-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result"><a href="#4-1-2-1-2-＜T＞-Future＜T＞-submit-Runnable-task-T-result" class="headerlink" title="4.1.2.1.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)"></a>4.1.2.1.2. ＜T＞ Future＜T＞ submit(Runnable task, T result)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br><br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br><br>execute(ftask);<br><br><span class="hljs-keyword">return</span> ftask;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="4-1-2-1-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task"><a href="#4-1-2-1-3-＜T＞-Future＜T＞-submit-Callable＜T＞-task" class="headerlink" title="4.1.2.1.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)"></a>4.1.2.1.3. ＜T＞ Future＜T＞ submit(Callable＜T＞ task)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br><br><span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br><br>execute(ftask);<br><br><span class="hljs-keyword">return</span> ftask;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.FutureTask＜V＞ 源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.FutureTask＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-FutureTask-概述"><a href="#3-1-FutureTask-概述" class="headerlink" title="3.1. FutureTask 概述"></a>3.1. FutureTask 概述</h3><p><code>FutureTask</code> 是一个具体类，继承了 <code>java.util.concurrent.RunnableFuture&lt;V&gt;</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>RunnableFuture&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.RunnableFuture＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.RunnableFuture＜V＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-FutureTask-相关状态"><a href="#3-2-FutureTask-相关状态" class="headerlink" title="3.2. FutureTask 相关状态"></a>3.2. FutureTask 相关状态</h3><ol><li><code>NEW（0）</code><ol><li>表示任务的初始状态</li></ol></li><li><code>COMPLETING（1）</code><ol><li>表示任务已经执行完毕，在赋值最终结果</li><li>这是一个非常短暂的瞬间状态</li></ol></li><li><code>NORMAL（2）</code><ol><li>表示任务正常退出</li></ol></li><li><code>EXCEPTIONAL（3）</code><ol><li>表示任务异常退出</li></ol></li><li><code>CANCELLED（4）</code><ol><li>表示任务已被取消</li></ol></li><li><code>INTERRUPTING（5）</code><ol><li>表示任务正在被停止</li></ol></li><li><code>INTERRUPTED（6）</code><ol><li>表示任务已被停止</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>取消任务和停止任务还是有所区别的：取消任务是指取消那些尚未执行的任务。而停止任务则是任务正在执行时，你通过中断去让它停下来。如果任务能够响应中断，那就算是成功停止。但问题在于，如果任务没有响应中断，那么即使你发出了中断请求，它仍然会继续执行。所以 “停止任务” 并不一定能让它 “停止下来”</li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-WaitNode"><a href="#4-1-WaitNode" class="headerlink" title="4.1. WaitNode"></a>4.1. WaitNode</h3><p><code>FutureTask</code> 的 <code>WaitNode</code> 链表就是由 <code>WaitNode</code> 构建的单向链表。所有因为调用 <code>Future#get</code> 而阻塞的 Thread 实例都会被投递到该队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br><br><span class="hljs-keyword">volatile</span> Thread thread;<br><br><span class="hljs-keyword">volatile</span> WaitNode next;<br><br>WaitNode() &#123; thread = Thread.currentThread(); &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示 FutureTask 的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 NEW 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 COMPLETING 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 NORMAL 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 EXCEPTIONAL 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 CANCELLED 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 INTERRUPTING 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 用于界定 FutureTask 的 INTERRUPTED 状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">// 表示 FutureTask 封装的 Callable 任务</span><br><span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br><br><span class="hljs-comment">// 表示 FutureTask 封装的 Callable 任务的结果</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 需要注意的是，返回值是 Object 类型，说明既能应对正常退出，又能应对异常退出</span><br><span class="hljs-keyword">private</span> Object outcome; <br><br><span class="hljs-comment">// 表示执行 FutureTask 的 Thread 实例</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br><br><span class="hljs-comment">// 表示 FutureTask 的 WaitNode 链表（单向）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br></code></pre></td></tr></table></figure><hr><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6. 构造方法"></a>6. 构造方法</h2><h3 id="6-1-FutureTask-Callable＜V＞-callable"><a href="#6-1-FutureTask-Callable＜V＞-callable" class="headerlink" title="6.1. FutureTask(Callable＜V＞ callable)"></a>6.1. FutureTask(Callable＜V＞ callable)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br><br><span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-built_in">this</span>.callable = callable;<br><br><span class="hljs-built_in">this</span>.state = NEW;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-2-FutureTask-Runnable-runnable-V-result"><a href="#6-2-FutureTask-Runnable-runnable-V-result" class="headerlink" title="6.2. FutureTask(Runnable runnable, V result)"></a>6.2. FutureTask(Runnable runnable, V result)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br><br><span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br><br><span class="hljs-built_in">this</span>.state = NEW;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-实例方法"><a href="#7-实例方法" class="headerlink" title="7. 实例方法"></a>7. 实例方法</h2><h3 id="7-1-实例具体方法"><a href="#7-1-实例具体方法" class="headerlink" title="7.1. 实例具体方法"></a>7.1. 实例具体方法</h3><h4 id="7-1-1-具体方法（实现）"><a href="#7-1-1-具体方法（实现）" class="headerlink" title="7.1.1. 具体方法（实现）"></a>7.1.1. 具体方法（实现）</h4><h5 id="7-1-1-1-Runnable-中接口方法的实现"><a href="#7-1-1-1-Runnable-中接口方法的实现" class="headerlink" title="7.1.1.1. Runnable 中接口方法的实现"></a>7.1.1.1. Runnable 中接口方法的实现</h5><h6 id="7-1-1-1-1-void-run"><a href="#7-1-1-1-1-void-run" class="headerlink" title="7.1.1.1.1. void run()"></a>7.1.1.1.1. void run()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (state != NEW ||<br>!RUNNER.compareAndSet(<span class="hljs-built_in">this</span>, <span class="hljs-literal">null</span>, Thread.currentThread()))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>Callable&lt;V&gt; c = callable;<br><span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>V result;<br><span class="hljs-type">boolean</span> ran;<br><span class="hljs-keyword">try</span> &#123;<br>result = c.call();<br>ran = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>result = <span class="hljs-literal">null</span>;<br>ran = <span class="hljs-literal">false</span>;<br>setException(ex);<br>&#125;<br><span class="hljs-keyword">if</span> (ran)<br>set(result);<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>runner = <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br><span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>handlePossibleCancellationInterrupt(s);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="7-1-1-2-Future-中接口方法的实现"><a href="#7-1-1-2-Future-中接口方法的实现" class="headerlink" title="7.1.1.2. Future 中接口方法的实现"></a>7.1.1.2. Future 中接口方法的实现</h5><h6 id="7-1-1-2-1-boolean-cancel-boolean-mayInterruptIfRunning"><a href="#7-1-1-2-1-boolean-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="7.1.1.2.1. boolean cancel(boolean mayInterruptIfRunning)"></a>7.1.1.2.1. boolean cancel(boolean mayInterruptIfRunning)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br><br><span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet<br>  (<span class="hljs-built_in">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>t.interrupt();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>STATE.setRelease(<span class="hljs-built_in">this</span>, INTERRUPTED);<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>finishCompletion();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-2-boolean-isCancelled"><a href="#7-1-1-2-2-boolean-isCancelled" class="headerlink" title="7.1.1.2.2. boolean isCancelled()"></a>7.1.1.2.2. boolean isCancelled()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-3-boolean-isDone"><a href="#7-1-1-2-3-boolean-isDone" class="headerlink" title="7.1.1.2.3. boolean isDone()"></a>7.1.1.2.3. boolean isDone()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> state != NEW;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-4-get"><a href="#7-1-1-2-4-get" class="headerlink" title="7.1.1.2.4. get()"></a>7.1.1.2.4. get()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br><br><span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><br><span class="hljs-keyword">return</span> report(s);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-1-2-5-get-long-timeout-TimeUnit-unit"><a href="#7-1-1-2-5-get-long-timeout-TimeUnit-unit" class="headerlink" title="7.1.1.2.5. get(long timeout, TimeUnit unit)"></a>7.1.1.2.5. get(long timeout, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br><br><span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br><br><span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>(s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br><br><span class="hljs-keyword">return</span> report(s);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.RunnableFuture＜V＞ 源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.RunnableFuture＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-RunnableFuture-概述"><a href="#3-1-RunnableFuture-概述" class="headerlink" title="3.1. RunnableFuture 概述"></a>3.1. RunnableFuture 概述</h3><p><code>RunnableFuture</code> 是一个接口，继承了 <code>java.util.concurrent.Runnable</code>、<code>java.util.concurrent.Future&lt;V&gt;</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.RunnableFuture%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.Runnable源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Future&lt;V&gt;</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurren.Future＜V＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurren.Future＜V＞源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt; &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ScheduledExecutorService 源码解析</title>
    <link href="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.ScheduledExecutorService源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ScheduledExecutorService-概述"><a href="#3-1-ScheduledExecutorService-概述" class="headerlink" title="3.1. ScheduledExecutorService 概述"></a>3.1. ScheduledExecutorService 概述</h3><p><code>ScheduledExecutorService</code> 是一个接口，继承了 <code>java.util.concurrent.ExecutorService</code><br><img src="/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ScheduledExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ScheduledExecutorService</code> 在 <code>ExecutorService</code> 的基础上，为我们提供了以下方法：</p><ol><li>提交一个 <code>Runnable</code> 任务并延迟执行（非阻塞）</li><li>提交一个 <code>Runnable</code> 任务并以固定速率周期性执行（非阻塞）</li><li>提交一个 <code>Runnable</code> 任务并以固定延迟周期性执行（非阻塞）</li><li>提交一个 <code>Callable</code> 任务并延迟执行（非阻塞）</li></ol><p>简单来说，<code>ExecutorService</code> 提供的方法都是任务提交后 “立即执行”，但是 <code>ScheduledExecutorService</code> 允许我们延迟执行任务、周期性执行任务</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/03/源码：java.util.concurrent.ExecutorService源码解析/</a></li></ol></li></ol></li><li>所谓的 “延迟执行” 是指：在指定的延迟时间到达后，任务 “可以被执行”。但它是否会立即真正运行，还取决于是否有空闲线程可以执行该任务。因此在高并发场景下，任务的实际执行时间可能会比指定的延迟时间更晚。</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并延迟 delay unit 时间后再执行</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable comm<br>                                       <span class="hljs-type">long</span> delay, TimeUnit unit);<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Callable 任务，并延迟 delay unit 时间后再执行</span><br>    <span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                           <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并延迟 delay unit 时间后再执行，并以固定速率周期性执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 延迟 initialDelay unit 时间后首次执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 然后以 period unit 固定速率周期性执行，例如 initialDelay unit 为 0s，period unit 为 5s</span><br><span class="hljs-comment">//     1. 第一次执行开始的时间为 0s</span><br><span class="hljs-comment">//     2. 第二次执行快速的时间为 5s</span><br><span class="hljs-comment">//     3. 第三次执行开始的时间为 10s</span><br><span class="hljs-comment">//     4. 以此类推...</span><br><span class="hljs-comment">//     5. 如果第一次执行的任务，耗时 7s，则该任务执行完成后，需要再次立即执行，去弥补第二次的空缺</span><br><span class="hljs-comment">//     6. 如果第二次执行的任务，仍然耗时 7s，则该任务执行完成后，需要再次立即执行，去弥补第三次的空缺</span><br><span class="hljs-comment">//     7. 如果第三次执行的任务，依旧耗时 7s，则该任务执行完成后，需要再次立即执行，去弥补第四次的空缺</span><br><span class="hljs-comment">//     8. 以此类推...</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 需要注意的是，如果执行任务的耗时 ＞ period unit，后续的任务执行可能会开始比较晚，但是不会并发执行。这种情况下就成一种连续执行了，上一个任务刚结束，下一个任务就开始，中间没有任何停顿</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                                  <span class="hljs-type">long</span> initialDelay,<br>                                                  <span class="hljs-type">long</span> period,<br>                                                  TimeUnit unit);<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并延迟 delay unit 时间后再执行，并以固定延迟周期性执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 延迟 initialDelay unit 后首次执行</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 然后以 period unit 固定延迟周期性执行，例如 initialDelay unit 为 0s，period unit 为 5s</span><br><span class="hljs-comment">//     1. 第一次执行的时间为 0s，如果该任务耗时 7s</span><br><span class="hljs-comment">//     2. 第二次执行的时间为 7s + 5s，即 12s，如果该任务耗时 5s</span><br><span class="hljs-comment">//     3. 第三次执行的时间为 12s + 5s，即 17s</span><br><span class="hljs-comment">//     4. 以此类推...</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                     <span class="hljs-type">long</span> initialDelay,<br>                                                     <span class="hljs-type">long</span> delay,<br>                                                     TimeUnit unit);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.io.Serializable 源码解析</title>
    <link href="/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Serializable-概述"><a href="#3-1-Serializable-概述" class="headerlink" title="3.1. Serializable 概述"></a>3.1. Serializable 概述</h3><p><code>Serializable</code> 是一个接口</p><p><code>Serializable</code> 是一个标记接口，只要我们 <code>Implements Serializable</code>，他就告诉 <code>JVM</code> 这个类的对象可以被序列化和反序列化</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>主要用于 <code>JDK</code> 序列化，其他序列化方式不需要实现该接口</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.AutoCloseable源码解析</title>
    <link href="/2025/10/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.AutoCloseable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/10/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.AutoCloseable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO-🐉"><a href="#1-TODO-🐉" class="headerlink" title="1. TODO 🐉"></a>1. TODO 🐉</h2><hr><h2 id="2-脑图-🐉"><a href="#2-脑图-🐉" class="headerlink" title="2. 脑图 🐉"></a>2. 脑图 🐉</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/10/10/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.AutoCloseable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/10/源码：java.lang.AutoCloseable源码解析/</a></p></li><li><p>代码洪荒（面试宝典）</p></li></ol><hr><h2 id="3-基础部分-🐉"><a href="#3-基础部分-🐉" class="headerlink" title="3. 基础部分 🐉"></a>3. 基础部分 🐉</h2><h3 id="3-1-AutoCloseable-概述-🐉"><a href="#3-1-AutoCloseable-概述-🐉" class="headerlink" title="3.1. AutoCloseable 概述 🐉"></a>3.1. AutoCloseable 概述 🐉</h3><p><code>AutoCloseable</code> 是一个接口</p><p><code>AutoCloseable</code> 接口通常会搭配 <code>try-with-resources</code> 语法糖</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在传统的 <code>try-catch-finally</code> 语句中，我们通常需要在 <code>finally</code> 块中编写释放资源的 <code>Java</code> 代码，这不仅增加了代码冗余，也容易导致资源泄漏（因为一时疏忽）</li><li>而 <code>try-with-resources</code> 是一种语法糖，在编译阶段中被编译器自动转换为以下的逻辑：在执行完毕 <code>try</code> 块（无论是否抛出异常）后，线程会自动调用实现 <code>AutoCloseable</code> 接口的具体类的 <code>AutoCloseable#close</code>，从而达到安全、可靠的释放资源的目的</li><li>在使用 <code>try-with-resources</code> 语法糖的过程中，我们无需也不应该手动释放资源。一个典型的 <code>try-with-resources</code> 语法糖：</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>()) &#123;<br>log.info(<span class="hljs-string">&quot;...&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>log.info(<span class="hljs-string">&quot;...&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>log.info(<span class="hljs-string">&quot;...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-源码部分-🐉"><a href="#4-源码部分-🐉" class="headerlink" title="4. 源码部分 🐉"></a>4. 源码部分 🐉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Object 源码解析</title>
    <link href="/2025/09/24/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/24/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/24/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Object%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/24/源码：java.lang.Object源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Object-概述"><a href="#3-1-Object-概述" class="headerlink" title="3.1. Object 概述"></a>3.1. Object 概述</h3><p><code>Object</code> 是一个具体类</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Object</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-comment">// 用于非阻塞获取类对象</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br><span class="hljs-comment">// 用于非阻塞获取哈希码</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞比较是否 ”相等“</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 默认比较的是内存地址</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>    &#125;<br><br><span class="hljs-comment">// 用于配置克隆机制，详见笔记：GOF 设计模式（obsidian 内部链接：[笔记：GOF设计模式](笔记：GOF设计模式.md)，Hexo 链接：）</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br><br><span class="hljs-comment">// 用于非阻塞获取 ”字符串表示形式“</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 Monitor 的 WaitSet 中的 “任意” 一个 Thread 实例，被唤醒的 Thread 实例被直接投递到 Monitor 的 EntryList 队列</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 所谓的 “任意” 是指：既不是严格的随机，也不保证是第一个，不同的 JVM 实现可能采用不同的策略</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#notify 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#notify，必须先获取 Monitor 锁。</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 Monitor 的 WaitSet 中的所有 Thread 实例，被唤醒的 Thread 实例被直接投递到 Monitor 的 EntryList 队列</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#notify 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#notify，必须先获取 Monitor 锁。</span><br>    <span class="hljs-meta">@IntrinsicCandidate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 Monitor 的 WaitSet 队列，等待被唤醒（Object#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#wait 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#wait，必须先获取 Monitor 锁。从 Object#wait 唤醒的本地线程，同样也需要先获取 Monitor 锁才能继续向下执行。从 Object#wait 响应中断的本地线程，同样也需要先获取 Monitor 锁才能抛出InterruptedException 异常。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        wait(<span class="hljs-number">0L</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 的 WaitSet 队列，等待被唤醒（Object#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#wait 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#wait，必须先获取 Monitor 锁。从 Object#wait 唤醒的本地线程，同样也需要先获取 Monitor 锁才能继续向下执行。从 Object#wait 响应中断的本地线程，同样也需要先获取 Monitor 锁才能抛出InterruptedException 异常。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 推荐使用 TimeUnit#timedWait 替代该方法，因为其可读性更好：TimeUnit.SECONDES.timedWait(obj, 5)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutMillis)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Monitor 的 WaitSet 队列，等待被唤醒（Object#notify）、被中断</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Object#wait 是和 synchronized 绑定的，它必须出现在 synchronized 代码块中，否则会抛出异常。也就是说：本地线程要想调用 Object#wait，必须先获取 Monitor 锁。从 Object#wait 唤醒的本地线程，同样也需要先获取 Monitor 锁才能继续向下执行。从 Object#wait 响应中断的本地线程，同样也需要先获取 Monitor 锁才能抛出InterruptedException 异常。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 推荐使用 TimeUnit#timedWait 替代该方法，因为其可读性更好：TimeUnit.SECONDES.timedWait(obj, 5)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutMillis, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (timeoutMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeoutMillis value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span> || nanos &gt; <span class="hljs-number">999999</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                                <span class="hljs-string">&quot;nanosecond timeout value out of range&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span> &amp;&amp; timeoutMillis &lt; Long.MAX_VALUE) &#123;<br>            timeoutMillis++;<br>        &#125;<br><br>        wait(timeoutMillis);<br>    &#125;<br><br><span class="hljs-comment">// 用于配置实例的 finalization 机制，详见笔记：JVM</span><br>    <span class="hljs-meta">@Deprecated(since=&quot;9&quot;)</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：Ijava.time.nstant 源码解析</title>
    <link href="/2025/09/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.time.Instant%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/16/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.time.Instant%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/16/%E6%BA%90%E7%A0%81%EF%BC%9AInstant%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/16/源码：Instant源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Instant-概述"><a href="#3-1-Instant-概述" class="headerlink" title="3.1. Instant 概述"></a>3.1. Instant 概述</h3><p><code>Instant</code> 表示一个时间点，是一个自 <code>1970-01-01 00:00:00 UTC</code> 起算的秒数 + 纳秒数，对应 <code>UTC</code> 时间线上的某个刻度</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>它相当于 <code>Java</code> 里的纳秒级 <code>Unix</code> 时间戳</li></ol></blockquote><hr><h2 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h2><h3 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1. 构造方法"></a>4.1. 构造方法</h3><h4 id="4-1-1-Instant-now"><a href="#4-1-1-Instant-now" class="headerlink" title="4.1.1. Instant.now()"></a>4.1.1. Instant.now()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造一个当前时间点对应的 Instant 实例</span><br><span class="hljs-type">Instant</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Instant.now();<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-2-Instant-ofEpochSecond-long-epochSecond"><a href="#4-1-2-Instant-ofEpochSecond-long-epochSecond" class="headerlink" title="4.1.2. Instant.ofEpochSecond (long epochSecond)"></a>4.1.2. Instant.ofEpochSecond (long epochSecond)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造一个秒级 Unix 时间戳对应的 Instant 实例</span><br><span class="hljs-type">Instant</span> <span class="hljs-variable">fromSeconds</span> <span class="hljs-operator">=</span> Instant.ofEpochSecond(<span class="hljs-number">1631788800</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="4-1-3-Instant-ofEpochMilli-long-epochMilli"><a href="#4-1-3-Instant-ofEpochMilli-long-epochMilli" class="headerlink" title="4.1.3. Instant.ofEpochMilli (long epochMilli)"></a>4.1.3. Instant.ofEpochMilli (long epochMilli)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造一个毫秒级 Unix 时间戳对应的 Instant 实例</span><br><span class="hljs-type">Instant</span> <span class="hljs-variable">fromMillis</span>  <span class="hljs-operator">=</span> Instant.ofEpochMilli(<span class="hljs-number">1631788800000L</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="4-2-实例方法"><a href="#4-2-实例方法" class="headerlink" title="4.2. 实例方法"></a>4.2. 实例方法</h3><h4 id="4-2-1-获取-Unix-时间戳"><a href="#4-2-1-获取-Unix-时间戳" class="headerlink" title="4.2.1. 获取 Unix 时间戳"></a>4.2.1. 获取 Unix 时间戳</h4><h5 id="4-2-1-1-long-getEpochSecond"><a href="#4-2-1-1-long-getEpochSecond" class="headerlink" title="4.2.1.1. long getEpochSecond()"></a>4.2.1.1. long getEpochSecond()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 返回值</span><br><span class="hljs-comment"> *      1. 某 Instant 实例的秒级 Unix 时间戳</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 获取某 Instant 实例的秒级 Unix 时间戳</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 会有精度截断</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-variable">epochSecond</span> <span class="hljs-operator">=</span> xxInstant.getEpochSecond();<br></code></pre></td></tr></table></figure><hr><h5 id="4-2-1-2-long-toEpochMilli"><a href="#4-2-1-2-long-toEpochMilli" class="headerlink" title="4.2.1.2. long toEpochMilli()"></a>4.2.1.2. long toEpochMilli()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 返回值</span><br><span class="hljs-comment"> *      1. 获取某 Instant 实例的毫秒级 Unix 时间戳</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 获取某 Instant 实例的毫秒级 Unix 时间戳</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 会有精度截断</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-variable">epochMilli</span> <span class="hljs-operator">=</span> xxInstant.toEpochMilli();<br></code></pre></td></tr></table></figure><hr><h5 id="4-2-1-3-int-getNano"><a href="#4-2-1-3-int-getNano" class="headerlink" title="4.2.1.3. int getNano()"></a>4.2.1.3. int getNano()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 返回值</span><br><span class="hljs-comment"> *      1. 某 Instant 实例的秒内的纳秒偏移量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 作用</span><br><span class="hljs-comment"> *      1. 获取某 Instant 实例的秒内的纳秒偏移量</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 7. 注意事项</span><br><span class="hljs-comment"> *      1. 并不是获取某 Instant 实例的纳秒级 Unix 时间戳</span><br><span class="hljs-comment"> *      2. 想要获取某 Instant 实例的纳秒级时间戳，可以：xxInstant.getEpochSecond() * 1_000_000_000L + xxInstant.getNano()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">nano</span> <span class="hljs-operator">=</span> xxInstant.getNano();<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记：Java 日期时间</title>
    <link href="/2025/09/16/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    <url>/2025/09/16/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TODO"><a href="#一、TODO" class="headerlink" title="一、TODO"></a>一、TODO</h1><ul><li><input disabled="" type="checkbox"> java.util.concurrent.TimeUnit</li><li><input disabled="" type="checkbox"> java.time.Duration</li></ul><hr><h1 id="二、脑图"><a href="#二、脑图" class="headerlink" title="二、脑图"></a>二、脑图</h1><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/16/%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/">http://blog.wangjia.ink/2025/09/16/笔记：Java日期时间/</a></p></li><li><p>代码洪荒（面试宝典）<br>👉 <a href="https://www.notion.so/Java-2b6974fbda5e80579ca9da17eb0c21f5?source=copy_link">https://www.notion.so/Java-2b6974fbda5e80579ca9da17eb0c21f5?source=copy_link</a></p></li></ol><hr><h1 id="三、Java-日期时间基础"><a href="#三、Java-日期时间基础" class="headerlink" title="三、Java 日期时间基础"></a>三、Java 日期时间基础</h1><h2 id="1-UTC-和时区"><a href="#1-UTC-和时区" class="headerlink" title="1. UTC 和时区"></a>1. UTC 和时区</h2><p><code>UTC (Coordinated Universal Time)</code> 是世界协调时，是全世界统一的 “标准时间”，在本初子午线（格林尼治，经度 <code>0°</code>），记作 <code>UTC+0</code></p><p>但是地球是圆的，不同地区的日出日落时间不同。如果全世界都直接使用 <code>UTC</code>，就会很混乱：比如英国人说 “我早上 <code>7</code> 点上班”，北京人也说 “我早上 <code>7</code> 点上班”，但实际上北京那时已经是下午，太阳快要落山了。</p><p>因此，我们引入了时区（<code>Time Zone</code>） 的概念，用来规定各地的本地时间。世界被划分为 <code>24</code> 个时区，每个时区相对于 <code>UTC</code> 都有一个固定的偏移量，本地时间就是在 <code>UTC</code> 的基础上加上这个偏移量，通常写作 <code>UTC+X </code>或 <code>UTC-X</code></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">UTC 时间：  2025<span class="hljs-string">-09</span><span class="hljs-string">-16</span> 07:00:00<br>纽约时间：  2025<span class="hljs-string">-09</span><span class="hljs-string">-16</span> 03:00:00 (UTC<span class="hljs-string">-4</span>)<br>北京时间：  2025<span class="hljs-string">-09</span><span class="hljs-string">-16</span> 15:00:00 (UTC<span class="hljs-string">+8</span>)<br>东京时间：  2025<span class="hljs-string">-09</span><span class="hljs-string">-16</span> 16:00:00 (UTC<span class="hljs-string">+9</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="2-ISO-8601-标准"><a href="#2-ISO-8601-标准" class="headerlink" title="2. ISO 8601 标准"></a>2. ISO 8601 标准</h2><p>想象一下这个场景：当我们看到 “<code>03/04/05</code>” 这种日期格式时，不同国家的人可能会有不同的理解：</p><ol><li>在美国，这可能意味着 <code>2005</code> 年<code>3</code> 月 <code>4</code> 日 (<code>MM/DD/YY</code>)</li><li>在欧洲，这可能意味着 <code>2005</code> 年 <code>4</code> 月 <code>3</code> 日 (<code>DD/MM/YY</code>)</li><li>在日本，这可能意味着 <code>2005</code> 年 <code>4</code> 月 <code>3</code> 日 (<code>YY/MM/DD</code>）</li></ol><p>这种混乱在国际化的软件开发和日志分析中可能是致命的，因为不同地区的日期格式差异极易导致数据解析错误、时间排序混乱，甚至系统行为异常。</p><p>为了解决这种日期格式上的混乱，<code>ISO 8601</code> 标准 应运而生。它由国际标准化组织（<code>ISO</code>） 制定，是一种用于消除日期与时间表示歧义的国际通用格式：</p><ol><li><code>YYYY-MM-DDTHH:mm:ssZ</code><ol><li><code>Z</code> 表示时间为 <code>UTC</code></li><li>例如 <code>2025-10-24T09:30:00Z</code></li></ol></li><li><code>YYYY-MM-DDTHH:mm:ss.SSS±HH:mm</code><ol><li><code>±HH:mm</code> 表示相对于 <code>UTC</code> 的时区偏移量</li><li>例如 <code>2025-10-24T01:30:00+09:00</code>、<code>2025-10-24T01:30:00-05:00</code></li></ol></li></ol><hr><h2 id="3-Unix-时间戳"><a href="#3-Unix-时间戳" class="headerlink" title="3. Unix 时间戳"></a>3. Unix 时间戳</h2><p>最早的 <code>Unix</code> 时间戳指的是：从 <code>1970-01-01 00:00:00 UTC</code> 到某一时刻经过的秒数，对应 <code>UTC</code> 时间线上的某个刻度。但是随着系统精度提高，很多语言 或 库（比如 <code>Java</code>、<code>JavaScript</code>）把时间戳扩展到了毫秒甚至是纳秒级</p><p>在 <code>Java</code> 中获取 <code>Unix</code> 时间戳的常用方式：</p><ol><li>秒级 <code>Unix</code> 时间戳<ol><li><code>Instant#getEpochSecond</code><ol><li>只截取秒数部分，截断了精度</li></ol></li><li><code>System.currentTimeMillis() / 1000</code></li></ol></li><li>毫秒级 <code>Unix</code> 时间戳<ol><li><code>Instant#toEpochMilli</code><ol><li>只截取毫秒级部分，截断了精度</li></ol></li><li><code>System.currentTimeMillis</code></li></ol></li><li>纳秒级 <code>Unix</code> 时间戳<ol><li><code>Instant#getEpochSecond() * 1_000_000_000L + Instant#getNano()</code>，需要注意的是，不会丢失毫秒级精度，只是被包含在纳秒级时间戳里了</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Unix</code> 时间戳是绝对不带时区的</li><li><code>UTC</code> 时间戳就是秒级 <code>Unix</code> 时间戳</li></ol></blockquote><hr><h1 id="四、java-time-Instant"><a href="#四、java-time-Instant" class="headerlink" title="四、java.time.Instant"></a>四、java.time.Instant</h1><p>详见源码：<code>Instant</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.time.Instant%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.time.Instant源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/16/%E6%BA%90%E7%A0%81%EF%BC%9AInstant%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/16/源码：Instant源码解析/</a></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java 日期时间</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ExecutorService 源码解析</title>
    <link href="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/03/源码：java.util.concurrent.ExecutorService源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="ExecutorService-概述"><a href="#ExecutorService-概述" class="headerlink" title="ExecutorService 概述"></a>ExecutorService 概述</h3><p><code>ExecutorService</code> 是一个接口，继承了 <code>java.util.concurrent.Executor</code><br><img src="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ExecutorService</code> 在 <code>Executor</code> 的基础上，为我们提供了以下方法：</p><ol><li>关闭线程池（非阻塞）</li><li>等待线程池关闭（限时阻塞）</li><li>查看线程池是否关闭（非阻塞）</li><li>查看线程池是否被执行过 <code>ExecutorService#shutdown</code> 或 <code>ExecutorService#shutdownNow</code>（非阻塞）</li><li>提交一个 <code>Callable</code> 任务（非阻塞）</li><li>提交一个 <code>Runnable</code> 任务（非阻塞）</li><li>提交一批 <code>Callable</code> 任务（阻塞、限时阻塞）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Executor</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Executor源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.Executor源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="2-源码部分"><a href="#2-源码部分" class="headerlink" title="2. 源码部分"></a>2. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br><br><span class="hljs-comment">// 用于非阻塞有序关闭线程池</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 已提交的任务会继续执行，但线程池不会再接收新的任务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞强制关闭线程池</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 正在运行的任务会被停止，并且返回还没开始执行的 Runnable 任务列表，线程池不会再接收新的任务</span><br>    List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看线程池是否被执行过 ExecutorService#shutdown 或 ExecutorService#shutdownNow</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看线程池是否关闭</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于限时阻塞等待线程池关闭</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br><span class="hljs-comment">//     1. 如果超时，返回 false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果线程池未关闭，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 ExecutorService 接口的具体实现类维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Callable 任务</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务，并手动指定一个任务结果</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 因为 Runnable 任务没有返回结果，如果你需要一个返回结果的话，可以手动指定</span><br>    &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该方法与 Executor#execute 的区别在于：</span><br><span class="hljs-comment">//     1. Executor#execute 只管提交，不问结果。它没有返回值，你无法知道任务是否执行成功，也无法知道任务的执行结果</span><br><span class="hljs-comment">//     2. 而 ExecutorService.submit 是提交任务，返回该任务对应的 Future 接口的具体实现类实例。我们可以根据返回的 Future 接口的具体实现类实例对该任务进行一系列操作</span><br><span class="hljs-comment">//     3. 需要注意的是，如果你提交的是 Runnable 任务，即便你使用 Future 接口的具体实现类实例获取该任务的结果，也只会是 null 或我们手动指定的任务结果。我们通常使用 Future 接口的具体实现类实例获取 Callable 任务的结果</span><br>    Future&lt;?&gt; submit(Runnable task);<br>    <br>    <span class="hljs-comment">// 用于阻塞提交一批 Callable 任务，并等待所有任务执行完毕（正常退出、异常退出、取消任务）后，再返回这些任务对应的 Future接口的具体实现类实例列表</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 在等待任务执行完毕的过程中，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：</span><br>    <span class="hljs-comment">//     1. 它并不像传统模式那样将任务统一投递到某个固定的数据结构中，而是循环调用每个 Future 接口的具体实现类实例的 Future#get</span><br>    <span class="hljs-comment">//     2. 因此 Thread 实例可能被投递到多个 Future 接口的具体实现类实例维护的某数据结构</span><br>    <span class="hljs-comment">//     3. 除此之外，这还意味着阻塞状态也是一段一段的，而不是从头到尾一直阻塞</span><br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">// 用于限时阻塞提交一批 Callable 任务，并等待所有任务执行完毕（正常退出、异常退出、取消任务）后，再返回这些任务对应的 Future 接口的具体实现类实例列表</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br>    <span class="hljs-comment">//     1. 如果超时，会撤销尚未执行的任务</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 在等待任务执行完毕的过程中，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 需要注意的是：</span><br>    <span class="hljs-comment">//     1. 它并不像传统模式那样将任务统一投递到某个固定的数据结构中，而是循环调用每个 Future 接口的具体实现类实例的 Future#get</span><br>    <span class="hljs-comment">//     2. 因此 Thread 实例可能被投递到多个 Future 接口的具体实现类实例维护的某数据结构</span><br>    <span class="hljs-comment">//     3. 除此之外，这还意味着阻塞状态也是一段一段的，而不是从头到尾一直阻塞</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">  <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于阻塞提交一批 Callable 任务，等待 “任意” 且 “第一个” 任务执行成功（正常退出），立即返回该任务的结果（并不是该任务对应的 Future 接口的具体实现类实例），并撤销尚未执行的任务和停止正在执行的任务</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在等待 “任意” 且 “第一个” 任务执行程序的过程中，本地线程进入 WAITING 状态，并被投递到 ExecutorCompletionService 维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果所有任务都执行失败，会抛出 ExecutionException 异常</span><br>    &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 用于限时阻塞提交一批 Callable 任务，等待 “任意” 且 “第一个” 任务执行成功（正常退出），立即返回该任务的结果（并不是该任务对应的 Future 实例），并 “尽力” 取消未执行的任务和停止正在执行的任务</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br><span class="hljs-comment">//     1. 如果超时，会抛出 TimeoutException 异常</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 在等待 “任意” 且 “第一个” 任务执行程序的过程中，本地线程进入 TIMED_WAITING 状态，并被投递到 ExecutorCompletionService 维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果所有任务都执行失败，会抛出 ExecutionException 异常</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params"><span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>取消任务和停止任务还是有所区别的：取消任务是指取消那些尚未执行的任务。而停止任务则是任务正在执行时，你通过中断去让它停下来。如果任务能够响应中断，那就算是成功停止。但问题在于，如果任务没有响应中断，那么即使你发出了中断请求，它仍然会继续执行。所以 “停止任务” 并不一定能让它 “停止下来”</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.ThreadPoolExecutor 源码解析</title>
    <link href="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/03/源码：java.util.concurrent.ThreadPoolExecutor源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ThreadPoolExecutor-概述"><a href="#3-1-ThreadPoolExecutor-概述" class="headerlink" title="3.1. ThreadPoolExecutor 概述"></a>3.1. ThreadPoolExecutor 概述</h3><p><code>ThreadPoolExecutor</code> 是一个具体类，继承了 <code>java.util.concurrent.AbstractExecutorService</code><br><img src="/2025/09/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractExecutorService</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.AbstractExecutorService源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/03/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.AbstractExecutorService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/03/源码：java.util.concurrent.AbstractExecutorService源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h3 id="3-2-ThreadPoolExecutor-相关状态"><a href="#3-2-ThreadPoolExecutor-相关状态" class="headerlink" title="3.2. ThreadPoolExecutor 相关状态"></a>3.2. ThreadPoolExecutor 相关状态</h3><ol><li><code>TERMINATED</code>（<code>011</code>）<ol><li>表示线程池关闭</li></ol></li><li><code>TIDYING</code>（<code>010</code>）<ol><li>表示线程池终止前的过渡状态</li><li>只有任务队列为空、所有任务停止、工作线程的数量为 <code>0</code></li></ol></li><li><code>STOP</code>（<code>001</code>）<ol><li>表示因为调用了 <code>ExecutorService#shutdownNow</code> 而进入的状态</li><li>正在运行的任务会被停止，并且返回还没开始执行的 <code>Runnable</code> 任务列表，线程池不会再接收新的任务</li><li>需要注意的是：<ol><li>如果任务本身并没有响应中断，那么正在执行任务的线程可能不会立刻停下，直到执行完这个任务</li></ol></li></ol></li><li><code>SHUTDOWN</code>（<code>000</code>）<ol><li>表示因为调用了 <code>ExecutorService#shutdown</code> 而进入的状态</li><li>已提交的任务会继续执行，但线程池不会再接收新的任务</li></ol></li><li><code>RUNNING</code>（<code>111</code>）<ol><li>表示线程池的初始状态</li><li>已提交的任务会继续执行，线程池也接收新的任务</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>ThreadPoolExecutor</code> 的状态，我们更常把他叫做 “线程池的状态”</li><li>线程池的状态，根据严重程度来看：<code>TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</code></li><li>取消任务和停止任务还是有所区别的：取消任务是指取消那些尚未执行的任务。而停止任务则是任务正在执行时，你通过中断去让它停下来。如果任务能够响应中断，那就算是成功停止。但问题在于，如果任务没有响应中断，那么即使你发出了中断请求，它仍然会继续执行。所以 “停止任务” 并不一定能让它 “停止下来”</li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Worker"><a href="#4-1-Worker" class="headerlink" title="4.1. Worker"></a>4.1. Worker</h3><p>详见源码：<code>ThreadPoolExecutor.Worker</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.ThreadPoolExecutor.Worker源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/04/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.ThreadPoolExecutor.Worker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/04/源码：java.util.concurrent.ThreadPoolExecutor.Worker源码解析/</a></li></ol></li></ol><hr><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p><code>AbortPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于直接抛出 <code>RejectedExecutionException</code> 非受检异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br> <span class="hljs-string">&quot; rejected from &quot;</span> +<br> e.toString());<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p><code>DiscardPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于直接丢弃该任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p><code>CallerRunsPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于让调用 <code>Executor#execute</code> 的线程自己去执行这个任务。简单来说就是：谁派来的活，谁自己去干</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>r.run();<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p><code>DiscardOldestPolicy</code> 是 <code>ThreadPoolExecutor</code> 内置的拒绝策略，用于直接丢弃任务队列中排队最久的任务，然后尝试把这个任务投递到任务队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br><span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>e.getQueue().poll();<br>e.execute(r);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int COUNT_MASK</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 表示 ThreadPoolExecutor 的状态和工作线程的个数</span><br><span class="hljs-comment"> *      2. ThreadPoolExecutor 的状态，我们更常把他叫做 “线程池的状态”</span><br><span class="hljs-comment"> *      </span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. 线程池的状态为 RUNNING，工作线程为 0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ctl 是一个 int 类型的变量，共有 32 bit，其中高 3 bit 表示线程池的状态，低 29 bit 表示工作线程的个数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 表示保存线程池个数的位数（低 bit）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int COUNT_MASK</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 表示保存线程池状态的位数（高 bit）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. (1 &lt;&lt; COUNT_BITS) - 1</span><br><span class="hljs-comment"> *      2. 即 00011111 11111111 11111111 11111111</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1 的二进制：</span><br><span class="hljs-comment"> * 00000000 00000000 00000000 00000001</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1  &lt;&lt; 29：</span><br><span class="hljs-comment"> * 把二进制数整体往左挪 29 位，左边溢出的丢掉，右边空出来的补零</span><br><span class="hljs-comment"> * 00100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (1 &lt;&lt; 29) - 1：</span><br><span class="hljs-comment"> * 00011111 11111111 11111111 11111111</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 属性：private static final int RUNNING</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，只能尝试类的内部方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *      1. final</span><br><span class="hljs-comment"> *          1. 不能修改该属性的值</span><br><span class="hljs-comment"> *          2. 必须在定义时直接赋值，或者在构造函数中保证赋值</span><br><span class="hljs-comment"> *      1. static</span><br><span class="hljs-comment"> *          1. 可以通过类名直接访问该属性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 作用</span><br><span class="hljs-comment"> *      1. 用于界定线程池的 RUNNING 状态</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 初始值</span><br><span class="hljs-comment"> *      1. -1 &lt;&lt; COUNT_BITS</span><br><span class="hljs-comment"> *      2. 即 11100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 详细介绍</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * -1 的二进制：</span><br><span class="hljs-comment"> * 11111111 11111111 11111111 11111111</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * -1 &lt;&lt; 29：</span><br><span class="hljs-comment"> * 11100000 00000000 00000000 00000000</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 SHUTDOWN 状态（000）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 STOP 状态（001）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 TIDYING 状态（010）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 用于界定线程池的 TERMINATED 状态（011）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 表示 TPE 的任务队列（单向队列），如果任务不能作为核心工作线程的 &quot;启动任务&quot;，则被投递到该队列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">// 表示 TPE 的 Worker 集合，所有 Worker 都会被投递到该集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-comment">// 表示 TPE 使用 AQS 创建的条件队列（双向），所有因为调用 ExecutorService#awaitTermination 而阻塞的 Thread 实例会被投递到该队列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">termination</span> <span class="hljs-operator">=</span> mainLock.newCondition();<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> largestPoolSize;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> completedTaskCount;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> keepAliveTime;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> allowCoreThreadTimeOut;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">defaultHandler</span> <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RuntimePermission</span> <span class="hljs-variable">shutdownPerm</span> <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimePermission</span>(<span class="hljs-string">&quot;modifyThread&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6. 构造方法"></a>6. 构造方法</h2><h3 id="6-1-ThreadPoolExecutor-int-corePoolSize-int-maximumPoolSize-long-keepAliveTime-TimeUnit-unit-BlockingQueue＜Runnable＞-workQueue-ThreadFactory-threadFactory-RejectedExecutionHandler-handler"><a href="#6-1-ThreadPoolExecutor-int-corePoolSize-int-maximumPoolSize-long-keepAliveTime-TimeUnit-unit-BlockingQueue＜Runnable＞-workQueue-ThreadFactory-threadFactory-RejectedExecutionHandler-handler" class="headerlink" title="6.1. ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue＜Runnable＞ workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)"></a>6.1. ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue＜Runnable＞ workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</h3><p><code>ThreadPoolExecutor</code> 虽然提供了 <code>4</code> 个构造方法，但是本质上都是调用这个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 构造方法：</span><br><span class="hljs-comment"> * public ThreadPoolExecutor(</span><br><span class="hljs-comment"> *         int corePoolSize,</span><br><span class="hljs-comment"> *         int maximumPoolSize,</span><br><span class="hljs-comment"> *         long keepAliveTime,</span><br><span class="hljs-comment"> *         TimeUnit unit,</span><br><span class="hljs-comment"> *         BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-comment"> *         ThreadFactory threadFactory,</span><br><span class="hljs-comment"> *         RejectedExecutionHandler handler</span><br><span class="hljs-comment"> * )</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. public</span><br><span class="hljs-comment"> *          1. 天下皆公（EveryWhere）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. int corePoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中的核心工作线程被允许的最大数量</span><br><span class="hljs-comment"> *          2. 需要注意的是：</span><br><span class="hljs-comment"> *              1. 该参数可以为 0</span><br><span class="hljs-comment"> *      2. int maximumPoolSize</span><br><span class="hljs-comment"> *          1. 指定线程池中的工作线程被允许的最大数量</span><br><span class="hljs-comment"> *          2. 需要注意的是：</span><br><span class="hljs-comment"> *              1. 工作线程的数量 = 核心工作线程的数量 + 非核心工作线程的数量</span><br><span class="hljs-comment"> *      3. long keepAliveTime</span><br><span class="hljs-comment"> *          1. 指定非核心工作线程 “空闲” 被允许的最长时间为 keepAliveTime unit</span><br><span class="hljs-comment"> *          2. 需要注意的是：</span><br><span class="hljs-comment"> *              1. 非核心线程 “空闲” 超时后会被销毁</span><br><span class="hljs-comment"> *              2. 核心线程 “空闲” 超时后不会被销毁</span><br><span class="hljs-comment"> *      4. TimeUnit unit</span><br><span class="hljs-comment"> *          1. 指定非核心工作线程 “空闲” 被允许的最长时间为 keepAliveTime unit</span><br><span class="hljs-comment"> *      5. BlockingQueue＜Runnable＞ workQueue</span><br><span class="hljs-comment"> *          1. 任务在没有核心工作线程处理时，先被投递到这个队列中</span><br><span class="hljs-comment"> *          2. 需要注意的是，是没有核心工作线程处理，而不是工作线程处理</span><br><span class="hljs-comment"> *      6. ThreadFactory threadFactory</span><br><span class="hljs-comment"> *          1. 指定创建 Thread 实例的线程工厂</span><br><span class="hljs-comment"> *      7. RejectedExecutionHandler handler</span><br><span class="hljs-comment"> *          1. 指定拒绝策略</span><br><span class="hljs-comment"> *          2. 当任务队列已满并且线程池中的工作线程数量已经达到了 maximumPoolSize，这时候再投递任务，就需要执行拒绝策略</span><br><span class="hljs-comment"> *          3. 需要注意的是：ThreadPoolExecutor 内置了 4 个拒绝策略，分别是</span><br><span class="hljs-comment"> *              1. ThreadPoolExecutor.AbortPolicy</span><br><span class="hljs-comment"> *              2. ThreadPoolExecutor.DiscardPolicy</span><br><span class="hljs-comment"> *              3. ThreadPoolExecutor.CallerRunsPolicy</span><br><span class="hljs-comment"> *              4. ThreadPoolExecutor.DiscardOldestPolicy</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 构造实例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="hljs-comment"> *     2,</span><br><span class="hljs-comment"> *     4,</span><br><span class="hljs-comment"> *     10,</span><br><span class="hljs-comment"> *     TimeUnit.SECONDS,</span><br><span class="hljs-comment"> *     new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="hljs-comment"> *     new ThreadFactory() &#123;</span><br><span class="hljs-comment"> *         private int count = 1;</span><br><span class="hljs-comment"> *         public Thread newThread(Runnable r) &#123;</span><br><span class="hljs-comment"> *             return new Thread(r, &quot;Worker-&quot; + count++);</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *     &#125;,</span><br><span class="hljs-comment"> *     new ThreadPoolExecutor.AbortPolicy()</span><br><span class="hljs-comment"> * );</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">  <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">  <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">  TimeUnit unit,</span><br><span class="hljs-params">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">  ThreadFactory threadFactory,</span><br><span class="hljs-params">  RejectedExecutionHandler handler)</span> &#123;<br><br><span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt; corePoolSize ||<br>keepAliveTime &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><br><span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br><br><span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br><br><span class="hljs-built_in">this</span>.workQueue = workQueue;<br><br><span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br><br><span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br><br><span class="hljs-built_in">this</span>.handler = handler;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-实例方法"><a href="#7-实例方法" class="headerlink" title="7. 实例方法"></a>7. 实例方法</h2><h3 id="7-1-实例具体方法"><a href="#7-1-实例具体方法" class="headerlink" title="7.1. 实例具体方法"></a>7.1. 实例具体方法</h3><h4 id="7-1-1-具体方法（普通）"><a href="#7-1-1-具体方法（普通）" class="headerlink" title="7.1.1. 具体方法（普通）"></a>7.1.1. 具体方法（普通）</h4><h5 id="7-1-1-1-boolean-addWorker-Runnable-firstTask-boolean-core"><a href="#7-1-1-1-boolean-addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="7.1.1.1. boolean addWorker(Runnable firstTask, boolean core)"></a>7.1.1.1. boolean addWorker(Runnable firstTask, boolean core)</h5><p>该方法用于创建并启动一个 <code>Worder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br><br><span class="hljs-comment">// 为循环起一个 Label</span><br>retry:<br><br><span class="hljs-comment">// 不断调用 AtomicInteger#get 获取 ctl 属性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();;) &#123;<br><br><span class="hljs-comment">// 如果</span><br><span class="hljs-comment">//     1. 调用 ThreadPoolExecutor#runStateAtLeast，发现线程池的状态至少为 SHUTDOWN（即 TERMINATED、TIDYING、STOP、SHUTDOWN）</span><br><span class="hljs-comment">//     2. 并且</span><br><span class="hljs-comment">//         1. 要么调用 ThreadPoolExecutor#runStateAtLeast，发现线程池的状态至少为 STOP（即 TERMINATED、TIDYING、STOP）</span><br><span class="hljs-comment">//         2. 要么 firstTask 方法参数为 null</span><br><span class="hljs-comment">//         3. 要么调用 Collection#isEmpty，发现任务队列为空</span><br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>&amp;&amp; (runStateAtLeast(c, STOP) || firstTask != <span class="hljs-literal">null</span>|| workQueue.isEmpty()))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><br><span class="hljs-comment">// 如果调用 ThreadPoolExecutor#workerCountOf，发现线程池中的工作线程的数量 &gt; 本次检查的线程数量上限</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// (core ? corePoolSize : maximumPoolSize) 是指：如果 core 为 true，本次检查的线程数量上限为核心工作线程被允许的最大数量。如果 core 为 false，本次检查的线程数量上限为工作线程被允许的最大数量</span><br><span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 如果调用 ThreadPoolExecutor#compareAndIncrementWorkerCount，成功将工作线程 + 1</span><br><span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br><span class="hljs-keyword">break</span> retry;<br><br><span class="hljs-comment">// 调用 AtomicInteger#get 获取 ctl 属性</span><br>c = ctl.get();<br><br><span class="hljs-comment">// 如果调用 ThreadPoolExecutor#runStateAtLeast，发现线程池的状态至少为 SHUTDOWN（即 TERMINATED、TIDYING、STOP、SHUTDOWN）</span><br><span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))<br><span class="hljs-keyword">continue</span> retry;<br>&#125;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-comment">// 创建 Worker 实例</span><br>w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br><br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br><br>mainLock.lock();<br><br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br><span class="hljs-keyword">if</span> (isRunning(c) ||<br>(runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br><br><span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><br><span class="hljs-comment">// 调用 HashSet#add，向 ThreadPoolExecutor-&gt;workers 添加新创建的 Worker 实例</span><br>workers.add(w);<br><br>workerAdded = <span class="hljs-literal">true</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br><br><span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>largestPoolSize = s;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>mainLock.unlock();<br>&#125;<br><span class="hljs-keyword">if</span> (workerAdded) &#123;<br><br><span class="hljs-comment">// 启动 Thread 实例</span><br>t.start();<br><br>workerStarted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br><span class="hljs-keyword">if</span> (! workerStarted)<br>addWorkerFailed(w);<br>&#125;<br><span class="hljs-keyword">return</span> workerStarted;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="7-1-1-2-void-runWorker-Worker-w"><a href="#7-1-1-2-void-runWorker-Worker-w" class="headerlink" title="7.1.1.2. void runWorker(Worker w)"></a>7.1.1.2. void runWorker(Worker w)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br><br>w.firstTask = <span class="hljs-literal">null</span>;<br><br>w.unlock();<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br><br>w.lock();<br><br><span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br> (Thread.interrupted() &amp;&amp;<br>  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>!wt.isInterrupted())<br>wt.interrupt();<br><br><span class="hljs-keyword">try</span> &#123;<br>beforeExecute(wt, task);<br><span class="hljs-keyword">try</span> &#123;<br>task.run();<br>afterExecute(task, <span class="hljs-literal">null</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>afterExecute(task, ex);<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>task = <span class="hljs-literal">null</span>;<br>w.completedTasks++;<br>w.unlock();<br>&#125;<br>&#125;<br>completedAbruptly = <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>processWorkerExit(w, completedAbruptly);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="7-1-2-具体方法（实现）"><a href="#7-1-2-具体方法（实现）" class="headerlink" title="7.1.2. 具体方法（实现）"></a>7.1.2. 具体方法（实现）</h4><h5 id="7-1-2-1-Executor-中接口方法的实现"><a href="#7-1-2-1-Executor-中接口方法的实现" class="headerlink" title="7.1.2.1. Executor 中接口方法的实现"></a>7.1.2.1. Executor 中接口方法的实现</h5><h6 id="7-1-2-1-1-void-execute-Runnable-command"><a href="#7-1-2-1-1-void-execute-Runnable-command" class="headerlink" title="7.1.2.1.1. void execute(Runnable command)"></a>7.1.2.1.1. void execute(Runnable command)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><br><span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br><span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br><span class="hljs-keyword">return</span>;<br>c = ctl.get();<br>&#125;<br><span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>reject(command);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>reject(command);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="7-1-2-2-ExecutorService-中接口方法的实现"><a href="#7-1-2-2-ExecutorService-中接口方法的实现" class="headerlink" title="7.1.2.2. ExecutorService 中接口方法的实现"></a>7.1.2.2. ExecutorService 中接口方法的实现</h5><h6 id="7-1-2-2-1-void-shutdown"><a href="#7-1-2-2-1-void-shutdown" class="headerlink" title="7.1.2.2.1. void shutdown()"></a>7.1.2.2.1. void shutdown()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>checkShutdownAccess();<br>advanceRunState(SHUTDOWN);<br>interruptIdleWorkers();<br>onShutdown();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br>tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-2-2-2-List＜Runnable＞-shutdownNow"><a href="#7-1-2-2-2-List＜Runnable＞-shutdownNow" class="headerlink" title="7.1.2.2.2. List＜Runnable＞ shutdownNow()"></a>7.1.2.2.2. List＜Runnable＞ shutdownNow()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>checkShutdownAccess();<br>advanceRunState(STOP);<br>interruptWorkers();<br>tasks = drainQueue();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="7-1-2-2-3-boolean-awaitTermination-long-timeout-TimeUnit-unit"><a href="#7-1-2-2-3-boolean-awaitTermination-long-timeout-TimeUnit-unit" class="headerlink" title="7.1.2.2.3. boolean awaitTermination(long timeout, TimeUnit unit)"></a>7.1.2.2.3. boolean awaitTermination(long timeout, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">while</span> (runStateLessThan(ctl.get(), TERMINATED)) &#123;<br><span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>nanos = termination.awaitNanos(nanos);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurren.Future＜V＞ 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurren.Future%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurren.Future＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Future-概述"><a href="#3-1-Future-概述" class="headerlink" title="3.1. Future 概述"></a>3.1. Future 概述</h3><p><code>Future</code> 是一个接口</p><p><code>Future</code> 为我们提供了以下方法：</p><ol><li>取消还未执行的任务、停止正在执行的任务（非阻塞）</li><li>查看任务是否已经被取消或停止（非阻塞）</li><li>查看任务是否已经执行完毕（非阻塞）</li><li>获取任务的结果（阻塞、限时阻塞）</li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞取消还未执行的任务，停止正在执行的任务</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看任务是否已经被取消或停止</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞查看任务是否已经执行完毕（正常退出、异常退出、取消任务）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于阻塞获取任务的结果</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 如果任务还没有执行完，本地线程进入阻塞状态，Thread 实例进入 WAITING 状态，并被投递到 Future 接口的具体实现类实例中维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 用于限时阻塞获取任务的结果</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：timeout unit</span><br><span class="hljs-comment">//     1. 如果超时，抛出 TimeoutException 异常</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果任务还没有执行完，本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态，并被投递到 Future 接口的具体实现类实例维护的某数据结构，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 TIMED_WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Callable＜V＞ 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Callable%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.Callable＜V＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Callable-概述"><a href="#3-1-Callable-概述" class="headerlink" title="3.1. Callable 概述"></a>3.1. Callable 概述</h3><p><code>Callable</code> 是一个接口</p><p>实现 <code>Callable</code> 接口的具体实现类，表示一个可被线程执行的任务，我们称之为 “<code>Callable</code> 任务”</p><p>与 <code>Runnable</code> 任务相比，<code>Callable</code> 任务既可以有返回值，也可以抛出异常</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 <code>Java</code> 中，线程执行的任务，通常是指 <code>Runnable</code> 任务和 <code>Callable</code> 任务</li><li><code>Runnable</code> 在 <code>Java1</code> 就出现了，但是 <code>Runnable</code> 任务既不能抛出受检异常，也没有返回值。执行 <code>Runnable</code> 就感觉进入了一个黑盒子，没有一点反馈，于是我们在 <code>Java5</code> 引入了 <code>Callable</code></li><li>需要注意的是，这里有一个 “坑”：<ol><li><code>Thread</code> 在设计之初就是只能用来执行 <code>Runnable</code> 任务，不能直接执行  <code>Callable</code> 任务（即 <code>本地线程 ➔ Thread#run ➔ target#run</code>，这里的 <code>target</code> 就是一个 <code>Runnable</code> 任务）</li><li>除此之外，即便能执行 <code>Callable</code> 任务，如何拿到这个 <code>Callable</code> 任务的返回值，也是一个问题</li><li>我们的解决思路通常是：<ol><li>将实现 <code>Callable</code> 接口的具体实现类，作为实现 <code>Runnable</code> 接口的具体实现类的属性，当线程调用实现 <code>Runnable</code> 接口的具体实现类时，会调用其 <code>run</code>，我们在 <code>run</code> 中再去调用实现 <code>Callable</code> 接口的具体实现类的 <code>call</code>，然后将 <code>call</code> 的返回值，也作为实现 <code>Runnable</code> 接口的具体实现类的属性</li><li><code>FutureTask</code> 就是这样做的，详见源码：<code>FutureTask</code>（<code>obsidian</code> 内部链接：<a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.FutureTask%EF%BC%9CV%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.FutureTask＜V＞源码解析</a>，<code>Hexo</code> 链接：）</li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br><br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Runnable 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.Runnable源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Runnable-概述"><a href="#3-1-Runnable-概述" class="headerlink" title="3.1. Runnable 概述"></a>3.1. Runnable 概述</h3><p><code>Runnable</code> 是一个接口</p><p>实现 <code>Runnable</code> 接口的具体实现类，表示一个可被线程执行的任务，我们称之为 “<code>Runnable</code> 任务”</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>在 <code>Java</code> 中，线程执行的任务，通常是指 <code>Runnable</code> 任务和 <code>Callable</code> 任务</li><li><code>Runnable</code> 在 <code>Java1</code> 就出现了，但是 <code>Runnable</code> 任务既不能抛出受检异常，也没有返回值。执行 <code>Runnable</code> 就感觉进入了一个黑盒子，没有一点反馈，于是我们在 <code>Java5</code> 引入了 <code>Callable&lt;V&gt;</code></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>接口中的接口方法却写 <code>abstract</code> 非访问修饰符，这是早期遗留的写法和部分人的编码习惯</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locksAbstractOwnableSynchronizer 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractOwnableSynchronizer-概述"><a href="#3-1-AbstractOwnableSynchronizer-概述" class="headerlink" title="3.1. AbstractOwnableSynchronizer 概述"></a>3.1. AbstractOwnableSynchronizer 概述</h3><p><code>AbstractOwnableSynchronizer</code> 是一个接口</p><p><code>AbstractOwnableSynchronizer</code> 提供了以下方法：</p><ol><li>记录当前独占该独占模式同步器资源的线程（非阻塞）</li><li>获取当前独占该独占模式同步器资源的线程（非阻塞）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>AOS</code> 仅用于独占模式同步器，如果基于 <code>AQS</code> 实现的是共享模式的同步器或状态机，那么 <code>AOS</code> 根本用不到</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;<br><br><span class="hljs-comment">// 表示当前独占该独占模式同步器资源的线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br><br><span class="hljs-comment">// 用于非阻塞记录当前独占该独占模式同步器资源的线程</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        exclusiveOwnerThread = thread;<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞获取当前独占该独占模式同步器资源的线程</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReentrantLock.Sync 源码解析</title>
    <link href="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.locks.ReentrantLock.Sync源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReentrantLock-Sync-概述"><a href="#3-1-ReentrantLock-Sync-概述" class="headerlink" title="3.1. ReentrantLock.Sync 概述"></a>3.1. ReentrantLock.Sync 概述</h3><p><code>Sync</code> 是一个抽象类，是 <code>java.util.concurrent.locks.ReentrantLock</code> 的静态内部类，继承了 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code><br><img src="/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>ReentrantLock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantLock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.ReentrantLock源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/01/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-keyword">if</span> (++c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!initialTryLock())<br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-keyword">if</span> (!initialTryLock())<br>acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLockNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-keyword">return</span> initialTryLock() || tryAcquireNanos(<span class="hljs-number">1</span>, nanos);<br>&#125;<br><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br><span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> (c == <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (free)<br>setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>&#125;<br><br><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>&#125;<br><br><span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getOwner</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : getExclusiveOwnerThread();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHoldCount</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> isHeldExclusively() ? getState() : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>s.defaultReadObject();<br>setState(<span class="hljs-number">0</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer 源码解析</title>
    <link href="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/01/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedSynchronizer-概述"><a href="#3-1-AbstractQueuedSynchronizer-概述" class="headerlink" title="3.1. AbstractQueuedSynchronizer 概述"></a>3.1. AbstractQueuedSynchronizer 概述</h3><p><code>AbstractQueuedSynchronizer</code> 是一个抽象类，继承了 <code>java.util.concurrent.locks.AbstractOwnableSynchronizer</code>，实现了 <code>java.io.Serializable</code><br><img src="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractOwnableSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractOwnableSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.locks.AbstractOwnableSynchronizer源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li><li>需要注意的是：<ol><li><code>Java8</code> 的 <code>AQS</code> 是只有 <code>Node</code> 的，没有 <code>ExclusiveNode</code>、<code>SharedNode</code>、<code>ConditionNode</code> 的</li></ol></li></ol></blockquote><hr><h3 id="3-2-AbstractQueuedSynchronizer-应用场景"><a href="#3-2-AbstractQueuedSynchronizer-应用场景" class="headerlink" title="3.2. AbstractQueuedSynchronizer 应用场景"></a>3.2. AbstractQueuedSynchronizer 应用场景</h3><h4 id="3-2-1-同步器"><a href="#3-2-1-同步器" class="headerlink" title="3.2.1. 同步器"></a>3.2.1. 同步器</h4><p>同步器是一种协调多个线程执行的工具。它通过内部维护的状态（<code>State</code>），用于控制多个线程对一个或多个共享资源的访问，从而实现线程间的同步与协作</p><p>简单来说，多个线程需要先竞争同步器资源（即 <code>State</code>），只有竞争成功的线程才能访问共享资源。而 <code>AQS</code> 提供了一系列机制，使得多个线程能够 “高效且安全” 地竞争、释放 <code>State</code></p><p>在基于 <code>AQS</code> 的同步器实现中，通常需要维护两种队列：</p><ol><li>一条同步队列<ol><li>同步队列用于管理那些尝试获取同步器资源，但暂时失败并暂时进入阻塞（<code>WAITING</code>、<code>TIMED_WAITING</code>）的线程</li><li><code>AQS</code> 已经封装好了相关的节点类型（即 <code>Node</code>、<code>ExclusiveNode</code>、<code>SharedNode</code>），并且提供了首尾哨兵节点。因此，我们的 <code>AQS</code> 实现类只需要在此基础上维护同步队列即可</li></ol></li><li>多条条件队列<ol><li>条件队列用于管理那些已经获取同步器资源，但因业务条件不满足，而调用了 <code>Condition.await</code>，释放同步器资源并暂时进入阻塞（<code>WAITING</code>、<code>TIMED_WAITING</code>）的线程</li><li><code>AQS</code> 已经封装好了 <code>ConditionObject</code> 和相关的节点类型（即 <code>ConditionNode</code>），一个 <code>ConditionObject</code> 实例就是一条条件队列。因此，我们的 <code>AQS</code> 实现类只需要根据自己的需要，创建并维护 <code>ConditionObject</code> 实例即可<br><img src="/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1.png"></li></ol></li></ol><p>在不同的同步器实现中，<code>State</code> 和共享资源有不同的含义，例如在 <code>ReentrantLock</code> 中：</p><ol><li><code>State</code> 表示锁的重入次数<ol><li><code>0</code><ol><li>表示锁空闲，线程可以尝试获取</li></ol></li><li><code>1</code><ol><li>表示锁已被某个线程持有</li></ol></li><li><code>n（n &gt; 1）</code><ol><li>表示同一线程对该锁进行了 <code>n</code> 次重入</li></ol></li></ol></li><li>共享资源表示加锁期间的操作</li></ol><p>在使用 <code>AQS</code> 时，绝大多数情况下（约 <code>99%</code>）都是用来实现各种同步器（例如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>）。在这种情况下，我们可能需要使用到的以下内容：</p><ol><li><code>AOS</code><ol><li>如果基于 <code>AQS</code> 实现的是独占模式的同步器（例如 <code>ReentrantLock</code>），就需要使用 <code>AOS</code> 记录当前独占该资源的线程</li><li>但是如果基于 <code>AQS</code> 实现的是共享模式的同步器（例如 <code>Semaphore</code>），那么 <code>AOS</code> 根本就用不到</li></ol></li><li><code>AQS</code><ol><li><code>State</code></li><li>同步队列</li><li>条件队列</li></ol></li></ol><p>在使用 <code>AQS</code> 实现同步器时，通常的做法是：在同步器内部定义一个静态内部类（一般命名为 <code>Sync</code>），并让 <code>Sync</code> 继承 <code>AbstractQueuedSynchronizer</code>，而不是让同步器直接继承 <code>AQS</code></p><p>当外部调用同步器的方法时，执行的流程大致为：<code>外部调用同步器的方法 → 同步器调用 Sync 的方法 → Sync 调用 AQS 的方法</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>在使用 <code>AQS</code> 实现同步器时，为什么不直接让同步器直接继承 <code>AQS</code>？<ol><li>其实这里实际使用了 <code>GOF</code> 设计模式之策略模式，以 <code>ReentrangLock</code> 为例</li><li><code>RenntrantLock</code> 需要支持 “公平锁” 和 “非公平锁” 两种模式，而两者在竞争 <code>State</code> 的逻辑上完全不同</li><li>但是 <code>AQS</code> 只提供了竞争 <code>State</code> 的方法，因此具体的竞争逻辑必须由 <code>AQS</code> 的实现类来定义。</li><li>如果同步器直接继承 <code>AQS</code>，就需要在每次操作中使用 <code>if...else if...else</code> 或 <code>switch...case...default</code> 判断公平锁或非公平锁，然后执行不同的竞争逻辑</li><li>为了避免大量的 <code>if...else if...else</code> 或 <code>switch...case...default</code> 判断，<code>ReentrantLock</code> 就采用了策略模式</li><li><code>ReentrantLock</code> 内部定义了两个静态内部类（即 <code>FairSync</code>、<code>NonFairSync</code>），这两个类分别实现各自的竞争逻辑</li></ol></li></ol></li></ol></blockquote><hr><h4 id="3-2-2-状态机"><a href="#3-2-2-状态机" class="headerlink" title="3.2.2. 状态机"></a>3.2.2. 状态机</h4><p>状态机通过内部维护的状态（<code>State</code>），用于表示其实例在生命周期中可能经历的各个阶段</p><p>在使用 <code>AQS</code> 时，有少数情况（约 <code>1%</code>）会用来实现状态机（例如 <code>ThreadPoolExecutor.Worker</code>）。在这种情况下，我们可能需要使用到以下内容：</p><ol><li><code>AQS</code><ol><li><code>State</code></li></ol></li></ol><p>在不同的状态机实现中，<code>State</code> 有不同的含义，例如在 <code>ThreadPoolExecutor.Worker</code> 中：</p><ol><li><code>-1</code><ol><li><code>Worker</code> 正在被实例化</li></ol></li><li><code>0</code><ol><li><code>Worker</code> 并没有 “执行” 任务（正在从任务队列中获取任务）</li></ol></li><li><code>1</code><ol><li><code>Worker</code> 正在 “执行” 任务</li></ol></li></ol><p>在使用 <code>AQS</code> 实现状态机时，通常的做法是：直接让状态机继承 <code>AQS</code></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code><ol><li>为什么实现状态机还要使用 <code>AQS</code>？我们直接在状态机内部维护一个 <code>State</code> 不就行了嘛？<ol><li>因为 <code>AQS</code> 提供了一系列机制，使得多个线程能够 “高效且安全” 地竞争、释放 <code>State</code></li><li>而我们自己实现不一定能做到这么稳妥，而且只是在走 “<code>AQS</code>” 的老路，不如直接复用最省心</li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Node"><a href="#4-1-Node" class="headerlink" title="4.1. Node"></a>4.1. Node</h3><p>详见源码：<code>AbstractQueuedSynchronizer.Node</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node源码解析/</a></li></ol></li></ol><hr><h3 id="4-2-ExclusiveNode"><a href="#4-2-ExclusiveNode" class="headerlink" title="4.2. ExclusiveNode"></a>4.2. ExclusiveNode</h3><p><code>AbstractQueuedSynchronizer.ExclusiveNode</code> 只是简单地继承了 <code>AbstractQueuedSynchronizer.Node</code>，为 <code>AbstractQueuedSynchronizer.Node</code> 增加了一层 “独占模式节点” 的标签，用来明确区分节点所处的语义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果基于 <code>AQS</code> 实现的是独占模式同步器（例如 <code>ReentrantLock</code>），那么同步队列中的 <code>Node</code> 就应该是 <code>ExclusiveNode</code></li></ol></blockquote><hr><h3 id="4-3-SharedNode"><a href="#4-3-SharedNode" class="headerlink" title="4.3. SharedNode"></a>4.3. SharedNode</h3><p><code>AbstractQueuedSynchronizer.SharedNode</code> 也只是简单地继承了 <code>AbstractQueuedSynchronizer.Node</code>，为 <code>AbstractQueuedSynchronizer.Node</code> 增加了一层 “共享模式节点” 的标签，用来明确区分节点所处的语义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>如果基于 <code>AQS</code> 实现的是共享模式同步器（例如 <code>Semaphore</code>），那么同步队列中的 <code>Node</code> 就应该是 <code>SharedNode</code></li></ol></blockquote><hr><h3 id="4-4-ConditionObject"><a href="#4-4-ConditionObject" class="headerlink" title="4.4. ConditionObject"></a>4.4. ConditionObject</h3><p>详见源码：<code>AbstractQueuedSynchronizer.ConditionObject</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject源码解析/</a></li></ol></li></ol><hr><h3 id="4-5-ConditionNode"><a href="#4-5-ConditionNode" class="headerlink" title="4.5. ConditionNode"></a>4.5. ConditionNode</h3><p>详见源码：<code>AbstractQueuedSynchronizer.ConditionNode</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode源码解析/</a></li></ol></li></ol><hr><h2 id="5-核心属性"><a href="#5-核心属性" class="headerlink" title="5. 核心属性"></a>5. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示 AQS 的同步队列的首哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 表示 AQS 的同步队列的尾哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 表示 AQS 的核心状态位（State）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.Executor 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Executor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.Executor源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Executor-概述"><a href="#3-1-Executor-概述" class="headerlink" title="3.1. Executor 概述"></a>3.1. Executor 概述</h3><p><code>Executor</code> 是一个接口，为我们提供了以下方法：</p><ol><li>提交一个 <code>Runnable</code> 任务（非阻塞）</li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br><br><span class="hljs-comment">// 用于非阻塞提交一个 Runnable 任务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Runnable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.Runnable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.Runnable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.Runnable源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="5-实现示例"><a href="#5-实现示例" class="headerlink" title="5. 实现示例"></a>5. 实现示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Runnable 不能为 null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(command).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoExecutor</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行任务 &quot;</span> + id + <span class="hljs-string">&quot; 的线程: &quot;</span> + Thread.currentThread().getName());<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionNode源码解析/</a></p></li></ol><hr><h2 id="3-概述"><a href="#3-概述" class="headerlink" title="3. 概述"></a>3. 概述</h2><p><code>AbstractQueuedSynchronizer.ConditionNode</code> 是一个具体类，是 <code>AQS</code> 的 静态内部类，继承了 <code>AbstractQueuedSynchronizer.Node</code>，实现了 <code>ForkJoinPool.ManagedBlocker</code></p><p><code>AQS</code> 的条件队列就是是由 <code>AbstractQueuedSynchronizer.ConditionNode</code> 构建的，基于单向链表的队列</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></li></ol></li></ol></li><li>详见源码：<code>AbstractQueuedSynchronizer.Node</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker &#123;<br><br><span class="hljs-comment">// 表示该节点在 AQS 的条件队列中的后驱节点</span><br>ConditionNode nextWaiter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> status &lt;= <span class="hljs-number">1</span> || Thread.currentThread().isInterrupted();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (!isReleasable()) LockSupport.park();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw<br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.eddx"></p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedSynchronizer-ConditionObject-概述"><a href="#3-1-AbstractQueuedSynchronizer-ConditionObject-概述" class="headerlink" title="3.1. AbstractQueuedSynchronizer.ConditionObject 概述"></a>3.1. AbstractQueuedSynchronizer.ConditionObject 概述</h3><p><code>ConditionObject</code> 是一个具体类，是 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>. 的普通内部类，实现了 <code>java.util.concurrent.locks.Condition</code>、<code>java.io.Serializable</code><br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ConditionObject</code> 维护了一个由 <code>AbstractQueuedSynchronizer.ConditionNode</code> 构建的，基于单向链表的队列。所谓的 “<code>AQS</code> 的条件队列” 其实就是在说 <code>ConditionObject</code> 维护的这条件队列<br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1.png"></p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/01/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Condition</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Condition源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.Condition源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-核心属性"><a href="#4-核心属性" class="headerlink" title="4. 核心属性"></a>4. 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示 AQS 的条件队列的首哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode firstWaiter;<br><br><span class="hljs-comment">// 表示 AQS 的条件队列的尾哨兵节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode lastWaiter;<br></code></pre></td></tr></table></figure><hr><h2 id="5-具体方法"><a href="#5-具体方法" class="headerlink" title="5. 具体方法"></a>5. 具体方法</h2><h3 id="5-1-具体方法（无）"><a href="#5-1-具体方法（无）" class="headerlink" title="5.1. 具体方法（无）"></a>5.1. 具体方法（无）</h3><h4 id="5-1-1-private-int-enableWait-ConditionNode-node"><a href="#5-1-1-private-int-enableWait-ConditionNode-node" class="headerlink" title="5.1.1. private int enableWait(ConditionNode node)"></a>5.1.1. private int enableWait(ConditionNode node)</h4><p><code>private int enableWait(ConditionNode node)</code> 用于 把当前线程包装成一个 <code>ConditionNode</code>，然后将该节点链接到条件队列（单向链表）中，并释放锁资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 1. 访问修饰符</span><br><span class="hljs-comment"> *      1. private</span><br><span class="hljs-comment"> *          1. 独守秘密（类内部）</span><br><span class="hljs-comment"> *          2. 由于是别人封装好的，类内部是做不到了，访问和操作是做不到了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 非访问修饰符</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 方法参数</span><br><span class="hljs-comment"> *      1. ConditionNode node</span><br><span class="hljs-comment"> *          1. 一个空的 ConditionNode，当前线程就是包装在这个 Node 中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 返回值</span><br><span class="hljs-comment"> *      1. 在进入 await() 之前，同步器（AQS）的 state 值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. 抛出异常</span><br><span class="hljs-comment"> *      1. IllegalMonitorStateException</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 6. 使用示例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enableWait</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br><br><span class="hljs-comment">// 如果独占锁是否被当前线程持有（Condition 是专门用于独占锁的）</span><br><span class="hljs-keyword">if</span> (isHeldExclusively()) &#123;<br><br><span class="hljs-comment">// 将当前线程封装到 Node 的 waiter 中</span><br>node.waiter = Thread.currentThread();<br><br><span class="hljs-comment">// 将 node 的状态设置为 COND（条件队列） + 等待中</span><br>node.setStatusRelaxed(COND | WAITING);<br><br><span class="hljs-comment">// 将 Node 链接到条件队列中（单向链表）</span><br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> lastWaiter;<br><span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>firstWaiter = node;<br><span class="hljs-keyword">else</span><br>last.nextWaiter = node;<br>lastWaiter = node;<br><br><span class="hljs-comment">// 记录当前 state</span><br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br><br><span class="hljs-comment">// 让 state 清零，彻底释放</span><br><span class="hljs-keyword">if</span> (release(savedState))<br><span class="hljs-keyword">return</span> savedState;<br>&#125;<br><span class="hljs-comment">// 如果独占锁不是被当前线程持有，则将该 Node 的状态设置为 CANCELLED 并抛出 throw new IllegalMonitorStateException();</span><br>node.status = CANCELLED;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="5-1-2-private-boolean-canReacquire-ConditionNode-node"><a href="#5-1-2-private-boolean-canReacquire-ConditionNode-node" class="headerlink" title="5.1.2. private boolean canReacquire(ConditionNode node)"></a>5.1.2. private boolean canReacquire(ConditionNode node)</h4><p><code>private boolean canReacquire(ConditionNode node)</code> 用于 判断某个在 <code>Condition</code> 上等待的节点，被 <code>Condition</code> 的 <code>signal</code> 后，是否已经链接到同步队列中</p><p>需要注意的是，线程在被 <code>Condition</code> 的 <code>signal()</code> 唤醒后，按设计一定会转移到同步队列中去竞争锁。但在高并发环境下，节点的入队过程并非一步到位，可能出现链表指针尚未完全修复或节点已被取消等等 “中间态”。因此，需要通过这个方法进行校验，确保节点确实已经稳定地进入同步队列，才算真正具备重新竞争锁的资格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canReacquire</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br>Node p;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * node != null 是最基础的检查，传入 Node 不能为 null</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (p = node.prev) != null 用于检查这个节点是否有前驱，</span><br><span class="hljs-comment"> * 因为在 AQS 的同步队列中，除了头节点，其他节点都必须有 prev</span><br><span class="hljs-comment"> * 如果 prev 为 null，说明它不在同步队列里</span><br><span class="hljs-comment"> * 不要猜测该节点是否是队头节点，因为同步队列一定会存在一个头节点，而且是一个哑节点</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (p.next == node || isEnqueued(node)) 中的 p.next == node</span><br><span class="hljs-comment"> * 是看这个节点的前驱节点的 next 是否正确指向自己，如果是，说明这个节点确实在同步队列中</span><br><span class="hljs-comment"> * 但是因为在高并发下，节点刚被加进队列，可能还没来得及完全修复 p.next，这种情况下，单靠这个判断会出错</span><br><span class="hljs-comment"> * 所以通过 isEnqueued(node) 来遍历确认它确实在同步队列中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; (p = node.prev) != <span class="hljs-literal">null</span> &amp;&amp;<br>(p.next == node || isEnqueued(node));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="5-1-3-private-void-doSignal-ConditionNode-first-boolean-all"><a href="#5-1-3-private-void-doSignal-ConditionNode-first-boolean-all" class="headerlink" title="5.1.3. private void doSignal(ConditionNode first, boolean all)"></a>5.1.3. private void doSignal(ConditionNode first, boolean all)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(ConditionNode first, <span class="hljs-type">boolean</span> all)</span> &#123;<br><span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br><span class="hljs-comment">// 把 firstWaiter 指向第二个节点</span><br><span class="hljs-keyword">if</span> ((firstWaiter = next) == <span class="hljs-literal">null</span>)<br>lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把 first 节点上的 COND 标志清掉，并返回旧值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 如果返回 COND，说明 first 节点还处于条件等待队列，进行 if 逻辑</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 进行这个检查的原因是，节点可能在 signal 之前就被取消了（超时/中断），就没资格进入同步队列了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 将 first 节点从条件队列转移到同步队列</span><br>enqueue(first);<br><span class="hljs-comment">// 如果不是 signalAll，不需要唤醒其他节点，退出 while 循环</span><br><span class="hljs-keyword">if</span> (!all)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 如果是 signalAll，将 first = next，继续 while 循环</span><br>first = next;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-具体方法（实现）"><a href="#5-2-具体方法（实现）" class="headerlink" title="5.2. 具体方法（实现）"></a>5.2. 具体方法（实现）</h3><h4 id="5-2-1-Condition-中的方法实现"><a href="#5-2-1-Condition-中的方法实现" class="headerlink" title="5.2.1. Condition 中的方法实现"></a>5.2.1. Condition 中的方法实现</h4><h5 id="5-2-1-1-public-final-void-await"><a href="#5-2-1-1-public-final-void-await" class="headerlink" title="5.2.1.1. public final void await()"></a>5.2.1.1. public final void await()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, cancelled = <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> (interrupted |= Thread.interrupted()) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (interrupted) &#123;<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125;<br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-2-public-final-void-awaitUninterruptibly"><a href="#5-2-1-2-public-final-void-awaitUninterruptibly" class="headerlink" title="5.2.1.2. public final void awaitUninterruptibly()"></a>5.2.1.2. public final void awaitUninterruptibly()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-comment">// 把当前线程包装成一个 ConditionNode，然后将该节点链接到条件队列（单向链表）中，并释放锁资源</span><br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><br><span class="hljs-comment">// 把 “阻塞原因” 对象（arg）写到当前 Thread 对象的内部字段 parkBlocker 上</span><br>LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 如果某个在 Condition 上等待的节点，还没有被链接到同步队列中</span><br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><br><span class="hljs-comment">// 如果被中断，设置中断标志位</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>interrupted = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 如果 Node 的 Status 还有 COND，说明确实还在条件队列中，进入循环</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 如果不是使用 ForkJoinPool 只能控制何时阻塞，则立即进行阻塞</span><br><span class="hljs-keyword">if</span> (rejected)<br>node.block();<br><span class="hljs-comment">// 否则说明使用了 ForkJoinPool，使用 ForkJoinPool 的 managedBlock 智能控制何时阻塞</span><br><span class="hljs-keyword">else</span><br>ForkJoinPool.managedBlock(node);<br>&#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>rejected = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 如果 Node 的 status 不含 COND，可能是已移出条件队列进入同步队列了（因为这个流程可能非常快，上一刻还在条件队列，下一刻就在同步队列了）</span><br><span class="hljs-comment">* 在这种临界状态，调用 Thread.onSpinWait() 提示 CPU 进入高效自旋，再次调用 canReacquire(node) 看是否已经在同步队列了</span><br><span class="hljs-comment">*/</span><br>&#125; <span class="hljs-keyword">else</span><br>Thread.onSpinWait();<br>&#125;<br><span class="hljs-comment">// 如果某个在 Condition 上等待的节点，已经被链接到同步队列中，继续执行</span><br><span class="hljs-comment">// 把当前 Thread 对象的内部字段 parkBlocker 上的 “阻塞原因” 对象置为 null</span><br>LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 清除 Node 的 Status</span><br>node.clearStatus();<br><br><span class="hljs-comment">// 不断重试获取锁</span><br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><br><span class="hljs-comment">// 在方法执行过程中，可能导致中断标志位被清除，这里恢复中断标志位</span><br><span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-3-public-final-long-awaitNanos-long-nanosTimeout"><a href="#5-2-1-3-public-final-long-awaitNanos-long-nanosTimeout" class="headerlink" title="5.2.1.3. public final long awaitNanos(long nanosTimeout)"></a>5.2.1.3. public final long awaitNanos(long nanosTimeout)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime(); <span class="hljs-comment">// avoid overflow</span><br><span class="hljs-keyword">return</span> (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-4-public-final-boolean-await-long-time-TimeUnit-unit"><a href="#5-2-1-4-public-final-boolean-await-long-time-TimeUnit-unit" class="headerlink" title="5.2.1.4. public final boolean await(long time, TimeUnit unit)"></a>5.2.1.4. public final boolean await(long time, TimeUnit unit)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">nanosTimeout</span> <span class="hljs-operator">=</span> unit.toNanos(time);<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>(nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-5-public-final-boolean-awaitUntil-Date-deadline"><a href="#5-2-1-5-public-final-boolean-awaitUntil-Date-deadline" class="headerlink" title="5.2.1.5. public final boolean awaitUntil(Date deadline)"></a>5.2.1.5. public final boolean awaitUntil(Date deadline)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">abstime</span> <span class="hljs-operator">=</span> deadline.getTime();<br><span class="hljs-keyword">if</span> (Thread.interrupted())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br><span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>System.currentTimeMillis() &gt;= abstime) &#123;<br><span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span><br>LockSupport.parkUntil(<span class="hljs-built_in">this</span>, abstime);<br>&#125;<br>node.clearStatus();<br>acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br><span class="hljs-keyword">if</span> (cancelled) &#123;<br>unlinkCancelledWaiters(node);<br><span class="hljs-keyword">if</span> (interrupted)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">return</span> !cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-6-public-final-void-signal"><a href="#5-2-1-6-public-final-void-signal" class="headerlink" title="5.2.1.6. public final void signal()"></a>5.2.1.6. public final void signal()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="5-2-1-7-public-final-void-signalAll"><a href="#5-2-1-7-public-final-void-signalAll" class="headerlink" title="5.2.1.7. public final void signalAll()"></a>5.2.1.7. public final void signalAll()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><span class="hljs-keyword">if</span> (!isHeldExclusively())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>doSignal(first, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.Node%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.Node源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-AbstractQueuedSynchronizer-Node-概述"><a href="#3-1-AbstractQueuedSynchronizer-Node-概述" class="headerlink" title="3.1. AbstractQueuedSynchronizer.Node 概述"></a>3.1. AbstractQueuedSynchronizer.Node 概述</h3><p><code>AbstractQueuedSynchronizer.Node</code> 是一个抽象类，是 <code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 的静态内部类</p><p><code>AQS</code> 的同步队列就是由 <code>AbstractQueuedSynchronizer.Node</code> 构建的，基于双向链表的队列</p><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>AbstractQueuedSynchronizer</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/01/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/01/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer源码解析/</a></li></ol></li></ol></li><li>在最初的设计里，<code>Node</code> 只是一个具体类，职责非常单纯，充当同步队列中的节点。但随着并发框架的发展，设计者意识到队列节点本身需要承载两种不同的语义：独占 (<code>exclusive</code>) 和 共享 (<code>shared</code>)<ol><li>为了更好地表达这一点，他们将 <code>Node</code> 改为抽象类。尽管 <code>Node</code> 中并没有抽象方法，看起来 “抽象” 似乎多此一举，但这样设计的核心目的，是阻止开发者直接去实例化一个原始的 <code>Node</code></li><li>取而代之的是，框架定义了两个具体子类：<code>ExclusiveNode</code> 和 <code>SharedNode</code>。这两个类除了继承 <code>Node</code> 外没有任何额外逻辑，但却起到了“标记” 的作用，明确区分了节点的语义。这样一来，开发者所创建的不是一个模糊的 “队列节点”，而是一个语义清晰的 “独占节点” 或 “共享节点”</li></ol></li></ol></blockquote><hr><h3 id="3-2-AbstractQueuedSynchronizer-Node-相关状态"><a href="#3-2-AbstractQueuedSynchronizer-Node-相关状态" class="headerlink" title="3.2. AbstractQueuedSynchronizer.Node 相关状态"></a>3.2. AbstractQueuedSynchronizer.Node 相关状态</h3><ol><li><code>0</code><ol><li>表示节点的初始状态</li></ol></li><li><code>1</code><ol><li>表示 <code>Thread</code> 实例可能因为阻塞超时、被中断后响应中断而结束阻塞</li><li>我们可以简单的理解为：节点已经结束等待了</li></ol></li><li><code>-1</code><ol><li>表示节点的后驱节点需要被唤醒</li><li>该状态是由后驱节点为该节点设置的，当该节点释放 <code>State</code> 时，需要负责唤醒后驱节点</li></ol></li><li><code>-2</code><ol><li>表示节点不在 <code>AQS</code> 的同步队列，而是在 <code>AQS</code> 的条件队列</li></ol></li><li><code>-3</code><ol><li>该状态仅用于共享模式的同步器，因为共享模式中可能会有多个线程同时尝试获取共享资源</li><li>当该节点被唤醒后，会继续唤醒后续节点。被唤醒的后续节点会再唤醒后续节点，形成 “级联唤醒”</li></ol></li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>这一套相关状态是在 <code>Java8</code> 下的相关状态，在 <code>Java17+</code> 发生了较大变化</li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><br><span class="hljs-comment">// 表示该节点在 AQS 的同步队列中的前驱节点</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-comment">// 表示该节点在 AQS 的同步队列中的后驱节点</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">// 表示该节点封装的 Thread 实例</span><br>Thread waiter;<br><br><span class="hljs-comment">// 表示该节点的状态</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casPrev</span><span class="hljs-params">(Node c, Node v)</span> &#123;<br><span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, PREV, c, v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node c, Node v)</span> &#123;<br><span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, NEXT, c, v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUnsetStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br><span class="hljs-keyword">return</span> U.getAndBitwiseAndInt(<span class="hljs-built_in">this</span>, STATUS, ~v);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrevRelaxed</span><span class="hljs-params">(Node p)</span> &#123;<br>U.putReference(<span class="hljs-built_in">this</span>, PREV, p);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatusRelaxed</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;<br>U.putInt(<span class="hljs-built_in">this</span>, STATUS, s);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearStatus</span><span class="hljs-params">()</span> &#123;<br>U.putIntOpaque(<span class="hljs-built_in">this</span>, STATUS, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">STATUS</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;status&quot;</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">NEXT</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;next&quot;</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">PREV</span><br><span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;prev&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>方法的实现涉及到了 <code>Unsafe</code>，先不看</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.Condition 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Condition%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.Condition源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Condition-概述"><a href="#3-1-Condition-概述" class="headerlink" title="3.1. Condition 概述"></a>3.1. Condition 概述</h3><p><code>Condition</code> 是一个接口</p><p>想象这样一个问题：<code>Monitor</code> 中只有一个等待队列（即 <code>WaitSet</code>）如果你有多个条件需要等待，你就无法精确控制唤醒哪一类等待者，因为他们都在同一个队列中等待</p><p>为了解决这一问题，我们可以创建多个 <code>Condition</code> 接口的具体实现类实例，每一个 <code>Condition</code> 接口的具体实现类就是一个队列</p><p><code>Condition + LockSupport</code> 相当于 <code>Object#wait</code>、<code>Object#notify</code> 的 <code>Plus</code> 版</p><p><code>Condition</code> 为我们提供了以下方法：</p><ol><li>让本地线程进入阻塞状态，<code>Thread</code> 示例进入 <code>WAITING</code> 状态</li><li>让本地线程进入限时阻塞状态，<code>Thread</code> 示例进入 <code>TIMED_WAITING</code> 状态</li><li>唤醒 AQS 的条件队列中的 “首个”  <code>Thread</code> 实例（非阻塞）</li><li>唤醒 AQS 的条件队列中的所有 <code>Thread</code> 实例（非阻塞）</li></ol><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 示例进入 WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入阻塞状态，Thread 示例进入 WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，不能能响应中断。线程会继续阻塞，并会保留 Thread 示例的中断状态。当线程被唤醒后，会继续向下执行（正常退出（未发生异常））</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于让本地线程进入限时阻塞状态，Thread 示例进入 TIMED_WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时超时被允许的最长时间为：nanosTimeout ns</span><br><span class="hljs-comment">//     1. 如果超时，false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入限时阻塞状态，Thread 示例进入 TIMED_WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许的最长时间为：time unit</span><br><span class="hljs-comment">//     1. 如果超时，返回 false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于让本地线程进入限时阻塞状态，Thread 示例进入 TIMED_WAITING 状态，并被投递到 AQS 的条件队列，等待被唤醒（LockSupport.unpark）、被中断（Thread#interrupt）、阻塞超时</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 限时阻塞被允许到 deadline</span><br><span class="hljs-comment">//     1. 如果超时，返回 false</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 本地线程进入阻塞状态，Thread 实例进入 WAITING 状态后，能响应中断。线程被唤醒，重新获得 CPU 时间片后，会抛出 InterruptedException 受检异常，并清除 Thread 实例的中断状态（异常退出或正常退出（发生异常），要看我们是否对该异常进行捕获并处理）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 AQS 的条件队列中的 “首个”  Thread 实例，被唤醒的 Thread 实例被直接投递到 AQS 的同步队列</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 所谓的 “首个” 是指：首个 Thread 实例可能因为阻塞超时、被中断后响应中断而结束阻塞，所以会依次向后查找，直到找到仍处于阻塞状态的 Thread 实例</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞唤醒 AQS 的条件队列中的所有 Thread 实例，被唤醒的 Thread 实例被直接投递到 AQS 的同步队列</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-内置实现"><a href="#5-内置实现" class="headerlink" title="5. 内置实现"></a>5. 内置实现</h2><h3 id="5-1-ConditionObject"><a href="#5-1-ConditionObject" class="headerlink" title="5.1. ConditionObject"></a>5.1. ConditionObject</h3><p>详见源码：<code>AbstractQueuedSynchronizer.ConditionObject</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject源码解析/</a></li></ol></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.concurrent.locks.ReentrantLock 源码解析</title>
    <link href="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/31/源码：java.util.concurrent.locks.ReentrantLock源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-ReentrantLock-概述"><a href="#3-1-ReentrantLock-概述" class="headerlink" title="3.1. ReentrantLock 概述"></a>3.1. ReentrantLock 概述</h3><p><code>ReentrantLock</code> 是一个具体类，实现了 <code>java.util.concurrent.locks.Lock</code>、<code>java.io.Serializable</code><br><img src="/2025/08/31/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><p><code>ReentrantLock</code> 是一种可重入、悲观、公平或非公平、互斥的锁，并且是使用 <code>AQS</code> 实现的独占模式的同步器。<code>State</code> 和共享资源表示以下含义：</p><ol><li><code>State</code> 表示锁的重入次数<ol><li><code>0</code><ol><li>表示锁空闲，线程可以尝试获取</li></ol></li><li><code>1</code><ol><li>表示锁已被某个线程持有</li></ol></li><li><code>n（n &gt; 1）</code><ol><li>表示同一线程对该锁进行了 <code>n</code> 次重入</li></ol></li></ol></li><li>共享资源表示加锁期间的操作</li></ol><p><code>ReentrantLock</code> 功能类似于 <code>synchronized</code>，但更灵活、功能更强大，主要包括：</p><ol><li><code>ReentrantLock</code> 支持阻塞竞争锁、限时阻塞竞争锁、非阻塞竞争锁，而 <code>synchronized</code> 只支持阻塞竞争锁</li><li><code>ReentrantLock</code> 在阻塞竞争锁、限时阻塞竞争锁时能响应中断，而 <code>synchronized</code> 在阻塞竞争锁时不能响应中断</li><li><code>ReentrantLock</code> 既可以是公平锁，也可以是非公平锁，而 <code>synchronized</code> 只能是非公平锁</li><li><code>ReentrantLock</code> 支持多条条件队列，而 <code>synchronized</code> 只支持一条条件队列（即 <code>waitSet</code>，因为在语义上，<code>EntryList</code> 不属于条件队列）</li></ol><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Lock</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.Lock源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/07/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.Lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/07/源码：java.util.concurrent.locks.Lock源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Serializable</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.io.Serializable源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/10/28/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.io.Serializable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/10/28/源码：java.io.Serializable源码解析/</a></li></ol></li></ol></li><li>锁竞争激烈的场景，建议优先使用 <code>ReentrantLock</code>，因为它没有 “锁升级” 的额外开销：<ol><li><code>synchronized</code> 在偏向锁、轻量级锁时，效率的确很高</li><li>但是，一旦升级为重量级锁，就无法降级，而且在锁竞争激烈的场景下性能会受到影响</li></ol></li><li>如果你对并发机制掌握不深，建议优先使用 <code>synchronized</code>，因为它语法简洁、出错率低。但如果你需要更强的灵活性，并且熟悉并发编程，<code>ReentrantLock</code> 会更合适</li></ol></blockquote><hr><h2 id="4-内部类"><a href="#4-内部类" class="headerlink" title="4. 内部类"></a>4. 内部类</h2><h3 id="4-1-Sync"><a href="#4-1-Sync" class="headerlink" title="4.1. Sync"></a>4.1. Sync</h3><p>详见源码：<code>ReentrantLock.Sync</code></p><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.concurrent.locks.ReentrantLock.Sync源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/09/02/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.concurrent.locks.ReentrantLock.Sync%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/09/02/源码：java.util.concurrent.locks.ReentrantLock.Sync源码解析/</a></li></ol></li></ol><hr><h3 id="4-2-NonfairSync"><a href="#4-2-NonfairSync" class="headerlink" title="4.2. NonfairSync"></a>4.2. NonfairSync</h3><p><code>NonfairSync</code> 用于实现非公平锁的加锁策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123; <br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span> &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3-FairSync"><a href="#4-3-FairSync" class="headerlink" title="4.3. FairSync"></a>4.3. FairSync</h3><p><code>FairSync</code> 用于实现公平锁的加锁策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!hasQueuedThreads() &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == current) &#123;<br><span class="hljs-keyword">if</span> (++c &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(c);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;<br>compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h2><h3 id="5-1-ReentrantLock"><a href="#5-1-ReentrantLock" class="headerlink" title="5.1. ReentrantLock()"></a>5.1. ReentrantLock()</h3><p>该方法用于构造一个非公平锁的 &#96;ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br><br>sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-2-ReentrantLock-boolean-fair"><a href="#5-2-ReentrantLock-boolean-fair" class="headerlink" title="5.2. ReentrantLock(boolean fair)"></a>5.2. ReentrantLock(boolean fair)</h3><p>该方法构造一个公平锁或非公平锁的 <code>ReentrantLock</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br><br>sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h2><h3 id="6-1-实例具体方法"><a href="#6-1-实例具体方法" class="headerlink" title="6.1. 实例具体方法"></a>6.1. 实例具体方法</h3><h4 id="6-1-1-具体方法（实现）"><a href="#6-1-1-具体方法（实现）" class="headerlink" title="6.1.1. 具体方法（实现）"></a>6.1.1. 具体方法（实现）</h4><h5 id="6-1-1-1-Lock-中接口方法的实现"><a href="#6-1-1-1-Lock-中接口方法的实现" class="headerlink" title="6.1.1.1. Lock 中接口方法的实现"></a>6.1.1.1. Lock 中接口方法的实现</h5><h6 id="6-1-1-1-1-void-lock"><a href="#6-1-1-1-1-void-lock" class="headerlink" title="6.1.1.1.1. void lock()"></a>6.1.1.1.1. void lock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><br>sync.lock();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-2-void-lockInterruptibly"><a href="#6-1-1-1-2-void-lockInterruptibly" class="headerlink" title="6.1.1.1.2. void lockInterruptibly()"></a>6.1.1.1.2. void lockInterruptibly()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>sync.lockInterruptibly();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-3-boolean-tryLock"><a href="#6-1-1-1-3-boolean-tryLock" class="headerlink" title="6.1.1.1.3. boolean tryLock()"></a>6.1.1.1.3. boolean tryLock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> sync.tryLock();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-4-boolean-tryLock-long-timeout-TimeUnit-unit"><a href="#6-1-1-1-4-boolean-tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="6.1.1.1.4. boolean tryLock(long timeout, TimeUnit unit)"></a>6.1.1.1.4. boolean tryLock(long timeout, TimeUnit unit)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br><span class="hljs-keyword">return</span> sync.tryLockNanos(unit.toNanos(timeout));<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-5-void-unlock"><a href="#6-1-1-1-5-void-unlock" class="headerlink" title="6.1.1.1.5. void unlock()"></a>6.1.1.1.5. void unlock()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br><br>sync.release(<span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="6-1-1-1-6-Condition-newCondition"><a href="#6-1-1-1-6-Condition-newCondition" class="headerlink" title="6.1.1.1.6. Condition newCondition()"></a>6.1.1.1.6. Condition newCondition()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">return</span> sync.newCondition();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.lang.Iterable＜T＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.lang.Iterable%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.lang.Iterable＜T＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Iterable＜T＞-概述"><a href="#3-1-Iterable＜T＞-概述" class="headerlink" title="3.1. Iterable＜T＞ 概述"></a>3.1. Iterable＜T＞ 概述</h3><p><code>Iterable＜T＞</code> 是一个接口</p><p><code>Iterable＜T＞</code> 为我们提供了以下方法：</p><ol><li>获取迭代器实例（非阻塞）</li><li>获取可拆分迭代器实例（非阻塞）</li><li>使用迭代器实例遍历 <code>Iterable＜T＞</code> 接口的具体实现类实例中维护的数据结构中的所有元素，并对每个元素执行传入的方法参数 <code>action</code>（非阻塞）</li></ol><p>用于遍历 Iterable 接口的具体实现类实例维护的数据结构中的所有元素，并对每个元素执行传入的方法参数 action</p><blockquote><p>[!NOTE] 注意事项</p><ol><li><code>Iterable＜T＞</code> 接口的具体实现类实例会维护一个数据结构，用于存储元素。而在 <code>Java</code> 应用中，遍历这个数据结构有两种方式：<ol><li>基于索引遍历</li><li>基于引用遍历</li><li>需要注意的是：<code>for</code> 循环、迭代器、可拆分迭代器等等，都是根据这个数据结构的特性，使用这两种方式中的其中一个实现遍历的</li></ol></li><li>可拆分迭代器虽然也能实现遍历，但它更侧重于提供数据的迭代拆分能力。而且可拆分迭代器是 <code>Java Stream</code> 的起点，也是 <code>Java Stream</code> 中元素的来源（不管是 <code>Java Stream</code> 的串行流还是 <code>Java Stream</code> 的并行流，都要以可拆分迭代器为起点）<ol><li>虽然说 “可拆分迭代器是 <code>Java Stream</code> 中元素的来源”，但它本质上也是基于索引遍历或基于引用遍历，把元素从数据结构中遍历出来的。所以我们会发现：<code>Java Stream</code> 处理元素时，也是把元素从数据结构中遍历出来，然后再处理的</li><li>如果是 <code>Java Stream</code> 的串行流，可拆分迭代器不会对数据结构中的元素进行迭代拆分。如果是 <code>Java Stream</code> 的并行流，可拆分迭代器会对数据结构中的元素进行迭代拆分</li><li>如果是 <code>Java Stream</code> 的并行流，可拆分迭代器会对数据结构中的元素进行迭代拆分，其拆分一般满足这样的规律：<ol><li>如果这个数据结构的底层是哪种分配连续内存的数据结构（例如数组），那么可拆分迭代器可以通过索引快速定位到中间位置，从而高效的对数据结构中的元素进行一次拆分（这种数据结构的遍历方式，通常是基于索引遍历）</li><li>但是如果这个数据结构的底层不是哪种分配连续内存的数据结构（例如链表），即使我们知道这个数据结构中的元素有多少个，但是也无法通过索引快速定位到中间位置。我们只能通过引用遍历到中间位置，才能对数据结构中的元素进行一次拆分，这就显著降低了对数据结构中的元素的拆分效率，因此对于这种数据结构，不太建议使用 <code>Java Stream</code> 的并行流（这种数据结构的遍历方式，通常是基于引用遍历）</li></ol></li></ol></li><li>猴哥的烦恼箱 <code>(｡•́︿•̀｡)</code>：<ol><li>如何判断遍历某个数据结构时，是基于哪种遍历方式？<ol><li>如果这个数据结构实现了 <code>RandomAccess</code> 接口，说明它是基于索引遍历</li><li>看它们底层的数据结构</li></ol></li></ol></li></ol></blockquote><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞获取迭代器实例</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 即获取一个 Iterator＜T＞ 接口的具体实现类实例</span><br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞使用迭代器实例遍历 Iterable＜T＞ 接口的具体实现类实例中维护的数据结构中的所有元素，并对每个元素执行传入的方法参数 action</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞获取可拆分迭代器实例</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 即获取一个 Spliterator＜T＞ 接口的具体实现类实例</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>详见源码：<code>Iterator＜E＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Iterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.Iterator＜E＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Iterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.util.Iterator＜E＞源码解析/</a></li></ol></li></ol></li><li>详见源码：<code>Consumer＜T＞</code><ol><li><code>obsidian</code> 内部链接：<ol><li><a href="%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">源码：java.util.function.Consumer＜T＞源码解析</a></li></ol></li><li><code>Hexo</code> 链接：<ol><li><a href="http://blog.wangjia.ink/2025/11/18/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.function.Consumer%EF%BC%9CT%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/11/18/源码：java.util.function.Consumer＜T＞源码解析/</a></li></ol></li></ol></li><li>增强 <code>for</code> 循环（<code>for-each</code> 循环）是 <code>Java</code> 提供的一种语法糖，在编译阶段会被编译器自动转换为等价的迭代器遍历代码</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译前</span><br><span class="hljs-keyword">for</span> (T t : iterable) &#123;<br>xxxxxx<br>&#125;<br><br><br><span class="hljs-comment">// 编译后</span><br><span class="hljs-keyword">for</span> (Iterator&lt;T&gt; it = iterable.iterator(); it.hasNext(); ) &#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> it.next();<br>xxxxxx<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项<br>4. <code>Spliterator</code> 是 <code>Java8</code> 为了支持并行流而专门引入的一个接口。详见笔记：<code>Java</code> 函数式编程（<code>obsidian</code> 内部链接：<a href="%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md">笔记：Java函数式编程</a>，<code>Hexo</code> 链接：）</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.Iterator＜E＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Iterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Iterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Iterator%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.util.Iterator＜E＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Iterator＜E＞-概述"><a href="#3-1-Iterator＜E＞-概述" class="headerlink" title="3.1. Iterator＜E＞  概述"></a>3.1. Iterator＜E＞  概述</h3><p><code>Iterator＜E＞</code> 是一个接口</p><p><code>Iterator＜E＞</code> 为我们提供了以下方法：</p><ol><li>查看该游标后面是否还有元素（非阻塞）</li><li>获取该游标位置的元素，并将游标向后移动一位（非阻塞）</li><li>“删” 上一次调用 <code>Iterator＜E＞#next</code> 时返回的元素（非阻塞）</li><li>对从该游标开始的每个元素执行传入的方法参数 <code>action</code>（非阻塞）</li></ol><p>我们可以简单的理解为：<code>Iterator＜E＞</code> 接口的具体实现类实例只是一个 “游标”，能够用来遍历数据结构</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br><br><span class="hljs-comment">// 用于非阻塞查看该游标后面是否还有元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞 “查” 该游标位置的元素，并将游标向后移动一位</span><br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞 “删” 上一次调用 Iterator#next 时返回的元素</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 需要注意的是：不能连续两次调用 Iterator#remove</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;remove&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞对从该游标开始的每个元素执行传入的方法参数 action</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">while</span> (hasNext())<br>            action.accept(next());<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意事项</p><ol><li>接口方法（<code>default</code>）中直接抛出 <code>UnsupportedOperationException</code> 异常，这意味着如果我们想要调用它，就必须重写该方法。因为在大多数情况下，我们可能并不需要这个操作</li></ol></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>源码：java.util.Collection＜E＞ 源码解析</title>
    <link href="/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Collection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Collection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h2><hr><h2 id="2-脑图"><a href="#2-脑图" class="headerlink" title="2. 脑图"></a>2. 脑图</h2><ol><li><p>Xmind</p></li><li><p>Edraw</p></li><li><p>Hexo 地址<br>👉 <a href="http://blog.wangjia.ink/2025/08/25/%E6%BA%90%E7%A0%81%EF%BC%9Ajava.util.Collection%EF%BC%9CE%EF%BC%9E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://blog.wangjia.ink/2025/08/25/源码：java.util.Collection＜E＞源码解析/</a></p></li></ol><hr><h2 id="3-基础部分"><a href="#3-基础部分" class="headerlink" title="3. 基础部分"></a>3. 基础部分</h2><h3 id="3-1-Collection-概述"><a href="#3-1-Collection-概述" class="headerlink" title="3.1. Collection 概述"></a>3.1. Collection 概述</h3><p><code>Collection</code> 是一个接口</p><hr><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4. 源码部分"></a>4. 源码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br><br>    Object[] toArray();<br><br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-keyword">default</span> &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) &#123;<br>        <span class="hljs-keyword">return</span> toArray(generator.apply(<span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>        Objects.requireNonNull(filter);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();<br>        <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>                each.remove();<br>                removed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 用于非阻塞获取可拆分迭代器实例</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞获取串行流实例</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br><span class="hljs-comment">// 用于非阻塞获取并行流实例</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
